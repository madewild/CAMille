/*
Unobtrusive JavaScript
https://github.com/rails/rails/blob/master/actionview/app/assets/javascripts
Released under the MIT license
 */


(function() {
    var context = this;
  
    (function() {
      (function() {
        this.Rails = {
          linkClickSelector: 'a[data-confirm], a[data-method], a[data-remote]:not([disabled]), a[data-disable-with], a[data-disable]',
          buttonClickSelector: {
            selector: 'button[data-remote]:not([form]), button[data-confirm]:not([form])',
            exclude: 'form button'
          },
          inputChangeSelector: 'select[data-remote], input[data-remote], textarea[data-remote]',
          formSubmitSelector: 'form',
          formInputClickSelector: 'form input[type=submit], form input[type=image], form button[type=submit], form button:not([type]), input[type=submit][form], input[type=image][form], button[type=submit][form], button[form]:not([type])',
          formDisableSelector: 'input[data-disable-with]:enabled, button[data-disable-with]:enabled, textarea[data-disable-with]:enabled, input[data-disable]:enabled, button[data-disable]:enabled, textarea[data-disable]:enabled',
          formEnableSelector: 'input[data-disable-with]:disabled, button[data-disable-with]:disabled, textarea[data-disable-with]:disabled, input[data-disable]:disabled, button[data-disable]:disabled, textarea[data-disable]:disabled',
          fileInputSelector: 'input[name][type=file]:not([disabled])',
          linkDisableSelector: 'a[data-disable-with], a[data-disable]',
          buttonDisableSelector: 'button[data-remote][data-disable-with], button[data-remote][data-disable]'
        };
  
      }).call(this);
    }).call(context);
  
    var Rails = context.Rails;
  
    (function() {
      (function() {
        var expando, m;
  
        m = Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector;
  
        Rails.matches = function(element, selector) {
          if (selector.exclude != null) {
            return m.call(element, selector.selector) && !m.call(element, selector.exclude);
          } else {
            return m.call(element, selector);
          }
        };
  
        expando = '_ujsData';
  
        Rails.getData = function(element, key) {
          var ref;
          return (ref = element[expando]) != null ? ref[key] : void 0;
        };
  
        Rails.setData = function(element, key, value) {
          if (element[expando] == null) {
            element[expando] = {};
          }
          return element[expando][key] = value;
        };
  
        Rails.$ = function(selector) {
          return Array.prototype.slice.call(document.querySelectorAll(selector));
        };
  
      }).call(this);
      (function() {
        var $, csrfParam, csrfToken;
  
        $ = Rails.$;
  
        csrfToken = Rails.csrfToken = function() {
          var meta;
          meta = document.querySelector('meta[name=csrf-token]');
          return meta && meta.content;
        };
  
        csrfParam = Rails.csrfParam = function() {
          var meta;
          meta = document.querySelector('meta[name=csrf-param]');
          return meta && meta.content;
        };
  
        Rails.CSRFProtection = function(xhr) {
          var token;
          token = csrfToken();
          if (token != null) {
            return xhr.setRequestHeader('X-CSRF-Token', token);
          }
        };
  
        Rails.refreshCSRFTokens = function() {
          var param, token;
          token = csrfToken();
          param = csrfParam();
          if ((token != null) && (param != null)) {
            return $('form input[name="' + param + '"]').forEach(function(input) {
              return input.value = token;
            });
          }
        };
  
      }).call(this);
      (function() {
        var CustomEvent, fire, matches;
  
        matches = Rails.matches;
  
        CustomEvent = window.CustomEvent;
  
        if (typeof CustomEvent !== 'function') {
          CustomEvent = function(event, params) {
            var evt;
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
            return evt;
          };
          CustomEvent.prototype = window.Event.prototype;
        }
  
        fire = Rails.fire = function(obj, name, data) {
          var event;
          event = new CustomEvent(name, {
            bubbles: true,
            cancelable: true,
            detail: data
          });
          obj.dispatchEvent(event);
          return !event.defaultPrevented;
        };
  
        Rails.stopEverything = function(e) {
          fire(e.target, 'ujs:everythingStopped');
          e.preventDefault();
          e.stopPropagation();
          return e.stopImmediatePropagation();
        };
  
        Rails.delegate = function(element, selector, eventType, handler) {
          return element.addEventListener(eventType, function(e) {
            var target;
            target = e.target;
            while (!(!(target instanceof Element) || matches(target, selector))) {
              target = target.parentNode;
            }
            if (target instanceof Element && handler.call(target, e) === false) {
              e.preventDefault();
              return e.stopPropagation();
            }
          });
        };
  
      }).call(this);
      (function() {
        var AcceptHeaders, CSRFProtection, createXHR, fire, prepareOptions, processResponse;
  
        CSRFProtection = Rails.CSRFProtection, fire = Rails.fire;
  
        AcceptHeaders = {
          '*': '*/*',
          text: 'text/plain',
          html: 'text/html',
          xml: 'application/xml, text/xml',
          json: 'application/json, text/javascript',
          script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript'
        };
  
        Rails.ajax = function(options) {
          var xhr;
          options = prepareOptions(options);
          xhr = createXHR(options, function() {
            var response;
            response = processResponse(xhr.response, xhr.getResponseHeader('Content-Type'));
            if (Math.floor(xhr.status / 100) === 2) {
              if (typeof options.success === "function") {
                options.success(response, xhr.statusText, xhr);
              }
            } else {
              if (typeof options.error === "function") {
                options.error(response, xhr.statusText, xhr);
              }
            }
            return typeof options.complete === "function" ? options.complete(xhr, xhr.statusText) : void 0;
          });
          if (!(typeof options.beforeSend === "function" ? options.beforeSend(xhr, options) : void 0)) {
            return false;
          }
          if (xhr.readyState === XMLHttpRequest.OPENED) {
            return xhr.send(options.data);
          }
        };
  
        prepareOptions = function(options) {
          options.url = options.url || location.href;
          options.type = options.type.toUpperCase();
          if (options.type === 'GET' && options.data) {
            if (options.url.indexOf('?') < 0) {
              options.url += '?' + options.data;
            } else {
              options.url += '&' + options.data;
            }
          }
          if (AcceptHeaders[options.dataType] == null) {
            options.dataType = '*';
          }
          options.accept = AcceptHeaders[options.dataType];
          if (options.dataType !== '*') {
            options.accept += ', */*; q=0.01';
          }
          return options;
        };
  
        createXHR = function(options, done) {
          var xhr;
          xhr = new XMLHttpRequest();
          xhr.open(options.type, options.url, true);
          xhr.setRequestHeader('Accept', options.accept);
          if (typeof options.data === 'string') {
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
          }
          if (!options.crossDomain) {
            xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
          }
          CSRFProtection(xhr);
          xhr.withCredentials = !!options.withCredentials;
          xhr.onreadystatechange = function() {
            if (xhr.readyState === XMLHttpRequest.DONE) {
              return done(xhr);
            }
          };
          return xhr;
        };
  
        processResponse = function(response, type) {
          var parser, script;
          if (typeof response === 'string' && typeof type === 'string') {
            if (type.match(/\bjson\b/)) {
              try {
                response = JSON.parse(response);
              } catch (error) {}
            } else if (type.match(/\b(?:java|ecma)script\b/)) {
              script = document.createElement('script');
              script.text = response;
              document.head.appendChild(script).parentNode.removeChild(script);
            } else if (type.match(/\b(xml|html|svg)\b/)) {
              parser = new DOMParser();
              type = type.replace(/;.+/, '');
              try {
                response = parser.parseFromString(response, type);
              } catch (error) {}
            }
          }
          return response;
        };
  
        Rails.href = function(element) {
          return element.href;
        };
  
        Rails.isCrossDomain = function(url) {
          var e, originAnchor, urlAnchor;
          originAnchor = document.createElement('a');
          originAnchor.href = location.href;
          urlAnchor = document.createElement('a');
          try {
            urlAnchor.href = url;
            return !(((!urlAnchor.protocol || urlAnchor.protocol === ':') && !urlAnchor.host) || (originAnchor.protocol + '//' + originAnchor.host === urlAnchor.protocol + '//' + urlAnchor.host));
          } catch (error) {
            e = error;
            return true;
          }
        };
  
      }).call(this);
      (function() {
        var matches, toArray;
  
        matches = Rails.matches;
  
        toArray = function(e) {
          return Array.prototype.slice.call(e);
        };
  
        Rails.serializeElement = function(element, additionalParam) {
          var inputs, params;
          inputs = [element];
          if (matches(element, 'form')) {
            inputs = toArray(element.elements);
          }
          params = [];
          inputs.forEach(function(input) {
            if (!input.name || input.disabled) {
              return;
            }
            if (matches(input, 'select')) {
              return toArray(input.options).forEach(function(option) {
                if (option.selected) {
                  return params.push({
                    name: input.name,
                    value: option.value
                  });
                }
              });
            } else if (input.checked || ['radio', 'checkbox', 'submit'].indexOf(input.type) === -1) {
              return params.push({
                name: input.name,
                value: input.value
              });
            }
          });
          if (additionalParam) {
            params.push(additionalParam);
          }
          return params.map(function(param) {
            if (param.name != null) {
              return (encodeURIComponent(param.name)) + "=" + (encodeURIComponent(param.value));
            } else {
              return param;
            }
          }).join('&');
        };
  
        Rails.formElements = function(form, selector) {
          if (matches(form, 'form')) {
            return toArray(form.elements).filter(function(el) {
              return matches(el, selector);
            });
          } else {
            return toArray(form.querySelectorAll(selector));
          }
        };
  
      }).call(this);
      (function() {
        var allowAction, fire, stopEverything;
  
        fire = Rails.fire, stopEverything = Rails.stopEverything;
  
        Rails.handleConfirm = function(e) {
          if (!allowAction(this)) {
            return stopEverything(e);
          }
        };
  
        allowAction = function(element) {
          var answer, callback, message;
          message = element.getAttribute('data-confirm');
          if (!message) {
            return true;
          }
          answer = false;
          if (fire(element, 'confirm')) {
            try {
              answer = confirm(message);
            } catch (error) {}
            callback = fire(element, 'confirm:complete', [answer]);
          }
          return answer && callback;
        };
  
      }).call(this);
      (function() {
        var disableFormElement, disableFormElements, disableLinkElement, enableFormElement, enableFormElements, enableLinkElement, formElements, getData, matches, setData, stopEverything;
  
        matches = Rails.matches, getData = Rails.getData, setData = Rails.setData, stopEverything = Rails.stopEverything, formElements = Rails.formElements;
  
        Rails.handleDisabledElement = function(e) {
          var element;
          element = this;
          if (element.disabled) {
            return stopEverything(e);
          }
        };
  
        Rails.enableElement = function(e) {
          var element;
          element = e instanceof Event ? e.target : e;
          if (matches(element, Rails.linkDisableSelector)) {
            return enableLinkElement(element);
          } else if (matches(element, Rails.buttonDisableSelector) || matches(element, Rails.formEnableSelector)) {
            return enableFormElement(element);
          } else if (matches(element, Rails.formSubmitSelector)) {
            return enableFormElements(element);
          }
        };
  
        Rails.disableElement = function(e) {
          var element;
          element = e instanceof Event ? e.target : e;
          if (matches(element, Rails.linkDisableSelector)) {
            return disableLinkElement(element);
          } else if (matches(element, Rails.buttonDisableSelector) || matches(element, Rails.formDisableSelector)) {
            return disableFormElement(element);
          } else if (matches(element, Rails.formSubmitSelector)) {
            return disableFormElements(element);
          }
        };
  
        disableLinkElement = function(element) {
          var replacement;
          replacement = element.getAttribute('data-disable-with');
          if (replacement != null) {
            setData(element, 'ujs:enable-with', element.innerHTML);
            element.innerHTML = replacement;
          }
          element.addEventListener('click', stopEverything);
          return setData(element, 'ujs:disabled', true);
        };
  
        enableLinkElement = function(element) {
          var originalText;
          originalText = getData(element, 'ujs:enable-with');
          if (originalText != null) {
            element.innerHTML = originalText;
            setData(element, 'ujs:enable-with', null);
          }
          element.removeEventListener('click', stopEverything);
          return setData(element, 'ujs:disabled', null);
        };
  
        disableFormElements = function(form) {
          return formElements(form, Rails.formDisableSelector).forEach(disableFormElement);
        };
  
        disableFormElement = function(element) {
          var replacement;
          replacement = element.getAttribute('data-disable-with');
          if (replacement != null) {
            if (matches(element, 'button')) {
              setData(element, 'ujs:enable-with', element.innerHTML);
              element.innerHTML = replacement;
            } else {
              setData(element, 'ujs:enable-with', element.value);
              element.value = replacement;
            }
          }
          element.disabled = true;
          return setData(element, 'ujs:disabled', true);
        };
  
        enableFormElements = function(form) {
          return formElements(form, Rails.formEnableSelector).forEach(enableFormElement);
        };
  
        enableFormElement = function(element) {
          var originalText;
          originalText = getData(element, 'ujs:enable-with');
          if (originalText != null) {
            if (matches(element, 'button')) {
              element.innerHTML = originalText;
            } else {
              element.value = originalText;
            }
            setData(element, 'ujs:enable-with', null);
          }
          element.disabled = false;
          return setData(element, 'ujs:disabled', null);
        };
  
      }).call(this);
      (function() {
        var stopEverything;
  
        stopEverything = Rails.stopEverything;
  
        Rails.handleMethod = function(e) {
          var csrfParam, csrfToken, form, formContent, href, link, method;
          link = this;
          method = link.getAttribute('data-method');
          if (!method) {
            return;
          }
          href = Rails.href(link);
          csrfToken = Rails.csrfToken();
          csrfParam = Rails.csrfParam();
          form = document.createElement('form');
          formContent = "<input name='_method' value='" + method + "' type='hidden' />";
          if ((csrfParam != null) && (csrfToken != null) && !Rails.isCrossDomain(href)) {
            formContent += "<input name='" + csrfParam + "' value='" + csrfToken + "' type='hidden' />";
          }
          formContent += '<input type="submit" />';
          form.method = 'post';
          form.action = href;
          form.target = link.target;
          form.innerHTML = formContent;
          form.style.display = 'none';
          document.body.appendChild(form);
          form.querySelector('[type="submit"]').click();
          return stopEverything(e);
        };
  
      }).call(this);
      (function() {
        var ajax, fire, getData, isCrossDomain, isRemote, matches, serializeElement, setData, stopEverything,
          slice = [].slice;
  
        matches = Rails.matches, getData = Rails.getData, setData = Rails.setData, fire = Rails.fire, stopEverything = Rails.stopEverything, ajax = Rails.ajax, isCrossDomain = Rails.isCrossDomain, serializeElement = Rails.serializeElement;
  
        isRemote = function(element) {
          var value;
          value = element.getAttribute('data-remote');
          return (value != null) && value !== 'false';
        };
  
        Rails.handleRemote = function(e) {
          var button, data, dataType, element, method, url, withCredentials;
          element = this;
          if (!isRemote(element)) {
            return true;
          }
          if (!fire(element, 'ajax:before')) {
            fire(element, 'ajax:stopped');
            return false;
          }
          withCredentials = element.getAttribute('data-with-credentials');
          dataType = element.getAttribute('data-type') || 'script';
          if (matches(element, Rails.formSubmitSelector)) {
            button = getData(element, 'ujs:submit-button');
            method = getData(element, 'ujs:submit-button-formmethod') || element.method;
            url = getData(element, 'ujs:submit-button-formaction') || element.getAttribute('action') || location.href;
            if (method.toUpperCase() === 'GET') {
              url = url.replace(/\?.*$/, '');
            }
            if (element.enctype === 'multipart/form-data') {
              data = new FormData(element);
              if (button != null) {
                data.append(button.name, button.value);
              }
            } else {
              data = serializeElement(element, button);
            }
            setData(element, 'ujs:submit-button', null);
            setData(element, 'ujs:submit-button-formmethod', null);
            setData(element, 'ujs:submit-button-formaction', null);
          } else if (matches(element, Rails.buttonClickSelector) || matches(element, Rails.inputChangeSelector)) {
            method = element.getAttribute('data-method');
            url = element.getAttribute('data-url');
            data = serializeElement(element, element.getAttribute('data-params'));
          } else {
            method = element.getAttribute('data-method');
            url = Rails.href(element);
            data = element.getAttribute('data-params');
          }
          ajax({
            type: method || 'GET',
            url: url,
            data: data,
            dataType: dataType,
            beforeSend: function(xhr, options) {
              if (fire(element, 'ajax:beforeSend', [xhr, options])) {
                return fire(element, 'ajax:send', [xhr]);
              } else {
                fire(element, 'ajax:stopped');
                return false;
              }
            },
            success: function() {
              var args;
              args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
              return fire(element, 'ajax:success', args);
            },
            error: function() {
              var args;
              args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
              return fire(element, 'ajax:error', args);
            },
            complete: function() {
              var args;
              args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
              return fire(element, 'ajax:complete', args);
            },
            crossDomain: isCrossDomain(url),
            withCredentials: (withCredentials != null) && withCredentials !== 'false'
          });
          return stopEverything(e);
        };
  
        Rails.formSubmitButtonClick = function(e) {
          var button, form;
          button = this;
          form = button.form;
          if (!form) {
            return;
          }
          if (button.name) {
            setData(form, 'ujs:submit-button', {
              name: button.name,
              value: button.value
            });
          }
          setData(form, 'ujs:formnovalidate-button', button.formNoValidate);
          setData(form, 'ujs:submit-button-formaction', button.getAttribute('formaction'));
          return setData(form, 'ujs:submit-button-formmethod', button.getAttribute('formmethod'));
        };
  
        Rails.handleMetaClick = function(e) {
          var data, link, metaClick, method;
          link = this;
          method = (link.getAttribute('data-method') || 'GET').toUpperCase();
          data = link.getAttribute('data-params');
          metaClick = e.metaKey || e.ctrlKey;
          if (metaClick && method === 'GET' && !data) {
            return e.stopImmediatePropagation();
          }
        };
  
      }).call(this);
      (function() {
        var $, CSRFProtection, delegate, disableElement, enableElement, fire, formSubmitButtonClick, getData, handleConfirm, handleDisabledElement, handleMetaClick, handleMethod, handleRemote, refreshCSRFTokens;
  
        fire = Rails.fire, delegate = Rails.delegate, getData = Rails.getData, $ = Rails.$, refreshCSRFTokens = Rails.refreshCSRFTokens, CSRFProtection = Rails.CSRFProtection, enableElement = Rails.enableElement, disableElement = Rails.disableElement, handleDisabledElement = Rails.handleDisabledElement, handleConfirm = Rails.handleConfirm, handleRemote = Rails.handleRemote, formSubmitButtonClick = Rails.formSubmitButtonClick, handleMetaClick = Rails.handleMetaClick, handleMethod = Rails.handleMethod;
  
        if ((typeof jQuery !== "undefined" && jQuery !== null) && (jQuery.ajax != null) && !jQuery.rails) {
          jQuery.rails = Rails;
          jQuery.ajaxPrefilter(function(options, originalOptions, xhr) {
            if (!options.crossDomain) {
              return CSRFProtection(xhr);
            }
          });
        }
  
        Rails.start = function() {
          if (window._rails_loaded) {
            throw new Error('rails-ujs has already been loaded!');
          }
          window.addEventListener('pageshow', function() {
            $(Rails.formEnableSelector).forEach(function(el) {
              if (getData(el, 'ujs:disabled')) {
                return enableElement(el);
              }
            });
            return $(Rails.linkDisableSelector).forEach(function(el) {
              if (getData(el, 'ujs:disabled')) {
                return enableElement(el);
              }
            });
          });
          delegate(document, Rails.linkDisableSelector, 'ajax:complete', enableElement);
          delegate(document, Rails.linkDisableSelector, 'ajax:stopped', enableElement);
          delegate(document, Rails.buttonDisableSelector, 'ajax:complete', enableElement);
          delegate(document, Rails.buttonDisableSelector, 'ajax:stopped', enableElement);
          delegate(document, Rails.linkClickSelector, 'click', handleDisabledElement);
          delegate(document, Rails.linkClickSelector, 'click', handleConfirm);
          delegate(document, Rails.linkClickSelector, 'click', handleMetaClick);
          delegate(document, Rails.linkClickSelector, 'click', disableElement);
          delegate(document, Rails.linkClickSelector, 'click', handleRemote);
          delegate(document, Rails.linkClickSelector, 'click', handleMethod);
          delegate(document, Rails.buttonClickSelector, 'click', handleDisabledElement);
          delegate(document, Rails.buttonClickSelector, 'click', handleConfirm);
          delegate(document, Rails.buttonClickSelector, 'click', disableElement);
          delegate(document, Rails.buttonClickSelector, 'click', handleRemote);
          delegate(document, Rails.inputChangeSelector, 'change', handleDisabledElement);
          delegate(document, Rails.inputChangeSelector, 'change', handleConfirm);
          delegate(document, Rails.inputChangeSelector, 'change', handleRemote);
          delegate(document, Rails.formSubmitSelector, 'submit', handleDisabledElement);
          delegate(document, Rails.formSubmitSelector, 'submit', handleConfirm);
          delegate(document, Rails.formSubmitSelector, 'submit', handleRemote);
          delegate(document, Rails.formSubmitSelector, 'submit', function(e) {
            return setTimeout((function() {
              return disableElement(e);
            }), 13);
          });
          delegate(document, Rails.formSubmitSelector, 'ajax:send', disableElement);
          delegate(document, Rails.formSubmitSelector, 'ajax:complete', enableElement);
          delegate(document, Rails.formInputClickSelector, 'click', handleDisabledElement);
          delegate(document, Rails.formInputClickSelector, 'click', handleConfirm);
          delegate(document, Rails.formInputClickSelector, 'click', formSubmitButtonClick);
          document.addEventListener('DOMContentLoaded', refreshCSRFTokens);
          return window._rails_loaded = true;
        };
  
        if (window.Rails === Rails && fire(document, 'rails:attachBindings')) {
          Rails.start();
        }
  
      }).call(this);
    }).call(this);
  
    if (typeof module === "object" && module.exports) {
      module.exports = Rails;
    } else if (typeof define === "function" && define.amd) {
      define(Rails);
    }
  }).call(this);
  /*
  Turbolinks 5.2.0
  Copyright © 2018 Basecamp, LLC
   */
  
  (function(){var t=this;(function(){(function(){this.Turbolinks={supported:function(){return null!=window.history.pushState&&null!=window.requestAnimationFrame&&null!=window.addEventListener}(),visit:function(t,r){return e.controller.visit(t,r)},clearCache:function(){return e.controller.clearCache()},setProgressBarDelay:function(t){return e.controller.setProgressBarDelay(t)}}}).call(this)}).call(t);var e=t.Turbolinks;(function(){(function(){var t,r,n,o=[].slice;e.copyObject=function(t){var e,r,n;r={};for(e in t)n=t[e],r[e]=n;return r},e.closest=function(e,r){return t.call(e,r)},t=function(){var t,e;return t=document.documentElement,null!=(e=t.closest)?e:function(t){var e;for(e=this;e;){if(e.nodeType===Node.ELEMENT_NODE&&r.call(e,t))return e;e=e.parentNode}}}(),e.defer=function(t){return setTimeout(t,1)},e.throttle=function(t){var e;return e=null,function(){var r;return r=1<=arguments.length?o.call(arguments,0):[],null!=e?e:e=requestAnimationFrame(function(n){return function(){return e=null,t.apply(n,r)}}(this))}},e.dispatch=function(t,e){var r,o,i,s,a,u;return a=null!=e?e:{},u=a.target,r=a.cancelable,o=a.data,i=document.createEvent("Events"),i.initEvent(t,!0,r===!0),i.data=null!=o?o:{},i.cancelable&&!n&&(s=i.preventDefault,i.preventDefault=function(){return this.defaultPrevented||Object.defineProperty(this,"defaultPrevented",{get:function(){return!0}}),s.call(this)}),(null!=u?u:document).dispatchEvent(i),i},n=function(){var t;return t=document.createEvent("Events"),t.initEvent("test",!0,!0),t.preventDefault(),t.defaultPrevented}(),e.match=function(t,e){return r.call(t,e)},r=function(){var t,e,r,n;return t=document.documentElement,null!=(e=null!=(r=null!=(n=t.matchesSelector)?n:t.webkitMatchesSelector)?r:t.msMatchesSelector)?e:t.mozMatchesSelector}(),e.uuid=function(){var t,e,r;for(r="",t=e=1;36>=e;t=++e)r+=9===t||14===t||19===t||24===t?"-":15===t?"4":20===t?(Math.floor(4*Math.random())+8).toString(16):Math.floor(15*Math.random()).toString(16);return r}}).call(this),function(){e.Location=function(){function t(t){var e,r;null==t&&(t=""),r=document.createElement("a"),r.href=t.toString(),this.absoluteURL=r.href,e=r.hash.length,2>e?this.requestURL=this.absoluteURL:(this.requestURL=this.absoluteURL.slice(0,-e),this.anchor=r.hash.slice(1))}var e,r,n,o;return t.wrap=function(t){return t instanceof this?t:new this(t)},t.prototype.getOrigin=function(){return this.absoluteURL.split("/",3).join("/")},t.prototype.getPath=function(){var t,e;return null!=(t=null!=(e=this.requestURL.match(/\/\/[^\/]*(\/[^?;]*)/))?e[1]:void 0)?t:"/"},t.prototype.getPathComponents=function(){return this.getPath().split("/").slice(1)},t.prototype.getLastPathComponent=function(){return this.getPathComponents().slice(-1)[0]},t.prototype.getExtension=function(){var t,e;return null!=(t=null!=(e=this.getLastPathComponent().match(/\.[^.]*$/))?e[0]:void 0)?t:""},t.prototype.isHTML=function(){return this.getExtension().match(/^(?:|\.(?:htm|html|xhtml))$/)},t.prototype.isPrefixedBy=function(t){var e;return e=r(t),this.isEqualTo(t)||o(this.absoluteURL,e)},t.prototype.isEqualTo=function(t){return this.absoluteURL===(null!=t?t.absoluteURL:void 0)},t.prototype.toCacheKey=function(){return this.requestURL},t.prototype.toJSON=function(){return this.absoluteURL},t.prototype.toString=function(){return this.absoluteURL},t.prototype.valueOf=function(){return this.absoluteURL},r=function(t){return e(t.getOrigin()+t.getPath())},e=function(t){return n(t,"/")?t:t+"/"},o=function(t,e){return t.slice(0,e.length)===e},n=function(t,e){return t.slice(-e.length)===e},t}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.HttpRequest=function(){function r(r,n,o){this.delegate=r,this.requestCanceled=t(this.requestCanceled,this),this.requestTimedOut=t(this.requestTimedOut,this),this.requestFailed=t(this.requestFailed,this),this.requestLoaded=t(this.requestLoaded,this),this.requestProgressed=t(this.requestProgressed,this),this.url=e.Location.wrap(n).requestURL,this.referrer=e.Location.wrap(o).absoluteURL,this.createXHR()}return r.NETWORK_FAILURE=0,r.TIMEOUT_FAILURE=-1,r.timeout=60,r.prototype.send=function(){var t;return this.xhr&&!this.sent?(this.notifyApplicationBeforeRequestStart(),this.setProgress(0),this.xhr.send(),this.sent=!0,"function"==typeof(t=this.delegate).requestStarted?t.requestStarted():void 0):void 0},r.prototype.cancel=function(){return this.xhr&&this.sent?this.xhr.abort():void 0},r.prototype.requestProgressed=function(t){return t.lengthComputable?this.setProgress(t.loaded/t.total):void 0},r.prototype.requestLoaded=function(){return this.endRequest(function(t){return function(){var e;return 200<=(e=t.xhr.status)&&300>e?t.delegate.requestCompletedWithResponse(t.xhr.responseText,t.xhr.getResponseHeader("Turbolinks-Location")):(t.failed=!0,t.delegate.requestFailedWithStatusCode(t.xhr.status,t.xhr.responseText))}}(this))},r.prototype.requestFailed=function(){return this.endRequest(function(t){return function(){return t.failed=!0,t.delegate.requestFailedWithStatusCode(t.constructor.NETWORK_FAILURE)}}(this))},r.prototype.requestTimedOut=function(){return this.endRequest(function(t){return function(){return t.failed=!0,t.delegate.requestFailedWithStatusCode(t.constructor.TIMEOUT_FAILURE)}}(this))},r.prototype.requestCanceled=function(){return this.endRequest()},r.prototype.notifyApplicationBeforeRequestStart=function(){return e.dispatch("turbolinks:request-start",{data:{url:this.url,xhr:this.xhr}})},r.prototype.notifyApplicationAfterRequestEnd=function(){return e.dispatch("turbolinks:request-end",{data:{url:this.url,xhr:this.xhr}})},r.prototype.createXHR=function(){return this.xhr=new XMLHttpRequest,this.xhr.open("GET",this.url,!0),this.xhr.timeout=1e3*this.constructor.timeout,this.xhr.setRequestHeader("Accept","text/html, application/xhtml+xml"),this.xhr.setRequestHeader("Turbolinks-Referrer",this.referrer),this.xhr.onprogress=this.requestProgressed,this.xhr.onload=this.requestLoaded,this.xhr.onerror=this.requestFailed,this.xhr.ontimeout=this.requestTimedOut,this.xhr.onabort=this.requestCanceled},r.prototype.endRequest=function(t){return this.xhr?(this.notifyApplicationAfterRequestEnd(),null!=t&&t.call(this),this.destroy()):void 0},r.prototype.setProgress=function(t){var e;return this.progress=t,"function"==typeof(e=this.delegate).requestProgressed?e.requestProgressed(this.progress):void 0},r.prototype.destroy=function(){var t;return this.setProgress(1),"function"==typeof(t=this.delegate).requestFinished&&t.requestFinished(),this.delegate=null,this.xhr=null},r}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.ProgressBar=function(){function e(){this.trickle=t(this.trickle,this),this.stylesheetElement=this.createStylesheetElement(),this.progressElement=this.createProgressElement()}var r;return r=300,e.defaultCSS=".turbolinks-progress-bar {\n  position: fixed;\n  display: block;\n  top: 0;\n  left: 0;\n  height: 3px;\n  background: #0076ff;\n  z-index: 9999;\n  transition: width "+r+"ms ease-out, opacity "+r/2+"ms "+r/2+"ms ease-in;\n  transform: translate3d(0, 0, 0);\n}",e.prototype.show=function(){return this.visible?void 0:(this.visible=!0,this.installStylesheetElement(),this.installProgressElement(),this.startTrickling())},e.prototype.hide=function(){return this.visible&&!this.hiding?(this.hiding=!0,this.fadeProgressElement(function(t){return function(){return t.uninstallProgressElement(),t.stopTrickling(),t.visible=!1,t.hiding=!1}}(this))):void 0},e.prototype.setValue=function(t){return this.value=t,this.refresh()},e.prototype.installStylesheetElement=function(){return document.head.insertBefore(this.stylesheetElement,document.head.firstChild)},e.prototype.installProgressElement=function(){return this.progressElement.style.width=0,this.progressElement.style.opacity=1,document.documentElement.insertBefore(this.progressElement,document.body),this.refresh()},e.prototype.fadeProgressElement=function(t){return this.progressElement.style.opacity=0,setTimeout(t,1.5*r)},e.prototype.uninstallProgressElement=function(){return this.progressElement.parentNode?document.documentElement.removeChild(this.progressElement):void 0},e.prototype.startTrickling=function(){return null!=this.trickleInterval?this.trickleInterval:this.trickleInterval=setInterval(this.trickle,r)},e.prototype.stopTrickling=function(){return clearInterval(this.trickleInterval),this.trickleInterval=null},e.prototype.trickle=function(){return this.setValue(this.value+Math.random()/100)},e.prototype.refresh=function(){return requestAnimationFrame(function(t){return function(){return t.progressElement.style.width=10+90*t.value+"%"}}(this))},e.prototype.createStylesheetElement=function(){var t;return t=document.createElement("style"),t.type="text/css",t.textContent=this.constructor.defaultCSS,t},e.prototype.createProgressElement=function(){var t;return t=document.createElement("div"),t.className="turbolinks-progress-bar",t},e}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.BrowserAdapter=function(){function r(r){this.controller=r,this.showProgressBar=t(this.showProgressBar,this),this.progressBar=new e.ProgressBar}var n,o,i;return i=e.HttpRequest,n=i.NETWORK_FAILURE,o=i.TIMEOUT_FAILURE,r.prototype.visitProposedToLocationWithAction=function(t,e){return this.controller.startVisitToLocationWithAction(t,e)},r.prototype.visitStarted=function(t){return t.issueRequest(),t.changeHistory(),t.loadCachedSnapshot()},r.prototype.visitRequestStarted=function(t){return this.progressBar.setValue(0),t.hasCachedSnapshot()||"restore"!==t.action?this.showProgressBarAfterDelay():this.showProgressBar()},r.prototype.visitRequestProgressed=function(t){return this.progressBar.setValue(t.progress)},r.prototype.visitRequestCompleted=function(t){return t.loadResponse()},r.prototype.visitRequestFailedWithStatusCode=function(t,e){switch(e){case n:case o:return this.reload();default:return t.loadResponse()}},r.prototype.visitRequestFinished=function(t){return this.hideProgressBar()},r.prototype.visitCompleted=function(t){return t.followRedirect()},r.prototype.pageInvalidated=function(){return this.reload()},r.prototype.showProgressBarAfterDelay=function(){return this.progressBarTimeout=setTimeout(this.showProgressBar,this.controller.progressBarDelay)},r.prototype.showProgressBar=function(){return this.progressBar.show()},r.prototype.hideProgressBar=function(){return this.progressBar.hide(),clearTimeout(this.progressBarTimeout)},r.prototype.reload=function(){return window.location.reload()},r}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.History=function(){function r(e){this.delegate=e,this.onPageLoad=t(this.onPageLoad,this),this.onPopState=t(this.onPopState,this)}return r.prototype.start=function(){return this.started?void 0:(addEventListener("popstate",this.onPopState,!1),addEventListener("load",this.onPageLoad,!1),this.started=!0)},r.prototype.stop=function(){return this.started?(removeEventListener("popstate",this.onPopState,!1),removeEventListener("load",this.onPageLoad,!1),this.started=!1):void 0},r.prototype.push=function(t,r){return t=e.Location.wrap(t),this.update("push",t,r)},r.prototype.replace=function(t,r){return t=e.Location.wrap(t),this.update("replace",t,r)},r.prototype.onPopState=function(t){var r,n,o,i;return this.shouldHandlePopState()&&(i=null!=(n=t.state)?n.turbolinks:void 0)?(r=e.Location.wrap(window.location),o=i.restorationIdentifier,this.delegate.historyPoppedToLocationWithRestorationIdentifier(r,o)):void 0},r.prototype.onPageLoad=function(t){return e.defer(function(t){return function(){return t.pageLoaded=!0}}(this))},r.prototype.shouldHandlePopState=function(){return this.pageIsLoaded()},r.prototype.pageIsLoaded=function(){return this.pageLoaded||"complete"===document.readyState},r.prototype.update=function(t,e,r){var n;return n={turbolinks:{restorationIdentifier:r}},history[t+"State"](n,null,e)},r}()}.call(this),function(){e.HeadDetails=function(){function t(t){var e,r,n,s,a,u;for(this.elements={},n=0,a=t.length;a>n;n++)u=t[n],u.nodeType===Node.ELEMENT_NODE&&(s=u.outerHTML,r=null!=(e=this.elements)[s]?e[s]:e[s]={type:i(u),tracked:o(u),elements:[]},r.elements.push(u))}var e,r,n,o,i;return t.fromHeadElement=function(t){var e;return new this(null!=(e=null!=t?t.childNodes:void 0)?e:[])},t.prototype.hasElementWithKey=function(t){return t in this.elements},t.prototype.getTrackedElementSignature=function(){var t,e;return function(){var r,n;r=this.elements,n=[];for(t in r)e=r[t].tracked,e&&n.push(t);return n}.call(this).join("")},t.prototype.getScriptElementsNotInDetails=function(t){return this.getElementsMatchingTypeNotInDetails("script",t)},t.prototype.getStylesheetElementsNotInDetails=function(t){return this.getElementsMatchingTypeNotInDetails("stylesheet",t)},t.prototype.getElementsMatchingTypeNotInDetails=function(t,e){var r,n,o,i,s,a;o=this.elements,s=[];for(n in o)i=o[n],a=i.type,r=i.elements,a!==t||e.hasElementWithKey(n)||s.push(r[0]);return s},t.prototype.getProvisionalElements=function(){var t,e,r,n,o,i,s;r=[],n=this.elements;for(e in n)o=n[e],s=o.type,i=o.tracked,t=o.elements,null!=s||i?t.length>1&&r.push.apply(r,t.slice(1)):r.push.apply(r,t);return r},t.prototype.getMetaValue=function(t){var e;return null!=(e=this.findMetaElementByName(t))?e.getAttribute("content"):void 0},t.prototype.findMetaElementByName=function(t){var r,n,o,i;r=void 0,i=this.elements;for(o in i)n=i[o].elements,e(n[0],t)&&(r=n[0]);return r},i=function(t){return r(t)?"script":n(t)?"stylesheet":void 0},o=function(t){return"reload"===t.getAttribute("data-turbolinks-track")},r=function(t){var e;return e=t.tagName.toLowerCase(),"script"===e},n=function(t){var e;return e=t.tagName.toLowerCase(),"style"===e||"link"===e&&"stylesheet"===t.getAttribute("rel")},e=function(t,e){var r;return r=t.tagName.toLowerCase(),"meta"===r&&t.getAttribute("name")===e},t}()}.call(this),function(){e.Snapshot=function(){function t(t,e){this.headDetails=t,this.bodyElement=e}return t.wrap=function(t){return t instanceof this?t:"string"==typeof t?this.fromHTMLString(t):this.fromHTMLElement(t)},t.fromHTMLString=function(t){var e;return e=document.createElement("html"),e.innerHTML=t,this.fromHTMLElement(e)},t.fromHTMLElement=function(t){var r,n,o,i;return o=t.querySelector("head"),r=null!=(i=t.querySelector("body"))?i:document.createElement("body"),n=e.HeadDetails.fromHeadElement(o),new this(n,r)},t.prototype.clone=function(){return new this.constructor(this.headDetails,this.bodyElement.cloneNode(!0))},t.prototype.getRootLocation=function(){var t,r;return r=null!=(t=this.getSetting("root"))?t:"/",new e.Location(r)},t.prototype.getCacheControlValue=function(){return this.getSetting("cache-control")},t.prototype.getElementForAnchor=function(t){try{return this.bodyElement.querySelector("[id='"+t+"'], a[name='"+t+"']")}catch(e){}},t.prototype.getPermanentElements=function(){return this.bodyElement.querySelectorAll("[id][data-turbolinks-permanent]")},t.prototype.getPermanentElementById=function(t){return this.bodyElement.querySelector("#"+t+"[data-turbolinks-permanent]")},t.prototype.getPermanentElementsPresentInSnapshot=function(t){var e,r,n,o,i;for(o=this.getPermanentElements(),i=[],r=0,n=o.length;n>r;r++)e=o[r],t.getPermanentElementById(e.id)&&i.push(e);return i},t.prototype.findFirstAutofocusableElement=function(){return this.bodyElement.querySelector("[autofocus]")},t.prototype.hasAnchor=function(t){return null!=this.getElementForAnchor(t)},t.prototype.isPreviewable=function(){return"no-preview"!==this.getCacheControlValue()},t.prototype.isCacheable=function(){return"no-cache"!==this.getCacheControlValue()},t.prototype.isVisitable=function(){return"reload"!==this.getSetting("visit-control")},t.prototype.getSetting=function(t){return this.headDetails.getMetaValue("turbolinks-"+t)},t}()}.call(this),function(){var t=[].slice;e.Renderer=function(){function e(){}var r;return e.render=function(){var e,r,n,o;return n=arguments[0],r=arguments[1],e=3<=arguments.length?t.call(arguments,2):[],o=function(t,e,r){r.prototype=t.prototype;var n=new r,o=t.apply(n,e);return Object(o)===o?o:n}(this,e,function(){}),o.delegate=n,o.render(r),o},e.prototype.renderView=function(t){return this.delegate.viewWillRender(this.newBody),t(),this.delegate.viewRendered(this.newBody)},e.prototype.invalidateView=function(){return this.delegate.viewInvalidated()},e.prototype.createScriptElement=function(t){var e;return"false"===t.getAttribute("data-turbolinks-eval")?t:(e=document.createElement("script"),e.textContent=t.textContent,e.async=!1,r(e,t),e)},r=function(t,e){var r,n,o,i,s,a,u;for(i=e.attributes,a=[],r=0,n=i.length;n>r;r++)s=i[r],o=s.name,u=s.value,a.push(t.setAttribute(o,u));return a},e}()}.call(this),function(){var t,r,n=function(t,e){function r(){this.constructor=t}for(var n in e)o.call(e,n)&&(t[n]=e[n]);return r.prototype=e.prototype,t.prototype=new r,t.__super__=e.prototype,t},o={}.hasOwnProperty;e.SnapshotRenderer=function(e){function o(t,e,r){this.currentSnapshot=t,this.newSnapshot=e,this.isPreview=r,this.currentHeadDetails=this.currentSnapshot.headDetails,this.newHeadDetails=this.newSnapshot.headDetails,this.currentBody=this.currentSnapshot.bodyElement,this.newBody=this.newSnapshot.bodyElement}return n(o,e),o.prototype.render=function(t){return this.shouldRender()?(this.mergeHead(),this.renderView(function(e){return function(){return e.replaceBody(),e.isPreview||e.focusFirstAutofocusableElement(),t()}}(this))):this.invalidateView()},o.prototype.mergeHead=function(){return this.copyNewHeadStylesheetElements(),this.copyNewHeadScriptElements(),this.removeCurrentHeadProvisionalElements(),this.copyNewHeadProvisionalElements()},o.prototype.replaceBody=function(){var t;return t=this.relocateCurrentBodyPermanentElements(),this.activateNewBodyScriptElements(),this.assignNewBody(),this.replacePlaceholderElementsWithClonedPermanentElements(t)},o.prototype.shouldRender=function(){return this.newSnapshot.isVisitable()&&this.trackedElementsAreIdentical()},o.prototype.trackedElementsAreIdentical=function(){return this.currentHeadDetails.getTrackedElementSignature()===this.newHeadDetails.getTrackedElementSignature()},o.prototype.copyNewHeadStylesheetElements=function(){var t,e,r,n,o;for(n=this.getNewHeadStylesheetElements(),o=[],e=0,r=n.length;r>e;e++)t=n[e],o.push(document.head.appendChild(t));return o},o.prototype.copyNewHeadScriptElements=function(){var t,e,r,n,o;for(n=this.getNewHeadScriptElements(),o=[],e=0,r=n.length;r>e;e++)t=n[e],o.push(document.head.appendChild(this.createScriptElement(t)));return o},o.prototype.removeCurrentHeadProvisionalElements=function(){var t,e,r,n,o;for(n=this.getCurrentHeadProvisionalElements(),o=[],e=0,r=n.length;r>e;e++)t=n[e],o.push(document.head.removeChild(t));return o},o.prototype.copyNewHeadProvisionalElements=function(){var t,e,r,n,o;for(n=this.getNewHeadProvisionalElements(),o=[],e=0,r=n.length;r>e;e++)t=n[e],o.push(document.head.appendChild(t));return o},o.prototype.relocateCurrentBodyPermanentElements=function(){var e,n,o,i,s,a,u;for(a=this.getCurrentBodyPermanentElements(),u=[],e=0,n=a.length;n>e;e++)i=a[e],s=t(i),o=this.newSnapshot.getPermanentElementById(i.id),r(i,s.element),r(o,i),u.push(s);return u},o.prototype.replacePlaceholderElementsWithClonedPermanentElements=function(t){var e,n,o,i,s,a,u;for(u=[],o=0,i=t.length;i>o;o++)a=t[o],n=a.element,s=a.permanentElement,e=s.cloneNode(!0),u.push(r(n,e));return u},o.prototype.activateNewBodyScriptElements=function(){var t,e,n,o,i,s;for(i=this.getNewBodyScriptElements(),s=[],e=0,o=i.length;o>e;e++)n=i[e],t=this.createScriptElement(n),s.push(r(n,t));return s},o.prototype.assignNewBody=function(){return document.body=this.newBody},o.prototype.focusFirstAutofocusableElement=function(){var t;return null!=(t=this.newSnapshot.findFirstAutofocusableElement())?t.focus():void 0},o.prototype.getNewHeadStylesheetElements=function(){return this.newHeadDetails.getStylesheetElementsNotInDetails(this.currentHeadDetails)},o.prototype.getNewHeadScriptElements=function(){return this.newHeadDetails.getScriptElementsNotInDetails(this.currentHeadDetails)},o.prototype.getCurrentHeadProvisionalElements=function(){return this.currentHeadDetails.getProvisionalElements()},o.prototype.getNewHeadProvisionalElements=function(){return this.newHeadDetails.getProvisionalElements()},o.prototype.getCurrentBodyPermanentElements=function(){return this.currentSnapshot.getPermanentElementsPresentInSnapshot(this.newSnapshot)},o.prototype.getNewBodyScriptElements=function(){return this.newBody.querySelectorAll("script")},o}(e.Renderer),t=function(t){var e;return e=document.createElement("meta"),e.setAttribute("name","turbolinks-permanent-placeholder"),e.setAttribute("content",t.id),{element:e,permanentElement:t}},r=function(t,e){var r;return(r=t.parentNode)?r.replaceChild(e,t):void 0}}.call(this),function(){var t=function(t,e){function n(){this.constructor=t}for(var o in e)r.call(e,o)&&(t[o]=e[o]);return n.prototype=e.prototype,t.prototype=new n,t.__super__=e.prototype,t},r={}.hasOwnProperty;e.ErrorRenderer=function(e){function r(t){var e;e=document.createElement("html"),e.innerHTML=t,this.newHead=e.querySelector("head"),this.newBody=e.querySelector("body")}return t(r,e),r.prototype.render=function(t){return this.renderView(function(e){return function(){return e.replaceHeadAndBody(),e.activateBodyScriptElements(),t()}}(this))},r.prototype.replaceHeadAndBody=function(){var t,e;return e=document.head,t=document.body,e.parentNode.replaceChild(this.newHead,e),t.parentNode.replaceChild(this.newBody,t)},r.prototype.activateBodyScriptElements=function(){var t,e,r,n,o,i;for(n=this.getScriptElements(),i=[],e=0,r=n.length;r>e;e++)o=n[e],t=this.createScriptElement(o),i.push(o.parentNode.replaceChild(t,o));return i},r.prototype.getScriptElements=function(){return document.documentElement.querySelectorAll("script")},r}(e.Renderer)}.call(this),function(){e.View=function(){function t(t){this.delegate=t,this.htmlElement=document.documentElement}return t.prototype.getRootLocation=function(){return this.getSnapshot().getRootLocation()},t.prototype.getElementForAnchor=function(t){return this.getSnapshot().getElementForAnchor(t)},t.prototype.getSnapshot=function(){return e.Snapshot.fromHTMLElement(this.htmlElement)},t.prototype.render=function(t,e){var r,n,o;return o=t.snapshot,r=t.error,n=t.isPreview,this.markAsPreview(n),null!=o?this.renderSnapshot(o,n,e):this.renderError(r,e)},t.prototype.markAsPreview=function(t){return t?this.htmlElement.setAttribute("data-turbolinks-preview",""):this.htmlElement.removeAttribute("data-turbolinks-preview")},t.prototype.renderSnapshot=function(t,r,n){return e.SnapshotRenderer.render(this.delegate,n,this.getSnapshot(),e.Snapshot.wrap(t),r)},t.prototype.renderError=function(t,r){return e.ErrorRenderer.render(this.delegate,r,t)},t}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.ScrollManager=function(){function r(r){this.delegate=r,this.onScroll=t(this.onScroll,this),this.onScroll=e.throttle(this.onScroll)}return r.prototype.start=function(){return this.started?void 0:(addEventListener("scroll",this.onScroll,!1),this.onScroll(),this.started=!0)},r.prototype.stop=function(){return this.started?(removeEventListener("scroll",this.onScroll,!1),this.started=!1):void 0},r.prototype.scrollToElement=function(t){return t.scrollIntoView()},r.prototype.scrollToPosition=function(t){var e,r;return e=t.x,r=t.y,window.scrollTo(e,r)},r.prototype.onScroll=function(t){return this.updatePosition({x:window.pageXOffset,y:window.pageYOffset})},r.prototype.updatePosition=function(t){var e;return this.position=t,null!=(e=this.delegate)?e.scrollPositionChanged(this.position):void 0},r}()}.call(this),function(){e.SnapshotCache=function(){function t(t){this.size=t,this.keys=[],this.snapshots={}}var r;return t.prototype.has=function(t){var e;return e=r(t),e in this.snapshots},t.prototype.get=function(t){var e;if(this.has(t))return e=this.read(t),this.touch(t),e},t.prototype.put=function(t,e){return this.write(t,e),this.touch(t),e},t.prototype.read=function(t){var e;return e=r(t),this.snapshots[e]},t.prototype.write=function(t,e){var n;return n=r(t),this.snapshots[n]=e},t.prototype.touch=function(t){var e,n;return n=r(t),e=this.keys.indexOf(n),e>-1&&this.keys.splice(e,1),this.keys.unshift(n),this.trim()},t.prototype.trim=function(){var t,e,r,n,o;for(n=this.keys.splice(this.size),o=[],t=0,r=n.length;r>t;t++)e=n[t],o.push(delete this.snapshots[e]);return o},r=function(t){return e.Location.wrap(t).toCacheKey()},t}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.Visit=function(){function r(r,n,o){this.controller=r,this.action=o,this.performScroll=t(this.performScroll,this),this.identifier=e.uuid(),this.location=e.Location.wrap(n),this.adapter=this.controller.adapter,this.state="initialized",this.timingMetrics={}}var n;return r.prototype.start=function(){return"initialized"===this.state?(this.recordTimingMetric("visitStart"),this.state="started",this.adapter.visitStarted(this)):void 0},r.prototype.cancel=function(){var t;return"started"===this.state?(null!=(t=this.request)&&t.cancel(),this.cancelRender(),this.state="canceled"):void 0},r.prototype.complete=function(){var t;return"started"===this.state?(this.recordTimingMetric("visitEnd"),this.state="completed","function"==typeof(t=this.adapter).visitCompleted&&t.visitCompleted(this),this.controller.visitCompleted(this)):void 0},r.prototype.fail=function(){var t;return"started"===this.state?(this.state="failed","function"==typeof(t=this.adapter).visitFailed?t.visitFailed(this):void 0):void 0},r.prototype.changeHistory=function(){var t,e;return this.historyChanged?void 0:(t=this.location.isEqualTo(this.referrer)?"replace":this.action,e=n(t),this.controller[e](this.location,this.restorationIdentifier),this.historyChanged=!0)},r.prototype.issueRequest=function(){return this.shouldIssueRequest()&&null==this.request?(this.progress=0,this.request=new e.HttpRequest(this,this.location,this.referrer),this.request.send()):void 0},r.prototype.getCachedSnapshot=function(){var t;return!(t=this.controller.getCachedSnapshotForLocation(this.location))||null!=this.location.anchor&&!t.hasAnchor(this.location.anchor)||"restore"!==this.action&&!t.isPreviewable()?void 0:t},r.prototype.hasCachedSnapshot=function(){return null!=this.getCachedSnapshot()},r.prototype.loadCachedSnapshot=function(){var t,e;return(e=this.getCachedSnapshot())?(t=this.shouldIssueRequest(),this.render(function(){var r;return this.cacheSnapshot(),this.controller.render({snapshot:e,isPreview:t},this.performScroll),"function"==typeof(r=this.adapter).visitRendered&&r.visitRendered(this),t?void 0:this.complete()})):void 0},r.prototype.loadResponse=function(){return null!=this.response?this.render(function(){var t,e;return this.cacheSnapshot(),this.request.failed?(this.controller.render({error:this.response},this.performScroll),"function"==typeof(t=this.adapter).visitRendered&&t.visitRendered(this),this.fail()):(this.controller.render({snapshot:this.response},this.performScroll),"function"==typeof(e=this.adapter).visitRendered&&e.visitRendered(this),this.complete())}):void 0},r.prototype.followRedirect=function(){return this.redirectedToLocation&&!this.followedRedirect?(this.location=this.redirectedToLocation,this.controller.replaceHistoryWithLocationAndRestorationIdentifier(this.redirectedToLocation,this.restorationIdentifier),this.followedRedirect=!0):void 0},r.prototype.requestStarted=function(){var t;return this.recordTimingMetric("requestStart"),"function"==typeof(t=this.adapter).visitRequestStarted?t.visitRequestStarted(this):void 0},r.prototype.requestProgressed=function(t){var e;return this.progress=t,"function"==typeof(e=this.adapter).visitRequestProgressed?e.visitRequestProgressed(this):void 0},r.prototype.requestCompletedWithResponse=function(t,r){return this.response=t,null!=r&&(this.redirectedToLocation=e.Location.wrap(r)),this.adapter.visitRequestCompleted(this)},r.prototype.requestFailedWithStatusCode=function(t,e){return this.response=e,this.adapter.visitRequestFailedWithStatusCode(this,t)},r.prototype.requestFinished=function(){var t;return this.recordTimingMetric("requestEnd"),"function"==typeof(t=this.adapter).visitRequestFinished?t.visitRequestFinished(this):void 0},r.prototype.performScroll=function(){return this.scrolled?void 0:("restore"===this.action?this.scrollToRestoredPosition()||this.scrollToTop():this.scrollToAnchor()||this.scrollToTop(),this.scrolled=!0)},r.prototype.scrollToRestoredPosition=function(){var t,e;return t=null!=(e=this.restorationData)?e.scrollPosition:void 0,null!=t?(this.controller.scrollToPosition(t),!0):void 0},r.prototype.scrollToAnchor=function(){return null!=this.location.anchor?(this.controller.scrollToAnchor(this.location.anchor),!0):void 0},r.prototype.scrollToTop=function(){return this.controller.scrollToPosition({x:0,y:0})},r.prototype.recordTimingMetric=function(t){var e;return null!=(e=this.timingMetrics)[t]?e[t]:e[t]=(new Date).getTime()},r.prototype.getTimingMetrics=function(){return e.copyObject(this.timingMetrics)},n=function(t){switch(t){case"replace":return"replaceHistoryWithLocationAndRestorationIdentifier";case"advance":case"restore":return"pushHistoryWithLocationAndRestorationIdentifier"}},r.prototype.shouldIssueRequest=function(){return"restore"===this.action?!this.hasCachedSnapshot():!0},r.prototype.cacheSnapshot=function(){return this.snapshotCached?void 0:(this.controller.cacheSnapshot(),this.snapshotCached=!0)},r.prototype.render=function(t){return this.cancelRender(),this.frame=requestAnimationFrame(function(e){return function(){return e.frame=null,t.call(e)}}(this))},r.prototype.cancelRender=function(){return this.frame?cancelAnimationFrame(this.frame):void 0},r}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.Controller=function(){function r(){this.clickBubbled=t(this.clickBubbled,this),this.clickCaptured=t(this.clickCaptured,this),this.pageLoaded=t(this.pageLoaded,this),this.history=new e.History(this),this.view=new e.View(this),this.scrollManager=new e.ScrollManager(this),this.restorationData={},this.clearCache(),this.setProgressBarDelay(500)}return r.prototype.start=function(){return e.supported&&!this.started?(addEventListener("click",this.clickCaptured,!0),addEventListener("DOMContentLoaded",this.pageLoaded,!1),this.scrollManager.start(),this.startHistory(),this.started=!0,this.enabled=!0):void 0},r.prototype.disable=function(){return this.enabled=!1},r.prototype.stop=function(){return this.started?(removeEventListener("click",this.clickCaptured,!0),removeEventListener("DOMContentLoaded",this.pageLoaded,!1),this.scrollManager.stop(),this.stopHistory(),this.started=!1):void 0},r.prototype.clearCache=function(){return this.cache=new e.SnapshotCache(10)},r.prototype.visit=function(t,r){var n,o;return null==r&&(r={}),t=e.Location.wrap(t),this.applicationAllowsVisitingLocation(t)?this.locationIsVisitable(t)?(n=null!=(o=r.action)?o:"advance",this.adapter.visitProposedToLocationWithAction(t,n)):window.location=t:void 0},r.prototype.startVisitToLocationWithAction=function(t,r,n){var o;return e.supported?(o=this.getRestorationDataForIdentifier(n),this.startVisit(t,r,{restorationData:o})):window.location=t},r.prototype.setProgressBarDelay=function(t){return this.progressBarDelay=t},r.prototype.startHistory=function(){return this.location=e.Location.wrap(window.location),this.restorationIdentifier=e.uuid(),this.history.start(),this.history.replace(this.location,this.restorationIdentifier)},r.prototype.stopHistory=function(){return this.history.stop()},r.prototype.pushHistoryWithLocationAndRestorationIdentifier=function(t,r){return this.restorationIdentifier=r,this.location=e.Location.wrap(t),this.history.push(this.location,this.restorationIdentifier)},r.prototype.replaceHistoryWithLocationAndRestorationIdentifier=function(t,r){return this.restorationIdentifier=r,this.location=e.Location.wrap(t),this.history.replace(this.location,this.restorationIdentifier)},r.prototype.historyPoppedToLocationWithRestorationIdentifier=function(t,r){var n;return this.restorationIdentifier=r,this.enabled?(n=this.getRestorationDataForIdentifier(this.restorationIdentifier),this.startVisit(t,"restore",{restorationIdentifier:this.restorationIdentifier,restorationData:n,historyChanged:!0}),this.location=e.Location.wrap(t)):this.adapter.pageInvalidated()},r.prototype.getCachedSnapshotForLocation=function(t){var e;return null!=(e=this.cache.get(t))?e.clone():void 0},r.prototype.shouldCacheSnapshot=function(){return this.view.getSnapshot().isCacheable();
  },r.prototype.cacheSnapshot=function(){var t,r;return this.shouldCacheSnapshot()?(this.notifyApplicationBeforeCachingSnapshot(),r=this.view.getSnapshot(),t=this.lastRenderedLocation,e.defer(function(e){return function(){return e.cache.put(t,r.clone())}}(this))):void 0},r.prototype.scrollToAnchor=function(t){var e;return(e=this.view.getElementForAnchor(t))?this.scrollToElement(e):this.scrollToPosition({x:0,y:0})},r.prototype.scrollToElement=function(t){return this.scrollManager.scrollToElement(t)},r.prototype.scrollToPosition=function(t){return this.scrollManager.scrollToPosition(t)},r.prototype.scrollPositionChanged=function(t){var e;return e=this.getCurrentRestorationData(),e.scrollPosition=t},r.prototype.render=function(t,e){return this.view.render(t,e)},r.prototype.viewInvalidated=function(){return this.adapter.pageInvalidated()},r.prototype.viewWillRender=function(t){return this.notifyApplicationBeforeRender(t)},r.prototype.viewRendered=function(){return this.lastRenderedLocation=this.currentVisit.location,this.notifyApplicationAfterRender()},r.prototype.pageLoaded=function(){return this.lastRenderedLocation=this.location,this.notifyApplicationAfterPageLoad()},r.prototype.clickCaptured=function(){return removeEventListener("click",this.clickBubbled,!1),addEventListener("click",this.clickBubbled,!1)},r.prototype.clickBubbled=function(t){var e,r,n;return this.enabled&&this.clickEventIsSignificant(t)&&(r=this.getVisitableLinkForNode(t.target))&&(n=this.getVisitableLocationForLink(r))&&this.applicationAllowsFollowingLinkToLocation(r,n)?(t.preventDefault(),e=this.getActionForLink(r),this.visit(n,{action:e})):void 0},r.prototype.applicationAllowsFollowingLinkToLocation=function(t,e){var r;return r=this.notifyApplicationAfterClickingLinkToLocation(t,e),!r.defaultPrevented},r.prototype.applicationAllowsVisitingLocation=function(t){var e;return e=this.notifyApplicationBeforeVisitingLocation(t),!e.defaultPrevented},r.prototype.notifyApplicationAfterClickingLinkToLocation=function(t,r){return e.dispatch("turbolinks:click",{target:t,data:{url:r.absoluteURL},cancelable:!0})},r.prototype.notifyApplicationBeforeVisitingLocation=function(t){return e.dispatch("turbolinks:before-visit",{data:{url:t.absoluteURL},cancelable:!0})},r.prototype.notifyApplicationAfterVisitingLocation=function(t){return e.dispatch("turbolinks:visit",{data:{url:t.absoluteURL}})},r.prototype.notifyApplicationBeforeCachingSnapshot=function(){return e.dispatch("turbolinks:before-cache")},r.prototype.notifyApplicationBeforeRender=function(t){return e.dispatch("turbolinks:before-render",{data:{newBody:t}})},r.prototype.notifyApplicationAfterRender=function(){return e.dispatch("turbolinks:render")},r.prototype.notifyApplicationAfterPageLoad=function(t){return null==t&&(t={}),e.dispatch("turbolinks:load",{data:{url:this.location.absoluteURL,timing:t}})},r.prototype.startVisit=function(t,e,r){var n;return null!=(n=this.currentVisit)&&n.cancel(),this.currentVisit=this.createVisit(t,e,r),this.currentVisit.start(),this.notifyApplicationAfterVisitingLocation(t)},r.prototype.createVisit=function(t,r,n){var o,i,s,a,u;return i=null!=n?n:{},a=i.restorationIdentifier,s=i.restorationData,o=i.historyChanged,u=new e.Visit(this,t,r),u.restorationIdentifier=null!=a?a:e.uuid(),u.restorationData=e.copyObject(s),u.historyChanged=o,u.referrer=this.location,u},r.prototype.visitCompleted=function(t){return this.notifyApplicationAfterPageLoad(t.getTimingMetrics())},r.prototype.clickEventIsSignificant=function(t){return!(t.defaultPrevented||t.target.isContentEditable||t.which>1||t.altKey||t.ctrlKey||t.metaKey||t.shiftKey)},r.prototype.getVisitableLinkForNode=function(t){return this.nodeIsVisitable(t)?e.closest(t,"a[href]:not([target]):not([download])"):void 0},r.prototype.getVisitableLocationForLink=function(t){var r;return r=new e.Location(t.getAttribute("href")),this.locationIsVisitable(r)?r:void 0},r.prototype.getActionForLink=function(t){var e;return null!=(e=t.getAttribute("data-turbolinks-action"))?e:"advance"},r.prototype.nodeIsVisitable=function(t){var r;return(r=e.closest(t,"[data-turbolinks]"))?"false"!==r.getAttribute("data-turbolinks"):!0},r.prototype.locationIsVisitable=function(t){return t.isPrefixedBy(this.view.getRootLocation())&&t.isHTML()},r.prototype.getCurrentRestorationData=function(){return this.getRestorationDataForIdentifier(this.restorationIdentifier)},r.prototype.getRestorationDataForIdentifier=function(t){var e;return null!=(e=this.restorationData)[t]?e[t]:e[t]={}},r}()}.call(this),function(){!function(){var t,e;if((t=e=document.currentScript)&&!e.hasAttribute("data-turbolinks-suppress-warning"))for(;t=t.parentNode;)if(t===document.body)return console.warn("You are loading Turbolinks from a <script> element inside the <body> element. This is probably not what you meant to do!\n\nLoad your application\u2019s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.\n\nFor more information, see: https://github.com/turbolinks/turbolinks#working-with-script-elements\n\n\u2014\u2014\nSuppress this warning by adding a `data-turbolinks-suppress-warning` attribute to: %s",e.outerHTML)}()}.call(this),function(){var t,r,n;e.start=function(){return r()?(null==e.controller&&(e.controller=t()),e.controller.start()):void 0},r=function(){return null==window.Turbolinks&&(window.Turbolinks=e),n()},t=function(){var t;return t=new e.Controller,t.adapter=new e.BrowserAdapter(t),t},n=function(){return window.Turbolinks===e},n()&&e.start()}.call(this)}).call(this),"object"==typeof module&&module.exports?module.exports=e:"function"==typeof define&&define.amd&&define(e)}).call(this);
  /*!
   * jQuery JavaScript Library v1.12.4
   * http://jquery.com/
   *
   * Includes Sizzle.js
   * http://sizzlejs.com/
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license
   * http://jquery.org/license
   *
   * Date: 2016-05-20T17:17Z
   */
  
  
  (function( global, factory ) {
  
      if ( typeof module === "object" && typeof module.exports === "object" ) {
          // For CommonJS and CommonJS-like environments where a proper `window`
          // is present, execute the factory and get jQuery.
          // For environments that do not have a `window` with a `document`
          // (such as Node.js), expose a factory as module.exports.
          // This accentuates the need for the creation of a real `window`.
          // e.g. var jQuery = require("jquery")(window);
          // See ticket #14549 for more info.
          module.exports = global.document ?
              factory( global, true ) :
              function( w ) {
                  if ( !w.document ) {
                      throw new Error( "jQuery requires a window with a document" );
                  }
                  return factory( w );
              };
      } else {
          factory( global );
      }
  
  // Pass this if window is not defined yet
  }(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
  
  // Support: Firefox 18+
  // Can't be in strict mode, several libs including ASP.NET trace
  // the stack via arguments.caller.callee and Firefox dies if
  // you try to trace through "use strict" call chains. (#13335)
  //"use strict";
  var deletedIds = [];
  
  var document = window.document;
  
  var slice = deletedIds.slice;
  
  var concat = deletedIds.concat;
  
  var push = deletedIds.push;
  
  var indexOf = deletedIds.indexOf;
  
  var class2type = {};
  
  var toString = class2type.toString;
  
  var hasOwn = class2type.hasOwnProperty;
  
  var support = {};
  
  
  
  var
      version = "1.12.4",
  
      // Define a local copy of jQuery
      jQuery = function( selector, context ) {
  
          // The jQuery object is actually just the init constructor 'enhanced'
          // Need init if jQuery is called (just allow error to be thrown if not included)
          return new jQuery.fn.init( selector, context );
      },
  
      // Support: Android<4.1, IE<9
      // Make sure we trim BOM and NBSP
      rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
  
      // Matches dashed string for camelizing
      rmsPrefix = /^-ms-/,
      rdashAlpha = /-([\da-z])/gi,
  
      // Used by jQuery.camelCase as callback to replace()
      fcamelCase = function( all, letter ) {
          return letter.toUpperCase();
      };
  
  jQuery.fn = jQuery.prototype = {
  
      // The current version of jQuery being used
      jquery: version,
  
      constructor: jQuery,
  
      // Start with an empty selector
      selector: "",
  
      // The default length of a jQuery object is 0
      length: 0,
  
      toArray: function() {
          return slice.call( this );
      },
  
      // Get the Nth element in the matched element set OR
      // Get the whole matched element set as a clean array
      get: function( num ) {
          return num != null ?
  
              // Return just the one element from the set
              ( num < 0 ? this[ num + this.length ] : this[ num ] ) :
  
              // Return all the elements in a clean array
              slice.call( this );
      },
  
      // Take an array of elements and push it onto the stack
      // (returning the new matched element set)
      pushStack: function( elems ) {
  
          // Build a new jQuery matched element set
          var ret = jQuery.merge( this.constructor(), elems );
  
          // Add the old object onto the stack (as a reference)
          ret.prevObject = this;
          ret.context = this.context;
  
          // Return the newly-formed element set
          return ret;
      },
  
      // Execute a callback for every element in the matched set.
      each: function( callback ) {
          return jQuery.each( this, callback );
      },
  
      map: function( callback ) {
          return this.pushStack( jQuery.map( this, function( elem, i ) {
              return callback.call( elem, i, elem );
          } ) );
      },
  
      slice: function() {
          return this.pushStack( slice.apply( this, arguments ) );
      },
  
      first: function() {
          return this.eq( 0 );
      },
  
      last: function() {
          return this.eq( -1 );
      },
  
      eq: function( i ) {
          var len = this.length,
              j = +i + ( i < 0 ? len : 0 );
          return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
      },
  
      end: function() {
          return this.prevObject || this.constructor();
      },
  
      // For internal use only.
      // Behaves like an Array's method, not like a jQuery method.
      push: push,
      sort: deletedIds.sort,
      splice: deletedIds.splice
  };
  
  jQuery.extend = jQuery.fn.extend = function() {
      var src, copyIsArray, copy, name, options, clone,
          target = arguments[ 0 ] || {},
          i = 1,
          length = arguments.length,
          deep = false;
  
      // Handle a deep copy situation
      if ( typeof target === "boolean" ) {
          deep = target;
  
          // skip the boolean and the target
          target = arguments[ i ] || {};
          i++;
      }
  
      // Handle case when target is a string or something (possible in deep copy)
      if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
          target = {};
      }
  
      // extend jQuery itself if only one argument is passed
      if ( i === length ) {
          target = this;
          i--;
      }
  
      for ( ; i < length; i++ ) {
  
          // Only deal with non-null/undefined values
          if ( ( options = arguments[ i ] ) != null ) {
  
              // Extend the base object
              for ( name in options ) {
                  src = target[ name ];
                  copy = options[ name ];
  
                  // Prevent never-ending loop
                  if ( target === copy ) {
                      continue;
                  }
  
                  // Recurse if we're merging plain objects or arrays
                  if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
                      ( copyIsArray = jQuery.isArray( copy ) ) ) ) {
  
                      if ( copyIsArray ) {
                          copyIsArray = false;
                          clone = src && jQuery.isArray( src ) ? src : [];
  
                      } else {
                          clone = src && jQuery.isPlainObject( src ) ? src : {};
                      }
  
                      // Never move original objects, clone them
                      target[ name ] = jQuery.extend( deep, clone, copy );
  
                  // Don't bring in undefined values
                  } else if ( copy !== undefined ) {
                      target[ name ] = copy;
                  }
              }
          }
      }
  
      // Return the modified object
      return target;
  };
  
  jQuery.extend( {
  
      // Unique for each copy of jQuery on the page
      expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
  
      // Assume jQuery is ready without the ready module
      isReady: true,
  
      error: function( msg ) {
          throw new Error( msg );
      },
  
      noop: function() {},
  
      // See test/unit/core.js for details concerning isFunction.
      // Since version 1.3, DOM methods and functions like alert
      // aren't supported. They return false on IE (#2968).
      isFunction: function( obj ) {
          return jQuery.type( obj ) === "function";
      },
  
      isArray: Array.isArray || function( obj ) {
          return jQuery.type( obj ) === "array";
      },
  
      isWindow: function( obj ) {
          /* jshint eqeqeq: false */
          return obj != null && obj == obj.window;
      },
  
      isNumeric: function( obj ) {
  
          // parseFloat NaNs numeric-cast false positives (null|true|false|"")
          // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
          // subtraction forces infinities to NaN
          // adding 1 corrects loss of precision from parseFloat (#15100)
          var realStringObj = obj && obj.toString();
          return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
      },
  
      isEmptyObject: function( obj ) {
          var name;
          for ( name in obj ) {
              return false;
          }
          return true;
      },
  
      isPlainObject: function( obj ) {
          var key;
  
          // Must be an Object.
          // Because of IE, we also have to check the presence of the constructor property.
          // Make sure that DOM nodes and window objects don't pass through, as well
          if ( !obj || jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
              return false;
          }
  
          try {
  
              // Not own constructor property must be Object
              if ( obj.constructor &&
                  !hasOwn.call( obj, "constructor" ) &&
                  !hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
                  return false;
              }
          } catch ( e ) {
  
              // IE8,9 Will throw exceptions on certain host objects #9897
              return false;
          }
  
          // Support: IE<9
          // Handle iteration over inherited properties before own properties.
          if ( !support.ownFirst ) {
              for ( key in obj ) {
                  return hasOwn.call( obj, key );
              }
          }
  
          // Own properties are enumerated firstly, so to speed up,
          // if last one is own, then all properties are own.
          for ( key in obj ) {}
  
          return key === undefined || hasOwn.call( obj, key );
      },
  
      type: function( obj ) {
          if ( obj == null ) {
              return obj + "";
          }
          return typeof obj === "object" || typeof obj === "function" ?
              class2type[ toString.call( obj ) ] || "object" :
              typeof obj;
      },
  
      // Workarounds based on findings by Jim Driscoll
      // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
      globalEval: function( data ) {
          if ( data && jQuery.trim( data ) ) {
  
              // We use execScript on Internet Explorer
              // We use an anonymous function so that context is window
              // rather than jQuery in Firefox
              ( window.execScript || function( data ) {
                  window[ "eval" ].call( window, data ); // jscs:ignore requireDotNotation
              } )( data );
          }
      },
  
      // Convert dashed to camelCase; used by the css and data modules
      // Microsoft forgot to hump their vendor prefix (#9572)
      camelCase: function( string ) {
          return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
      },
  
      nodeName: function( elem, name ) {
          return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
      },
  
      each: function( obj, callback ) {
          var length, i = 0;
  
          if ( isArrayLike( obj ) ) {
              length = obj.length;
              for ( ; i < length; i++ ) {
                  if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                      break;
                  }
              }
          } else {
              for ( i in obj ) {
                  if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                      break;
                  }
              }
          }
  
          return obj;
      },
  
      // Support: Android<4.1, IE<9
      trim: function( text ) {
          return text == null ?
              "" :
              ( text + "" ).replace( rtrim, "" );
      },
  
      // results is for internal usage only
      makeArray: function( arr, results ) {
          var ret = results || [];
  
          if ( arr != null ) {
              if ( isArrayLike( Object( arr ) ) ) {
                  jQuery.merge( ret,
                      typeof arr === "string" ?
                      [ arr ] : arr
                  );
              } else {
                  push.call( ret, arr );
              }
          }
  
          return ret;
      },
  
      inArray: function( elem, arr, i ) {
          var len;
  
          if ( arr ) {
              if ( indexOf ) {
                  return indexOf.call( arr, elem, i );
              }
  
              len = arr.length;
              i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;
  
              for ( ; i < len; i++ ) {
  
                  // Skip accessing in sparse arrays
                  if ( i in arr && arr[ i ] === elem ) {
                      return i;
                  }
              }
          }
  
          return -1;
      },
  
      merge: function( first, second ) {
          var len = +second.length,
              j = 0,
              i = first.length;
  
          while ( j < len ) {
              first[ i++ ] = second[ j++ ];
          }
  
          // Support: IE<9
          // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
          if ( len !== len ) {
              while ( second[ j ] !== undefined ) {
                  first[ i++ ] = second[ j++ ];
              }
          }
  
          first.length = i;
  
          return first;
      },
  
      grep: function( elems, callback, invert ) {
          var callbackInverse,
              matches = [],
              i = 0,
              length = elems.length,
              callbackExpect = !invert;
  
          // Go through the array, only saving the items
          // that pass the validator function
          for ( ; i < length; i++ ) {
              callbackInverse = !callback( elems[ i ], i );
              if ( callbackInverse !== callbackExpect ) {
                  matches.push( elems[ i ] );
              }
          }
  
          return matches;
      },
  
      // arg is for internal usage only
      map: function( elems, callback, arg ) {
          var length, value,
              i = 0,
              ret = [];
  
          // Go through the array, translating each of the items to their new values
          if ( isArrayLike( elems ) ) {
              length = elems.length;
              for ( ; i < length; i++ ) {
                  value = callback( elems[ i ], i, arg );
  
                  if ( value != null ) {
                      ret.push( value );
                  }
              }
  
          // Go through every key on the object,
          } else {
              for ( i in elems ) {
                  value = callback( elems[ i ], i, arg );
  
                  if ( value != null ) {
                      ret.push( value );
                  }
              }
          }
  
          // Flatten any nested arrays
          return concat.apply( [], ret );
      },
  
      // A global GUID counter for objects
      guid: 1,
  
      // Bind a function to a context, optionally partially applying any
      // arguments.
      proxy: function( fn, context ) {
          var args, proxy, tmp;
  
          if ( typeof context === "string" ) {
              tmp = fn[ context ];
              context = fn;
              fn = tmp;
          }
  
          // Quick check to determine if target is callable, in the spec
          // this throws a TypeError, but we will just return undefined.
          if ( !jQuery.isFunction( fn ) ) {
              return undefined;
          }
  
          // Simulated bind
          args = slice.call( arguments, 2 );
          proxy = function() {
              return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
          };
  
          // Set the guid of unique handler to the same of original handler, so it can be removed
          proxy.guid = fn.guid = fn.guid || jQuery.guid++;
  
          return proxy;
      },
  
      now: function() {
          return +( new Date() );
      },
  
      // jQuery.support is not used in Core but other projects attach their
      // properties to it so it needs to exist.
      support: support
  } );
  
  // JSHint would error on this code due to the Symbol not being defined in ES5.
  // Defining this global in .jshintrc would create a danger of using the global
  // unguarded in another place, it seems safer to just disable JSHint for these
  // three lines.
  /* jshint ignore: start */
  if ( typeof Symbol === "function" ) {
      jQuery.fn[ Symbol.iterator ] = deletedIds[ Symbol.iterator ];
  }
  /* jshint ignore: end */
  
  // Populate the class2type map
  jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
  function( i, name ) {
      class2type[ "[object " + name + "]" ] = name.toLowerCase();
  } );
  
  function isArrayLike( obj ) {
  
      // Support: iOS 8.2 (not reproducible in simulator)
      // `in` check used to prevent JIT error (gh-2145)
      // hasOwn isn't used here due to false negatives
      // regarding Nodelist length in IE
      var length = !!obj && "length" in obj && obj.length,
          type = jQuery.type( obj );
  
      if ( type === "function" || jQuery.isWindow( obj ) ) {
          return false;
      }
  
      return type === "array" || length === 0 ||
          typeof length === "number" && length > 0 && ( length - 1 ) in obj;
  }
  var Sizzle =
  /*!
   * Sizzle CSS Selector Engine v2.2.1
   * http://sizzlejs.com/
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license
   * http://jquery.org/license
   *
   * Date: 2015-10-17
   */
  (function( window ) {
  
  var i,
      support,
      Expr,
      getText,
      isXML,
      tokenize,
      compile,
      select,
      outermostContext,
      sortInput,
      hasDuplicate,
  
      // Local document vars
      setDocument,
      document,
      docElem,
      documentIsHTML,
      rbuggyQSA,
      rbuggyMatches,
      matches,
      contains,
  
      // Instance-specific data
      expando = "sizzle" + 1 * new Date(),
      preferredDoc = window.document,
      dirruns = 0,
      done = 0,
      classCache = createCache(),
      tokenCache = createCache(),
      compilerCache = createCache(),
      sortOrder = function( a, b ) {
          if ( a === b ) {
              hasDuplicate = true;
          }
          return 0;
      },
  
      // General-purpose constants
      MAX_NEGATIVE = 1 << 31,
  
      // Instance methods
      hasOwn = ({}).hasOwnProperty,
      arr = [],
      pop = arr.pop,
      push_native = arr.push,
      push = arr.push,
      slice = arr.slice,
      // Use a stripped-down indexOf as it's faster than native
      // http://jsperf.com/thor-indexof-vs-for/5
      indexOf = function( list, elem ) {
          var i = 0,
              len = list.length;
          for ( ; i < len; i++ ) {
              if ( list[i] === elem ) {
                  return i;
              }
          }
          return -1;
      },
  
      booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
  
      // Regular expressions
  
      // http://www.w3.org/TR/css3-selectors/#whitespace
      whitespace = "[\\x20\\t\\r\\n\\f]",
  
      // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
      identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
  
      // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
      attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
          // Operator (capture 2)
          "*([*^$|!~]?=)" + whitespace +
          // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
          "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
          "*\\]",
  
      pseudos = ":(" + identifier + ")(?:\\((" +
          // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
          // 1. quoted (capture 3; capture 4 or capture 5)
          "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
          // 2. simple (capture 6)
          "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
          // 3. anything else (capture 2)
          ".*" +
          ")\\)|)",
  
      // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
      rwhitespace = new RegExp( whitespace + "+", "g" ),
      rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
  
      rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
      rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
  
      rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
  
      rpseudo = new RegExp( pseudos ),
      ridentifier = new RegExp( "^" + identifier + "$" ),
  
      matchExpr = {
          "ID": new RegExp( "^#(" + identifier + ")" ),
          "CLASS": new RegExp( "^\\.(" + identifier + ")" ),
          "TAG": new RegExp( "^(" + identifier + "|[*])" ),
          "ATTR": new RegExp( "^" + attributes ),
          "PSEUDO": new RegExp( "^" + pseudos ),
          "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
              "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
              "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
          "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
              whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
      },
  
      rinputs = /^(?:input|select|textarea|button)$/i,
      rheader = /^h\d$/i,
  
      rnative = /^[^{]+\{\s*\[native \w/,
  
      // Easily-parseable/retrievable ID or TAG or CLASS selectors
      rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
  
      rsibling = /[+~]/,
      rescape = /'|\\/g,
  
      // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
      runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
      funescape = function( _, escaped, escapedWhitespace ) {
          var high = "0x" + escaped - 0x10000;
          // NaN means non-codepoint
          // Support: Firefox<24
          // Workaround erroneous numeric interpretation of +"0x"
          return high !== high || escapedWhitespace ?
              escaped :
              high < 0 ?
                  // BMP codepoint
                  String.fromCharCode( high + 0x10000 ) :
                  // Supplemental Plane codepoint (surrogate pair)
                  String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
      },
  
      // Used for iframes
      // See setDocument()
      // Removing the function wrapper causes a "Permission Denied"
      // error in IE
      unloadHandler = function() {
          setDocument();
      };
  
  // Optimize for push.apply( _, NodeList )
  try {
      push.apply(
          (arr = slice.call( preferredDoc.childNodes )),
          preferredDoc.childNodes
      );
      // Support: Android<4.0
      // Detect silently failing push.apply
      arr[ preferredDoc.childNodes.length ].nodeType;
  } catch ( e ) {
      push = { apply: arr.length ?
  
          // Leverage slice if possible
          function( target, els ) {
              push_native.apply( target, slice.call(els) );
          } :
  
          // Support: IE<9
          // Otherwise append directly
          function( target, els ) {
              var j = target.length,
                  i = 0;
              // Can't trust NodeList.length
              while ( (target[j++] = els[i++]) ) {}
              target.length = j - 1;
          }
      };
  }
  
  function Sizzle( selector, context, results, seed ) {
      var m, i, elem, nid, nidselect, match, groups, newSelector,
          newContext = context && context.ownerDocument,
  
          // nodeType defaults to 9, since context defaults to document
          nodeType = context ? context.nodeType : 9;
  
      results = results || [];
  
      // Return early from calls with invalid selector or context
      if ( typeof selector !== "string" || !selector ||
          nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
  
          return results;
      }
  
      // Try to shortcut find operations (as opposed to filters) in HTML documents
      if ( !seed ) {
  
          if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
              setDocument( context );
          }
          context = context || document;
  
          if ( documentIsHTML ) {
  
              // If the selector is sufficiently simple, try using a "get*By*" DOM method
              // (excepting DocumentFragment context, where the methods don't exist)
              if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
  
                  // ID selector
                  if ( (m = match[1]) ) {
  
                      // Document context
                      if ( nodeType === 9 ) {
                          if ( (elem = context.getElementById( m )) ) {
  
                              // Support: IE, Opera, Webkit
                              // TODO: identify versions
                              // getElementById can match elements by name instead of ID
                              if ( elem.id === m ) {
                                  results.push( elem );
                                  return results;
                              }
                          } else {
                              return results;
                          }
  
                      // Element context
                      } else {
  
                          // Support: IE, Opera, Webkit
                          // TODO: identify versions
                          // getElementById can match elements by name instead of ID
                          if ( newContext && (elem = newContext.getElementById( m )) &&
                              contains( context, elem ) &&
                              elem.id === m ) {
  
                              results.push( elem );
                              return results;
                          }
                      }
  
                  // Type selector
                  } else if ( match[2] ) {
                      push.apply( results, context.getElementsByTagName( selector ) );
                      return results;
  
                  // Class selector
                  } else if ( (m = match[3]) && support.getElementsByClassName &&
                      context.getElementsByClassName ) {
  
                      push.apply( results, context.getElementsByClassName( m ) );
                      return results;
                  }
              }
  
              // Take advantage of querySelectorAll
              if ( support.qsa &&
                  !compilerCache[ selector + " " ] &&
                  (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
  
                  if ( nodeType !== 1 ) {
                      newContext = context;
                      newSelector = selector;
  
                  // qSA looks outside Element context, which is not what we want
                  // Thanks to Andrew Dupont for this workaround technique
                  // Support: IE <=8
                  // Exclude object elements
                  } else if ( context.nodeName.toLowerCase() !== "object" ) {
  
                      // Capture the context ID, setting it first if necessary
                      if ( (nid = context.getAttribute( "id" )) ) {
                          nid = nid.replace( rescape, "\\$&" );
                      } else {
                          context.setAttribute( "id", (nid = expando) );
                      }
  
                      // Prefix every selector in the list
                      groups = tokenize( selector );
                      i = groups.length;
                      nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
                      while ( i-- ) {
                          groups[i] = nidselect + " " + toSelector( groups[i] );
                      }
                      newSelector = groups.join( "," );
  
                      // Expand context for sibling selectors
                      newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
                          context;
                  }
  
                  if ( newSelector ) {
                      try {
                          push.apply( results,
                              newContext.querySelectorAll( newSelector )
                          );
                          return results;
                      } catch ( qsaError ) {
                      } finally {
                          if ( nid === expando ) {
                              context.removeAttribute( "id" );
                          }
                      }
                  }
              }
          }
      }
  
      // All others
      return select( selector.replace( rtrim, "$1" ), context, results, seed );
  }
  
  /**
   * Create key-value caches of limited size
   * @returns {function(string, object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */
  function createCache() {
      var keys = [];
  
      function cache( key, value ) {
          // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
          if ( keys.push( key + " " ) > Expr.cacheLength ) {
              // Only keep the most recent entries
              delete cache[ keys.shift() ];
          }
          return (cache[ key + " " ] = value);
      }
      return cache;
  }
  
  /**
   * Mark a function for special use by Sizzle
   * @param {Function} fn The function to mark
   */
  function markFunction( fn ) {
      fn[ expando ] = true;
      return fn;
  }
  
  /**
   * Support testing using an element
   * @param {Function} fn Passed the created div and expects a boolean result
   */
  function assert( fn ) {
      var div = document.createElement("div");
  
      try {
          return !!fn( div );
      } catch (e) {
          return false;
      } finally {
          // Remove from its parent by default
          if ( div.parentNode ) {
              div.parentNode.removeChild( div );
          }
          // release memory in IE
          div = null;
      }
  }
  
  /**
   * Adds the same handler for all of the specified attrs
   * @param {String} attrs Pipe-separated list of attributes
   * @param {Function} handler The method that will be applied
   */
  function addHandle( attrs, handler ) {
      var arr = attrs.split("|"),
          i = arr.length;
  
      while ( i-- ) {
          Expr.attrHandle[ arr[i] ] = handler;
      }
  }
  
  /**
   * Checks document order of two siblings
   * @param {Element} a
   * @param {Element} b
   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
   */
  function siblingCheck( a, b ) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
              ( ~b.sourceIndex || MAX_NEGATIVE ) -
              ( ~a.sourceIndex || MAX_NEGATIVE );
  
      // Use IE sourceIndex if available on both nodes
      if ( diff ) {
          return diff;
      }
  
      // Check if b follows a
      if ( cur ) {
          while ( (cur = cur.nextSibling) ) {
              if ( cur === b ) {
                  return -1;
              }
          }
      }
  
      return a ? 1 : -1;
  }
  
  /**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */
  function createInputPseudo( type ) {
      return function( elem ) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === type;
      };
  }
  
  /**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */
  function createButtonPseudo( type ) {
      return function( elem ) {
          var name = elem.nodeName.toLowerCase();
          return (name === "input" || name === "button") && elem.type === type;
      };
  }
  
  /**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */
  function createPositionalPseudo( fn ) {
      return markFunction(function( argument ) {
          argument = +argument;
          return markFunction(function( seed, matches ) {
              var j,
                  matchIndexes = fn( [], seed.length, argument ),
                  i = matchIndexes.length;
  
              // Match elements found at the specified indexes
              while ( i-- ) {
                  if ( seed[ (j = matchIndexes[i]) ] ) {
                      seed[j] = !(matches[j] = seed[j]);
                  }
              }
          });
      });
  }
  
  /**
   * Checks a node for validity as a Sizzle context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */
  function testContext( context ) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
  }
  
  // Expose support vars for convenience
  support = Sizzle.support = {};
  
  /**
   * Detects XML nodes
   * @param {Element|Object} elem An element or a document
   * @returns {Boolean} True iff elem is a non-HTML XML node
   */
  isXML = Sizzle.isXML = function( elem ) {
      // documentElement is verified for cases where it doesn't yet exist
      // (such as loading iframes in IE - #4833)
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
  };
  
  /**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [doc] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */
  setDocument = Sizzle.setDocument = function( node ) {
      var hasCompare, parent,
          doc = node ? node.ownerDocument || node : preferredDoc;
  
      // Return early if doc is invalid or already selected
      if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
          return document;
      }
  
      // Update global variables
      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML( document );
  
      // Support: IE 9-11, Edge
      // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
      if ( (parent = document.defaultView) && parent.top !== parent ) {
          // Support: IE 11
          if ( parent.addEventListener ) {
              parent.addEventListener( "unload", unloadHandler, false );
  
          // Support: IE 9 - 10 only
          } else if ( parent.attachEvent ) {
              parent.attachEvent( "onunload", unloadHandler );
          }
      }
  
      /* Attributes
      ---------------------------------------------------------------------- */
  
      // Support: IE<8
      // Verify that getAttribute really returns attributes and not properties
      // (excepting IE8 booleans)
      support.attributes = assert(function( div ) {
          div.className = "i";
          return !div.getAttribute("className");
      });
  
      /* getElement(s)By*
      ---------------------------------------------------------------------- */
  
      // Check if getElementsByTagName("*") returns only elements
      support.getElementsByTagName = assert(function( div ) {
          div.appendChild( document.createComment("") );
          return !div.getElementsByTagName("*").length;
      });
  
      // Support: IE<9
      support.getElementsByClassName = rnative.test( document.getElementsByClassName );
  
      // Support: IE<10
      // Check if getElementById returns elements by name
      // The broken getElementById methods don't pick up programatically-set names,
      // so use a roundabout getElementsByName test
      support.getById = assert(function( div ) {
          docElem.appendChild( div ).id = expando;
          return !document.getElementsByName || !document.getElementsByName( expando ).length;
      });
  
      // ID find and filter
      if ( support.getById ) {
          Expr.find["ID"] = function( id, context ) {
              if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
                  var m = context.getElementById( id );
                  return m ? [ m ] : [];
              }
          };
          Expr.filter["ID"] = function( id ) {
              var attrId = id.replace( runescape, funescape );
              return function( elem ) {
                  return elem.getAttribute("id") === attrId;
              };
          };
      } else {
          // Support: IE6/7
          // getElementById is not reliable as a find shortcut
          delete Expr.find["ID"];
  
          Expr.filter["ID"] =  function( id ) {
              var attrId = id.replace( runescape, funescape );
              return function( elem ) {
                  var node = typeof elem.getAttributeNode !== "undefined" &&
                      elem.getAttributeNode("id");
                  return node && node.value === attrId;
              };
          };
      }
  
      // Tag
      Expr.find["TAG"] = support.getElementsByTagName ?
          function( tag, context ) {
              if ( typeof context.getElementsByTagName !== "undefined" ) {
                  return context.getElementsByTagName( tag );
  
              // DocumentFragment nodes don't have gEBTN
              } else if ( support.qsa ) {
                  return context.querySelectorAll( tag );
              }
          } :
  
          function( tag, context ) {
              var elem,
                  tmp = [],
                  i = 0,
                  // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                  results = context.getElementsByTagName( tag );
  
              // Filter out possible comments
              if ( tag === "*" ) {
                  while ( (elem = results[i++]) ) {
                      if ( elem.nodeType === 1 ) {
                          tmp.push( elem );
                      }
                  }
  
                  return tmp;
              }
              return results;
          };
  
      // Class
      Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
          if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
              return context.getElementsByClassName( className );
          }
      };
  
      /* QSA/matchesSelector
      ---------------------------------------------------------------------- */
  
      // QSA and matchesSelector support
  
      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
      rbuggyMatches = [];
  
      // qSa(:focus) reports false when true (Chrome 21)
      // We allow this because of a bug in IE8/9 that throws an error
      // whenever `document.activeElement` is accessed on an iframe
      // So, we allow :focus to pass through QSA all the time to avoid the IE error
      // See http://bugs.jquery.com/ticket/13378
      rbuggyQSA = [];
  
      if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
          // Build QSA regex
          // Regex strategy adopted from Diego Perini
          assert(function( div ) {
              // Select is set to empty string on purpose
              // This is to test IE's treatment of not explicitly
              // setting a boolean content attribute,
              // since its presence should be enough
              // http://bugs.jquery.com/ticket/12359
              docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
                  "<select id='" + expando + "-\r\\' msallowcapture=''>" +
                  "<option selected=''></option></select>";
  
              // Support: IE8, Opera 11-12.16
              // Nothing should be selected when empty strings follow ^= or $= or *=
              // The test attribute must be unknown in Opera but "safe" for WinRT
              // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
              if ( div.querySelectorAll("[msallowcapture^='']").length ) {
                  rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
              }
  
              // Support: IE8
              // Boolean attributes and "value" are not treated correctly
              if ( !div.querySelectorAll("[selected]").length ) {
                  rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
              }
  
              // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
              if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
                  rbuggyQSA.push("~=");
              }
  
              // Webkit/Opera - :checked should return selected option elements
              // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
              // IE8 throws error here and will not see later tests
              if ( !div.querySelectorAll(":checked").length ) {
                  rbuggyQSA.push(":checked");
              }
  
              // Support: Safari 8+, iOS 8+
              // https://bugs.webkit.org/show_bug.cgi?id=136851
              // In-page `selector#id sibing-combinator selector` fails
              if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
                  rbuggyQSA.push(".#.+[+~]");
              }
          });
  
          assert(function( div ) {
              // Support: Windows 8 Native Apps
              // The type and name attributes are restricted during .innerHTML assignment
              var input = document.createElement("input");
              input.setAttribute( "type", "hidden" );
              div.appendChild( input ).setAttribute( "name", "D" );
  
              // Support: IE8
              // Enforce case-sensitivity of name attribute
              if ( div.querySelectorAll("[name=d]").length ) {
                  rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
              }
  
              // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
              // IE8 throws error here and will not see later tests
              if ( !div.querySelectorAll(":enabled").length ) {
                  rbuggyQSA.push( ":enabled", ":disabled" );
              }
  
              // Opera 10-11 does not throw on post-comma invalid pseudos
              div.querySelectorAll("*,:x");
              rbuggyQSA.push(",.*:");
          });
      }
  
      if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
          docElem.webkitMatchesSelector ||
          docElem.mozMatchesSelector ||
          docElem.oMatchesSelector ||
          docElem.msMatchesSelector) )) ) {
  
          assert(function( div ) {
              // Check to see if it's possible to do matchesSelector
              // on a disconnected node (IE 9)
              support.disconnectedMatch = matches.call( div, "div" );
  
              // This should fail with an exception
              // Gecko does not error, returns false instead
              matches.call( div, "[s!='']:x" );
              rbuggyMatches.push( "!=", pseudos );
          });
      }
  
      rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
      rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
  
      /* Contains
      ---------------------------------------------------------------------- */
      hasCompare = rnative.test( docElem.compareDocumentPosition );
  
      // Element contains another
      // Purposefully self-exclusive
      // As in, an element does not contain itself
      contains = hasCompare || rnative.test( docElem.contains ) ?
          function( a, b ) {
              var adown = a.nodeType === 9 ? a.documentElement : a,
                  bup = b && b.parentNode;
              return a === bup || !!( bup && bup.nodeType === 1 && (
                  adown.contains ?
                      adown.contains( bup ) :
                      a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
              ));
          } :
          function( a, b ) {
              if ( b ) {
                  while ( (b = b.parentNode) ) {
                      if ( b === a ) {
                          return true;
                      }
                  }
              }
              return false;
          };
  
      /* Sorting
      ---------------------------------------------------------------------- */
  
      // Document order sorting
      sortOrder = hasCompare ?
      function( a, b ) {
  
          // Flag for duplicate removal
          if ( a === b ) {
              hasDuplicate = true;
              return 0;
          }
  
          // Sort on method existence if only one input has compareDocumentPosition
          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
          if ( compare ) {
              return compare;
          }
  
          // Calculate position if both inputs belong to the same document
          compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
              a.compareDocumentPosition( b ) :
  
              // Otherwise we know they are disconnected
              1;
  
          // Disconnected nodes
          if ( compare & 1 ||
              (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
  
              // Choose the first element that is related to our preferred document
              if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
                  return -1;
              }
              if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
                  return 1;
              }
  
              // Maintain original order
              return sortInput ?
                  ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                  0;
          }
  
          return compare & 4 ? -1 : 1;
      } :
      function( a, b ) {
          // Exit early if the nodes are identical
          if ( a === b ) {
              hasDuplicate = true;
              return 0;
          }
  
          var cur,
              i = 0,
              aup = a.parentNode,
              bup = b.parentNode,
              ap = [ a ],
              bp = [ b ];
  
          // Parentless nodes are either documents or disconnected
          if ( !aup || !bup ) {
              return a === document ? -1 :
                  b === document ? 1 :
                  aup ? -1 :
                  bup ? 1 :
                  sortInput ?
                  ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                  0;
  
          // If the nodes are siblings, we can do a quick check
          } else if ( aup === bup ) {
              return siblingCheck( a, b );
          }
  
          // Otherwise we need full lists of their ancestors for comparison
          cur = a;
          while ( (cur = cur.parentNode) ) {
              ap.unshift( cur );
          }
          cur = b;
          while ( (cur = cur.parentNode) ) {
              bp.unshift( cur );
          }
  
          // Walk down the tree looking for a discrepancy
          while ( ap[i] === bp[i] ) {
              i++;
          }
  
          return i ?
              // Do a sibling check if the nodes have a common ancestor
              siblingCheck( ap[i], bp[i] ) :
  
              // Otherwise nodes in our document sort first
              ap[i] === preferredDoc ? -1 :
              bp[i] === preferredDoc ? 1 :
              0;
      };
  
      return document;
  };
  
  Sizzle.matches = function( expr, elements ) {
      return Sizzle( expr, null, null, elements );
  };
  
  Sizzle.matchesSelector = function( elem, expr ) {
      // Set document vars if needed
      if ( ( elem.ownerDocument || elem ) !== document ) {
          setDocument( elem );
      }
  
      // Make sure that attribute selectors are quoted
      expr = expr.replace( rattributeQuotes, "='$1']" );
  
      if ( support.matchesSelector && documentIsHTML &&
          !compilerCache[ expr + " " ] &&
          ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
          ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
  
          try {
              var ret = matches.call( elem, expr );
  
              // IE 9's matchesSelector returns false on disconnected nodes
              if ( ret || support.disconnectedMatch ||
                      // As well, disconnected nodes are said to be in a document
                      // fragment in IE 9
                      elem.document && elem.document.nodeType !== 11 ) {
                  return ret;
              }
          } catch (e) {}
      }
  
      return Sizzle( expr, document, null, [ elem ] ).length > 0;
  };
  
  Sizzle.contains = function( context, elem ) {
      // Set document vars if needed
      if ( ( context.ownerDocument || context ) !== document ) {
          setDocument( context );
      }
      return contains( context, elem );
  };
  
  Sizzle.attr = function( elem, name ) {
      // Set document vars if needed
      if ( ( elem.ownerDocument || elem ) !== document ) {
          setDocument( elem );
      }
  
      var fn = Expr.attrHandle[ name.toLowerCase() ],
          // Don't get fooled by Object.prototype properties (jQuery #13807)
          val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
              fn( elem, name, !documentIsHTML ) :
              undefined;
  
      return val !== undefined ?
          val :
          support.attributes || !documentIsHTML ?
              elem.getAttribute( name ) :
              (val = elem.getAttributeNode(name)) && val.specified ?
                  val.value :
                  null;
  };
  
  Sizzle.error = function( msg ) {
      throw new Error( "Syntax error, unrecognized expression: " + msg );
  };
  
  /**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */
  Sizzle.uniqueSort = function( results ) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0;
  
      // Unless we *know* we can detect duplicates, assume their presence
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice( 0 );
      results.sort( sortOrder );
  
      if ( hasDuplicate ) {
          while ( (elem = results[i++]) ) {
              if ( elem === results[ i ] ) {
                  j = duplicates.push( i );
              }
          }
          while ( j-- ) {
              results.splice( duplicates[ j ], 1 );
          }
      }
  
      // Clear input after sorting to release objects
      // See https://github.com/jquery/sizzle/pull/225
      sortInput = null;
  
      return results;
  };
  
  /**
   * Utility function for retrieving the text value of an array of DOM nodes
   * @param {Array|Element} elem
   */
  getText = Sizzle.getText = function( elem ) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;
  
      if ( !nodeType ) {
          // If no nodeType, this is expected to be an array
          while ( (node = elem[i++]) ) {
              // Do not traverse comment nodes
              ret += getText( node );
          }
      } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
          // Use textContent for elements
          // innerText usage removed for consistency of new lines (jQuery #11153)
          if ( typeof elem.textContent === "string" ) {
              return elem.textContent;
          } else {
              // Traverse its children
              for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                  ret += getText( elem );
              }
          }
      } else if ( nodeType === 3 || nodeType === 4 ) {
          return elem.nodeValue;
      }
      // Do not include comment or processing instruction nodes
  
      return ret;
  };
  
  Expr = Sizzle.selectors = {
  
      // Can be adjusted by the user
      cacheLength: 50,
  
      createPseudo: markFunction,
  
      match: matchExpr,
  
      attrHandle: {},
  
      find: {},
  
      relative: {
          ">": { dir: "parentNode", first: true },
          " ": { dir: "parentNode" },
          "+": { dir: "previousSibling", first: true },
          "~": { dir: "previousSibling" }
      },
  
      preFilter: {
          "ATTR": function( match ) {
              match[1] = match[1].replace( runescape, funescape );
  
              // Move the given value to match[3] whether quoted or unquoted
              match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
  
              if ( match[2] === "~=" ) {
                  match[3] = " " + match[3] + " ";
              }
  
              return match.slice( 0, 4 );
          },
  
          "CHILD": function( match ) {
              /* matches from matchExpr["CHILD"]
                  1 type (only|nth|...)
                  2 what (child|of-type)
                  3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                  4 xn-component of xn+y argument ([+-]?\d*n|)
                  5 sign of xn-component
                  6 x of xn-component
                  7 sign of y-component
                  8 y of y-component
              */
              match[1] = match[1].toLowerCase();
  
              if ( match[1].slice( 0, 3 ) === "nth" ) {
                  // nth-* requires argument
                  if ( !match[3] ) {
                      Sizzle.error( match[0] );
                  }
  
                  // numeric x and y parameters for Expr.filter.CHILD
                  // remember that false/true cast respectively to 0/1
                  match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
                  match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
  
              // other types prohibit arguments
              } else if ( match[3] ) {
                  Sizzle.error( match[0] );
              }
  
              return match;
          },
  
          "PSEUDO": function( match ) {
              var excess,
                  unquoted = !match[6] && match[2];
  
              if ( matchExpr["CHILD"].test( match[0] ) ) {
                  return null;
              }
  
              // Accept quoted arguments as-is
              if ( match[3] ) {
                  match[2] = match[4] || match[5] || "";
  
              // Strip excess characters from unquoted arguments
              } else if ( unquoted && rpseudo.test( unquoted ) &&
                  // Get excess from tokenize (recursively)
                  (excess = tokenize( unquoted, true )) &&
                  // advance to the next closing parenthesis
                  (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
  
                  // excess is a negative index
                  match[0] = match[0].slice( 0, excess );
                  match[2] = unquoted.slice( 0, excess );
              }
  
              // Return only captures needed by the pseudo filter method (type and argument)
              return match.slice( 0, 3 );
          }
      },
  
      filter: {
  
          "TAG": function( nodeNameSelector ) {
              var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
              return nodeNameSelector === "*" ?
                  function() { return true; } :
                  function( elem ) {
                      return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                  };
          },
  
          "CLASS": function( className ) {
              var pattern = classCache[ className + " " ];
  
              return pattern ||
                  (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
                  classCache( className, function( elem ) {
                      return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
                  });
          },
  
          "ATTR": function( name, operator, check ) {
              return function( elem ) {
                  var result = Sizzle.attr( elem, name );
  
                  if ( result == null ) {
                      return operator === "!=";
                  }
                  if ( !operator ) {
                      return true;
                  }
  
                  result += "";
  
                  return operator === "=" ? result === check :
                      operator === "!=" ? result !== check :
                      operator === "^=" ? check && result.indexOf( check ) === 0 :
                      operator === "*=" ? check && result.indexOf( check ) > -1 :
                      operator === "$=" ? check && result.slice( -check.length ) === check :
                      operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
                      operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                      false;
              };
          },
  
          "CHILD": function( type, what, argument, first, last ) {
              var simple = type.slice( 0, 3 ) !== "nth",
                  forward = type.slice( -4 ) !== "last",
                  ofType = what === "of-type";
  
              return first === 1 && last === 0 ?
  
                  // Shortcut for :nth-*(n)
                  function( elem ) {
                      return !!elem.parentNode;
                  } :
  
                  function( elem, context, xml ) {
                      var cache, uniqueCache, outerCache, node, nodeIndex, start,
                          dir = simple !== forward ? "nextSibling" : "previousSibling",
                          parent = elem.parentNode,
                          name = ofType && elem.nodeName.toLowerCase(),
                          useCache = !xml && !ofType,
                          diff = false;
  
                      if ( parent ) {
  
                          // :(first|last|only)-(child|of-type)
                          if ( simple ) {
                              while ( dir ) {
                                  node = elem;
                                  while ( (node = node[ dir ]) ) {
                                      if ( ofType ?
                                          node.nodeName.toLowerCase() === name :
                                          node.nodeType === 1 ) {
  
                                          return false;
                                      }
                                  }
                                  // Reverse direction for :only-* (if we haven't yet done so)
                                  start = dir = type === "only" && !start && "nextSibling";
                              }
                              return true;
                          }
  
                          start = [ forward ? parent.firstChild : parent.lastChild ];
  
                          // non-xml :nth-child(...) stores cache data on `parent`
                          if ( forward && useCache ) {
  
                              // Seek `elem` from a previously-cached index
  
                              // ...in a gzip-friendly way
                              node = parent;
                              outerCache = node[ expando ] || (node[ expando ] = {});
  
                              // Support: IE <9 only
                              // Defend against cloned attroperties (jQuery gh-1709)
                              uniqueCache = outerCache[ node.uniqueID ] ||
                                  (outerCache[ node.uniqueID ] = {});
  
                              cache = uniqueCache[ type ] || [];
                              nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                              diff = nodeIndex && cache[ 2 ];
                              node = nodeIndex && parent.childNodes[ nodeIndex ];
  
                              while ( (node = ++nodeIndex && node && node[ dir ] ||
  
                                  // Fallback to seeking `elem` from the start
                                  (diff = nodeIndex = 0) || start.pop()) ) {
  
                                  // When found, cache indexes on `parent` and break
                                  if ( node.nodeType === 1 && ++diff && node === elem ) {
                                      uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
                                      break;
                                  }
                              }
  
                          } else {
                              // Use previously-cached element index if available
                              if ( useCache ) {
                                  // ...in a gzip-friendly way
                                  node = elem;
                                  outerCache = node[ expando ] || (node[ expando ] = {});
  
                                  // Support: IE <9 only
                                  // Defend against cloned attroperties (jQuery gh-1709)
                                  uniqueCache = outerCache[ node.uniqueID ] ||
                                      (outerCache[ node.uniqueID ] = {});
  
                                  cache = uniqueCache[ type ] || [];
                                  nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                                  diff = nodeIndex;
                              }
  
                              // xml :nth-child(...)
                              // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                              if ( diff === false ) {
                                  // Use the same loop as above to seek `elem` from the start
                                  while ( (node = ++nodeIndex && node && node[ dir ] ||
                                      (diff = nodeIndex = 0) || start.pop()) ) {
  
                                      if ( ( ofType ?
                                          node.nodeName.toLowerCase() === name :
                                          node.nodeType === 1 ) &&
                                          ++diff ) {
  
                                          // Cache the index of each encountered element
                                          if ( useCache ) {
                                              outerCache = node[ expando ] || (node[ expando ] = {});
  
                                              // Support: IE <9 only
                                              // Defend against cloned attroperties (jQuery gh-1709)
                                              uniqueCache = outerCache[ node.uniqueID ] ||
                                                  (outerCache[ node.uniqueID ] = {});
  
                                              uniqueCache[ type ] = [ dirruns, diff ];
                                          }
  
                                          if ( node === elem ) {
                                              break;
                                          }
                                      }
                                  }
                              }
                          }
  
                          // Incorporate the offset, then check against cycle size
                          diff -= last;
                          return diff === first || ( diff % first === 0 && diff / first >= 0 );
                      }
                  };
          },
  
          "PSEUDO": function( pseudo, argument ) {
              // pseudo-class names are case-insensitive
              // http://www.w3.org/TR/selectors/#pseudo-classes
              // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
              // Remember that setFilters inherits from pseudos
              var args,
                  fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                      Sizzle.error( "unsupported pseudo: " + pseudo );
  
              // The user may use createPseudo to indicate that
              // arguments are needed to create the filter function
              // just as Sizzle does
              if ( fn[ expando ] ) {
                  return fn( argument );
              }
  
              // But maintain support for old signatures
              if ( fn.length > 1 ) {
                  args = [ pseudo, pseudo, "", argument ];
                  return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                      markFunction(function( seed, matches ) {
                          var idx,
                              matched = fn( seed, argument ),
                              i = matched.length;
                          while ( i-- ) {
                              idx = indexOf( seed, matched[i] );
                              seed[ idx ] = !( matches[ idx ] = matched[i] );
                          }
                      }) :
                      function( elem ) {
                          return fn( elem, 0, args );
                      };
              }
  
              return fn;
          }
      },
  
      pseudos: {
          // Potentially complex pseudos
          "not": markFunction(function( selector ) {
              // Trim the selector passed to compile
              // to avoid treating leading and trailing
              // spaces as combinators
              var input = [],
                  results = [],
                  matcher = compile( selector.replace( rtrim, "$1" ) );
  
              return matcher[ expando ] ?
                  markFunction(function( seed, matches, context, xml ) {
                      var elem,
                          unmatched = matcher( seed, null, xml, [] ),
                          i = seed.length;
  
                      // Match elements unmatched by `matcher`
                      while ( i-- ) {
                          if ( (elem = unmatched[i]) ) {
                              seed[i] = !(matches[i] = elem);
                          }
                      }
                  }) :
                  function( elem, context, xml ) {
                      input[0] = elem;
                      matcher( input, null, xml, results );
                      // Don't keep the element (issue #299)
                      input[0] = null;
                      return !results.pop();
                  };
          }),
  
          "has": markFunction(function( selector ) {
              return function( elem ) {
                  return Sizzle( selector, elem ).length > 0;
              };
          }),
  
          "contains": markFunction(function( text ) {
              text = text.replace( runescape, funescape );
              return function( elem ) {
                  return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
              };
          }),
  
          // "Whether an element is represented by a :lang() selector
          // is based solely on the element's language value
          // being equal to the identifier C,
          // or beginning with the identifier C immediately followed by "-".
          // The matching of C against the element's language value is performed case-insensitively.
          // The identifier C does not have to be a valid language name."
          // http://www.w3.org/TR/selectors/#lang-pseudo
          "lang": markFunction( function( lang ) {
              // lang value must be a valid identifier
              if ( !ridentifier.test(lang || "") ) {
                  Sizzle.error( "unsupported lang: " + lang );
              }
              lang = lang.replace( runescape, funescape ).toLowerCase();
              return function( elem ) {
                  var elemLang;
                  do {
                      if ( (elemLang = documentIsHTML ?
                          elem.lang :
                          elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
  
                          elemLang = elemLang.toLowerCase();
                          return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                      }
                  } while ( (elem = elem.parentNode) && elem.nodeType === 1 );
                  return false;
              };
          }),
  
          // Miscellaneous
          "target": function( elem ) {
              var hash = window.location && window.location.hash;
              return hash && hash.slice( 1 ) === elem.id;
          },
  
          "root": function( elem ) {
              return elem === docElem;
          },
  
          "focus": function( elem ) {
              return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
          },
  
          // Boolean properties
          "enabled": function( elem ) {
              return elem.disabled === false;
          },
  
          "disabled": function( elem ) {
              return elem.disabled === true;
          },
  
          "checked": function( elem ) {
              // In CSS3, :checked should return both checked and selected elements
              // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
              var nodeName = elem.nodeName.toLowerCase();
              return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
          },
  
          "selected": function( elem ) {
              // Accessing this property makes selected-by-default
              // options in Safari work properly
              if ( elem.parentNode ) {
                  elem.parentNode.selectedIndex;
              }
  
              return elem.selected === true;
          },
  
          // Contents
          "empty": function( elem ) {
              // http://www.w3.org/TR/selectors/#empty-pseudo
              // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
              //   but not by others (comment: 8; processing instruction: 7; etc.)
              // nodeType < 6 works because attributes (2) do not appear as children
              for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                  if ( elem.nodeType < 6 ) {
                      return false;
                  }
              }
              return true;
          },
  
          "parent": function( elem ) {
              return !Expr.pseudos["empty"]( elem );
          },
  
          // Element/input types
          "header": function( elem ) {
              return rheader.test( elem.nodeName );
          },
  
          "input": function( elem ) {
              return rinputs.test( elem.nodeName );
          },
  
          "button": function( elem ) {
              var name = elem.nodeName.toLowerCase();
              return name === "input" && elem.type === "button" || name === "button";
          },
  
          "text": function( elem ) {
              var attr;
              return elem.nodeName.toLowerCase() === "input" &&
                  elem.type === "text" &&
  
                  // Support: IE<8
                  // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                  ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
          },
  
          // Position-in-collection
          "first": createPositionalPseudo(function() {
              return [ 0 ];
          }),
  
          "last": createPositionalPseudo(function( matchIndexes, length ) {
              return [ length - 1 ];
          }),
  
          "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
              return [ argument < 0 ? argument + length : argument ];
          }),
  
          "even": createPositionalPseudo(function( matchIndexes, length ) {
              var i = 0;
              for ( ; i < length; i += 2 ) {
                  matchIndexes.push( i );
              }
              return matchIndexes;
          }),
  
          "odd": createPositionalPseudo(function( matchIndexes, length ) {
              var i = 1;
              for ( ; i < length; i += 2 ) {
                  matchIndexes.push( i );
              }
              return matchIndexes;
          }),
  
          "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
              var i = argument < 0 ? argument + length : argument;
              for ( ; --i >= 0; ) {
                  matchIndexes.push( i );
              }
              return matchIndexes;
          }),
  
          "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
              var i = argument < 0 ? argument + length : argument;
              for ( ; ++i < length; ) {
                  matchIndexes.push( i );
              }
              return matchIndexes;
          })
      }
  };
  
  Expr.pseudos["nth"] = Expr.pseudos["eq"];
  
  // Add button/input type pseudos
  for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
      Expr.pseudos[ i ] = createInputPseudo( i );
  }
  for ( i in { submit: true, reset: true } ) {
      Expr.pseudos[ i ] = createButtonPseudo( i );
  }
  
  // Easy API for creating new setFilters
  function setFilters() {}
  setFilters.prototype = Expr.filters = Expr.pseudos;
  Expr.setFilters = new setFilters();
  
  tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
      var matched, match, tokens, type,
          soFar, groups, preFilters,
          cached = tokenCache[ selector + " " ];
  
      if ( cached ) {
          return parseOnly ? 0 : cached.slice( 0 );
      }
  
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
  
      while ( soFar ) {
  
          // Comma and first run
          if ( !matched || (match = rcomma.exec( soFar )) ) {
              if ( match ) {
                  // Don't consume trailing commas as valid
                  soFar = soFar.slice( match[0].length ) || soFar;
              }
              groups.push( (tokens = []) );
          }
  
          matched = false;
  
          // Combinators
          if ( (match = rcombinators.exec( soFar )) ) {
              matched = match.shift();
              tokens.push({
                  value: matched,
                  // Cast descendant combinators to space
                  type: match[0].replace( rtrim, " " )
              });
              soFar = soFar.slice( matched.length );
          }
  
          // Filters
          for ( type in Expr.filter ) {
              if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
                  (match = preFilters[ type ]( match ))) ) {
                  matched = match.shift();
                  tokens.push({
                      value: matched,
                      type: type,
                      matches: match
                  });
                  soFar = soFar.slice( matched.length );
              }
          }
  
          if ( !matched ) {
              break;
          }
      }
  
      // Return the length of the invalid excess
      // if we're just parsing
      // Otherwise, throw an error or return tokens
      return parseOnly ?
          soFar.length :
          soFar ?
              Sizzle.error( selector ) :
              // Cache the tokens
              tokenCache( selector, groups ).slice( 0 );
  };
  
  function toSelector( tokens ) {
      var i = 0,
          len = tokens.length,
          selector = "";
      for ( ; i < len; i++ ) {
          selector += tokens[i].value;
      }
      return selector;
  }
  
  function addCombinator( matcher, combinator, base ) {
      var dir = combinator.dir,
          checkNonElements = base && dir === "parentNode",
          doneName = done++;
  
      return combinator.first ?
          // Check against closest ancestor/preceding element
          function( elem, context, xml ) {
              while ( (elem = elem[ dir ]) ) {
                  if ( elem.nodeType === 1 || checkNonElements ) {
                      return matcher( elem, context, xml );
                  }
              }
          } :
  
          // Check against all ancestor/preceding elements
          function( elem, context, xml ) {
              var oldCache, uniqueCache, outerCache,
                  newCache = [ dirruns, doneName ];
  
              // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
              if ( xml ) {
                  while ( (elem = elem[ dir ]) ) {
                      if ( elem.nodeType === 1 || checkNonElements ) {
                          if ( matcher( elem, context, xml ) ) {
                              return true;
                          }
                      }
                  }
              } else {
                  while ( (elem = elem[ dir ]) ) {
                      if ( elem.nodeType === 1 || checkNonElements ) {
                          outerCache = elem[ expando ] || (elem[ expando ] = {});
  
                          // Support: IE <9 only
                          // Defend against cloned attroperties (jQuery gh-1709)
                          uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
  
                          if ( (oldCache = uniqueCache[ dir ]) &&
                              oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
  
                              // Assign to newCache so results back-propagate to previous elements
                              return (newCache[ 2 ] = oldCache[ 2 ]);
                          } else {
                              // Reuse newcache so results back-propagate to previous elements
                              uniqueCache[ dir ] = newCache;
  
                              // A match means we're done; a fail means we have to keep checking
                              if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                                  return true;
                              }
                          }
                      }
                  }
              }
          };
  }
  
  function elementMatcher( matchers ) {
      return matchers.length > 1 ?
          function( elem, context, xml ) {
              var i = matchers.length;
              while ( i-- ) {
                  if ( !matchers[i]( elem, context, xml ) ) {
                      return false;
                  }
              }
              return true;
          } :
          matchers[0];
  }
  
  function multipleContexts( selector, contexts, results ) {
      var i = 0,
          len = contexts.length;
      for ( ; i < len; i++ ) {
          Sizzle( selector, contexts[i], results );
      }
      return results;
  }
  
  function condense( unmatched, map, filter, context, xml ) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;
  
      for ( ; i < len; i++ ) {
          if ( (elem = unmatched[i]) ) {
              if ( !filter || filter( elem, context, xml ) ) {
                  newUnmatched.push( elem );
                  if ( mapped ) {
                      map.push( i );
                  }
              }
          }
      }
  
      return newUnmatched;
  }
  
  function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
      if ( postFilter && !postFilter[ expando ] ) {
          postFilter = setMatcher( postFilter );
      }
      if ( postFinder && !postFinder[ expando ] ) {
          postFinder = setMatcher( postFinder, postSelector );
      }
      return markFunction(function( seed, results, context, xml ) {
          var temp, i, elem,
              preMap = [],
              postMap = [],
              preexisting = results.length,
  
              // Get initial elements from seed or context
              elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
  
              // Prefilter to get matcher input, preserving a map for seed-results synchronization
              matcherIn = preFilter && ( seed || !selector ) ?
                  condense( elems, preMap, preFilter, context, xml ) :
                  elems,
  
              matcherOut = matcher ?
                  // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                  postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
  
                      // ...intermediate processing is necessary
                      [] :
  
                      // ...otherwise use results directly
                      results :
                  matcherIn;
  
          // Find primary matches
          if ( matcher ) {
              matcher( matcherIn, matcherOut, context, xml );
          }
  
          // Apply postFilter
          if ( postFilter ) {
              temp = condense( matcherOut, postMap );
              postFilter( temp, [], context, xml );
  
              // Un-match failing elements by moving them back to matcherIn
              i = temp.length;
              while ( i-- ) {
                  if ( (elem = temp[i]) ) {
                      matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                  }
              }
          }
  
          if ( seed ) {
              if ( postFinder || preFilter ) {
                  if ( postFinder ) {
                      // Get the final matcherOut by condensing this intermediate into postFinder contexts
                      temp = [];
                      i = matcherOut.length;
                      while ( i-- ) {
                          if ( (elem = matcherOut[i]) ) {
                              // Restore matcherIn since elem is not yet a final match
                              temp.push( (matcherIn[i] = elem) );
                          }
                      }
                      postFinder( null, (matcherOut = []), temp, xml );
                  }
  
                  // Move matched elements from seed to results to keep them synchronized
                  i = matcherOut.length;
                  while ( i-- ) {
                      if ( (elem = matcherOut[i]) &&
                          (temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
  
                          seed[temp] = !(results[temp] = elem);
                      }
                  }
              }
  
          // Add elements to results, through postFinder if defined
          } else {
              matcherOut = condense(
                  matcherOut === results ?
                      matcherOut.splice( preexisting, matcherOut.length ) :
                      matcherOut
              );
              if ( postFinder ) {
                  postFinder( null, results, matcherOut, xml );
              } else {
                  push.apply( results, matcherOut );
              }
          }
      });
  }
  
  function matcherFromTokens( tokens ) {
      var checkContext, matcher, j,
          len = tokens.length,
          leadingRelative = Expr.relative[ tokens[0].type ],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
  
          // The foundational matcher ensures that elements are reachable from top-level context(s)
          matchContext = addCombinator( function( elem ) {
              return elem === checkContext;
          }, implicitRelative, true ),
          matchAnyContext = addCombinator( function( elem ) {
              return indexOf( checkContext, elem ) > -1;
          }, implicitRelative, true ),
          matchers = [ function( elem, context, xml ) {
              var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                  (checkContext = context).nodeType ?
                      matchContext( elem, context, xml ) :
                      matchAnyContext( elem, context, xml ) );
              // Avoid hanging onto element (issue #299)
              checkContext = null;
              return ret;
          } ];
  
      for ( ; i < len; i++ ) {
          if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
              matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
          } else {
              matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
  
              // Return special upon seeing a positional matcher
              if ( matcher[ expando ] ) {
                  // Find the next relative operator (if any) for proper handling
                  j = ++i;
                  for ( ; j < len; j++ ) {
                      if ( Expr.relative[ tokens[j].type ] ) {
                          break;
                      }
                  }
                  return setMatcher(
                      i > 1 && elementMatcher( matchers ),
                      i > 1 && toSelector(
                          // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                          tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
                      ).replace( rtrim, "$1" ),
                      matcher,
                      i < j && matcherFromTokens( tokens.slice( i, j ) ),
                      j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
                      j < len && toSelector( tokens )
                  );
              }
              matchers.push( matcher );
          }
      }
  
      return elementMatcher( matchers );
  }
  
  function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function( seed, context, xml, results, outermost ) {
              var elem, j, matcher,
                  matchedCount = 0,
                  i = "0",
                  unmatched = seed && [],
                  setMatched = [],
                  contextBackup = outermostContext,
                  // We must always have either seed elements or outermost context
                  elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
                  // Use integer dirruns iff this is the outermost matcher
                  dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                  len = elems.length;
  
              if ( outermost ) {
                  outermostContext = context === document || context || outermost;
              }
  
              // Add elements passing elementMatchers directly to results
              // Support: IE<9, Safari
              // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
              for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
                  if ( byElement && elem ) {
                      j = 0;
                      if ( !context && elem.ownerDocument !== document ) {
                          setDocument( elem );
                          xml = !documentIsHTML;
                      }
                      while ( (matcher = elementMatchers[j++]) ) {
                          if ( matcher( elem, context || document, xml) ) {
                              results.push( elem );
                              break;
                          }
                      }
                      if ( outermost ) {
                          dirruns = dirrunsUnique;
                      }
                  }
  
                  // Track unmatched elements for set filters
                  if ( bySet ) {
                      // They will have gone through all possible matchers
                      if ( (elem = !matcher && elem) ) {
                          matchedCount--;
                      }
  
                      // Lengthen the array for every element, matched or not
                      if ( seed ) {
                          unmatched.push( elem );
                      }
                  }
              }
  
              // `i` is now the count of elements visited above, and adding it to `matchedCount`
              // makes the latter nonnegative.
              matchedCount += i;
  
              // Apply set filters to unmatched elements
              // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
              // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
              // no element matchers and no seed.
              // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
              // case, which will result in a "00" `matchedCount` that differs from `i` but is also
              // numerically zero.
              if ( bySet && i !== matchedCount ) {
                  j = 0;
                  while ( (matcher = setMatchers[j++]) ) {
                      matcher( unmatched, setMatched, context, xml );
                  }
  
                  if ( seed ) {
                      // Reintegrate element matches to eliminate the need for sorting
                      if ( matchedCount > 0 ) {
                          while ( i-- ) {
                              if ( !(unmatched[i] || setMatched[i]) ) {
                                  setMatched[i] = pop.call( results );
                              }
                          }
                      }
  
                      // Discard index placeholder values to get only actual matches
                      setMatched = condense( setMatched );
                  }
  
                  // Add matches to results
                  push.apply( results, setMatched );
  
                  // Seedless set matches succeeding multiple successful matchers stipulate sorting
                  if ( outermost && !seed && setMatched.length > 0 &&
                      ( matchedCount + setMatchers.length ) > 1 ) {
  
                      Sizzle.uniqueSort( results );
                  }
              }
  
              // Override manipulation of globals by nested matchers
              if ( outermost ) {
                  dirruns = dirrunsUnique;
                  outermostContext = contextBackup;
              }
  
              return unmatched;
          };
  
      return bySet ?
          markFunction( superMatcher ) :
          superMatcher;
  }
  
  compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[ selector + " " ];
  
      if ( !cached ) {
          // Generate a function of recursive functions that can be used to check each element
          if ( !match ) {
              match = tokenize( selector );
          }
          i = match.length;
          while ( i-- ) {
              cached = matcherFromTokens( match[i] );
              if ( cached[ expando ] ) {
                  setMatchers.push( cached );
              } else {
                  elementMatchers.push( cached );
              }
          }
  
          // Cache the compiled function
          cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
  
          // Save selector and tokenization
          cached.selector = selector;
      }
      return cached;
  };
  
  /**
   * A low-level selection function that works with Sizzle's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with Sizzle.compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */
  select = Sizzle.select = function( selector, context, results, seed ) {
      var i, tokens, token, type, find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize( (selector = compiled.selector || selector) );
  
      results = results || [];
  
      // Try to minimize operations if there is only one selector in the list and no seed
      // (the latter of which guarantees us context)
      if ( match.length === 1 ) {
  
          // Reduce context if the leading compound selector is an ID
          tokens = match[0] = match[0].slice( 0 );
          if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                  support.getById && context.nodeType === 9 && documentIsHTML &&
                  Expr.relative[ tokens[1].type ] ) {
  
              context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
              if ( !context ) {
                  return results;
  
              // Precompiled matchers will still verify ancestry, so step up a level
              } else if ( compiled ) {
                  context = context.parentNode;
              }
  
              selector = selector.slice( tokens.shift().value.length );
          }
  
          // Fetch a seed set for right-to-left matching
          i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
          while ( i-- ) {
              token = tokens[i];
  
              // Abort if we hit a combinator
              if ( Expr.relative[ (type = token.type) ] ) {
                  break;
              }
              if ( (find = Expr.find[ type ]) ) {
                  // Search, expanding context for leading sibling combinators
                  if ( (seed = find(
                      token.matches[0].replace( runescape, funescape ),
                      rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
                  )) ) {
  
                      // If seed is empty or no tokens remain, we can return early
                      tokens.splice( i, 1 );
                      selector = seed.length && toSelector( tokens );
                      if ( !selector ) {
                          push.apply( results, seed );
                          return results;
                      }
  
                      break;
                  }
              }
          }
      }
  
      // Compile and execute a filtering function if one is not provided
      // Provide `match` to avoid retokenization if we modified the selector above
      ( compiled || compile( selector, match ) )(
          seed,
          context,
          !documentIsHTML,
          results,
          !context || rsibling.test( selector ) && testContext( context.parentNode ) || context
      );
      return results;
  };
  
  // One-time assignments
  
  // Sort stability
  support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
  
  // Support: Chrome 14-35+
  // Always assume duplicates if they aren't passed to the comparison function
  support.detectDuplicates = !!hasDuplicate;
  
  // Initialize against the default document
  setDocument();
  
  // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
  // Detached nodes confoundingly follow *each other*
  support.sortDetached = assert(function( div1 ) {
      // Should return 1, but returns 4 (following)
      return div1.compareDocumentPosition( document.createElement("div") ) & 1;
  });
  
  // Support: IE<8
  // Prevent attribute/property "interpolation"
  // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
  if ( !assert(function( div ) {
      div.innerHTML = "<a href='#'></a>";
      return div.firstChild.getAttribute("href") === "#" ;
  }) ) {
      addHandle( "type|href|height|width", function( elem, name, isXML ) {
          if ( !isXML ) {
              return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
          }
      });
  }
  
  // Support: IE<9
  // Use defaultValue in place of getAttribute("value")
  if ( !support.attributes || !assert(function( div ) {
      div.innerHTML = "<input/>";
      div.firstChild.setAttribute( "value", "" );
      return div.firstChild.getAttribute( "value" ) === "";
  }) ) {
      addHandle( "value", function( elem, name, isXML ) {
          if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
              return elem.defaultValue;
          }
      });
  }
  
  // Support: IE<9
  // Use getAttributeNode to fetch booleans when getAttribute lies
  if ( !assert(function( div ) {
      return div.getAttribute("disabled") == null;
  }) ) {
      addHandle( booleans, function( elem, name, isXML ) {
          var val;
          if ( !isXML ) {
              return elem[ name ] === true ? name.toLowerCase() :
                      (val = elem.getAttributeNode( name )) && val.specified ?
                      val.value :
                  null;
          }
      });
  }
  
  return Sizzle;
  
  })( window );
  
  
  
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[ ":" ] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  
  
  
  var dir = function( elem, dir, until ) {
      var matched = [],
          truncate = until !== undefined;
  
      while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
          if ( elem.nodeType === 1 ) {
              if ( truncate && jQuery( elem ).is( until ) ) {
                  break;
              }
              matched.push( elem );
          }
      }
      return matched;
  };
  
  
  var siblings = function( n, elem ) {
      var matched = [];
  
      for ( ; n; n = n.nextSibling ) {
          if ( n.nodeType === 1 && n !== elem ) {
              matched.push( n );
          }
      }
  
      return matched;
  };
  
  
  var rneedsContext = jQuery.expr.match.needsContext;
  
  var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );
  
  
  
  var risSimple = /^.[^:#\[\.,]*$/;
  
  // Implement the identical functionality for filter and not
  function winnow( elements, qualifier, not ) {
      if ( jQuery.isFunction( qualifier ) ) {
          return jQuery.grep( elements, function( elem, i ) {
              /* jshint -W018 */
              return !!qualifier.call( elem, i, elem ) !== not;
          } );
  
      }
  
      if ( qualifier.nodeType ) {
          return jQuery.grep( elements, function( elem ) {
              return ( elem === qualifier ) !== not;
          } );
  
      }
  
      if ( typeof qualifier === "string" ) {
          if ( risSimple.test( qualifier ) ) {
              return jQuery.filter( qualifier, elements, not );
          }
  
          qualifier = jQuery.filter( qualifier, elements );
      }
  
      return jQuery.grep( elements, function( elem ) {
          return ( jQuery.inArray( elem, qualifier ) > -1 ) !== not;
      } );
  }
  
  jQuery.filter = function( expr, elems, not ) {
      var elem = elems[ 0 ];
  
      if ( not ) {
          expr = ":not(" + expr + ")";
      }
  
      return elems.length === 1 && elem.nodeType === 1 ?
          jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
          jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
              return elem.nodeType === 1;
          } ) );
  };
  
  jQuery.fn.extend( {
      find: function( selector ) {
          var i,
              ret = [],
              self = this,
              len = self.length;
  
          if ( typeof selector !== "string" ) {
              return this.pushStack( jQuery( selector ).filter( function() {
                  for ( i = 0; i < len; i++ ) {
                      if ( jQuery.contains( self[ i ], this ) ) {
                          return true;
                      }
                  }
              } ) );
          }
  
          for ( i = 0; i < len; i++ ) {
              jQuery.find( selector, self[ i ], ret );
          }
  
          // Needed because $( selector, context ) becomes $( context ).find( selector )
          ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
          ret.selector = this.selector ? this.selector + " " + selector : selector;
          return ret;
      },
      filter: function( selector ) {
          return this.pushStack( winnow( this, selector || [], false ) );
      },
      not: function( selector ) {
          return this.pushStack( winnow( this, selector || [], true ) );
      },
      is: function( selector ) {
          return !!winnow(
              this,
  
              // If this is a positional/relative selector, check membership in the returned set
              // so $("p:first").is("p:last") won't return true for a doc with two "p".
              typeof selector === "string" && rneedsContext.test( selector ) ?
                  jQuery( selector ) :
                  selector || [],
              false
          ).length;
      }
  } );
  
  
  // Initialize a jQuery object
  
  
  // A central reference to the root jQuery(document)
  var rootjQuery,
  
      // A simple way to check for HTML strings
      // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
      // Strict HTML recognition (#11290: must start with <)
      rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
  
      init = jQuery.fn.init = function( selector, context, root ) {
          var match, elem;
  
          // HANDLE: $(""), $(null), $(undefined), $(false)
          if ( !selector ) {
              return this;
          }
  
          // init accepts an alternate rootjQuery
          // so migrate can support jQuery.sub (gh-2101)
          root = root || rootjQuery;
  
          // Handle HTML strings
          if ( typeof selector === "string" ) {
              if ( selector.charAt( 0 ) === "<" &&
                  selector.charAt( selector.length - 1 ) === ">" &&
                  selector.length >= 3 ) {
  
                  // Assume that strings that start and end with <> are HTML and skip the regex check
                  match = [ null, selector, null ];
  
              } else {
                  match = rquickExpr.exec( selector );
              }
  
              // Match html or make sure no context is specified for #id
              if ( match && ( match[ 1 ] || !context ) ) {
  
                  // HANDLE: $(html) -> $(array)
                  if ( match[ 1 ] ) {
                      context = context instanceof jQuery ? context[ 0 ] : context;
  
                      // scripts is true for back-compat
                      // Intentionally let the error be thrown if parseHTML is not present
                      jQuery.merge( this, jQuery.parseHTML(
                          match[ 1 ],
                          context && context.nodeType ? context.ownerDocument || context : document,
                          true
                      ) );
  
                      // HANDLE: $(html, props)
                      if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
                          for ( match in context ) {
  
                              // Properties of context are called as methods if possible
                              if ( jQuery.isFunction( this[ match ] ) ) {
                                  this[ match ]( context[ match ] );
  
                              // ...and otherwise set as attributes
                              } else {
                                  this.attr( match, context[ match ] );
                              }
                          }
                      }
  
                      return this;
  
                  // HANDLE: $(#id)
                  } else {
                      elem = document.getElementById( match[ 2 ] );
  
                      // Check parentNode to catch when Blackberry 4.6 returns
                      // nodes that are no longer in the document #6963
                      if ( elem && elem.parentNode ) {
  
                          // Handle the case where IE and Opera return items
                          // by name instead of ID
                          if ( elem.id !== match[ 2 ] ) {
                              return rootjQuery.find( selector );
                          }
  
                          // Otherwise, we inject the element directly into the jQuery object
                          this.length = 1;
                          this[ 0 ] = elem;
                      }
  
                      this.context = document;
                      this.selector = selector;
                      return this;
                  }
  
              // HANDLE: $(expr, $(...))
              } else if ( !context || context.jquery ) {
                  return ( context || root ).find( selector );
  
              // HANDLE: $(expr, context)
              // (which is just equivalent to: $(context).find(expr)
              } else {
                  return this.constructor( context ).find( selector );
              }
  
          // HANDLE: $(DOMElement)
          } else if ( selector.nodeType ) {
              this.context = this[ 0 ] = selector;
              this.length = 1;
              return this;
  
          // HANDLE: $(function)
          // Shortcut for document ready
          } else if ( jQuery.isFunction( selector ) ) {
              return typeof root.ready !== "undefined" ?
                  root.ready( selector ) :
  
                  // Execute immediately if ready is not present
                  selector( jQuery );
          }
  
          if ( selector.selector !== undefined ) {
              this.selector = selector.selector;
              this.context = selector.context;
          }
  
          return jQuery.makeArray( selector, this );
      };
  
  // Give the init function the jQuery prototype for later instantiation
  init.prototype = jQuery.fn;
  
  // Initialize central reference
  rootjQuery = jQuery( document );
  
  
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
  
      // methods guaranteed to produce a unique set when starting from a unique set
      guaranteedUnique = {
          children: true,
          contents: true,
          next: true,
          prev: true
      };
  
  jQuery.fn.extend( {
      has: function( target ) {
          var i,
              targets = jQuery( target, this ),
              len = targets.length;
  
          return this.filter( function() {
              for ( i = 0; i < len; i++ ) {
                  if ( jQuery.contains( this, targets[ i ] ) ) {
                      return true;
                  }
              }
          } );
      },
  
      closest: function( selectors, context ) {
          var cur,
              i = 0,
              l = this.length,
              matched = [],
              pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
                  jQuery( selectors, context || this.context ) :
                  0;
  
          for ( ; i < l; i++ ) {
              for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
  
                  // Always skip document fragments
                  if ( cur.nodeType < 11 && ( pos ?
                      pos.index( cur ) > -1 :
  
                      // Don't pass non-elements to Sizzle
                      cur.nodeType === 1 &&
                          jQuery.find.matchesSelector( cur, selectors ) ) ) {
  
                      matched.push( cur );
                      break;
                  }
              }
          }
  
          return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
      },
  
      // Determine the position of an element within
      // the matched set of elements
      index: function( elem ) {
  
          // No argument, return index in parent
          if ( !elem ) {
              return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
          }
  
          // index in selector
          if ( typeof elem === "string" ) {
              return jQuery.inArray( this[ 0 ], jQuery( elem ) );
          }
  
          // Locate the position of the desired element
          return jQuery.inArray(
  
              // If it receives a jQuery object, the first element is used
              elem.jquery ? elem[ 0 ] : elem, this );
      },
  
      add: function( selector, context ) {
          return this.pushStack(
              jQuery.uniqueSort(
                  jQuery.merge( this.get(), jQuery( selector, context ) )
              )
          );
      },
  
      addBack: function( selector ) {
          return this.add( selector == null ?
              this.prevObject : this.prevObject.filter( selector )
          );
      }
  } );
  
  function sibling( cur, dir ) {
      do {
          cur = cur[ dir ];
      } while ( cur && cur.nodeType !== 1 );
  
      return cur;
  }
  
  jQuery.each( {
      parent: function( elem ) {
          var parent = elem.parentNode;
          return parent && parent.nodeType !== 11 ? parent : null;
      },
      parents: function( elem ) {
          return dir( elem, "parentNode" );
      },
      parentsUntil: function( elem, i, until ) {
          return dir( elem, "parentNode", until );
      },
      next: function( elem ) {
          return sibling( elem, "nextSibling" );
      },
      prev: function( elem ) {
          return sibling( elem, "previousSibling" );
      },
      nextAll: function( elem ) {
          return dir( elem, "nextSibling" );
      },
      prevAll: function( elem ) {
          return dir( elem, "previousSibling" );
      },
      nextUntil: function( elem, i, until ) {
          return dir( elem, "nextSibling", until );
      },
      prevUntil: function( elem, i, until ) {
          return dir( elem, "previousSibling", until );
      },
      siblings: function( elem ) {
          return siblings( ( elem.parentNode || {} ).firstChild, elem );
      },
      children: function( elem ) {
          return siblings( elem.firstChild );
      },
      contents: function( elem ) {
          return jQuery.nodeName( elem, "iframe" ) ?
              elem.contentDocument || elem.contentWindow.document :
              jQuery.merge( [], elem.childNodes );
      }
  }, function( name, fn ) {
      jQuery.fn[ name ] = function( until, selector ) {
          var ret = jQuery.map( this, fn, until );
  
          if ( name.slice( -5 ) !== "Until" ) {
              selector = until;
          }
  
          if ( selector && typeof selector === "string" ) {
              ret = jQuery.filter( selector, ret );
          }
  
          if ( this.length > 1 ) {
  
              // Remove duplicates
              if ( !guaranteedUnique[ name ] ) {
                  ret = jQuery.uniqueSort( ret );
              }
  
              // Reverse order for parents* and prev-derivatives
              if ( rparentsprev.test( name ) ) {
                  ret = ret.reverse();
              }
          }
  
          return this.pushStack( ret );
      };
  } );
  var rnotwhite = ( /\S+/g );
  
  
  
  // Convert String-formatted options into Object-formatted ones
  function createOptions( options ) {
      var object = {};
      jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
          object[ flag ] = true;
      } );
      return object;
  }
  
  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */
  jQuery.Callbacks = function( options ) {
  
      // Convert options from String-formatted to Object-formatted if needed
      // (we check in cache first)
      options = typeof options === "string" ?
          createOptions( options ) :
          jQuery.extend( {}, options );
  
      var // Flag to know if list is currently firing
          firing,
  
          // Last fire value for non-forgettable lists
          memory,
  
          // Flag to know if list was already fired
          fired,
  
          // Flag to prevent firing
          locked,
  
          // Actual callback list
          list = [],
  
          // Queue of execution data for repeatable lists
          queue = [],
  
          // Index of currently firing callback (modified by add/remove as needed)
          firingIndex = -1,
  
          // Fire callbacks
          fire = function() {
  
              // Enforce single-firing
              locked = options.once;
  
              // Execute callbacks for all pending executions,
              // respecting firingIndex overrides and runtime changes
              fired = firing = true;
              for ( ; queue.length; firingIndex = -1 ) {
                  memory = queue.shift();
                  while ( ++firingIndex < list.length ) {
  
                      // Run callback and check for early termination
                      if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
                          options.stopOnFalse ) {
  
                          // Jump to end and forget the data so .add doesn't re-fire
                          firingIndex = list.length;
                          memory = false;
                      }
                  }
              }
  
              // Forget the data if we're done with it
              if ( !options.memory ) {
                  memory = false;
              }
  
              firing = false;
  
              // Clean up if we're done firing for good
              if ( locked ) {
  
                  // Keep an empty list if we have data for future add calls
                  if ( memory ) {
                      list = [];
  
                  // Otherwise, this object is spent
                  } else {
                      list = "";
                  }
              }
          },
  
          // Actual Callbacks object
          self = {
  
              // Add a callback or a collection of callbacks to the list
              add: function() {
                  if ( list ) {
  
                      // If we have memory from a past run, we should fire after adding
                      if ( memory && !firing ) {
                          firingIndex = list.length - 1;
                          queue.push( memory );
                      }
  
                      ( function add( args ) {
                          jQuery.each( args, function( _, arg ) {
                              if ( jQuery.isFunction( arg ) ) {
                                  if ( !options.unique || !self.has( arg ) ) {
                                      list.push( arg );
                                  }
                              } else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {
  
                                  // Inspect recursively
                                  add( arg );
                              }
                          } );
                      } )( arguments );
  
                      if ( memory && !firing ) {
                          fire();
                      }
                  }
                  return this;
              },
  
              // Remove a callback from the list
              remove: function() {
                  jQuery.each( arguments, function( _, arg ) {
                      var index;
                      while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
                          list.splice( index, 1 );
  
                          // Handle firing indexes
                          if ( index <= firingIndex ) {
                              firingIndex--;
                          }
                      }
                  } );
                  return this;
              },
  
              // Check if a given callback is in the list.
              // If no argument is given, return whether or not list has callbacks attached.
              has: function( fn ) {
                  return fn ?
                      jQuery.inArray( fn, list ) > -1 :
                      list.length > 0;
              },
  
              // Remove all callbacks from the list
              empty: function() {
                  if ( list ) {
                      list = [];
                  }
                  return this;
              },
  
              // Disable .fire and .add
              // Abort any current/pending executions
              // Clear all callbacks and values
              disable: function() {
                  locked = queue = [];
                  list = memory = "";
                  return this;
              },
              disabled: function() {
                  return !list;
              },
  
              // Disable .fire
              // Also disable .add unless we have memory (since it would have no effect)
              // Abort any pending executions
              lock: function() {
                  locked = true;
                  if ( !memory ) {
                      self.disable();
                  }
                  return this;
              },
              locked: function() {
                  return !!locked;
              },
  
              // Call all callbacks with the given context and arguments
              fireWith: function( context, args ) {
                  if ( !locked ) {
                      args = args || [];
                      args = [ context, args.slice ? args.slice() : args ];
                      queue.push( args );
                      if ( !firing ) {
                          fire();
                      }
                  }
                  return this;
              },
  
              // Call all the callbacks with the given arguments
              fire: function() {
                  self.fireWith( this, arguments );
                  return this;
              },
  
              // To know if the callbacks have already been called at least once
              fired: function() {
                  return !!fired;
              }
          };
  
      return self;
  };
  
  
  jQuery.extend( {
  
      Deferred: function( func ) {
          var tuples = [
  
                  // action, add listener, listener list, final state
                  [ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
                  [ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
                  [ "notify", "progress", jQuery.Callbacks( "memory" ) ]
              ],
              state = "pending",
              promise = {
                  state: function() {
                      return state;
                  },
                  always: function() {
                      deferred.done( arguments ).fail( arguments );
                      return this;
                  },
                  then: function( /* fnDone, fnFail, fnProgress */ ) {
                      var fns = arguments;
                      return jQuery.Deferred( function( newDefer ) {
                          jQuery.each( tuples, function( i, tuple ) {
                              var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
  
                              // deferred[ done | fail | progress ] for forwarding actions to newDefer
                              deferred[ tuple[ 1 ] ]( function() {
                                  var returned = fn && fn.apply( this, arguments );
                                  if ( returned && jQuery.isFunction( returned.promise ) ) {
                                      returned.promise()
                                          .progress( newDefer.notify )
                                          .done( newDefer.resolve )
                                          .fail( newDefer.reject );
                                  } else {
                                      newDefer[ tuple[ 0 ] + "With" ](
                                          this === promise ? newDefer.promise() : this,
                                          fn ? [ returned ] : arguments
                                      );
                                  }
                              } );
                          } );
                          fns = null;
                      } ).promise();
                  },
  
                  // Get a promise for this deferred
                  // If obj is provided, the promise aspect is added to the object
                  promise: function( obj ) {
                      return obj != null ? jQuery.extend( obj, promise ) : promise;
                  }
              },
              deferred = {};
  
          // Keep pipe for back-compat
          promise.pipe = promise.then;
  
          // Add list-specific methods
          jQuery.each( tuples, function( i, tuple ) {
              var list = tuple[ 2 ],
                  stateString = tuple[ 3 ];
  
              // promise[ done | fail | progress ] = list.add
              promise[ tuple[ 1 ] ] = list.add;
  
              // Handle state
              if ( stateString ) {
                  list.add( function() {
  
                      // state = [ resolved | rejected ]
                      state = stateString;
  
                  // [ reject_list | resolve_list ].disable; progress_list.lock
                  }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
              }
  
              // deferred[ resolve | reject | notify ]
              deferred[ tuple[ 0 ] ] = function() {
                  deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
                  return this;
              };
              deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
          } );
  
          // Make the deferred a promise
          promise.promise( deferred );
  
          // Call given func if any
          if ( func ) {
              func.call( deferred, deferred );
          }
  
          // All done!
          return deferred;
      },
  
      // Deferred helper
      when: function( subordinate /* , ..., subordinateN */ ) {
          var i = 0,
              resolveValues = slice.call( arguments ),
              length = resolveValues.length,
  
              // the count of uncompleted subordinates
              remaining = length !== 1 ||
                  ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
  
              // the master Deferred.
              // If resolveValues consist of only a single Deferred, just use that.
              deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
  
              // Update function for both resolve and progress values
              updateFunc = function( i, contexts, values ) {
                  return function( value ) {
                      contexts[ i ] = this;
                      values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                      if ( values === progressValues ) {
                          deferred.notifyWith( contexts, values );
  
                      } else if ( !( --remaining ) ) {
                          deferred.resolveWith( contexts, values );
                      }
                  };
              },
  
              progressValues, progressContexts, resolveContexts;
  
          // add listeners to Deferred subordinates; treat others as resolved
          if ( length > 1 ) {
              progressValues = new Array( length );
              progressContexts = new Array( length );
              resolveContexts = new Array( length );
              for ( ; i < length; i++ ) {
                  if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                      resolveValues[ i ].promise()
                          .progress( updateFunc( i, progressContexts, progressValues ) )
                          .done( updateFunc( i, resolveContexts, resolveValues ) )
                          .fail( deferred.reject );
                  } else {
                      --remaining;
                  }
              }
          }
  
          // if we're not waiting on anything, resolve the master
          if ( !remaining ) {
              deferred.resolveWith( resolveContexts, resolveValues );
          }
  
          return deferred.promise();
      }
  } );
  
  
  // The deferred used on DOM ready
  var readyList;
  
  jQuery.fn.ready = function( fn ) {
  
      // Add the callback
      jQuery.ready.promise().done( fn );
  
      return this;
  };
  
  jQuery.extend( {
  
      // Is the DOM ready to be used? Set to true once it occurs.
      isReady: false,
  
      // A counter to track how many items to wait for before
      // the ready event fires. See #6781
      readyWait: 1,
  
      // Hold (or release) the ready event
      holdReady: function( hold ) {
          if ( hold ) {
              jQuery.readyWait++;
          } else {
              jQuery.ready( true );
          }
      },
  
      // Handle when the DOM is ready
      ready: function( wait ) {
  
          // Abort if there are pending holds or we're already ready
          if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
              return;
          }
  
          // Remember that the DOM is ready
          jQuery.isReady = true;
  
          // If a normal DOM Ready event fired, decrement, and wait if need be
          if ( wait !== true && --jQuery.readyWait > 0 ) {
              return;
          }
  
          // If there are functions bound, to execute
          readyList.resolveWith( document, [ jQuery ] );
  
          // Trigger any bound ready events
          if ( jQuery.fn.triggerHandler ) {
              jQuery( document ).triggerHandler( "ready" );
              jQuery( document ).off( "ready" );
          }
      }
  } );
  
  /**
   * Clean-up method for dom ready events
   */
  function detach() {
      if ( document.addEventListener ) {
          document.removeEventListener( "DOMContentLoaded", completed );
          window.removeEventListener( "load", completed );
  
      } else {
          document.detachEvent( "onreadystatechange", completed );
          window.detachEvent( "onload", completed );
      }
  }
  
  /**
   * The ready event handler and self cleanup method
   */
  function completed() {
  
      // readyState === "complete" is good enough for us to call the dom ready in oldIE
      if ( document.addEventListener ||
          window.event.type === "load" ||
          document.readyState === "complete" ) {
  
          detach();
          jQuery.ready();
      }
  }
  
  jQuery.ready.promise = function( obj ) {
      if ( !readyList ) {
  
          readyList = jQuery.Deferred();
  
          // Catch cases where $(document).ready() is called
          // after the browser event has already occurred.
          // Support: IE6-10
          // Older IE sometimes signals "interactive" too soon
          if ( document.readyState === "complete" ||
              ( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
  
              // Handle it asynchronously to allow scripts the opportunity to delay ready
              window.setTimeout( jQuery.ready );
  
          // Standards-based browsers support DOMContentLoaded
          } else if ( document.addEventListener ) {
  
              // Use the handy event callback
              document.addEventListener( "DOMContentLoaded", completed );
  
              // A fallback to window.onload, that will always work
              window.addEventListener( "load", completed );
  
          // If IE event model is used
          } else {
  
              // Ensure firing before onload, maybe late but safe also for iframes
              document.attachEvent( "onreadystatechange", completed );
  
              // A fallback to window.onload, that will always work
              window.attachEvent( "onload", completed );
  
              // If IE and not a frame
              // continually check to see if the document is ready
              var top = false;
  
              try {
                  top = window.frameElement == null && document.documentElement;
              } catch ( e ) {}
  
              if ( top && top.doScroll ) {
                  ( function doScrollCheck() {
                      if ( !jQuery.isReady ) {
  
                          try {
  
                              // Use the trick by Diego Perini
                              // http://javascript.nwbox.com/IEContentLoaded/
                              top.doScroll( "left" );
                          } catch ( e ) {
                              return window.setTimeout( doScrollCheck, 50 );
                          }
  
                          // detach all dom ready events
                          detach();
  
                          // and execute any waiting functions
                          jQuery.ready();
                      }
                  } )();
              }
          }
      }
      return readyList.promise( obj );
  };
  
  // Kick off the DOM ready check even if the user does not
  jQuery.ready.promise();
  
  
  
  
  // Support: IE<9
  // Iteration over object's inherited properties before its own
  var i;
  for ( i in jQuery( support ) ) {
      break;
  }
  support.ownFirst = i === "0";
  
  // Note: most support tests are defined in their respective modules.
  // false until the test is run
  support.inlineBlockNeedsLayout = false;
  
  // Execute ASAP in case we need to set body.style.zoom
  jQuery( function() {
  
      // Minified: var a,b,c,d
      var val, div, body, container;
  
      body = document.getElementsByTagName( "body" )[ 0 ];
      if ( !body || !body.style ) {
  
          // Return for frameset docs that don't have a body
          return;
      }
  
      // Setup
      div = document.createElement( "div" );
      container = document.createElement( "div" );
      container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
      body.appendChild( container ).appendChild( div );
  
      if ( typeof div.style.zoom !== "undefined" ) {
  
          // Support: IE<8
          // Check if natively block-level elements act like inline-block
          // elements when setting their display to 'inline' and giving
          // them layout
          div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";
  
          support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
          if ( val ) {
  
              // Prevent IE 6 from affecting layout for positioned elements #11048
              // Prevent IE from shrinking the body in IE 7 mode #12869
              // Support: IE<8
              body.style.zoom = 1;
          }
      }
  
      body.removeChild( container );
  } );
  
  
  ( function() {
      var div = document.createElement( "div" );
  
      // Support: IE<9
      support.deleteExpando = true;
      try {
          delete div.test;
      } catch ( e ) {
          support.deleteExpando = false;
      }
  
      // Null elements to avoid leaks in IE.
      div = null;
  } )();
  var acceptData = function( elem ) {
      var noData = jQuery.noData[ ( elem.nodeName + " " ).toLowerCase() ],
          nodeType = +elem.nodeType || 1;
  
      // Do not set data on non-element DOM nodes because it will not be cleared (#8335).
      return nodeType !== 1 && nodeType !== 9 ?
          false :
  
          // Nodes accept data unless otherwise specified; rejection can be conditional
          !noData || noData !== true && elem.getAttribute( "classid" ) === noData;
  };
  
  
  
  
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /([A-Z])/g;
  
  function dataAttr( elem, key, data ) {
  
      // If nothing was found internally, try to fetch any
      // data from the HTML5 data-* attribute
      if ( data === undefined && elem.nodeType === 1 ) {
  
          var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
  
          data = elem.getAttribute( name );
  
          if ( typeof data === "string" ) {
              try {
                  data = data === "true" ? true :
                      data === "false" ? false :
                      data === "null" ? null :
  
                      // Only convert to a number if it doesn't change the string
                      +data + "" === data ? +data :
                      rbrace.test( data ) ? jQuery.parseJSON( data ) :
                      data;
              } catch ( e ) {}
  
              // Make sure we set the data so it isn't changed later
              jQuery.data( elem, key, data );
  
          } else {
              data = undefined;
          }
      }
  
      return data;
  }
  
  // checks a cache object for emptiness
  function isEmptyDataObject( obj ) {
      var name;
      for ( name in obj ) {
  
          // if the public data object is empty, the private is still empty
          if ( name === "data" && jQuery.isEmptyObject( obj[ name ] ) ) {
              continue;
          }
          if ( name !== "toJSON" ) {
              return false;
          }
      }
  
      return true;
  }
  
  function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
      if ( !acceptData( elem ) ) {
          return;
      }
  
      var ret, thisCache,
          internalKey = jQuery.expando,
  
          // We have to handle DOM nodes and JS objects differently because IE6-7
          // can't GC object references properly across the DOM-JS boundary
          isNode = elem.nodeType,
  
          // Only DOM nodes need the global jQuery cache; JS object data is
          // attached directly to the object so GC can occur automatically
          cache = isNode ? jQuery.cache : elem,
  
          // Only defining an ID for JS objects if its cache already exists allows
          // the code to shortcut on the same path as a DOM node with no cache
          id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;
  
      // Avoid doing any more work than we need to when trying to get data on an
      // object that has no data at all
      if ( ( !id || !cache[ id ] || ( !pvt && !cache[ id ].data ) ) &&
          data === undefined && typeof name === "string" ) {
          return;
      }
  
      if ( !id ) {
  
          // Only DOM nodes need a new unique ID for each element since their data
          // ends up in the global cache
          if ( isNode ) {
              id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
          } else {
              id = internalKey;
          }
      }
  
      if ( !cache[ id ] ) {
  
          // Avoid exposing jQuery metadata on plain JS objects when the object
          // is serialized using JSON.stringify
          cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
      }
  
      // An object can be passed to jQuery.data instead of a key/value pair; this gets
      // shallow copied over onto the existing cache
      if ( typeof name === "object" || typeof name === "function" ) {
          if ( pvt ) {
              cache[ id ] = jQuery.extend( cache[ id ], name );
          } else {
              cache[ id ].data = jQuery.extend( cache[ id ].data, name );
          }
      }
  
      thisCache = cache[ id ];
  
      // jQuery data() is stored in a separate object inside the object's internal data
      // cache in order to avoid key collisions between internal data and user-defined
      // data.
      if ( !pvt ) {
          if ( !thisCache.data ) {
              thisCache.data = {};
          }
  
          thisCache = thisCache.data;
      }
  
      if ( data !== undefined ) {
          thisCache[ jQuery.camelCase( name ) ] = data;
      }
  
      // Check for both converted-to-camel and non-converted data property names
      // If a data property was specified
      if ( typeof name === "string" ) {
  
          // First Try to find as-is property data
          ret = thisCache[ name ];
  
          // Test for null|undefined property data
          if ( ret == null ) {
  
              // Try to find the camelCased property
              ret = thisCache[ jQuery.camelCase( name ) ];
          }
      } else {
          ret = thisCache;
      }
  
      return ret;
  }
  
  function internalRemoveData( elem, name, pvt ) {
      if ( !acceptData( elem ) ) {
          return;
      }
  
      var thisCache, i,
          isNode = elem.nodeType,
  
          // See jQuery.data for more information
          cache = isNode ? jQuery.cache : elem,
          id = isNode ? elem[ jQuery.expando ] : jQuery.expando;
  
      // If there is already no cache entry for this object, there is no
      // purpose in continuing
      if ( !cache[ id ] ) {
          return;
      }
  
      if ( name ) {
  
          thisCache = pvt ? cache[ id ] : cache[ id ].data;
  
          if ( thisCache ) {
  
              // Support array or space separated string names for data keys
              if ( !jQuery.isArray( name ) ) {
  
                  // try the string as a key before any manipulation
                  if ( name in thisCache ) {
                      name = [ name ];
                  } else {
  
                      // split the camel cased version by spaces unless a key with the spaces exists
                      name = jQuery.camelCase( name );
                      if ( name in thisCache ) {
                          name = [ name ];
                      } else {
                          name = name.split( " " );
                      }
                  }
              } else {
  
                  // If "name" is an array of keys...
                  // When data is initially created, via ("key", "val") signature,
                  // keys will be converted to camelCase.
                  // Since there is no way to tell _how_ a key was added, remove
                  // both plain key and camelCase key. #12786
                  // This will only penalize the array argument path.
                  name = name.concat( jQuery.map( name, jQuery.camelCase ) );
              }
  
              i = name.length;
              while ( i-- ) {
                  delete thisCache[ name[ i ] ];
              }
  
              // If there is no data left in the cache, we want to continue
              // and let the cache object itself get destroyed
              if ( pvt ? !isEmptyDataObject( thisCache ) : !jQuery.isEmptyObject( thisCache ) ) {
                  return;
              }
          }
      }
  
      // See jQuery.data for more information
      if ( !pvt ) {
          delete cache[ id ].data;
  
          // Don't destroy the parent cache unless the internal data object
          // had been the only thing left in it
          if ( !isEmptyDataObject( cache[ id ] ) ) {
              return;
          }
      }
  
      // Destroy the cache
      if ( isNode ) {
          jQuery.cleanData( [ elem ], true );
  
      // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
      /* jshint eqeqeq: false */
      } else if ( support.deleteExpando || cache != cache.window ) {
          /* jshint eqeqeq: true */
          delete cache[ id ];
  
      // When all else fails, undefined
      } else {
          cache[ id ] = undefined;
      }
  }
  
  jQuery.extend( {
      cache: {},
  
      // The following elements (space-suffixed to avoid Object.prototype collisions)
      // throw uncatchable exceptions if you attempt to set expando properties
      noData: {
          "applet ": true,
          "embed ": true,
  
          // ...but Flash objects (which have this classid) *can* handle expandos
          "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
      },
  
      hasData: function( elem ) {
          elem = elem.nodeType ? jQuery.cache[ elem[ jQuery.expando ] ] : elem[ jQuery.expando ];
          return !!elem && !isEmptyDataObject( elem );
      },
  
      data: function( elem, name, data ) {
          return internalData( elem, name, data );
      },
  
      removeData: function( elem, name ) {
          return internalRemoveData( elem, name );
      },
  
      // For internal use only.
      _data: function( elem, name, data ) {
          return internalData( elem, name, data, true );
      },
  
      _removeData: function( elem, name ) {
          return internalRemoveData( elem, name, true );
      }
  } );
  
  jQuery.fn.extend( {
      data: function( key, value ) {
          var i, name, data,
              elem = this[ 0 ],
              attrs = elem && elem.attributes;
  
          // Special expections of .data basically thwart jQuery.access,
          // so implement the relevant behavior ourselves
  
          // Gets all values
          if ( key === undefined ) {
              if ( this.length ) {
                  data = jQuery.data( elem );
  
                  if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
                      i = attrs.length;
                      while ( i-- ) {
  
                          // Support: IE11+
                          // The attrs elements can be null (#14894)
                          if ( attrs[ i ] ) {
                              name = attrs[ i ].name;
                              if ( name.indexOf( "data-" ) === 0 ) {
                                  name = jQuery.camelCase( name.slice( 5 ) );
                                  dataAttr( elem, name, data[ name ] );
                              }
                          }
                      }
                      jQuery._data( elem, "parsedAttrs", true );
                  }
              }
  
              return data;
          }
  
          // Sets multiple values
          if ( typeof key === "object" ) {
              return this.each( function() {
                  jQuery.data( this, key );
              } );
          }
  
          return arguments.length > 1 ?
  
              // Sets one value
              this.each( function() {
                  jQuery.data( this, key, value );
              } ) :
  
              // Gets one value
              // Try to fetch any internally stored data first
              elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
      },
  
      removeData: function( key ) {
          return this.each( function() {
              jQuery.removeData( this, key );
          } );
      }
  } );
  
  
  jQuery.extend( {
      queue: function( elem, type, data ) {
          var queue;
  
          if ( elem ) {
              type = ( type || "fx" ) + "queue";
              queue = jQuery._data( elem, type );
  
              // Speed up dequeue by getting out quickly if this is just a lookup
              if ( data ) {
                  if ( !queue || jQuery.isArray( data ) ) {
                      queue = jQuery._data( elem, type, jQuery.makeArray( data ) );
                  } else {
                      queue.push( data );
                  }
              }
              return queue || [];
          }
      },
  
      dequeue: function( elem, type ) {
          type = type || "fx";
  
          var queue = jQuery.queue( elem, type ),
              startLength = queue.length,
              fn = queue.shift(),
              hooks = jQuery._queueHooks( elem, type ),
              next = function() {
                  jQuery.dequeue( elem, type );
              };
  
          // If the fx queue is dequeued, always remove the progress sentinel
          if ( fn === "inprogress" ) {
              fn = queue.shift();
              startLength--;
          }
  
          if ( fn ) {
  
              // Add a progress sentinel to prevent the fx queue from being
              // automatically dequeued
              if ( type === "fx" ) {
                  queue.unshift( "inprogress" );
              }
  
              // clear up the last queue stop function
              delete hooks.stop;
              fn.call( elem, next, hooks );
          }
  
          if ( !startLength && hooks ) {
              hooks.empty.fire();
          }
      },
  
      // not intended for public consumption - generates a queueHooks object,
      // or returns the current one
      _queueHooks: function( elem, type ) {
          var key = type + "queueHooks";
          return jQuery._data( elem, key ) || jQuery._data( elem, key, {
              empty: jQuery.Callbacks( "once memory" ).add( function() {
                  jQuery._removeData( elem, type + "queue" );
                  jQuery._removeData( elem, key );
              } )
          } );
      }
  } );
  
  jQuery.fn.extend( {
      queue: function( type, data ) {
          var setter = 2;
  
          if ( typeof type !== "string" ) {
              data = type;
              type = "fx";
              setter--;
          }
  
          if ( arguments.length < setter ) {
              return jQuery.queue( this[ 0 ], type );
          }
  
          return data === undefined ?
              this :
              this.each( function() {
                  var queue = jQuery.queue( this, type, data );
  
                  // ensure a hooks for this queue
                  jQuery._queueHooks( this, type );
  
                  if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
                      jQuery.dequeue( this, type );
                  }
              } );
      },
      dequeue: function( type ) {
          return this.each( function() {
              jQuery.dequeue( this, type );
          } );
      },
      clearQueue: function( type ) {
          return this.queue( type || "fx", [] );
      },
  
      // Get a promise resolved when queues of a certain type
      // are emptied (fx is the type by default)
      promise: function( type, obj ) {
          var tmp,
              count = 1,
              defer = jQuery.Deferred(),
              elements = this,
              i = this.length,
              resolve = function() {
                  if ( !( --count ) ) {
                      defer.resolveWith( elements, [ elements ] );
                  }
              };
  
          if ( typeof type !== "string" ) {
              obj = type;
              type = undefined;
          }
          type = type || "fx";
  
          while ( i-- ) {
              tmp = jQuery._data( elements[ i ], type + "queueHooks" );
              if ( tmp && tmp.empty ) {
                  count++;
                  tmp.empty.add( resolve );
              }
          }
          resolve();
          return defer.promise( obj );
      }
  } );
  
  
  ( function() {
      var shrinkWrapBlocksVal;
  
      support.shrinkWrapBlocks = function() {
          if ( shrinkWrapBlocksVal != null ) {
              return shrinkWrapBlocksVal;
          }
  
          // Will be changed later if needed.
          shrinkWrapBlocksVal = false;
  
          // Minified: var b,c,d
          var div, body, container;
  
          body = document.getElementsByTagName( "body" )[ 0 ];
          if ( !body || !body.style ) {
  
              // Test fired too early or in an unsupported environment, exit.
              return;
          }
  
          // Setup
          div = document.createElement( "div" );
          container = document.createElement( "div" );
          container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
          body.appendChild( container ).appendChild( div );
  
          // Support: IE6
          // Check if elements with layout shrink-wrap their children
          if ( typeof div.style.zoom !== "undefined" ) {
  
              // Reset CSS: box-sizing; display; margin; border
              div.style.cssText =
  
                  // Support: Firefox<29, Android 2.3
                  // Vendor-prefix box-sizing
                  "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                  "box-sizing:content-box;display:block;margin:0;border:0;" +
                  "padding:1px;width:1px;zoom:1";
              div.appendChild( document.createElement( "div" ) ).style.width = "5px";
              shrinkWrapBlocksVal = div.offsetWidth !== 3;
          }
  
          body.removeChild( container );
  
          return shrinkWrapBlocksVal;
      };
  
  } )();
  var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
  
  var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
  
  
  var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
  
  var isHidden = function( elem, el ) {
  
          // isHidden might be called from jQuery#filter function;
          // in that case, element will be second argument
          elem = el || elem;
          return jQuery.css( elem, "display" ) === "none" ||
              !jQuery.contains( elem.ownerDocument, elem );
      };
  
  
  
  function adjustCSS( elem, prop, valueParts, tween ) {
      var adjusted,
          scale = 1,
          maxIterations = 20,
          currentValue = tween ?
              function() { return tween.cur(); } :
              function() { return jQuery.css( elem, prop, "" ); },
          initial = currentValue(),
          unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
  
          // Starting value computation is required for potential unit mismatches
          initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
              rcssNum.exec( jQuery.css( elem, prop ) );
  
      if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
  
          // Trust units reported by jQuery.css
          unit = unit || initialInUnit[ 3 ];
  
          // Make sure we update the tween properties later on
          valueParts = valueParts || [];
  
          // Iteratively approximate from a nonzero starting point
          initialInUnit = +initial || 1;
  
          do {
  
              // If previous iteration zeroed out, double until we get *something*.
              // Use string for doubling so we don't accidentally see scale as unchanged below
              scale = scale || ".5";
  
              // Adjust and apply
              initialInUnit = initialInUnit / scale;
              jQuery.style( elem, prop, initialInUnit + unit );
  
          // Update scale, tolerating zero or NaN from tween.cur()
          // Break the loop if scale is unchanged or perfect, or if we've just had enough.
          } while (
              scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
          );
      }
  
      if ( valueParts ) {
          initialInUnit = +initialInUnit || +initial || 0;
  
          // Apply relative offset (+=/-=) if specified
          adjusted = valueParts[ 1 ] ?
              initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
              +valueParts[ 2 ];
          if ( tween ) {
              tween.unit = unit;
              tween.start = initialInUnit;
              tween.end = adjusted;
          }
      }
      return adjusted;
  }
  
  
  // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function
  var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
      var i = 0,
          length = elems.length,
          bulk = key == null;
  
      // Sets many values
      if ( jQuery.type( key ) === "object" ) {
          chainable = true;
          for ( i in key ) {
              access( elems, fn, i, key[ i ], true, emptyGet, raw );
          }
  
      // Sets one value
      } else if ( value !== undefined ) {
          chainable = true;
  
          if ( !jQuery.isFunction( value ) ) {
              raw = true;
          }
  
          if ( bulk ) {
  
              // Bulk operations run against the entire set
              if ( raw ) {
                  fn.call( elems, value );
                  fn = null;
  
              // ...except when executing function values
              } else {
                  bulk = fn;
                  fn = function( elem, key, value ) {
                      return bulk.call( jQuery( elem ), value );
                  };
              }
          }
  
          if ( fn ) {
              for ( ; i < length; i++ ) {
                  fn(
                      elems[ i ],
                      key,
                      raw ? value : value.call( elems[ i ], i, fn( elems[ i ], key ) )
                  );
              }
          }
      }
  
      return chainable ?
          elems :
  
          // Gets
          bulk ?
              fn.call( elems ) :
              length ? fn( elems[ 0 ], key ) : emptyGet;
  };
  var rcheckableType = ( /^(?:checkbox|radio)$/i );
  
  var rtagName = ( /<([\w:-]+)/ );
  
  var rscriptType = ( /^$|\/(?:java|ecma)script/i );
  
  var rleadingWhitespace = ( /^\s+/ );
  
  var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|" +
          "details|dialog|figcaption|figure|footer|header|hgroup|main|" +
          "mark|meter|nav|output|picture|progress|section|summary|template|time|video";
  
  
  
  function createSafeFragment( document ) {
      var list = nodeNames.split( "|" ),
          safeFrag = document.createDocumentFragment();
  
      if ( safeFrag.createElement ) {
          while ( list.length ) {
              safeFrag.createElement(
                  list.pop()
              );
          }
      }
      return safeFrag;
  }
  
  
  ( function() {
      var div = document.createElement( "div" ),
          fragment = document.createDocumentFragment(),
          input = document.createElement( "input" );
  
      // Setup
      div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
  
      // IE strips leading whitespace when .innerHTML is used
      support.leadingWhitespace = div.firstChild.nodeType === 3;
  
      // Make sure that tbody elements aren't automatically inserted
      // IE will insert them into empty tables
      support.tbody = !div.getElementsByTagName( "tbody" ).length;
  
      // Make sure that link elements get serialized correctly by innerHTML
      // This requires a wrapper element in IE
      support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;
  
      // Makes sure cloning an html5 element does not cause problems
      // Where outerHTML is undefined, this still works
      support.html5Clone =
          document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";
  
      // Check if a disconnected checkbox will retain its checked
      // value of true after appended to the DOM (IE6/7)
      input.type = "checkbox";
      input.checked = true;
      fragment.appendChild( input );
      support.appendChecked = input.checked;
  
      // Make sure textarea (and checkbox) defaultValue is properly cloned
      // Support: IE6-IE11+
      div.innerHTML = "<textarea>x</textarea>";
      support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
  
      // #11217 - WebKit loses check when the name is after the checked attribute
      fragment.appendChild( div );
  
      // Support: Windows Web Apps (WWA)
      // `name` and `type` must use .setAttribute for WWA (#14901)
      input = document.createElement( "input" );
      input.setAttribute( "type", "radio" );
      input.setAttribute( "checked", "checked" );
      input.setAttribute( "name", "t" );
  
      div.appendChild( input );
  
      // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
      // old WebKit doesn't clone checked state correctly in fragments
      support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
  
      // Support: IE<9
      // Cloned elements keep attachEvent handlers, we use addEventListener on IE9+
      support.noCloneEvent = !!div.addEventListener;
  
      // Support: IE<9
      // Since attributes and properties are the same in IE,
      // cleanData must set properties to undefined rather than use removeAttribute
      div[ jQuery.expando ] = 1;
      support.attributes = !div.getAttribute( jQuery.expando );
  } )();
  
  
  // We have to close these tags to support XHTML (#13200)
  var wrapMap = {
      option: [ 1, "<select multiple='multiple'>", "</select>" ],
      legend: [ 1, "<fieldset>", "</fieldset>" ],
      area: [ 1, "<map>", "</map>" ],
  
      // Support: IE8
      param: [ 1, "<object>", "</object>" ],
      thead: [ 1, "<table>", "</table>" ],
      tr: [ 2, "<table><tbody>", "</tbody></table>" ],
      col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
      td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
  
      // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
      // unless wrapped in a div with non-breaking characters in front of it.
      _default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>" ]
  };
  
  // Support: IE8-IE9
  wrapMap.optgroup = wrapMap.option;
  
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  
  
  function getAll( context, tag ) {
      var elems, elem,
          i = 0,
          found = typeof context.getElementsByTagName !== "undefined" ?
              context.getElementsByTagName( tag || "*" ) :
              typeof context.querySelectorAll !== "undefined" ?
                  context.querySelectorAll( tag || "*" ) :
                  undefined;
  
      if ( !found ) {
          for ( found = [], elems = context.childNodes || context;
              ( elem = elems[ i ] ) != null;
              i++
          ) {
              if ( !tag || jQuery.nodeName( elem, tag ) ) {
                  found.push( elem );
              } else {
                  jQuery.merge( found, getAll( elem, tag ) );
              }
          }
      }
  
      return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
          jQuery.merge( [ context ], found ) :
          found;
  }
  
  
  // Mark scripts as having already been evaluated
  function setGlobalEval( elems, refElements ) {
      var elem,
          i = 0;
      for ( ; ( elem = elems[ i ] ) != null; i++ ) {
          jQuery._data(
              elem,
              "globalEval",
              !refElements || jQuery._data( refElements[ i ], "globalEval" )
          );
      }
  }
  
  
  var rhtml = /<|&#?\w+;/,
      rtbody = /<tbody/i;
  
  function fixDefaultChecked( elem ) {
      if ( rcheckableType.test( elem.type ) ) {
          elem.defaultChecked = elem.checked;
      }
  }
  
  function buildFragment( elems, context, scripts, selection, ignored ) {
      var j, elem, contains,
          tmp, tag, tbody, wrap,
          l = elems.length,
  
          // Ensure a safe fragment
          safe = createSafeFragment( context ),
  
          nodes = [],
          i = 0;
  
      for ( ; i < l; i++ ) {
          elem = elems[ i ];
  
          if ( elem || elem === 0 ) {
  
              // Add nodes directly
              if ( jQuery.type( elem ) === "object" ) {
                  jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
  
              // Convert non-html into a text node
              } else if ( !rhtml.test( elem ) ) {
                  nodes.push( context.createTextNode( elem ) );
  
              // Convert html into DOM nodes
              } else {
                  tmp = tmp || safe.appendChild( context.createElement( "div" ) );
  
                  // Deserialize a standard representation
                  tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
                  wrap = wrapMap[ tag ] || wrapMap._default;
  
                  tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
  
                  // Descend through wrappers to the right content
                  j = wrap[ 0 ];
                  while ( j-- ) {
                      tmp = tmp.lastChild;
                  }
  
                  // Manually add leading whitespace removed by IE
                  if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
                      nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[ 0 ] ) );
                  }
  
                  // Remove IE's autoinserted <tbody> from table fragments
                  if ( !support.tbody ) {
  
                      // String was a <table>, *may* have spurious <tbody>
                      elem = tag === "table" && !rtbody.test( elem ) ?
                          tmp.firstChild :
  
                          // String was a bare <thead> or <tfoot>
                          wrap[ 1 ] === "<table>" && !rtbody.test( elem ) ?
                              tmp :
                              0;
  
                      j = elem && elem.childNodes.length;
                      while ( j-- ) {
                          if ( jQuery.nodeName( ( tbody = elem.childNodes[ j ] ), "tbody" ) &&
                              !tbody.childNodes.length ) {
  
                              elem.removeChild( tbody );
                          }
                      }
                  }
  
                  jQuery.merge( nodes, tmp.childNodes );
  
                  // Fix #12392 for WebKit and IE > 9
                  tmp.textContent = "";
  
                  // Fix #12392 for oldIE
                  while ( tmp.firstChild ) {
                      tmp.removeChild( tmp.firstChild );
                  }
  
                  // Remember the top-level container for proper cleanup
                  tmp = safe.lastChild;
              }
          }
      }
  
      // Fix #11356: Clear elements from fragment
      if ( tmp ) {
          safe.removeChild( tmp );
      }
  
      // Reset defaultChecked for any radios and checkboxes
      // about to be appended to the DOM in IE 6/7 (#8060)
      if ( !support.appendChecked ) {
          jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
      }
  
      i = 0;
      while ( ( elem = nodes[ i++ ] ) ) {
  
          // Skip elements already in the context collection (trac-4087)
          if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
              if ( ignored ) {
                  ignored.push( elem );
              }
  
              continue;
          }
  
          contains = jQuery.contains( elem.ownerDocument, elem );
  
          // Append to fragment
          tmp = getAll( safe.appendChild( elem ), "script" );
  
          // Preserve script evaluation history
          if ( contains ) {
              setGlobalEval( tmp );
          }
  
          // Capture executables
          if ( scripts ) {
              j = 0;
              while ( ( elem = tmp[ j++ ] ) ) {
                  if ( rscriptType.test( elem.type || "" ) ) {
                      scripts.push( elem );
                  }
              }
          }
      }
  
      tmp = null;
  
      return safe;
  }
  
  
  ( function() {
      var i, eventName,
          div = document.createElement( "div" );
  
      // Support: IE<9 (lack submit/change bubble), Firefox (lack focus(in | out) events)
      for ( i in { submit: true, change: true, focusin: true } ) {
          eventName = "on" + i;
  
          if ( !( support[ i ] = eventName in window ) ) {
  
              // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
              div.setAttribute( eventName, "t" );
              support[ i ] = div.attributes[ eventName ].expando === false;
          }
      }
  
      // Null elements to avoid leaks in IE.
      div = null;
  } )();
  
  
  var rformElems = /^(?:input|select|textarea)$/i,
      rkeyEvent = /^key/,
      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
      rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
  
  function returnTrue() {
      return true;
  }
  
  function returnFalse() {
      return false;
  }
  
  // Support: IE9
  // See #13393 for more info
  function safeActiveElement() {
      try {
          return document.activeElement;
      } catch ( err ) { }
  }
  
  function on( elem, types, selector, data, fn, one ) {
      var origFn, type;
  
      // Types can be a map of types/handlers
      if ( typeof types === "object" ) {
  
          // ( types-Object, selector, data )
          if ( typeof selector !== "string" ) {
  
              // ( types-Object, data )
              data = data || selector;
              selector = undefined;
          }
          for ( type in types ) {
              on( elem, type, selector, data, types[ type ], one );
          }
          return elem;
      }
  
      if ( data == null && fn == null ) {
  
          // ( types, fn )
          fn = selector;
          data = selector = undefined;
      } else if ( fn == null ) {
          if ( typeof selector === "string" ) {
  
              // ( types, selector, fn )
              fn = data;
              data = undefined;
          } else {
  
              // ( types, data, fn )
              fn = data;
              data = selector;
              selector = undefined;
          }
      }
      if ( fn === false ) {
          fn = returnFalse;
      } else if ( !fn ) {
          return elem;
      }
  
      if ( one === 1 ) {
          origFn = fn;
          fn = function( event ) {
  
              // Can use an empty set, since event contains the info
              jQuery().off( event );
              return origFn.apply( this, arguments );
          };
  
          // Use same guid so caller can remove using origFn
          fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
      }
      return elem.each( function() {
          jQuery.event.add( this, types, fn, data, selector );
      } );
  }
  
  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */
  jQuery.event = {
  
      global: {},
  
      add: function( elem, types, handler, data, selector ) {
          var tmp, events, t, handleObjIn,
              special, eventHandle, handleObj,
              handlers, type, namespaces, origType,
              elemData = jQuery._data( elem );
  
          // Don't attach events to noData or text/comment nodes (but allow plain objects)
          if ( !elemData ) {
              return;
          }
  
          // Caller can pass in an object of custom data in lieu of the handler
          if ( handler.handler ) {
              handleObjIn = handler;
              handler = handleObjIn.handler;
              selector = handleObjIn.selector;
          }
  
          // Make sure that the handler has a unique ID, used to find/remove it later
          if ( !handler.guid ) {
              handler.guid = jQuery.guid++;
          }
  
          // Init the element's event structure and main handler, if this is the first
          if ( !( events = elemData.events ) ) {
              events = elemData.events = {};
          }
          if ( !( eventHandle = elemData.handle ) ) {
              eventHandle = elemData.handle = function( e ) {
  
                  // Discard the second event of a jQuery.event.trigger() and
                  // when an event is called after a page has unloaded
                  return typeof jQuery !== "undefined" &&
                      ( !e || jQuery.event.triggered !== e.type ) ?
                      jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
                      undefined;
              };
  
              // Add elem as a property of the handle fn to prevent a memory leak
              // with IE non-native events
              eventHandle.elem = elem;
          }
  
          // Handle multiple events separated by a space
          types = ( types || "" ).match( rnotwhite ) || [ "" ];
          t = types.length;
          while ( t-- ) {
              tmp = rtypenamespace.exec( types[ t ] ) || [];
              type = origType = tmp[ 1 ];
              namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
  
              // There *must* be a type, no attaching namespace-only handlers
              if ( !type ) {
                  continue;
              }
  
              // If event changes its type, use the special event handlers for the changed type
              special = jQuery.event.special[ type ] || {};
  
              // If selector defined, determine special event api type, otherwise given type
              type = ( selector ? special.delegateType : special.bindType ) || type;
  
              // Update special based on newly reset type
              special = jQuery.event.special[ type ] || {};
  
              // handleObj is passed to all event handlers
              handleObj = jQuery.extend( {
                  type: type,
                  origType: origType,
                  data: data,
                  handler: handler,
                  guid: handler.guid,
                  selector: selector,
                  needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
                  namespace: namespaces.join( "." )
              }, handleObjIn );
  
              // Init the event handler queue if we're the first
              if ( !( handlers = events[ type ] ) ) {
                  handlers = events[ type ] = [];
                  handlers.delegateCount = 0;
  
                  // Only use addEventListener/attachEvent if the special events handler returns false
                  if ( !special.setup ||
                      special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
  
                      // Bind the global event handler to the element
                      if ( elem.addEventListener ) {
                          elem.addEventListener( type, eventHandle, false );
  
                      } else if ( elem.attachEvent ) {
                          elem.attachEvent( "on" + type, eventHandle );
                      }
                  }
              }
  
              if ( special.add ) {
                  special.add.call( elem, handleObj );
  
                  if ( !handleObj.handler.guid ) {
                      handleObj.handler.guid = handler.guid;
                  }
              }
  
              // Add to the element's handler list, delegates in front
              if ( selector ) {
                  handlers.splice( handlers.delegateCount++, 0, handleObj );
              } else {
                  handlers.push( handleObj );
              }
  
              // Keep track of which events have ever been used, for event optimization
              jQuery.event.global[ type ] = true;
          }
  
          // Nullify elem to prevent memory leaks in IE
          elem = null;
      },
  
      // Detach an event or set of events from an element
      remove: function( elem, types, handler, selector, mappedTypes ) {
          var j, handleObj, tmp,
              origCount, t, events,
              special, handlers, type,
              namespaces, origType,
              elemData = jQuery.hasData( elem ) && jQuery._data( elem );
  
          if ( !elemData || !( events = elemData.events ) ) {
              return;
          }
  
          // Once for each type.namespace in types; type may be omitted
          types = ( types || "" ).match( rnotwhite ) || [ "" ];
          t = types.length;
          while ( t-- ) {
              tmp = rtypenamespace.exec( types[ t ] ) || [];
              type = origType = tmp[ 1 ];
              namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
  
              // Unbind all events (on this namespace, if provided) for the element
              if ( !type ) {
                  for ( type in events ) {
                      jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                  }
                  continue;
              }
  
              special = jQuery.event.special[ type ] || {};
              type = ( selector ? special.delegateType : special.bindType ) || type;
              handlers = events[ type ] || [];
              tmp = tmp[ 2 ] &&
                  new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
  
              // Remove matching events
              origCount = j = handlers.length;
              while ( j-- ) {
                  handleObj = handlers[ j ];
  
                  if ( ( mappedTypes || origType === handleObj.origType ) &&
                      ( !handler || handler.guid === handleObj.guid ) &&
                      ( !tmp || tmp.test( handleObj.namespace ) ) &&
                      ( !selector || selector === handleObj.selector ||
                          selector === "**" && handleObj.selector ) ) {
                      handlers.splice( j, 1 );
  
                      if ( handleObj.selector ) {
                          handlers.delegateCount--;
                      }
                      if ( special.remove ) {
                          special.remove.call( elem, handleObj );
                      }
                  }
              }
  
              // Remove generic event handler if we removed something and no more handlers exist
              // (avoids potential for endless recursion during removal of special event handlers)
              if ( origCount && !handlers.length ) {
                  if ( !special.teardown ||
                      special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
  
                      jQuery.removeEvent( elem, type, elemData.handle );
                  }
  
                  delete events[ type ];
              }
          }
  
          // Remove the expando if it's no longer used
          if ( jQuery.isEmptyObject( events ) ) {
              delete elemData.handle;
  
              // removeData also checks for emptiness and clears the expando if empty
              // so use it instead of delete
              jQuery._removeData( elem, "events" );
          }
      },
  
      trigger: function( event, data, elem, onlyHandlers ) {
          var handle, ontype, cur,
              bubbleType, special, tmp, i,
              eventPath = [ elem || document ],
              type = hasOwn.call( event, "type" ) ? event.type : event,
              namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
  
          cur = tmp = elem = elem || document;
  
          // Don't do events on text and comment nodes
          if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
              return;
          }
  
          // focus/blur morphs to focusin/out; ensure we're not firing them right now
          if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
              return;
          }
  
          if ( type.indexOf( "." ) > -1 ) {
  
              // Namespaced trigger; create a regexp to match event type in handle()
              namespaces = type.split( "." );
              type = namespaces.shift();
              namespaces.sort();
          }
          ontype = type.indexOf( ":" ) < 0 && "on" + type;
  
          // Caller can pass in a jQuery.Event object, Object, or just an event type string
          event = event[ jQuery.expando ] ?
              event :
              new jQuery.Event( type, typeof event === "object" && event );
  
          // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
          event.isTrigger = onlyHandlers ? 2 : 3;
          event.namespace = namespaces.join( "." );
          event.rnamespace = event.namespace ?
              new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
              null;
  
          // Clean up the event in case it is being reused
          event.result = undefined;
          if ( !event.target ) {
              event.target = elem;
          }
  
          // Clone any incoming data and prepend the event, creating the handler arg list
          data = data == null ?
              [ event ] :
              jQuery.makeArray( data, [ event ] );
  
          // Allow special events to draw outside the lines
          special = jQuery.event.special[ type ] || {};
          if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
              return;
          }
  
          // Determine event propagation path in advance, per W3C events spec (#9951)
          // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
          if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
  
              bubbleType = special.delegateType || type;
              if ( !rfocusMorph.test( bubbleType + type ) ) {
                  cur = cur.parentNode;
              }
              for ( ; cur; cur = cur.parentNode ) {
                  eventPath.push( cur );
                  tmp = cur;
              }
  
              // Only add window if we got to document (e.g., not plain obj or detached DOM)
              if ( tmp === ( elem.ownerDocument || document ) ) {
                  eventPath.push( tmp.defaultView || tmp.parentWindow || window );
              }
          }
  
          // Fire handlers on the event path
          i = 0;
          while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
  
              event.type = i > 1 ?
                  bubbleType :
                  special.bindType || type;
  
              // jQuery handler
              handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] &&
                  jQuery._data( cur, "handle" );
  
              if ( handle ) {
                  handle.apply( cur, data );
              }
  
              // Native handler
              handle = ontype && cur[ ontype ];
              if ( handle && handle.apply && acceptData( cur ) ) {
                  event.result = handle.apply( cur, data );
                  if ( event.result === false ) {
                      event.preventDefault();
                  }
              }
          }
          event.type = type;
  
          // If nobody prevented the default action, do it now
          if ( !onlyHandlers && !event.isDefaultPrevented() ) {
  
              if (
                  ( !special._default ||
                   special._default.apply( eventPath.pop(), data ) === false
                  ) && acceptData( elem )
              ) {
  
                  // Call a native DOM method on the target with the same name name as the event.
                  // Can't use an .isFunction() check here because IE6/7 fails that test.
                  // Don't do default actions on window, that's where global variables be (#6170)
                  if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {
  
                      // Don't re-trigger an onFOO event when we call its FOO() method
                      tmp = elem[ ontype ];
  
                      if ( tmp ) {
                          elem[ ontype ] = null;
                      }
  
                      // Prevent re-triggering of the same event, since we already bubbled it above
                      jQuery.event.triggered = type;
                      try {
                          elem[ type ]();
                      } catch ( e ) {
  
                          // IE<9 dies on focus/blur to hidden element (#1486,#12518)
                          // only reproducible on winXP IE8 native, not IE9 in IE8 mode
                      }
                      jQuery.event.triggered = undefined;
  
                      if ( tmp ) {
                          elem[ ontype ] = tmp;
                      }
                  }
              }
          }
  
          return event.result;
      },
  
      dispatch: function( event ) {
  
          // Make a writable jQuery.Event from the native event object
          event = jQuery.event.fix( event );
  
          var i, j, ret, matched, handleObj,
              handlerQueue = [],
              args = slice.call( arguments ),
              handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
              special = jQuery.event.special[ event.type ] || {};
  
          // Use the fix-ed jQuery.Event rather than the (read-only) native event
          args[ 0 ] = event;
          event.delegateTarget = this;
  
          // Call the preDispatch hook for the mapped type, and let it bail if desired
          if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
              return;
          }
  
          // Determine handlers
          handlerQueue = jQuery.event.handlers.call( this, event, handlers );
  
          // Run delegates first; they may want to stop propagation beneath us
          i = 0;
          while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
              event.currentTarget = matched.elem;
  
              j = 0;
              while ( ( handleObj = matched.handlers[ j++ ] ) &&
                  !event.isImmediatePropagationStopped() ) {
  
                  // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                  // a subset or equal to those in the bound event (both can have no namespace).
                  if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
  
                      event.handleObj = handleObj;
                      event.data = handleObj.data;
  
                      ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
                          handleObj.handler ).apply( matched.elem, args );
  
                      if ( ret !== undefined ) {
                          if ( ( event.result = ret ) === false ) {
                              event.preventDefault();
                              event.stopPropagation();
                          }
                      }
                  }
              }
          }
  
          // Call the postDispatch hook for the mapped type
          if ( special.postDispatch ) {
              special.postDispatch.call( this, event );
          }
  
          return event.result;
      },
  
      handlers: function( event, handlers ) {
          var i, matches, sel, handleObj,
              handlerQueue = [],
              delegateCount = handlers.delegateCount,
              cur = event.target;
  
          // Support (at least): Chrome, IE9
          // Find delegate handlers
          // Black-hole SVG <use> instance trees (#13180)
          //
          // Support: Firefox<=42+
          // Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
          if ( delegateCount && cur.nodeType &&
              ( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {
  
              /* jshint eqeqeq: false */
              for ( ; cur != this; cur = cur.parentNode || this ) {
                  /* jshint eqeqeq: true */
  
                  // Don't check non-elements (#13208)
                  // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                  if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
                      matches = [];
                      for ( i = 0; i < delegateCount; i++ ) {
                          handleObj = handlers[ i ];
  
                          // Don't conflict with Object.prototype properties (#13203)
                          sel = handleObj.selector + " ";
  
                          if ( matches[ sel ] === undefined ) {
                              matches[ sel ] = handleObj.needsContext ?
                                  jQuery( sel, this ).index( cur ) > -1 :
                                  jQuery.find( sel, this, null, [ cur ] ).length;
                          }
                          if ( matches[ sel ] ) {
                              matches.push( handleObj );
                          }
                      }
                      if ( matches.length ) {
                          handlerQueue.push( { elem: cur, handlers: matches } );
                      }
                  }
              }
          }
  
          // Add the remaining (directly-bound) handlers
          if ( delegateCount < handlers.length ) {
              handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
          }
  
          return handlerQueue;
      },
  
      fix: function( event ) {
          if ( event[ jQuery.expando ] ) {
              return event;
          }
  
          // Create a writable copy of the event object and normalize some properties
          var i, prop, copy,
              type = event.type,
              originalEvent = event,
              fixHook = this.fixHooks[ type ];
  
          if ( !fixHook ) {
              this.fixHooks[ type ] = fixHook =
                  rmouseEvent.test( type ) ? this.mouseHooks :
                  rkeyEvent.test( type ) ? this.keyHooks :
                  {};
          }
          copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
  
          event = new jQuery.Event( originalEvent );
  
          i = copy.length;
          while ( i-- ) {
              prop = copy[ i ];
              event[ prop ] = originalEvent[ prop ];
          }
  
          // Support: IE<9
          // Fix target property (#1925)
          if ( !event.target ) {
              event.target = originalEvent.srcElement || document;
          }
  
          // Support: Safari 6-8+
          // Target should not be a text node (#504, #13143)
          if ( event.target.nodeType === 3 ) {
              event.target = event.target.parentNode;
          }
  
          // Support: IE<9
          // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
          event.metaKey = !!event.metaKey;
  
          return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
      },
  
      // Includes some event props shared by KeyEvent and MouseEvent
      props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
          "metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),
  
      fixHooks: {},
  
      keyHooks: {
          props: "char charCode key keyCode".split( " " ),
          filter: function( event, original ) {
  
              // Add which for key events
              if ( event.which == null ) {
                  event.which = original.charCode != null ? original.charCode : original.keyCode;
              }
  
              return event;
          }
      },
  
      mouseHooks: {
          props: ( "button buttons clientX clientY fromElement offsetX offsetY " +
              "pageX pageY screenX screenY toElement" ).split( " " ),
          filter: function( event, original ) {
              var body, eventDoc, doc,
                  button = original.button,
                  fromElement = original.fromElement;
  
              // Calculate pageX/Y if missing and clientX/Y available
              if ( event.pageX == null && original.clientX != null ) {
                  eventDoc = event.target.ownerDocument || document;
                  doc = eventDoc.documentElement;
                  body = eventDoc.body;
  
                  event.pageX = original.clientX +
                      ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
                      ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                  event.pageY = original.clientY +
                      ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
                      ( doc && doc.clientTop  || body && body.clientTop  || 0 );
              }
  
              // Add relatedTarget, if necessary
              if ( !event.relatedTarget && fromElement ) {
                  event.relatedTarget = fromElement === event.target ?
                      original.toElement :
                      fromElement;
              }
  
              // Add which for click: 1 === left; 2 === middle; 3 === right
              // Note: button is not normalized, so don't use it
              if ( !event.which && button !== undefined ) {
                  event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
              }
  
              return event;
          }
      },
  
      special: {
          load: {
  
              // Prevent triggered image.load events from bubbling to window.load
              noBubble: true
          },
          focus: {
  
              // Fire native event if possible so blur/focus sequence is correct
              trigger: function() {
                  if ( this !== safeActiveElement() && this.focus ) {
                      try {
                          this.focus();
                          return false;
                      } catch ( e ) {
  
                          // Support: IE<9
                          // If we error on focus to hidden element (#1486, #12518),
                          // let .trigger() run the handlers
                      }
                  }
              },
              delegateType: "focusin"
          },
          blur: {
              trigger: function() {
                  if ( this === safeActiveElement() && this.blur ) {
                      this.blur();
                      return false;
                  }
              },
              delegateType: "focusout"
          },
          click: {
  
              // For checkbox, fire native event so checked state will be right
              trigger: function() {
                  if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
                      this.click();
                      return false;
                  }
              },
  
              // For cross-browser consistency, don't fire native .click() on links
              _default: function( event ) {
                  return jQuery.nodeName( event.target, "a" );
              }
          },
  
          beforeunload: {
              postDispatch: function( event ) {
  
                  // Support: Firefox 20+
                  // Firefox doesn't alert if the returnValue field is not set.
                  if ( event.result !== undefined && event.originalEvent ) {
                      event.originalEvent.returnValue = event.result;
                  }
              }
          }
      },
  
      // Piggyback on a donor event to simulate a different one
      simulate: function( type, elem, event ) {
          var e = jQuery.extend(
              new jQuery.Event(),
              event,
              {
                  type: type,
                  isSimulated: true
  
                  // Previously, `originalEvent: {}` was set here, so stopPropagation call
                  // would not be triggered on donor event, since in our own
                  // jQuery.event.stopPropagation function we had a check for existence of
                  // originalEvent.stopPropagation method, so, consequently it would be a noop.
                  //
                  // Guard for simulated events was moved to jQuery.event.stopPropagation function
                  // since `originalEvent` should point to the original event for the
                  // constancy with other events and for more focused logic
              }
          );
  
          jQuery.event.trigger( e, null, elem );
  
          if ( e.isDefaultPrevented() ) {
              event.preventDefault();
          }
      }
  };
  
  jQuery.removeEvent = document.removeEventListener ?
      function( elem, type, handle ) {
  
          // This "if" is needed for plain objects
          if ( elem.removeEventListener ) {
              elem.removeEventListener( type, handle );
          }
      } :
      function( elem, type, handle ) {
          var name = "on" + type;
  
          if ( elem.detachEvent ) {
  
              // #8545, #7054, preventing memory leaks for custom events in IE6-8
              // detachEvent needed property on element, by name of that event,
              // to properly expose it to GC
              if ( typeof elem[ name ] === "undefined" ) {
                  elem[ name ] = null;
              }
  
              elem.detachEvent( name, handle );
          }
      };
  
  jQuery.Event = function( src, props ) {
  
      // Allow instantiation without the 'new' keyword
      if ( !( this instanceof jQuery.Event ) ) {
          return new jQuery.Event( src, props );
      }
  
      // Event object
      if ( src && src.type ) {
          this.originalEvent = src;
          this.type = src.type;
  
          // Events bubbling up the document may have been marked as prevented
          // by a handler lower down the tree; reflect the correct value.
          this.isDefaultPrevented = src.defaultPrevented ||
                  src.defaultPrevented === undefined &&
  
                  // Support: IE < 9, Android < 4.0
                  src.returnValue === false ?
              returnTrue :
              returnFalse;
  
      // Event type
      } else {
          this.type = src;
      }
  
      // Put explicitly provided properties onto the event object
      if ( props ) {
          jQuery.extend( this, props );
      }
  
      // Create a timestamp if incoming event doesn't have one
      this.timeStamp = src && src.timeStamp || jQuery.now();
  
      // Mark it as fixed
      this[ jQuery.expando ] = true;
  };
  
  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  jQuery.Event.prototype = {
      constructor: jQuery.Event,
      isDefaultPrevented: returnFalse,
      isPropagationStopped: returnFalse,
      isImmediatePropagationStopped: returnFalse,
  
      preventDefault: function() {
          var e = this.originalEvent;
  
          this.isDefaultPrevented = returnTrue;
          if ( !e ) {
              return;
          }
  
          // If preventDefault exists, run it on the original event
          if ( e.preventDefault ) {
              e.preventDefault();
  
          // Support: IE
          // Otherwise set the returnValue property of the original event to false
          } else {
              e.returnValue = false;
          }
      },
      stopPropagation: function() {
          var e = this.originalEvent;
  
          this.isPropagationStopped = returnTrue;
  
          if ( !e || this.isSimulated ) {
              return;
          }
  
          // If stopPropagation exists, run it on the original event
          if ( e.stopPropagation ) {
              e.stopPropagation();
          }
  
          // Support: IE
          // Set the cancelBubble property of the original event to true
          e.cancelBubble = true;
      },
      stopImmediatePropagation: function() {
          var e = this.originalEvent;
  
          this.isImmediatePropagationStopped = returnTrue;
  
          if ( e && e.stopImmediatePropagation ) {
              e.stopImmediatePropagation();
          }
  
          this.stopPropagation();
      }
  };
  
  // Create mouseenter/leave events using mouseover/out and event-time checks
  // so that event delegation works in jQuery.
  // Do the same for pointerenter/pointerleave and pointerover/pointerout
  //
  // Support: Safari 7 only
  // Safari sends mouseenter too often; see:
  // https://code.google.com/p/chromium/issues/detail?id=470258
  // for the description of the bug (it existed in older Chrome versions as well).
  jQuery.each( {
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout"
  }, function( orig, fix ) {
      jQuery.event.special[ orig ] = {
          delegateType: fix,
          bindType: fix,
  
          handle: function( event ) {
              var ret,
                  target = this,
                  related = event.relatedTarget,
                  handleObj = event.handleObj;
  
              // For mouseenter/leave call the handler if related is outside the target.
              // NB: No relatedTarget if the mouse left/entered the browser window
              if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
                  event.type = handleObj.origType;
                  ret = handleObj.handler.apply( this, arguments );
                  event.type = fix;
              }
              return ret;
          }
      };
  } );
  
  // IE submit delegation
  if ( !support.submit ) {
  
      jQuery.event.special.submit = {
          setup: function() {
  
              // Only need this for delegated form submit events
              if ( jQuery.nodeName( this, "form" ) ) {
                  return false;
              }
  
              // Lazy-add a submit handler when a descendant form may potentially be submitted
              jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
  
                  // Node name check avoids a VML-related crash in IE (#9807)
                  var elem = e.target,
                      form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ?
  
                          // Support: IE <=8
                          // We use jQuery.prop instead of elem.form
                          // to allow fixing the IE8 delegated submit issue (gh-2332)
                          // by 3rd party polyfills/workarounds.
                          jQuery.prop( elem, "form" ) :
                          undefined;
  
                  if ( form && !jQuery._data( form, "submit" ) ) {
                      jQuery.event.add( form, "submit._submit", function( event ) {
                          event._submitBubble = true;
                      } );
                      jQuery._data( form, "submit", true );
                  }
              } );
  
              // return undefined since we don't need an event listener
          },
  
          postDispatch: function( event ) {
  
              // If form was submitted by the user, bubble the event up the tree
              if ( event._submitBubble ) {
                  delete event._submitBubble;
                  if ( this.parentNode && !event.isTrigger ) {
                      jQuery.event.simulate( "submit", this.parentNode, event );
                  }
              }
          },
  
          teardown: function() {
  
              // Only need this for delegated form submit events
              if ( jQuery.nodeName( this, "form" ) ) {
                  return false;
              }
  
              // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
              jQuery.event.remove( this, "._submit" );
          }
      };
  }
  
  // IE change delegation and checkbox/radio fix
  if ( !support.change ) {
  
      jQuery.event.special.change = {
  
          setup: function() {
  
              if ( rformElems.test( this.nodeName ) ) {
  
                  // IE doesn't fire change on a check/radio until blur; trigger it on click
                  // after a propertychange. Eat the blur-change in special.change.handle.
                  // This still fires onchange a second time for check/radio after blur.
                  if ( this.type === "checkbox" || this.type === "radio" ) {
                      jQuery.event.add( this, "propertychange._change", function( event ) {
                          if ( event.originalEvent.propertyName === "checked" ) {
                              this._justChanged = true;
                          }
                      } );
                      jQuery.event.add( this, "click._change", function( event ) {
                          if ( this._justChanged && !event.isTrigger ) {
                              this._justChanged = false;
                          }
  
                          // Allow triggered, simulated change events (#11500)
                          jQuery.event.simulate( "change", this, event );
                      } );
                  }
                  return false;
              }
  
              // Delegated event; lazy-add a change handler on descendant inputs
              jQuery.event.add( this, "beforeactivate._change", function( e ) {
                  var elem = e.target;
  
                  if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "change" ) ) {
                      jQuery.event.add( elem, "change._change", function( event ) {
                          if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
                              jQuery.event.simulate( "change", this.parentNode, event );
                          }
                      } );
                      jQuery._data( elem, "change", true );
                  }
              } );
          },
  
          handle: function( event ) {
              var elem = event.target;
  
              // Swallow native change events from checkbox/radio, we already triggered them above
              if ( this !== elem || event.isSimulated || event.isTrigger ||
                  ( elem.type !== "radio" && elem.type !== "checkbox" ) ) {
  
                  return event.handleObj.handler.apply( this, arguments );
              }
          },
  
          teardown: function() {
              jQuery.event.remove( this, "._change" );
  
              return !rformElems.test( this.nodeName );
          }
      };
  }
  
  // Support: Firefox
  // Firefox doesn't have focus(in | out) events
  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  //
  // Support: Chrome, Safari
  // focus(in | out) events fire after focus & blur events,
  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  // Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
  if ( !support.focusin ) {
      jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
  
          // Attach a single capturing handler on the document while someone wants focusin/focusout
          var handler = function( event ) {
              jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
          };
  
          jQuery.event.special[ fix ] = {
              setup: function() {
                  var doc = this.ownerDocument || this,
                      attaches = jQuery._data( doc, fix );
  
                  if ( !attaches ) {
                      doc.addEventListener( orig, handler, true );
                  }
                  jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
              },
              teardown: function() {
                  var doc = this.ownerDocument || this,
                      attaches = jQuery._data( doc, fix ) - 1;
  
                  if ( !attaches ) {
                      doc.removeEventListener( orig, handler, true );
                      jQuery._removeData( doc, fix );
                  } else {
                      jQuery._data( doc, fix, attaches );
                  }
              }
          };
      } );
  }
  
  jQuery.fn.extend( {
  
      on: function( types, selector, data, fn ) {
          return on( this, types, selector, data, fn );
      },
      one: function( types, selector, data, fn ) {
          return on( this, types, selector, data, fn, 1 );
      },
      off: function( types, selector, fn ) {
          var handleObj, type;
          if ( types && types.preventDefault && types.handleObj ) {
  
              // ( event )  dispatched jQuery.Event
              handleObj = types.handleObj;
              jQuery( types.delegateTarget ).off(
                  handleObj.namespace ?
                      handleObj.origType + "." + handleObj.namespace :
                      handleObj.origType,
                  handleObj.selector,
                  handleObj.handler
              );
              return this;
          }
          if ( typeof types === "object" ) {
  
              // ( types-object [, selector] )
              for ( type in types ) {
                  this.off( type, selector, types[ type ] );
              }
              return this;
          }
          if ( selector === false || typeof selector === "function" ) {
  
              // ( types [, fn] )
              fn = selector;
              selector = undefined;
          }
          if ( fn === false ) {
              fn = returnFalse;
          }
          return this.each( function() {
              jQuery.event.remove( this, types, fn, selector );
          } );
      },
  
      trigger: function( type, data ) {
          return this.each( function() {
              jQuery.event.trigger( type, data, this );
          } );
      },
      triggerHandler: function( type, data ) {
          var elem = this[ 0 ];
          if ( elem ) {
              return jQuery.event.trigger( type, data, elem, true );
          }
      }
  } );
  
  
  var rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
      rnoshimcache = new RegExp( "<(?:" + nodeNames + ")[\\s/>]", "i" ),
      rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
  
      // Support: IE 10-11, Edge 10240+
      // In IE/Edge using regex groups here causes severe slowdowns.
      // See https://connect.microsoft.com/IE/feedback/details/1736512/
      rnoInnerhtml = /<script|<style|<link/i,
  
      // checked="checked" or checked
      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rscriptTypeMasked = /^true\/(.*)/,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
      safeFragment = createSafeFragment( document ),
      fragmentDiv = safeFragment.appendChild( document.createElement( "div" ) );
  
  // Support: IE<8
  // Manipulating tables requires a tbody
  function manipulationTarget( elem, content ) {
      return jQuery.nodeName( elem, "table" ) &&
          jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?
  
          elem.getElementsByTagName( "tbody" )[ 0 ] ||
              elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
          elem;
  }
  
  // Replace/restore the type attribute of script elements for safe DOM manipulation
  function disableScript( elem ) {
      elem.type = ( jQuery.find.attr( elem, "type" ) !== null ) + "/" + elem.type;
      return elem;
  }
  function restoreScript( elem ) {
      var match = rscriptTypeMasked.exec( elem.type );
      if ( match ) {
          elem.type = match[ 1 ];
      } else {
          elem.removeAttribute( "type" );
      }
      return elem;
  }
  
  function cloneCopyEvent( src, dest ) {
      if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
          return;
      }
  
      var type, i, l,
          oldData = jQuery._data( src ),
          curData = jQuery._data( dest, oldData ),
          events = oldData.events;
  
      if ( events ) {
          delete curData.handle;
          curData.events = {};
  
          for ( type in events ) {
              for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                  jQuery.event.add( dest, type, events[ type ][ i ] );
              }
          }
      }
  
      // make the cloned public data object a copy from the original
      if ( curData.data ) {
          curData.data = jQuery.extend( {}, curData.data );
      }
  }
  
  function fixCloneNodeIssues( src, dest ) {
      var nodeName, e, data;
  
      // We do not need to do anything for non-Elements
      if ( dest.nodeType !== 1 ) {
          return;
      }
  
      nodeName = dest.nodeName.toLowerCase();
  
      // IE6-8 copies events bound via attachEvent when using cloneNode.
      if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
          data = jQuery._data( dest );
  
          for ( e in data.events ) {
              jQuery.removeEvent( dest, e, data.handle );
          }
  
          // Event data gets referenced instead of copied if the expando gets copied too
          dest.removeAttribute( jQuery.expando );
      }
  
      // IE blanks contents when cloning scripts, and tries to evaluate newly-set text
      if ( nodeName === "script" && dest.text !== src.text ) {
          disableScript( dest ).text = src.text;
          restoreScript( dest );
  
      // IE6-10 improperly clones children of object elements using classid.
      // IE10 throws NoModificationAllowedError if parent is null, #12132.
      } else if ( nodeName === "object" ) {
          if ( dest.parentNode ) {
              dest.outerHTML = src.outerHTML;
          }
  
          // This path appears unavoidable for IE9. When cloning an object
          // element in IE9, the outerHTML strategy above is not sufficient.
          // If the src has innerHTML and the destination does not,
          // copy the src.innerHTML into the dest.innerHTML. #10324
          if ( support.html5Clone && ( src.innerHTML && !jQuery.trim( dest.innerHTML ) ) ) {
              dest.innerHTML = src.innerHTML;
          }
  
      } else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
  
          // IE6-8 fails to persist the checked state of a cloned checkbox
          // or radio button. Worse, IE6-7 fail to give the cloned element
          // a checked appearance if the defaultChecked value isn't also set
  
          dest.defaultChecked = dest.checked = src.checked;
  
          // IE6-7 get confused and end up setting the value of a cloned
          // checkbox/radio button to an empty string instead of "on"
          if ( dest.value !== src.value ) {
              dest.value = src.value;
          }
  
      // IE6-8 fails to return the selected option to the default selected
      // state when cloning options
      } else if ( nodeName === "option" ) {
          dest.defaultSelected = dest.selected = src.defaultSelected;
  
      // IE6-8 fails to set the defaultValue to the correct value when
      // cloning other types of input fields
      } else if ( nodeName === "input" || nodeName === "textarea" ) {
          dest.defaultValue = src.defaultValue;
      }
  }
  
  function domManip( collection, args, callback, ignored ) {
  
      // Flatten any nested arrays
      args = concat.apply( [], args );
  
      var first, node, hasScripts,
          scripts, doc, fragment,
          i = 0,
          l = collection.length,
          iNoClone = l - 1,
          value = args[ 0 ],
          isFunction = jQuery.isFunction( value );
  
      // We can't cloneNode fragments that contain checked, in WebKit
      if ( isFunction ||
              ( l > 1 && typeof value === "string" &&
                  !support.checkClone && rchecked.test( value ) ) ) {
          return collection.each( function( index ) {
              var self = collection.eq( index );
              if ( isFunction ) {
                  args[ 0 ] = value.call( this, index, self.html() );
              }
              domManip( self, args, callback, ignored );
          } );
      }
  
      if ( l ) {
          fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
          first = fragment.firstChild;
  
          if ( fragment.childNodes.length === 1 ) {
              fragment = first;
          }
  
          // Require either new content or an interest in ignored elements to invoke the callback
          if ( first || ignored ) {
              scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
              hasScripts = scripts.length;
  
              // Use the original fragment for the last item
              // instead of the first because it can end up
              // being emptied incorrectly in certain situations (#8070).
              for ( ; i < l; i++ ) {
                  node = fragment;
  
                  if ( i !== iNoClone ) {
                      node = jQuery.clone( node, true, true );
  
                      // Keep references to cloned scripts for later restoration
                      if ( hasScripts ) {
  
                          // Support: Android<4.1, PhantomJS<2
                          // push.apply(_, arraylike) throws on ancient WebKit
                          jQuery.merge( scripts, getAll( node, "script" ) );
                      }
                  }
  
                  callback.call( collection[ i ], node, i );
              }
  
              if ( hasScripts ) {
                  doc = scripts[ scripts.length - 1 ].ownerDocument;
  
                  // Reenable scripts
                  jQuery.map( scripts, restoreScript );
  
                  // Evaluate executable scripts on first document insertion
                  for ( i = 0; i < hasScripts; i++ ) {
                      node = scripts[ i ];
                      if ( rscriptType.test( node.type || "" ) &&
                          !jQuery._data( node, "globalEval" ) &&
                          jQuery.contains( doc, node ) ) {
  
                          if ( node.src ) {
  
                              // Optional AJAX dependency, but won't run scripts if not present
                              if ( jQuery._evalUrl ) {
                                  jQuery._evalUrl( node.src );
                              }
                          } else {
                              jQuery.globalEval(
                                  ( node.text || node.textContent || node.innerHTML || "" )
                                      .replace( rcleanScript, "" )
                              );
                          }
                      }
                  }
              }
  
              // Fix #11809: Avoid leaking memory
              fragment = first = null;
          }
      }
  
      return collection;
  }
  
  function remove( elem, selector, keepData ) {
      var node,
          elems = selector ? jQuery.filter( selector, elem ) : elem,
          i = 0;
  
      for ( ; ( node = elems[ i ] ) != null; i++ ) {
  
          if ( !keepData && node.nodeType === 1 ) {
              jQuery.cleanData( getAll( node ) );
          }
  
          if ( node.parentNode ) {
              if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
                  setGlobalEval( getAll( node, "script" ) );
              }
              node.parentNode.removeChild( node );
          }
      }
  
      return elem;
  }
  
  jQuery.extend( {
      htmlPrefilter: function( html ) {
          return html.replace( rxhtmlTag, "<$1></$2>" );
      },
  
      clone: function( elem, dataAndEvents, deepDataAndEvents ) {
          var destElements, node, clone, i, srcElements,
              inPage = jQuery.contains( elem.ownerDocument, elem );
  
          if ( support.html5Clone || jQuery.isXMLDoc( elem ) ||
              !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
  
              clone = elem.cloneNode( true );
  
          // IE<=8 does not properly clone detached, unknown element nodes
          } else {
              fragmentDiv.innerHTML = elem.outerHTML;
              fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
          }
  
          if ( ( !support.noCloneEvent || !support.noCloneChecked ) &&
                  ( elem.nodeType === 1 || elem.nodeType === 11 ) && !jQuery.isXMLDoc( elem ) ) {
  
              // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
              destElements = getAll( clone );
              srcElements = getAll( elem );
  
              // Fix all IE cloning issues
              for ( i = 0; ( node = srcElements[ i ] ) != null; ++i ) {
  
                  // Ensure that the destination node is not null; Fixes #9587
                  if ( destElements[ i ] ) {
                      fixCloneNodeIssues( node, destElements[ i ] );
                  }
              }
          }
  
          // Copy the events from the original to the clone
          if ( dataAndEvents ) {
              if ( deepDataAndEvents ) {
                  srcElements = srcElements || getAll( elem );
                  destElements = destElements || getAll( clone );
  
                  for ( i = 0; ( node = srcElements[ i ] ) != null; i++ ) {
                      cloneCopyEvent( node, destElements[ i ] );
                  }
              } else {
                  cloneCopyEvent( elem, clone );
              }
          }
  
          // Preserve script evaluation history
          destElements = getAll( clone, "script" );
          if ( destElements.length > 0 ) {
              setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
          }
  
          destElements = srcElements = node = null;
  
          // Return the cloned set
          return clone;
      },
  
      cleanData: function( elems, /* internal */ forceAcceptData ) {
          var elem, type, id, data,
              i = 0,
              internalKey = jQuery.expando,
              cache = jQuery.cache,
              attributes = support.attributes,
              special = jQuery.event.special;
  
          for ( ; ( elem = elems[ i ] ) != null; i++ ) {
              if ( forceAcceptData || acceptData( elem ) ) {
  
                  id = elem[ internalKey ];
                  data = id && cache[ id ];
  
                  if ( data ) {
                      if ( data.events ) {
                          for ( type in data.events ) {
                              if ( special[ type ] ) {
                                  jQuery.event.remove( elem, type );
  
                              // This is a shortcut to avoid jQuery.event.remove's overhead
                              } else {
                                  jQuery.removeEvent( elem, type, data.handle );
                              }
                          }
                      }
  
                      // Remove cache only if it was not already removed by jQuery.event.remove
                      if ( cache[ id ] ) {
  
                          delete cache[ id ];
  
                          // Support: IE<9
                          // IE does not allow us to delete expando properties from nodes
                          // IE creates expando attributes along with the property
                          // IE does not have a removeAttribute function on Document nodes
                          if ( !attributes && typeof elem.removeAttribute !== "undefined" ) {
                              elem.removeAttribute( internalKey );
  
                          // Webkit & Blink performance suffers when deleting properties
                          // from DOM nodes, so set to undefined instead
                          // https://code.google.com/p/chromium/issues/detail?id=378607
                          } else {
                              elem[ internalKey ] = undefined;
                          }
  
                          deletedIds.push( id );
                      }
                  }
              }
          }
      }
  } );
  
  jQuery.fn.extend( {
  
      // Keep domManip exposed until 3.0 (gh-2225)
      domManip: domManip,
  
      detach: function( selector ) {
          return remove( this, selector, true );
      },
  
      remove: function( selector ) {
          return remove( this, selector );
      },
  
      text: function( value ) {
          return access( this, function( value ) {
              return value === undefined ?
                  jQuery.text( this ) :
                  this.empty().append(
                      ( this[ 0 ] && this[ 0 ].ownerDocument || document ).createTextNode( value )
                  );
          }, null, value, arguments.length );
      },
  
      append: function() {
          return domManip( this, arguments, function( elem ) {
              if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                  var target = manipulationTarget( this, elem );
                  target.appendChild( elem );
              }
          } );
      },
  
      prepend: function() {
          return domManip( this, arguments, function( elem ) {
              if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                  var target = manipulationTarget( this, elem );
                  target.insertBefore( elem, target.firstChild );
              }
          } );
      },
  
      before: function() {
          return domManip( this, arguments, function( elem ) {
              if ( this.parentNode ) {
                  this.parentNode.insertBefore( elem, this );
              }
          } );
      },
  
      after: function() {
          return domManip( this, arguments, function( elem ) {
              if ( this.parentNode ) {
                  this.parentNode.insertBefore( elem, this.nextSibling );
              }
          } );
      },
  
      empty: function() {
          var elem,
              i = 0;
  
          for ( ; ( elem = this[ i ] ) != null; i++ ) {
  
              // Remove element nodes and prevent memory leaks
              if ( elem.nodeType === 1 ) {
                  jQuery.cleanData( getAll( elem, false ) );
              }
  
              // Remove any remaining nodes
              while ( elem.firstChild ) {
                  elem.removeChild( elem.firstChild );
              }
  
              // If this is a select, ensure that it displays empty (#12336)
              // Support: IE<9
              if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
                  elem.options.length = 0;
              }
          }
  
          return this;
      },
  
      clone: function( dataAndEvents, deepDataAndEvents ) {
          dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
          deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
  
          return this.map( function() {
              return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
          } );
      },
  
      html: function( value ) {
          return access( this, function( value ) {
              var elem = this[ 0 ] || {},
                  i = 0,
                  l = this.length;
  
              if ( value === undefined ) {
                  return elem.nodeType === 1 ?
                      elem.innerHTML.replace( rinlinejQuery, "" ) :
                      undefined;
              }
  
              // See if we can take a shortcut and just use innerHTML
              if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
                  ( support.htmlSerialize || !rnoshimcache.test( value )  ) &&
                  ( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
                  !wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
  
                  value = jQuery.htmlPrefilter( value );
  
                  try {
                      for ( ; i < l; i++ ) {
  
                          // Remove element nodes and prevent memory leaks
                          elem = this[ i ] || {};
                          if ( elem.nodeType === 1 ) {
                              jQuery.cleanData( getAll( elem, false ) );
                              elem.innerHTML = value;
                          }
                      }
  
                      elem = 0;
  
                  // If using innerHTML throws an exception, use the fallback method
                  } catch ( e ) {}
              }
  
              if ( elem ) {
                  this.empty().append( value );
              }
          }, null, value, arguments.length );
      },
  
      replaceWith: function() {
          var ignored = [];
  
          // Make the changes, replacing each non-ignored context element with the new content
          return domManip( this, arguments, function( elem ) {
              var parent = this.parentNode;
  
              if ( jQuery.inArray( this, ignored ) < 0 ) {
                  jQuery.cleanData( getAll( this ) );
                  if ( parent ) {
                      parent.replaceChild( elem, this );
                  }
              }
  
          // Force callback invocation
          }, ignored );
      }
  } );
  
  jQuery.each( {
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith"
  }, function( name, original ) {
      jQuery.fn[ name ] = function( selector ) {
          var elems,
              i = 0,
              ret = [],
              insert = jQuery( selector ),
              last = insert.length - 1;
  
          for ( ; i <= last; i++ ) {
              elems = i === last ? this : this.clone( true );
              jQuery( insert[ i ] )[ original ]( elems );
  
              // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
              push.apply( ret, elems.get() );
          }
  
          return this.pushStack( ret );
      };
  } );
  
  
  var iframe,
      elemdisplay = {
  
          // Support: Firefox
          // We have to pre-define these values for FF (#10227)
          HTML: "block",
          BODY: "block"
      };
  
  /**
   * Retrieve the actual display of a element
   * @param {String} name nodeName of the element
   * @param {Object} doc Document object
   */
  
  // Called only from within defaultDisplay
  function actualDisplay( name, doc ) {
      var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
  
          display = jQuery.css( elem[ 0 ], "display" );
  
      // We don't have any data stored on the element,
      // so use "detach" method as fast way to get rid of the element
      elem.detach();
  
      return display;
  }
  
  /**
   * Try to determine the default display value of an element
   * @param {String} nodeName
   */
  function defaultDisplay( nodeName ) {
      var doc = document,
          display = elemdisplay[ nodeName ];
  
      if ( !display ) {
          display = actualDisplay( nodeName, doc );
  
          // If the simple way fails, read from inside an iframe
          if ( display === "none" || !display ) {
  
              // Use the already-created iframe if possible
              iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
                  .appendTo( doc.documentElement );
  
              // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
              doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;
  
              // Support: IE
              doc.write();
              doc.close();
  
              display = actualDisplay( nodeName, doc );
              iframe.detach();
          }
  
          // Store the correct default display
          elemdisplay[ nodeName ] = display;
      }
  
      return display;
  }
  var rmargin = ( /^margin/ );
  
  var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
  
  var swap = function( elem, options, callback, args ) {
      var ret, name,
          old = {};
  
      // Remember the old values, and insert the new ones
      for ( name in options ) {
          old[ name ] = elem.style[ name ];
          elem.style[ name ] = options[ name ];
      }
  
      ret = callback.apply( elem, args || [] );
  
      // Revert the old values
      for ( name in options ) {
          elem.style[ name ] = old[ name ];
      }
  
      return ret;
  };
  
  
  var documentElement = document.documentElement;
  
  
  
  ( function() {
      var pixelPositionVal, pixelMarginRightVal, boxSizingReliableVal,
          reliableHiddenOffsetsVal, reliableMarginRightVal, reliableMarginLeftVal,
          container = document.createElement( "div" ),
          div = document.createElement( "div" );
  
      // Finish early in limited (non-browser) environments
      if ( !div.style ) {
          return;
      }
  
      div.style.cssText = "float:left;opacity:.5";
  
      // Support: IE<9
      // Make sure that element opacity exists (as opposed to filter)
      support.opacity = div.style.opacity === "0.5";
  
      // Verify style float existence
      // (IE uses styleFloat instead of cssFloat)
      support.cssFloat = !!div.style.cssFloat;
  
      div.style.backgroundClip = "content-box";
      div.cloneNode( true ).style.backgroundClip = "";
      support.clearCloneStyle = div.style.backgroundClip === "content-box";
  
      container = document.createElement( "div" );
      container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
          "padding:0;margin-top:1px;position:absolute";
      div.innerHTML = "";
      container.appendChild( div );
  
      // Support: Firefox<29, Android 2.3
      // Vendor-prefix box-sizing
      support.boxSizing = div.style.boxSizing === "" || div.style.MozBoxSizing === "" ||
          div.style.WebkitBoxSizing === "";
  
      jQuery.extend( support, {
          reliableHiddenOffsets: function() {
              if ( pixelPositionVal == null ) {
                  computeStyleTests();
              }
              return reliableHiddenOffsetsVal;
          },
  
          boxSizingReliable: function() {
  
              // We're checking for pixelPositionVal here instead of boxSizingReliableVal
              // since that compresses better and they're computed together anyway.
              if ( pixelPositionVal == null ) {
                  computeStyleTests();
              }
              return boxSizingReliableVal;
          },
  
          pixelMarginRight: function() {
  
              // Support: Android 4.0-4.3
              if ( pixelPositionVal == null ) {
                  computeStyleTests();
              }
              return pixelMarginRightVal;
          },
  
          pixelPosition: function() {
              if ( pixelPositionVal == null ) {
                  computeStyleTests();
              }
              return pixelPositionVal;
          },
  
          reliableMarginRight: function() {
  
              // Support: Android 2.3
              if ( pixelPositionVal == null ) {
                  computeStyleTests();
              }
              return reliableMarginRightVal;
          },
  
          reliableMarginLeft: function() {
  
              // Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
              if ( pixelPositionVal == null ) {
                  computeStyleTests();
              }
              return reliableMarginLeftVal;
          }
      } );
  
      function computeStyleTests() {
          var contents, divStyle,
              documentElement = document.documentElement;
  
          // Setup
          documentElement.appendChild( container );
  
          div.style.cssText =
  
              // Support: Android 2.3
              // Vendor-prefix box-sizing
              "-webkit-box-sizing:border-box;box-sizing:border-box;" +
              "position:relative;display:block;" +
              "margin:auto;border:1px;padding:1px;" +
              "top:1%;width:50%";
  
          // Support: IE<9
          // Assume reasonable values in the absence of getComputedStyle
          pixelPositionVal = boxSizingReliableVal = reliableMarginLeftVal = false;
          pixelMarginRightVal = reliableMarginRightVal = true;
  
          // Check for getComputedStyle so that this code is not run in IE<9.
          if ( window.getComputedStyle ) {
              divStyle = window.getComputedStyle( div );
              pixelPositionVal = ( divStyle || {} ).top !== "1%";
              reliableMarginLeftVal = ( divStyle || {} ).marginLeft === "2px";
              boxSizingReliableVal = ( divStyle || { width: "4px" } ).width === "4px";
  
              // Support: Android 4.0 - 4.3 only
              // Some styles come back with percentage values, even though they shouldn't
              div.style.marginRight = "50%";
              pixelMarginRightVal = ( divStyle || { marginRight: "4px" } ).marginRight === "4px";
  
              // Support: Android 2.3 only
              // Div with explicit width and no margin-right incorrectly
              // gets computed margin-right based on width of container (#3333)
              // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
              contents = div.appendChild( document.createElement( "div" ) );
  
              // Reset CSS: box-sizing; display; margin; border; padding
              contents.style.cssText = div.style.cssText =
  
                  // Support: Android 2.3
                  // Vendor-prefix box-sizing
                  "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                  "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
              contents.style.marginRight = contents.style.width = "0";
              div.style.width = "1px";
  
              reliableMarginRightVal =
                  !parseFloat( ( window.getComputedStyle( contents ) || {} ).marginRight );
  
              div.removeChild( contents );
          }
  
          // Support: IE6-8
          // First check that getClientRects works as expected
          // Check if table cells still have offsetWidth/Height when they are set
          // to display:none and there are still other visible table cells in a
          // table row; if so, offsetWidth/Height are not reliable for use when
          // determining if an element has been hidden directly using
          // display:none (it is still safe to use offsets if a parent element is
          // hidden; don safety goggles and see bug #4512 for more information).
          div.style.display = "none";
          reliableHiddenOffsetsVal = div.getClientRects().length === 0;
          if ( reliableHiddenOffsetsVal ) {
              div.style.display = "";
              div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
              div.childNodes[ 0 ].style.borderCollapse = "separate";
              contents = div.getElementsByTagName( "td" );
              contents[ 0 ].style.cssText = "margin:0;border:0;padding:0;display:none";
              reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
              if ( reliableHiddenOffsetsVal ) {
                  contents[ 0 ].style.display = "";
                  contents[ 1 ].style.display = "none";
                  reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
              }
          }
  
          // Teardown
          documentElement.removeChild( container );
      }
  
  } )();
  
  
  var getStyles, curCSS,
      rposition = /^(top|right|bottom|left)$/;
  
  if ( window.getComputedStyle ) {
      getStyles = function( elem ) {
  
          // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
          // IE throws on elements created in popups
          // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
          var view = elem.ownerDocument.defaultView;
  
          if ( !view || !view.opener ) {
              view = window;
          }
  
          return view.getComputedStyle( elem );
      };
  
      curCSS = function( elem, name, computed ) {
          var width, minWidth, maxWidth, ret,
              style = elem.style;
  
          computed = computed || getStyles( elem );
  
          // getPropertyValue is only needed for .css('filter') in IE9, see #12537
          ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;
  
          // Support: Opera 12.1x only
          // Fall back to style even without computed
          // computed is undefined for elems on document fragments
          if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
              ret = jQuery.style( elem, name );
          }
  
          if ( computed ) {
  
              // A tribute to the "awesome hack by Dean Edwards"
              // Chrome < 17 and Safari 5.0 uses "computed value"
              // instead of "used value" for margin-right
              // Safari 5.1.7 (at least) returns percentage for a larger set of values,
              // but width seems to be reliably pixels
              // this is against the CSSOM draft spec:
              // http://dev.w3.org/csswg/cssom/#resolved-values
              if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {
  
                  // Remember the original values
                  width = style.width;
                  minWidth = style.minWidth;
                  maxWidth = style.maxWidth;
  
                  // Put in the new values to get a computed value out
                  style.minWidth = style.maxWidth = style.width = ret;
                  ret = computed.width;
  
                  // Revert the changed values
                  style.width = width;
                  style.minWidth = minWidth;
                  style.maxWidth = maxWidth;
              }
          }
  
          // Support: IE
          // IE returns zIndex value as an integer.
          return ret === undefined ?
              ret :
              ret + "";
      };
  } else if ( documentElement.currentStyle ) {
      getStyles = function( elem ) {
          return elem.currentStyle;
      };
  
      curCSS = function( elem, name, computed ) {
          var left, rs, rsLeft, ret,
              style = elem.style;
  
          computed = computed || getStyles( elem );
          ret = computed ? computed[ name ] : undefined;
  
          // Avoid setting ret to empty string here
          // so we don't default to auto
          if ( ret == null && style && style[ name ] ) {
              ret = style[ name ];
          }
  
          // From the awesome hack by Dean Edwards
          // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
  
          // If we're not dealing with a regular pixel number
          // but a number that has a weird ending, we need to convert it to pixels
          // but not position css attributes, as those are
          // proportional to the parent element instead
          // and we can't measure the parent instead because it
          // might trigger a "stacking dolls" problem
          if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {
  
              // Remember the original values
              left = style.left;
              rs = elem.runtimeStyle;
              rsLeft = rs && rs.left;
  
              // Put in the new values to get a computed value out
              if ( rsLeft ) {
                  rs.left = elem.currentStyle.left;
              }
              style.left = name === "fontSize" ? "1em" : ret;
              ret = style.pixelLeft + "px";
  
              // Revert the changed values
              style.left = left;
              if ( rsLeft ) {
                  rs.left = rsLeft;
              }
          }
  
          // Support: IE
          // IE returns zIndex value as an integer.
          return ret === undefined ?
              ret :
              ret + "" || "auto";
      };
  }
  
  
  
  
  function addGetHookIf( conditionFn, hookFn ) {
  
      // Define the hook, we'll check on the first run if it's really needed.
      return {
          get: function() {
              if ( conditionFn() ) {
  
                  // Hook not needed (or it's not possible to use it due
                  // to missing dependency), remove it.
                  delete this.get;
                  return;
              }
  
              // Hook needed; redefine it so that the support test is not executed again.
              return ( this.get = hookFn ).apply( this, arguments );
          }
      };
  }
  
  
  var
  
          ralpha = /alpha\([^)]*\)/i,
      ropacity = /opacity\s*=\s*([^)]*)/i,
  
      // swappable if display is none or starts with table except
      // "table", "table-cell", or "table-caption"
      // see here for display values:
      // https://developer.mozilla.org/en-US/docs/CSS/display
      rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
  
      cssShow = { position: "absolute", visibility: "hidden", display: "block" },
      cssNormalTransform = {
          letterSpacing: "0",
          fontWeight: "400"
      },
  
      cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
      emptyStyle = document.createElement( "div" ).style;
  
  
  // return a css property mapped to a potentially vendor prefixed property
  function vendorPropName( name ) {
  
      // shortcut for names that are not vendor prefixed
      if ( name in emptyStyle ) {
          return name;
      }
  
      // check for vendor prefixed names
      var capName = name.charAt( 0 ).toUpperCase() + name.slice( 1 ),
          i = cssPrefixes.length;
  
      while ( i-- ) {
          name = cssPrefixes[ i ] + capName;
          if ( name in emptyStyle ) {
              return name;
          }
      }
  }
  
  function showHide( elements, show ) {
      var display, elem, hidden,
          values = [],
          index = 0,
          length = elements.length;
  
      for ( ; index < length; index++ ) {
          elem = elements[ index ];
          if ( !elem.style ) {
              continue;
          }
  
          values[ index ] = jQuery._data( elem, "olddisplay" );
          display = elem.style.display;
          if ( show ) {
  
              // Reset the inline display of this element to learn if it is
              // being hidden by cascaded rules or not
              if ( !values[ index ] && display === "none" ) {
                  elem.style.display = "";
              }
  
              // Set elements which have been overridden with display: none
              // in a stylesheet to whatever the default browser style is
              // for such an element
              if ( elem.style.display === "" && isHidden( elem ) ) {
                  values[ index ] =
                      jQuery._data( elem, "olddisplay", defaultDisplay( elem.nodeName ) );
              }
          } else {
              hidden = isHidden( elem );
  
              if ( display && display !== "none" || !hidden ) {
                  jQuery._data(
                      elem,
                      "olddisplay",
                      hidden ? display : jQuery.css( elem, "display" )
                  );
              }
          }
      }
  
      // Set the display of most of the elements in a second loop
      // to avoid the constant reflow
      for ( index = 0; index < length; index++ ) {
          elem = elements[ index ];
          if ( !elem.style ) {
              continue;
          }
          if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
              elem.style.display = show ? values[ index ] || "" : "none";
          }
      }
  
      return elements;
  }
  
  function setPositiveNumber( elem, value, subtract ) {
      var matches = rnumsplit.exec( value );
      return matches ?
  
          // Guard against undefined "subtract", e.g., when used as in cssHooks
          Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
          value;
  }
  
  function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
      var i = extra === ( isBorderBox ? "border" : "content" ) ?
  
          // If we already have the right measurement, avoid augmentation
          4 :
  
          // Otherwise initialize for horizontal or vertical properties
          name === "width" ? 1 : 0,
  
          val = 0;
  
      for ( ; i < 4; i += 2 ) {
  
          // both box models exclude margin, so add it if we want it
          if ( extra === "margin" ) {
              val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
          }
  
          if ( isBorderBox ) {
  
              // border-box includes padding, so remove it if we want content
              if ( extra === "content" ) {
                  val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
              }
  
              // at this point, extra isn't border nor margin, so remove border
              if ( extra !== "margin" ) {
                  val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
              }
          } else {
  
              // at this point, extra isn't content, so add padding
              val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
  
              // at this point, extra isn't content nor padding, so add border
              if ( extra !== "padding" ) {
                  val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
              }
          }
      }
  
      return val;
  }
  
  function getWidthOrHeight( elem, name, extra ) {
  
      // Start with offset property, which is equivalent to the border-box value
      var valueIsBorderBox = true,
          val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
          styles = getStyles( elem ),
          isBorderBox = support.boxSizing &&
              jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
  
      // some non-html elements return undefined for offsetWidth, so check for null/undefined
      // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
      // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
      if ( val <= 0 || val == null ) {
  
          // Fall back to computed then uncomputed css if necessary
          val = curCSS( elem, name, styles );
          if ( val < 0 || val == null ) {
              val = elem.style[ name ];
          }
  
          // Computed unit is not pixels. Stop here and return.
          if ( rnumnonpx.test( val ) ) {
              return val;
          }
  
          // we need the check for style in case a browser which returns unreliable values
          // for getComputedStyle silently falls back to the reliable elem.style
          valueIsBorderBox = isBorderBox &&
              ( support.boxSizingReliable() || val === elem.style[ name ] );
  
          // Normalize "", auto, and prepare for extra
          val = parseFloat( val ) || 0;
      }
  
      // use the active box-sizing model to add/subtract irrelevant styles
      return ( val +
          augmentWidthOrHeight(
              elem,
              name,
              extra || ( isBorderBox ? "border" : "content" ),
              valueIsBorderBox,
              styles
          )
      ) + "px";
  }
  
  jQuery.extend( {
  
      // Add in style property hooks for overriding the default
      // behavior of getting and setting a style property
      cssHooks: {
          opacity: {
              get: function( elem, computed ) {
                  if ( computed ) {
  
                      // We should always get a number back from opacity
                      var ret = curCSS( elem, "opacity" );
                      return ret === "" ? "1" : ret;
                  }
              }
          }
      },
  
      // Don't automatically add "px" to these possibly-unitless properties
      cssNumber: {
          "animationIterationCount": true,
          "columnCount": true,
          "fillOpacity": true,
          "flexGrow": true,
          "flexShrink": true,
          "fontWeight": true,
          "lineHeight": true,
          "opacity": true,
          "order": true,
          "orphans": true,
          "widows": true,
          "zIndex": true,
          "zoom": true
      },
  
      // Add in properties whose names you wish to fix before
      // setting or getting the value
      cssProps: {
  
          // normalize float css property
          "float": support.cssFloat ? "cssFloat" : "styleFloat"
      },
  
      // Get and set the style property on a DOM Node
      style: function( elem, name, value, extra ) {
  
          // Don't set styles on text and comment nodes
          if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
              return;
          }
  
          // Make sure that we're working with the right name
          var ret, type, hooks,
              origName = jQuery.camelCase( name ),
              style = elem.style;
  
          name = jQuery.cssProps[ origName ] ||
              ( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
  
          // gets hook for the prefixed version
          // followed by the unprefixed version
          hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
  
          // Check if we're setting a value
          if ( value !== undefined ) {
              type = typeof value;
  
              // Convert "+=" or "-=" to relative numbers (#7345)
              if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
                  value = adjustCSS( elem, name, ret );
  
                  // Fixes bug #9237
                  type = "number";
              }
  
              // Make sure that null and NaN values aren't set. See: #7116
              if ( value == null || value !== value ) {
                  return;
              }
  
              // If a number was passed in, add the unit (except for certain CSS properties)
              if ( type === "number" ) {
                  value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
              }
  
              // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
              // but it would mean to define eight
              // (for every problematic property) identical functions
              if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
                  style[ name ] = "inherit";
              }
  
              // If a hook was provided, use that value, otherwise just set the specified value
              if ( !hooks || !( "set" in hooks ) ||
                  ( value = hooks.set( elem, value, extra ) ) !== undefined ) {
  
                  // Support: IE
                  // Swallow errors from 'invalid' CSS values (#5509)
                  try {
                      style[ name ] = value;
                  } catch ( e ) {}
              }
  
          } else {
  
              // If a hook was provided get the non-computed value from there
              if ( hooks && "get" in hooks &&
                  ( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
  
                  return ret;
              }
  
              // Otherwise just get the value from the style object
              return style[ name ];
          }
      },
  
      css: function( elem, name, extra, styles ) {
          var num, val, hooks,
              origName = jQuery.camelCase( name );
  
          // Make sure that we're working with the right name
          name = jQuery.cssProps[ origName ] ||
              ( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
  
          // gets hook for the prefixed version
          // followed by the unprefixed version
          hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
  
          // If a hook was provided get the computed value from there
          if ( hooks && "get" in hooks ) {
              val = hooks.get( elem, true, extra );
          }
  
          // Otherwise, if a way to get the computed value exists, use that
          if ( val === undefined ) {
              val = curCSS( elem, name, styles );
          }
  
          //convert "normal" to computed value
          if ( val === "normal" && name in cssNormalTransform ) {
              val = cssNormalTransform[ name ];
          }
  
          // Return, converting to number if forced or a qualifier was provided and val looks numeric
          if ( extra === "" || extra ) {
              num = parseFloat( val );
              return extra === true || isFinite( num ) ? num || 0 : val;
          }
          return val;
      }
  } );
  
  jQuery.each( [ "height", "width" ], function( i, name ) {
      jQuery.cssHooks[ name ] = {
          get: function( elem, computed, extra ) {
              if ( computed ) {
  
                  // certain elements can have dimension info if we invisibly show them
                  // however, it must have a current display style that would benefit from this
                  return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
                      elem.offsetWidth === 0 ?
                          swap( elem, cssShow, function() {
                              return getWidthOrHeight( elem, name, extra );
                          } ) :
                          getWidthOrHeight( elem, name, extra );
              }
          },
  
          set: function( elem, value, extra ) {
              var styles = extra && getStyles( elem );
              return setPositiveNumber( elem, value, extra ?
                  augmentWidthOrHeight(
                      elem,
                      name,
                      extra,
                      support.boxSizing &&
                          jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
                      styles
                  ) : 0
              );
          }
      };
  } );
  
  if ( !support.opacity ) {
      jQuery.cssHooks.opacity = {
          get: function( elem, computed ) {
  
              // IE uses filters for opacity
              return ropacity.test( ( computed && elem.currentStyle ?
                  elem.currentStyle.filter :
                  elem.style.filter ) || "" ) ?
                      ( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
                      computed ? "1" : "";
          },
  
          set: function( elem, value ) {
              var style = elem.style,
                  currentStyle = elem.currentStyle,
                  opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
                  filter = currentStyle && currentStyle.filter || style.filter || "";
  
              // IE has trouble with opacity if it does not have layout
              // Force it by setting the zoom level
              style.zoom = 1;
  
              // if setting opacity to 1, and no other filters exist -
              // attempt to remove filter attribute #6652
              // if value === "", then remove inline opacity #12685
              if ( ( value >= 1 || value === "" ) &&
                      jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
                      style.removeAttribute ) {
  
                  // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                  // if "filter:" is present at all, clearType is disabled, we want to avoid this
                  // style.removeAttribute is IE Only, but so apparently is this code path...
                  style.removeAttribute( "filter" );
  
                  // if there is no filter style applied in a css rule
                  // or unset inline opacity, we are done
                  if ( value === "" || currentStyle && !currentStyle.filter ) {
                      return;
                  }
              }
  
              // otherwise, set new filter values
              style.filter = ralpha.test( filter ) ?
                  filter.replace( ralpha, opacity ) :
                  filter + " " + opacity;
          }
      };
  }
  
  jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
      function( elem, computed ) {
          if ( computed ) {
              return swap( elem, { "display": "inline-block" },
                  curCSS, [ elem, "marginRight" ] );
          }
      }
  );
  
  jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
      function( elem, computed ) {
          if ( computed ) {
              return (
                  parseFloat( curCSS( elem, "marginLeft" ) ) ||
  
                  // Support: IE<=11+
                  // Running getBoundingClientRect on a disconnected node in IE throws an error
                  // Support: IE8 only
                  // getClientRects() errors on disconnected elems
                  ( jQuery.contains( elem.ownerDocument, elem ) ?
                      elem.getBoundingClientRect().left -
                          swap( elem, { marginLeft: 0 }, function() {
                              return elem.getBoundingClientRect().left;
                          } ) :
                      0
                  )
              ) + "px";
          }
      }
  );
  
  // These hooks are used by animate to expand properties
  jQuery.each( {
      margin: "",
      padding: "",
      border: "Width"
  }, function( prefix, suffix ) {
      jQuery.cssHooks[ prefix + suffix ] = {
          expand: function( value ) {
              var i = 0,
                  expanded = {},
  
                  // assumes a single number if not a string
                  parts = typeof value === "string" ? value.split( " " ) : [ value ];
  
              for ( ; i < 4; i++ ) {
                  expanded[ prefix + cssExpand[ i ] + suffix ] =
                      parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
              }
  
              return expanded;
          }
      };
  
      if ( !rmargin.test( prefix ) ) {
          jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
      }
  } );
  
  jQuery.fn.extend( {
      css: function( name, value ) {
          return access( this, function( elem, name, value ) {
              var styles, len,
                  map = {},
                  i = 0;
  
              if ( jQuery.isArray( name ) ) {
                  styles = getStyles( elem );
                  len = name.length;
  
                  for ( ; i < len; i++ ) {
                      map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                  }
  
                  return map;
              }
  
              return value !== undefined ?
                  jQuery.style( elem, name, value ) :
                  jQuery.css( elem, name );
          }, name, value, arguments.length > 1 );
      },
      show: function() {
          return showHide( this, true );
      },
      hide: function() {
          return showHide( this );
      },
      toggle: function( state ) {
          if ( typeof state === "boolean" ) {
              return state ? this.show() : this.hide();
          }
  
          return this.each( function() {
              if ( isHidden( this ) ) {
                  jQuery( this ).show();
              } else {
                  jQuery( this ).hide();
              }
          } );
      }
  } );
  
  
  function Tween( elem, options, prop, end, easing ) {
      return new Tween.prototype.init( elem, options, prop, end, easing );
  }
  jQuery.Tween = Tween;
  
  Tween.prototype = {
      constructor: Tween,
      init: function( elem, options, prop, end, easing, unit ) {
          this.elem = elem;
          this.prop = prop;
          this.easing = easing || jQuery.easing._default;
          this.options = options;
          this.start = this.now = this.cur();
          this.end = end;
          this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
      },
      cur: function() {
          var hooks = Tween.propHooks[ this.prop ];
  
          return hooks && hooks.get ?
              hooks.get( this ) :
              Tween.propHooks._default.get( this );
      },
      run: function( percent ) {
          var eased,
              hooks = Tween.propHooks[ this.prop ];
  
          if ( this.options.duration ) {
              this.pos = eased = jQuery.easing[ this.easing ](
                  percent, this.options.duration * percent, 0, 1, this.options.duration
              );
          } else {
              this.pos = eased = percent;
          }
          this.now = ( this.end - this.start ) * eased + this.start;
  
          if ( this.options.step ) {
              this.options.step.call( this.elem, this.now, this );
          }
  
          if ( hooks && hooks.set ) {
              hooks.set( this );
          } else {
              Tween.propHooks._default.set( this );
          }
          return this;
      }
  };
  
  Tween.prototype.init.prototype = Tween.prototype;
  
  Tween.propHooks = {
      _default: {
          get: function( tween ) {
              var result;
  
              // Use a property on the element directly when it is not a DOM element,
              // or when there is no matching style property that exists.
              if ( tween.elem.nodeType !== 1 ||
                  tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
                  return tween.elem[ tween.prop ];
              }
  
              // passing an empty string as a 3rd parameter to .css will automatically
              // attempt a parseFloat and fallback to a string if the parse fails
              // so, simple values such as "10px" are parsed to Float.
              // complex values such as "rotate(1rad)" are returned as is.
              result = jQuery.css( tween.elem, tween.prop, "" );
  
              // Empty strings, null, undefined and "auto" are converted to 0.
              return !result || result === "auto" ? 0 : result;
          },
          set: function( tween ) {
  
              // use step hook for back compat - use cssHook if its there - use .style if its
              // available and use plain properties where available
              if ( jQuery.fx.step[ tween.prop ] ) {
                  jQuery.fx.step[ tween.prop ]( tween );
              } else if ( tween.elem.nodeType === 1 &&
                  ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
                      jQuery.cssHooks[ tween.prop ] ) ) {
                  jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
              } else {
                  tween.elem[ tween.prop ] = tween.now;
              }
          }
      }
  };
  
  // Support: IE <=9
  // Panic based approach to setting things on disconnected nodes
  
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
      set: function( tween ) {
          if ( tween.elem.nodeType && tween.elem.parentNode ) {
              tween.elem[ tween.prop ] = tween.now;
          }
      }
  };
  
  jQuery.easing = {
      linear: function( p ) {
          return p;
      },
      swing: function( p ) {
          return 0.5 - Math.cos( p * Math.PI ) / 2;
      },
      _default: "swing"
  };
  
  jQuery.fx = Tween.prototype.init;
  
  // Back Compat <1.8 extension point
  jQuery.fx.step = {};
  
  
  
  
  var
      fxNow, timerId,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;
  
  // Animations created synchronously will run synchronously
  function createFxNow() {
      window.setTimeout( function() {
          fxNow = undefined;
      } );
      return ( fxNow = jQuery.now() );
  }
  
  // Generate parameters to create a standard animation
  function genFx( type, includeWidth ) {
      var which,
          attrs = { height: type },
          i = 0;
  
      // if we include width, step value is 1 to do all cssExpand values,
      // if we don't include width, step value is 2 to skip over Left and Right
      includeWidth = includeWidth ? 1 : 0;
      for ( ; i < 4 ; i += 2 - includeWidth ) {
          which = cssExpand[ i ];
          attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
      }
  
      if ( includeWidth ) {
          attrs.opacity = attrs.width = type;
      }
  
      return attrs;
  }
  
  function createTween( value, prop, animation ) {
      var tween,
          collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
          index = 0,
          length = collection.length;
      for ( ; index < length; index++ ) {
          if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
  
              // we're done with this property
              return tween;
          }
      }
  }
  
  function defaultPrefilter( elem, props, opts ) {
      /* jshint validthis: true */
      var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
          anim = this,
          orig = {},
          style = elem.style,
          hidden = elem.nodeType && isHidden( elem ),
          dataShow = jQuery._data( elem, "fxshow" );
  
      // handle queue: false promises
      if ( !opts.queue ) {
          hooks = jQuery._queueHooks( elem, "fx" );
          if ( hooks.unqueued == null ) {
              hooks.unqueued = 0;
              oldfire = hooks.empty.fire;
              hooks.empty.fire = function() {
                  if ( !hooks.unqueued ) {
                      oldfire();
                  }
              };
          }
          hooks.unqueued++;
  
          anim.always( function() {
  
              // doing this makes sure that the complete handler will be called
              // before this completes
              anim.always( function() {
                  hooks.unqueued--;
                  if ( !jQuery.queue( elem, "fx" ).length ) {
                      hooks.empty.fire();
                  }
              } );
          } );
      }
  
      // height/width overflow pass
      if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
  
          // Make sure that nothing sneaks out
          // Record all 3 overflow attributes because IE does not
          // change the overflow attribute when overflowX and
          // overflowY are set to the same value
          opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
  
          // Set display property to inline-block for height/width
          // animations on inline elements that are having width/height animated
          display = jQuery.css( elem, "display" );
  
          // Test default display if display is currently "none"
          checkDisplay = display === "none" ?
              jQuery._data( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;
  
          if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
  
              // inline-level elements accept inline-block;
              // block-level elements need to be inline with layout
              if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === "inline" ) {
                  style.display = "inline-block";
              } else {
                  style.zoom = 1;
              }
          }
      }
  
      if ( opts.overflow ) {
          style.overflow = "hidden";
          if ( !support.shrinkWrapBlocks() ) {
              anim.always( function() {
                  style.overflow = opts.overflow[ 0 ];
                  style.overflowX = opts.overflow[ 1 ];
                  style.overflowY = opts.overflow[ 2 ];
              } );
          }
      }
  
      // show/hide pass
      for ( prop in props ) {
          value = props[ prop ];
          if ( rfxtypes.exec( value ) ) {
              delete props[ prop ];
              toggle = toggle || value === "toggle";
              if ( value === ( hidden ? "hide" : "show" ) ) {
  
                  // If there is dataShow left over from a stopped hide or show
                  // and we are going to proceed with show, we should pretend to be hidden
                  if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
                      hidden = true;
                  } else {
                      continue;
                  }
              }
              orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
  
          // Any non-fx value stops us from restoring the original display value
          } else {
              display = undefined;
          }
      }
  
      if ( !jQuery.isEmptyObject( orig ) ) {
          if ( dataShow ) {
              if ( "hidden" in dataShow ) {
                  hidden = dataShow.hidden;
              }
          } else {
              dataShow = jQuery._data( elem, "fxshow", {} );
          }
  
          // store state if its toggle - enables .stop().toggle() to "reverse"
          if ( toggle ) {
              dataShow.hidden = !hidden;
          }
          if ( hidden ) {
              jQuery( elem ).show();
          } else {
              anim.done( function() {
                  jQuery( elem ).hide();
              } );
          }
          anim.done( function() {
              var prop;
              jQuery._removeData( elem, "fxshow" );
              for ( prop in orig ) {
                  jQuery.style( elem, prop, orig[ prop ] );
              }
          } );
          for ( prop in orig ) {
              tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
  
              if ( !( prop in dataShow ) ) {
                  dataShow[ prop ] = tween.start;
                  if ( hidden ) {
                      tween.end = tween.start;
                      tween.start = prop === "width" || prop === "height" ? 1 : 0;
                  }
              }
          }
  
      // If this is a noop like .hide().hide(), restore an overwritten display value
      } else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
          style.display = display;
      }
  }
  
  function propFilter( props, specialEasing ) {
      var index, name, easing, value, hooks;
  
      // camelCase, specialEasing and expand cssHook pass
      for ( index in props ) {
          name = jQuery.camelCase( index );
          easing = specialEasing[ name ];
          value = props[ index ];
          if ( jQuery.isArray( value ) ) {
              easing = value[ 1 ];
              value = props[ index ] = value[ 0 ];
          }
  
          if ( index !== name ) {
              props[ name ] = value;
              delete props[ index ];
          }
  
          hooks = jQuery.cssHooks[ name ];
          if ( hooks && "expand" in hooks ) {
              value = hooks.expand( value );
              delete props[ name ];
  
              // not quite $.extend, this wont overwrite keys already present.
              // also - reusing 'index' from above because we have the correct "name"
              for ( index in value ) {
                  if ( !( index in props ) ) {
                      props[ index ] = value[ index ];
                      specialEasing[ index ] = easing;
                  }
              }
          } else {
              specialEasing[ name ] = easing;
          }
      }
  }
  
  function Animation( elem, properties, options ) {
      var result,
          stopped,
          index = 0,
          length = Animation.prefilters.length,
          deferred = jQuery.Deferred().always( function() {
  
              // don't match elem in the :animated selector
              delete tick.elem;
          } ),
          tick = function() {
              if ( stopped ) {
                  return false;
              }
              var currentTime = fxNow || createFxNow(),
                  remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
  
                  // Support: Android 2.3
                  // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                  temp = remaining / animation.duration || 0,
                  percent = 1 - temp,
                  index = 0,
                  length = animation.tweens.length;
  
              for ( ; index < length ; index++ ) {
                  animation.tweens[ index ].run( percent );
              }
  
              deferred.notifyWith( elem, [ animation, percent, remaining ] );
  
              if ( percent < 1 && length ) {
                  return remaining;
              } else {
                  deferred.resolveWith( elem, [ animation ] );
                  return false;
              }
          },
          animation = deferred.promise( {
              elem: elem,
              props: jQuery.extend( {}, properties ),
              opts: jQuery.extend( true, {
                  specialEasing: {},
                  easing: jQuery.easing._default
              }, options ),
              originalProperties: properties,
              originalOptions: options,
              startTime: fxNow || createFxNow(),
              duration: options.duration,
              tweens: [],
              createTween: function( prop, end ) {
                  var tween = jQuery.Tween( elem, animation.opts, prop, end,
                          animation.opts.specialEasing[ prop ] || animation.opts.easing );
                  animation.tweens.push( tween );
                  return tween;
              },
              stop: function( gotoEnd ) {
                  var index = 0,
  
                      // if we are going to the end, we want to run all the tweens
                      // otherwise we skip this part
                      length = gotoEnd ? animation.tweens.length : 0;
                  if ( stopped ) {
                      return this;
                  }
                  stopped = true;
                  for ( ; index < length ; index++ ) {
                      animation.tweens[ index ].run( 1 );
                  }
  
                  // resolve when we played the last frame
                  // otherwise, reject
                  if ( gotoEnd ) {
                      deferred.notifyWith( elem, [ animation, 1, 0 ] );
                      deferred.resolveWith( elem, [ animation, gotoEnd ] );
                  } else {
                      deferred.rejectWith( elem, [ animation, gotoEnd ] );
                  }
                  return this;
              }
          } ),
          props = animation.props;
  
      propFilter( props, animation.opts.specialEasing );
  
      for ( ; index < length ; index++ ) {
          result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
          if ( result ) {
              if ( jQuery.isFunction( result.stop ) ) {
                  jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
                      jQuery.proxy( result.stop, result );
              }
              return result;
          }
      }
  
      jQuery.map( props, createTween, animation );
  
      if ( jQuery.isFunction( animation.opts.start ) ) {
          animation.opts.start.call( elem, animation );
      }
  
      jQuery.fx.timer(
          jQuery.extend( tick, {
              elem: elem,
              anim: animation,
              queue: animation.opts.queue
          } )
      );
  
      // attach callbacks from options
      return animation.progress( animation.opts.progress )
          .done( animation.opts.done, animation.opts.complete )
          .fail( animation.opts.fail )
          .always( animation.opts.always );
  }
  
  jQuery.Animation = jQuery.extend( Animation, {
  
      tweeners: {
          "*": [ function( prop, value ) {
              var tween = this.createTween( prop, value );
              adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
              return tween;
          } ]
      },
  
      tweener: function( props, callback ) {
          if ( jQuery.isFunction( props ) ) {
              callback = props;
              props = [ "*" ];
          } else {
              props = props.match( rnotwhite );
          }
  
          var prop,
              index = 0,
              length = props.length;
  
          for ( ; index < length ; index++ ) {
              prop = props[ index ];
              Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
              Animation.tweeners[ prop ].unshift( callback );
          }
      },
  
      prefilters: [ defaultPrefilter ],
  
      prefilter: function( callback, prepend ) {
          if ( prepend ) {
              Animation.prefilters.unshift( callback );
          } else {
              Animation.prefilters.push( callback );
          }
      }
  } );
  
  jQuery.speed = function( speed, easing, fn ) {
      var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
          complete: fn || !fn && easing ||
              jQuery.isFunction( speed ) && speed,
          duration: speed,
          easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
      };
  
      opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
          opt.duration in jQuery.fx.speeds ?
              jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
  
      // normalize opt.queue - true/undefined/null -> "fx"
      if ( opt.queue == null || opt.queue === true ) {
          opt.queue = "fx";
      }
  
      // Queueing
      opt.old = opt.complete;
  
      opt.complete = function() {
          if ( jQuery.isFunction( opt.old ) ) {
              opt.old.call( this );
          }
  
          if ( opt.queue ) {
              jQuery.dequeue( this, opt.queue );
          }
      };
  
      return opt;
  };
  
  jQuery.fn.extend( {
      fadeTo: function( speed, to, easing, callback ) {
  
          // show any hidden elements after setting opacity to 0
          return this.filter( isHidden ).css( "opacity", 0 ).show()
  
              // animate to the value specified
              .end().animate( { opacity: to }, speed, easing, callback );
      },
      animate: function( prop, speed, easing, callback ) {
          var empty = jQuery.isEmptyObject( prop ),
              optall = jQuery.speed( speed, easing, callback ),
              doAnimation = function() {
  
                  // Operate on a copy of prop so per-property easing won't be lost
                  var anim = Animation( this, jQuery.extend( {}, prop ), optall );
  
                  // Empty animations, or finishing resolves immediately
                  if ( empty || jQuery._data( this, "finish" ) ) {
                      anim.stop( true );
                  }
              };
              doAnimation.finish = doAnimation;
  
          return empty || optall.queue === false ?
              this.each( doAnimation ) :
              this.queue( optall.queue, doAnimation );
      },
      stop: function( type, clearQueue, gotoEnd ) {
          var stopQueue = function( hooks ) {
              var stop = hooks.stop;
              delete hooks.stop;
              stop( gotoEnd );
          };
  
          if ( typeof type !== "string" ) {
              gotoEnd = clearQueue;
              clearQueue = type;
              type = undefined;
          }
          if ( clearQueue && type !== false ) {
              this.queue( type || "fx", [] );
          }
  
          return this.each( function() {
              var dequeue = true,
                  index = type != null && type + "queueHooks",
                  timers = jQuery.timers,
                  data = jQuery._data( this );
  
              if ( index ) {
                  if ( data[ index ] && data[ index ].stop ) {
                      stopQueue( data[ index ] );
                  }
              } else {
                  for ( index in data ) {
                      if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                          stopQueue( data[ index ] );
                      }
                  }
              }
  
              for ( index = timers.length; index--; ) {
                  if ( timers[ index ].elem === this &&
                      ( type == null || timers[ index ].queue === type ) ) {
  
                      timers[ index ].anim.stop( gotoEnd );
                      dequeue = false;
                      timers.splice( index, 1 );
                  }
              }
  
              // start the next in the queue if the last step wasn't forced
              // timers currently will call their complete callbacks, which will dequeue
              // but only if they were gotoEnd
              if ( dequeue || !gotoEnd ) {
                  jQuery.dequeue( this, type );
              }
          } );
      },
      finish: function( type ) {
          if ( type !== false ) {
              type = type || "fx";
          }
          return this.each( function() {
              var index,
                  data = jQuery._data( this ),
                  queue = data[ type + "queue" ],
                  hooks = data[ type + "queueHooks" ],
                  timers = jQuery.timers,
                  length = queue ? queue.length : 0;
  
              // enable finishing flag on private data
              data.finish = true;
  
              // empty the queue first
              jQuery.queue( this, type, [] );
  
              if ( hooks && hooks.stop ) {
                  hooks.stop.call( this, true );
              }
  
              // look for any active animations, and finish them
              for ( index = timers.length; index--; ) {
                  if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
                      timers[ index ].anim.stop( true );
                      timers.splice( index, 1 );
                  }
              }
  
              // look for any animations in the old queue and finish them
              for ( index = 0; index < length; index++ ) {
                  if ( queue[ index ] && queue[ index ].finish ) {
                      queue[ index ].finish.call( this );
                  }
              }
  
              // turn off finishing flag
              delete data.finish;
          } );
      }
  } );
  
  jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
      var cssFn = jQuery.fn[ name ];
      jQuery.fn[ name ] = function( speed, easing, callback ) {
          return speed == null || typeof speed === "boolean" ?
              cssFn.apply( this, arguments ) :
              this.animate( genFx( name, true ), speed, easing, callback );
      };
  } );
  
  // Generate shortcuts for custom animations
  jQuery.each( {
      slideDown: genFx( "show" ),
      slideUp: genFx( "hide" ),
      slideToggle: genFx( "toggle" ),
      fadeIn: { opacity: "show" },
      fadeOut: { opacity: "hide" },
      fadeToggle: { opacity: "toggle" }
  }, function( name, props ) {
      jQuery.fn[ name ] = function( speed, easing, callback ) {
          return this.animate( props, speed, easing, callback );
      };
  } );
  
  jQuery.timers = [];
  jQuery.fx.tick = function() {
      var timer,
          timers = jQuery.timers,
          i = 0;
  
      fxNow = jQuery.now();
  
      for ( ; i < timers.length; i++ ) {
          timer = timers[ i ];
  
          // Checks the timer has not already been removed
          if ( !timer() && timers[ i ] === timer ) {
              timers.splice( i--, 1 );
          }
      }
  
      if ( !timers.length ) {
          jQuery.fx.stop();
      }
      fxNow = undefined;
  };
  
  jQuery.fx.timer = function( timer ) {
      jQuery.timers.push( timer );
      if ( timer() ) {
          jQuery.fx.start();
      } else {
          jQuery.timers.pop();
      }
  };
  
  jQuery.fx.interval = 13;
  
  jQuery.fx.start = function() {
      if ( !timerId ) {
          timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
      }
  };
  
  jQuery.fx.stop = function() {
      window.clearInterval( timerId );
      timerId = null;
  };
  
  jQuery.fx.speeds = {
      slow: 600,
      fast: 200,
  
      // Default speed
      _default: 400
  };
  
  
  // Based off of the plugin by Clint Helfers, with permission.
  // http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
  jQuery.fn.delay = function( time, type ) {
      time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
      type = type || "fx";
  
      return this.queue( type, function( next, hooks ) {
          var timeout = window.setTimeout( next, time );
          hooks.stop = function() {
              window.clearTimeout( timeout );
          };
      } );
  };
  
  
  ( function() {
      var a,
          input = document.createElement( "input" ),
          div = document.createElement( "div" ),
          select = document.createElement( "select" ),
          opt = select.appendChild( document.createElement( "option" ) );
  
      // Setup
      div = document.createElement( "div" );
      div.setAttribute( "className", "t" );
      div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
      a = div.getElementsByTagName( "a" )[ 0 ];
  
      // Support: Windows Web Apps (WWA)
      // `type` must use .setAttribute for WWA (#14901)
      input.setAttribute( "type", "checkbox" );
      div.appendChild( input );
  
      a = div.getElementsByTagName( "a" )[ 0 ];
  
      // First batch of tests.
      a.style.cssText = "top:1px";
  
      // Test setAttribute on camelCase class.
      // If it works, we need attrFixes when doing get/setAttribute (ie6/7)
      support.getSetAttribute = div.className !== "t";
  
      // Get the style information from getAttribute
      // (IE uses .cssText instead)
      support.style = /top/.test( a.getAttribute( "style" ) );
  
      // Make sure that URLs aren't manipulated
      // (IE normalizes it by default)
      support.hrefNormalized = a.getAttribute( "href" ) === "/a";
  
      // Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
      support.checkOn = !!input.value;
  
      // Make sure that a selected-by-default option has a working selected property.
      // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
      support.optSelected = opt.selected;
  
      // Tests for enctype support on a form (#6743)
      support.enctype = !!document.createElement( "form" ).enctype;
  
      // Make sure that the options inside disabled selects aren't marked as disabled
      // (WebKit marks them as disabled)
      select.disabled = true;
      support.optDisabled = !opt.disabled;
  
      // Support: IE8 only
      // Check if we can trust getAttribute("value")
      input = document.createElement( "input" );
      input.setAttribute( "value", "" );
      support.input = input.getAttribute( "value" ) === "";
  
      // Check if an input maintains its value after becoming a radio
      input.value = "t";
      input.setAttribute( "type", "radio" );
      support.radioValue = input.value === "t";
  } )();
  
  
  var rreturn = /\r/g,
      rspaces = /[\x20\t\r\n\f]+/g;
  
  jQuery.fn.extend( {
      val: function( value ) {
          var hooks, ret, isFunction,
              elem = this[ 0 ];
  
          if ( !arguments.length ) {
              if ( elem ) {
                  hooks = jQuery.valHooks[ elem.type ] ||
                      jQuery.valHooks[ elem.nodeName.toLowerCase() ];
  
                  if (
                      hooks &&
                      "get" in hooks &&
                      ( ret = hooks.get( elem, "value" ) ) !== undefined
                  ) {
                      return ret;
                  }
  
                  ret = elem.value;
  
                  return typeof ret === "string" ?
  
                      // handle most common string cases
                      ret.replace( rreturn, "" ) :
  
                      // handle cases where value is null/undef or number
                      ret == null ? "" : ret;
              }
  
              return;
          }
  
          isFunction = jQuery.isFunction( value );
  
          return this.each( function( i ) {
              var val;
  
              if ( this.nodeType !== 1 ) {
                  return;
              }
  
              if ( isFunction ) {
                  val = value.call( this, i, jQuery( this ).val() );
              } else {
                  val = value;
              }
  
              // Treat null/undefined as ""; convert numbers to string
              if ( val == null ) {
                  val = "";
              } else if ( typeof val === "number" ) {
                  val += "";
              } else if ( jQuery.isArray( val ) ) {
                  val = jQuery.map( val, function( value ) {
                      return value == null ? "" : value + "";
                  } );
              }
  
              hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
  
              // If set returns undefined, fall back to normal setting
              if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
                  this.value = val;
              }
          } );
      }
  } );
  
  jQuery.extend( {
      valHooks: {
          option: {
              get: function( elem ) {
                  var val = jQuery.find.attr( elem, "value" );
                  return val != null ?
                      val :
  
                      // Support: IE10-11+
                      // option.text throws exceptions (#14686, #14858)
                      // Strip and collapse whitespace
                      // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                      jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
              }
          },
          select: {
              get: function( elem ) {
                  var value, option,
                      options = elem.options,
                      index = elem.selectedIndex,
                      one = elem.type === "select-one" || index < 0,
                      values = one ? null : [],
                      max = one ? index + 1 : options.length,
                      i = index < 0 ?
                          max :
                          one ? index : 0;
  
                  // Loop through all the selected options
                  for ( ; i < max; i++ ) {
                      option = options[ i ];
  
                      // oldIE doesn't update selected after form reset (#2551)
                      if ( ( option.selected || i === index ) &&
  
                              // Don't return options that are disabled or in a disabled optgroup
                              ( support.optDisabled ?
                                  !option.disabled :
                                  option.getAttribute( "disabled" ) === null ) &&
                              ( !option.parentNode.disabled ||
                                  !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
  
                          // Get the specific value for the option
                          value = jQuery( option ).val();
  
                          // We don't need an array for one selects
                          if ( one ) {
                              return value;
                          }
  
                          // Multi-Selects return an array
                          values.push( value );
                      }
                  }
  
                  return values;
              },
  
              set: function( elem, value ) {
                  var optionSet, option,
                      options = elem.options,
                      values = jQuery.makeArray( value ),
                      i = options.length;
  
                  while ( i-- ) {
                      option = options[ i ];
  
                      if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1 ) {
  
                          // Support: IE6
                          // When new option element is added to select box we need to
                          // force reflow of newly added node in order to workaround delay
                          // of initialization properties
                          try {
                              option.selected = optionSet = true;
  
                          } catch ( _ ) {
  
                              // Will be executed only in IE6
                              option.scrollHeight;
                          }
  
                      } else {
                          option.selected = false;
                      }
                  }
  
                  // Force browsers to behave consistently when non-matching value is set
                  if ( !optionSet ) {
                      elem.selectedIndex = -1;
                  }
  
                  return options;
              }
          }
      }
  } );
  
  // Radios and checkboxes getter/setter
  jQuery.each( [ "radio", "checkbox" ], function() {
      jQuery.valHooks[ this ] = {
          set: function( elem, value ) {
              if ( jQuery.isArray( value ) ) {
                  return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
              }
          }
      };
      if ( !support.checkOn ) {
          jQuery.valHooks[ this ].get = function( elem ) {
              return elem.getAttribute( "value" ) === null ? "on" : elem.value;
          };
      }
  } );
  
  
  
  
  var nodeHook, boolHook,
      attrHandle = jQuery.expr.attrHandle,
      ruseDefault = /^(?:checked|selected)$/i,
      getSetAttribute = support.getSetAttribute,
      getSetInput = support.input;
  
  jQuery.fn.extend( {
      attr: function( name, value ) {
          return access( this, jQuery.attr, name, value, arguments.length > 1 );
      },
  
      removeAttr: function( name ) {
          return this.each( function() {
              jQuery.removeAttr( this, name );
          } );
      }
  } );
  
  jQuery.extend( {
      attr: function( elem, name, value ) {
          var ret, hooks,
              nType = elem.nodeType;
  
          // Don't get/set attributes on text, comment and attribute nodes
          if ( nType === 3 || nType === 8 || nType === 2 ) {
              return;
          }
  
          // Fallback to prop when attributes are not supported
          if ( typeof elem.getAttribute === "undefined" ) {
              return jQuery.prop( elem, name, value );
          }
  
          // All attributes are lowercase
          // Grab necessary hook if one is defined
          if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
              name = name.toLowerCase();
              hooks = jQuery.attrHooks[ name ] ||
                  ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
          }
  
          if ( value !== undefined ) {
              if ( value === null ) {
                  jQuery.removeAttr( elem, name );
                  return;
              }
  
              if ( hooks && "set" in hooks &&
                  ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
                  return ret;
              }
  
              elem.setAttribute( name, value + "" );
              return value;
          }
  
          if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
              return ret;
          }
  
          ret = jQuery.find.attr( elem, name );
  
          // Non-existent attributes return null, we normalize to undefined
          return ret == null ? undefined : ret;
      },
  
      attrHooks: {
          type: {
              set: function( elem, value ) {
                  if ( !support.radioValue && value === "radio" &&
                      jQuery.nodeName( elem, "input" ) ) {
  
                      // Setting the type on a radio button after the value resets the value in IE8-9
                      // Reset value to default in case type is set after value during creation
                      var val = elem.value;
                      elem.setAttribute( "type", value );
                      if ( val ) {
                          elem.value = val;
                      }
                      return value;
                  }
              }
          }
      },
  
      removeAttr: function( elem, value ) {
          var name, propName,
              i = 0,
              attrNames = value && value.match( rnotwhite );
  
          if ( attrNames && elem.nodeType === 1 ) {
              while ( ( name = attrNames[ i++ ] ) ) {
                  propName = jQuery.propFix[ name ] || name;
  
                  // Boolean attributes get special treatment (#10870)
                  if ( jQuery.expr.match.bool.test( name ) ) {
  
                      // Set corresponding property to false
                      if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
                          elem[ propName ] = false;
  
                      // Support: IE<9
                      // Also clear defaultChecked/defaultSelected (if appropriate)
                      } else {
                          elem[ jQuery.camelCase( "default-" + name ) ] =
                              elem[ propName ] = false;
                      }
  
                  // See #9699 for explanation of this approach (setting first, then removal)
                  } else {
                      jQuery.attr( elem, name, "" );
                  }
  
                  elem.removeAttribute( getSetAttribute ? name : propName );
              }
          }
      }
  } );
  
  // Hooks for boolean attributes
  boolHook = {
      set: function( elem, value, name ) {
          if ( value === false ) {
  
              // Remove boolean attributes when set to false
              jQuery.removeAttr( elem, name );
          } else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
  
              // IE<8 needs the *property* name
              elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );
  
          } else {
  
              // Support: IE<9
              // Use defaultChecked and defaultSelected for oldIE
              elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
          }
          return name;
      }
  };
  
  jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
      var getter = attrHandle[ name ] || jQuery.find.attr;
  
      if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
          attrHandle[ name ] = function( elem, name, isXML ) {
              var ret, handle;
              if ( !isXML ) {
  
                  // Avoid an infinite loop by temporarily removing this function from the getter
                  handle = attrHandle[ name ];
                  attrHandle[ name ] = ret;
                  ret = getter( elem, name, isXML ) != null ?
                      name.toLowerCase() :
                      null;
                  attrHandle[ name ] = handle;
              }
              return ret;
          };
      } else {
          attrHandle[ name ] = function( elem, name, isXML ) {
              if ( !isXML ) {
                  return elem[ jQuery.camelCase( "default-" + name ) ] ?
                      name.toLowerCase() :
                      null;
              }
          };
      }
  } );
  
  // fix oldIE attroperties
  if ( !getSetInput || !getSetAttribute ) {
      jQuery.attrHooks.value = {
          set: function( elem, value, name ) {
              if ( jQuery.nodeName( elem, "input" ) ) {
  
                  // Does not return so that setAttribute is also used
                  elem.defaultValue = value;
              } else {
  
                  // Use nodeHook if defined (#1954); otherwise setAttribute is fine
                  return nodeHook && nodeHook.set( elem, value, name );
              }
          }
      };
  }
  
  // IE6/7 do not support getting/setting some attributes with get/setAttribute
  if ( !getSetAttribute ) {
  
      // Use this for any attribute in IE6/7
      // This fixes almost every IE6/7 issue
      nodeHook = {
          set: function( elem, value, name ) {
  
              // Set the existing or create a new attribute node
              var ret = elem.getAttributeNode( name );
              if ( !ret ) {
                  elem.setAttributeNode(
                      ( ret = elem.ownerDocument.createAttribute( name ) )
                  );
              }
  
              ret.value = value += "";
  
              // Break association with cloned elements by also using setAttribute (#9646)
              if ( name === "value" || value === elem.getAttribute( name ) ) {
                  return value;
              }
          }
      };
  
      // Some attributes are constructed with empty-string values when not defined
      attrHandle.id = attrHandle.name = attrHandle.coords =
          function( elem, name, isXML ) {
              var ret;
              if ( !isXML ) {
                  return ( ret = elem.getAttributeNode( name ) ) && ret.value !== "" ?
                      ret.value :
                      null;
              }
          };
  
      // Fixing value retrieval on a button requires this module
      jQuery.valHooks.button = {
          get: function( elem, name ) {
              var ret = elem.getAttributeNode( name );
              if ( ret && ret.specified ) {
                  return ret.value;
              }
          },
          set: nodeHook.set
      };
  
      // Set contenteditable to false on removals(#10429)
      // Setting to empty string throws an error as an invalid value
      jQuery.attrHooks.contenteditable = {
          set: function( elem, value, name ) {
              nodeHook.set( elem, value === "" ? false : value, name );
          }
      };
  
      // Set width and height to auto instead of 0 on empty string( Bug #8150 )
      // This is for removals
      jQuery.each( [ "width", "height" ], function( i, name ) {
          jQuery.attrHooks[ name ] = {
              set: function( elem, value ) {
                  if ( value === "" ) {
                      elem.setAttribute( name, "auto" );
                      return value;
                  }
              }
          };
      } );
  }
  
  if ( !support.style ) {
      jQuery.attrHooks.style = {
          get: function( elem ) {
  
              // Return undefined in the case of empty string
              // Note: IE uppercases css property names, but if we were to .toLowerCase()
              // .cssText, that would destroy case sensitivity in URL's, like in "background"
              return elem.style.cssText || undefined;
          },
          set: function( elem, value ) {
              return ( elem.style.cssText = value + "" );
          }
      };
  }
  
  
  
  
  var rfocusable = /^(?:input|select|textarea|button|object)$/i,
      rclickable = /^(?:a|area)$/i;
  
  jQuery.fn.extend( {
      prop: function( name, value ) {
          return access( this, jQuery.prop, name, value, arguments.length > 1 );
      },
  
      removeProp: function( name ) {
          name = jQuery.propFix[ name ] || name;
          return this.each( function() {
  
              // try/catch handles cases where IE balks (such as removing a property on window)
              try {
                  this[ name ] = undefined;
                  delete this[ name ];
              } catch ( e ) {}
          } );
      }
  } );
  
  jQuery.extend( {
      prop: function( elem, name, value ) {
          var ret, hooks,
              nType = elem.nodeType;
  
          // Don't get/set properties on text, comment and attribute nodes
          if ( nType === 3 || nType === 8 || nType === 2 ) {
              return;
          }
  
          if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
  
              // Fix name and attach hooks
              name = jQuery.propFix[ name ] || name;
              hooks = jQuery.propHooks[ name ];
          }
  
          if ( value !== undefined ) {
              if ( hooks && "set" in hooks &&
                  ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
                  return ret;
              }
  
              return ( elem[ name ] = value );
          }
  
          if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
              return ret;
          }
  
          return elem[ name ];
      },
  
      propHooks: {
          tabIndex: {
              get: function( elem ) {
  
                  // elem.tabIndex doesn't always return the
                  // correct value when it hasn't been explicitly set
                  // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                  // Use proper attribute retrieval(#12072)
                  var tabindex = jQuery.find.attr( elem, "tabindex" );
  
                  return tabindex ?
                      parseInt( tabindex, 10 ) :
                      rfocusable.test( elem.nodeName ) ||
                          rclickable.test( elem.nodeName ) && elem.href ?
                              0 :
                              -1;
              }
          }
      },
  
      propFix: {
          "for": "htmlFor",
          "class": "className"
      }
  } );
  
  // Some attributes require a special call on IE
  // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
  if ( !support.hrefNormalized ) {
  
      // href/src property should get the full normalized URL (#10299/#12915)
      jQuery.each( [ "href", "src" ], function( i, name ) {
          jQuery.propHooks[ name ] = {
              get: function( elem ) {
                  return elem.getAttribute( name, 4 );
              }
          };
      } );
  }
  
  // Support: Safari, IE9+
  // Accessing the selectedIndex property
  // forces the browser to respect setting selected
  // on the option
  // The getter ensures a default option is selected
  // when in an optgroup
  if ( !support.optSelected ) {
      jQuery.propHooks.selected = {
          get: function( elem ) {
              var parent = elem.parentNode;
  
              if ( parent ) {
                  parent.selectedIndex;
  
                  // Make sure that it also works with optgroups, see #5701
                  if ( parent.parentNode ) {
                      parent.parentNode.selectedIndex;
                  }
              }
              return null;
          },
          set: function( elem ) {
              var parent = elem.parentNode;
              if ( parent ) {
                  parent.selectedIndex;
  
                  if ( parent.parentNode ) {
                      parent.parentNode.selectedIndex;
                  }
              }
          }
      };
  }
  
  jQuery.each( [
      "tabIndex",
      "readOnly",
      "maxLength",
      "cellSpacing",
      "cellPadding",
      "rowSpan",
      "colSpan",
      "useMap",
      "frameBorder",
      "contentEditable"
  ], function() {
      jQuery.propFix[ this.toLowerCase() ] = this;
  } );
  
  // IE6/7 call enctype encoding
  if ( !support.enctype ) {
      jQuery.propFix.enctype = "encoding";
  }
  
  
  
  
  var rclass = /[\t\r\n\f]/g;
  
  function getClass( elem ) {
      return jQuery.attr( elem, "class" ) || "";
  }
  
  jQuery.fn.extend( {
      addClass: function( value ) {
          var classes, elem, cur, curValue, clazz, j, finalValue,
              i = 0;
  
          if ( jQuery.isFunction( value ) ) {
              return this.each( function( j ) {
                  jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
              } );
          }
  
          if ( typeof value === "string" && value ) {
              classes = value.match( rnotwhite ) || [];
  
              while ( ( elem = this[ i++ ] ) ) {
                  curValue = getClass( elem );
                  cur = elem.nodeType === 1 &&
                      ( " " + curValue + " " ).replace( rclass, " " );
  
                  if ( cur ) {
                      j = 0;
                      while ( ( clazz = classes[ j++ ] ) ) {
                          if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                              cur += clazz + " ";
                          }
                      }
  
                      // only assign if different to avoid unneeded rendering.
                      finalValue = jQuery.trim( cur );
                      if ( curValue !== finalValue ) {
                          jQuery.attr( elem, "class", finalValue );
                      }
                  }
              }
          }
  
          return this;
      },
  
      removeClass: function( value ) {
          var classes, elem, cur, curValue, clazz, j, finalValue,
              i = 0;
  
          if ( jQuery.isFunction( value ) ) {
              return this.each( function( j ) {
                  jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
              } );
          }
  
          if ( !arguments.length ) {
              return this.attr( "class", "" );
          }
  
          if ( typeof value === "string" && value ) {
              classes = value.match( rnotwhite ) || [];
  
              while ( ( elem = this[ i++ ] ) ) {
                  curValue = getClass( elem );
  
                  // This expression is here for better compressibility (see addClass)
                  cur = elem.nodeType === 1 &&
                      ( " " + curValue + " " ).replace( rclass, " " );
  
                  if ( cur ) {
                      j = 0;
                      while ( ( clazz = classes[ j++ ] ) ) {
  
                          // Remove *all* instances
                          while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
                              cur = cur.replace( " " + clazz + " ", " " );
                          }
                      }
  
                      // Only assign if different to avoid unneeded rendering.
                      finalValue = jQuery.trim( cur );
                      if ( curValue !== finalValue ) {
                          jQuery.attr( elem, "class", finalValue );
                      }
                  }
              }
          }
  
          return this;
      },
  
      toggleClass: function( value, stateVal ) {
          var type = typeof value;
  
          if ( typeof stateVal === "boolean" && type === "string" ) {
              return stateVal ? this.addClass( value ) : this.removeClass( value );
          }
  
          if ( jQuery.isFunction( value ) ) {
              return this.each( function( i ) {
                  jQuery( this ).toggleClass(
                      value.call( this, i, getClass( this ), stateVal ),
                      stateVal
                  );
              } );
          }
  
          return this.each( function() {
              var className, i, self, classNames;
  
              if ( type === "string" ) {
  
                  // Toggle individual class names
                  i = 0;
                  self = jQuery( this );
                  classNames = value.match( rnotwhite ) || [];
  
                  while ( ( className = classNames[ i++ ] ) ) {
  
                      // Check each className given, space separated list
                      if ( self.hasClass( className ) ) {
                          self.removeClass( className );
                      } else {
                          self.addClass( className );
                      }
                  }
  
              // Toggle whole class name
              } else if ( value === undefined || type === "boolean" ) {
                  className = getClass( this );
                  if ( className ) {
  
                      // store className if set
                      jQuery._data( this, "__className__", className );
                  }
  
                  // If the element has a class name or if we're passed "false",
                  // then remove the whole classname (if there was one, the above saved it).
                  // Otherwise bring back whatever was previously saved (if anything),
                  // falling back to the empty string if nothing was stored.
                  jQuery.attr( this, "class",
                      className || value === false ?
                      "" :
                      jQuery._data( this, "__className__" ) || ""
                  );
              }
          } );
      },
  
      hasClass: function( selector ) {
          var className, elem,
              i = 0;
  
          className = " " + selector + " ";
          while ( ( elem = this[ i++ ] ) ) {
              if ( elem.nodeType === 1 &&
                  ( " " + getClass( elem ) + " " ).replace( rclass, " " )
                      .indexOf( className ) > -1
              ) {
                  return true;
              }
          }
  
          return false;
      }
  } );
  
  
  
  
  // Return jQuery for attributes-only inclusion
  
  
  jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
      "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
      "change select submit keydown keypress keyup error contextmenu" ).split( " " ),
      function( i, name ) {
  
      // Handle event binding
      jQuery.fn[ name ] = function( data, fn ) {
          return arguments.length > 0 ?
              this.on( name, null, data, fn ) :
              this.trigger( name );
      };
  } );
  
  jQuery.fn.extend( {
      hover: function( fnOver, fnOut ) {
          return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
      }
  } );
  
  
  var location = window.location;
  
  var nonce = jQuery.now();
  
  var rquery = ( /\?/ );
  
  
  
  var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
  
  jQuery.parseJSON = function( data ) {
  
      // Attempt to parse using the native JSON parser first
      if ( window.JSON && window.JSON.parse ) {
  
          // Support: Android 2.3
          // Workaround failure to string-cast null input
          return window.JSON.parse( data + "" );
      }
  
      var requireNonComma,
          depth = null,
          str = jQuery.trim( data + "" );
  
      // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
      // after removing valid tokens
      return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {
  
          // Force termination if we see a misplaced comma
          if ( requireNonComma && comma ) {
              depth = 0;
          }
  
          // Perform no more replacements after returning to outermost depth
          if ( depth === 0 ) {
              return token;
          }
  
          // Commas must not follow "[", "{", or ","
          requireNonComma = open || comma;
  
          // Determine new depth
          // array/object open ("[" or "{"): depth += true - false (increment)
          // array/object close ("]" or "}"): depth += false - true (decrement)
          // other cases ("," or primitive): depth += true - true (numeric cast)
          depth += !close - !open;
  
          // Remove this token
          return "";
      } ) ) ?
          ( Function( "return " + str ) )() :
          jQuery.error( "Invalid JSON: " + data );
  };
  
  
  // Cross-browser xml parsing
  jQuery.parseXML = function( data ) {
      var xml, tmp;
      if ( !data || typeof data !== "string" ) {
          return null;
      }
      try {
          if ( window.DOMParser ) { // Standard
              tmp = new window.DOMParser();
              xml = tmp.parseFromString( data, "text/xml" );
          } else { // IE
              xml = new window.ActiveXObject( "Microsoft.XMLDOM" );
              xml.async = "false";
              xml.loadXML( data );
          }
      } catch ( e ) {
          xml = undefined;
      }
      if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
          jQuery.error( "Invalid XML: " + data );
      }
      return xml;
  };
  
  
  var
      rhash = /#.*$/,
      rts = /([?&])_=[^&]*/,
  
      // IE leaves an \r character at EOL
      rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg,
  
      // #7653, #8125, #8152: local protocol detection
      rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,
      rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
  
      /* Prefilters
       * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
       * 2) These are called:
       *    - BEFORE asking for a transport
       *    - AFTER param serialization (s.data is a string if s.processData is true)
       * 3) key is the dataType
       * 4) the catchall symbol "*" can be used
       * 5) execution will start with transport dataType and THEN continue down to "*" if needed
       */
      prefilters = {},
  
      /* Transports bindings
       * 1) key is the dataType
       * 2) the catchall symbol "*" can be used
       * 3) selection will start with transport dataType and THEN go to "*" if needed
       */
      transports = {},
  
      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
      allTypes = "*/".concat( "*" ),
  
      // Document location
      ajaxLocation = location.href,
  
      // Segment location into parts
      ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
  
  // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
  function addToPrefiltersOrTransports( structure ) {
  
      // dataTypeExpression is optional and defaults to "*"
      return function( dataTypeExpression, func ) {
  
          if ( typeof dataTypeExpression !== "string" ) {
              func = dataTypeExpression;
              dataTypeExpression = "*";
          }
  
          var dataType,
              i = 0,
              dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];
  
          if ( jQuery.isFunction( func ) ) {
  
              // For each dataType in the dataTypeExpression
              while ( ( dataType = dataTypes[ i++ ] ) ) {
  
                  // Prepend if requested
                  if ( dataType.charAt( 0 ) === "+" ) {
                      dataType = dataType.slice( 1 ) || "*";
                      ( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
  
                  // Otherwise append
                  } else {
                      ( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
                  }
              }
          }
      };
  }
  
  // Base inspection function for prefilters and transports
  function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
  
      var inspected = {},
          seekingTransport = ( structure === transports );
  
      function inspect( dataType ) {
          var selected;
          inspected[ dataType ] = true;
          jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
              var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
              if ( typeof dataTypeOrTransport === "string" &&
                  !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
  
                  options.dataTypes.unshift( dataTypeOrTransport );
                  inspect( dataTypeOrTransport );
                  return false;
              } else if ( seekingTransport ) {
                  return !( selected = dataTypeOrTransport );
              }
          } );
          return selected;
      }
  
      return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
  }
  
  // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887
  function ajaxExtend( target, src ) {
      var deep, key,
          flatOptions = jQuery.ajaxSettings.flatOptions || {};
  
      for ( key in src ) {
          if ( src[ key ] !== undefined ) {
              ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
          }
      }
      if ( deep ) {
          jQuery.extend( true, target, deep );
      }
  
      return target;
  }
  
  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */
  function ajaxHandleResponses( s, jqXHR, responses ) {
      var firstDataType, ct, finalDataType, type,
          contents = s.contents,
          dataTypes = s.dataTypes;
  
      // Remove auto dataType and get content-type in the process
      while ( dataTypes[ 0 ] === "*" ) {
          dataTypes.shift();
          if ( ct === undefined ) {
              ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
          }
      }
  
      // Check if we're dealing with a known content-type
      if ( ct ) {
          for ( type in contents ) {
              if ( contents[ type ] && contents[ type ].test( ct ) ) {
                  dataTypes.unshift( type );
                  break;
              }
          }
      }
  
      // Check to see if we have a response for the expected dataType
      if ( dataTypes[ 0 ] in responses ) {
          finalDataType = dataTypes[ 0 ];
      } else {
  
          // Try convertible dataTypes
          for ( type in responses ) {
              if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
                  finalDataType = type;
                  break;
              }
              if ( !firstDataType ) {
                  firstDataType = type;
              }
          }
  
          // Or just use first one
          finalDataType = finalDataType || firstDataType;
      }
  
      // If we found a dataType
      // We add the dataType to the list if needed
      // and return the corresponding response
      if ( finalDataType ) {
          if ( finalDataType !== dataTypes[ 0 ] ) {
              dataTypes.unshift( finalDataType );
          }
          return responses[ finalDataType ];
      }
  }
  
  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */
  function ajaxConvert( s, response, jqXHR, isSuccess ) {
      var conv2, current, conv, tmp, prev,
          converters = {},
  
          // Work with a copy of dataTypes in case we need to modify it for conversion
          dataTypes = s.dataTypes.slice();
  
      // Create converters map with lowercased keys
      if ( dataTypes[ 1 ] ) {
          for ( conv in s.converters ) {
              converters[ conv.toLowerCase() ] = s.converters[ conv ];
          }
      }
  
      current = dataTypes.shift();
  
      // Convert to each sequential dataType
      while ( current ) {
  
          if ( s.responseFields[ current ] ) {
              jqXHR[ s.responseFields[ current ] ] = response;
          }
  
          // Apply the dataFilter if provided
          if ( !prev && isSuccess && s.dataFilter ) {
              response = s.dataFilter( response, s.dataType );
          }
  
          prev = current;
          current = dataTypes.shift();
  
          if ( current ) {
  
              // There's only work to do if current dataType is non-auto
              if ( current === "*" ) {
  
                  current = prev;
  
              // Convert response if prev dataType is non-auto and differs from current
              } else if ( prev !== "*" && prev !== current ) {
  
                  // Seek a direct converter
                  conv = converters[ prev + " " + current ] || converters[ "* " + current ];
  
                  // If none found, seek a pair
                  if ( !conv ) {
                      for ( conv2 in converters ) {
  
                          // If conv2 outputs current
                          tmp = conv2.split( " " );
                          if ( tmp[ 1 ] === current ) {
  
                              // If prev can be converted to accepted input
                              conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                  converters[ "* " + tmp[ 0 ] ];
                              if ( conv ) {
  
                                  // Condense equivalence converters
                                  if ( conv === true ) {
                                      conv = converters[ conv2 ];
  
                                  // Otherwise, insert the intermediate dataType
                                  } else if ( converters[ conv2 ] !== true ) {
                                      current = tmp[ 0 ];
                                      dataTypes.unshift( tmp[ 1 ] );
                                  }
                                  break;
                              }
                          }
                      }
                  }
  
                  // Apply converter (if not an equivalence)
                  if ( conv !== true ) {
  
                      // Unless errors are allowed to bubble, catch and return them
                      if ( conv && s[ "throws" ] ) { // jscs:ignore requireDotNotation
                          response = conv( response );
                      } else {
                          try {
                              response = conv( response );
                          } catch ( e ) {
                              return {
                                  state: "parsererror",
                                  error: conv ? e : "No conversion from " + prev + " to " + current
                              };
                          }
                      }
                  }
              }
          }
      }
  
      return { state: "success", data: response };
  }
  
  jQuery.extend( {
  
      // Counter for holding the number of active queries
      active: 0,
  
      // Last-Modified header cache for next request
      lastModified: {},
      etag: {},
  
      ajaxSettings: {
          url: ajaxLocation,
          type: "GET",
          isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
          global: true,
          processData: true,
          async: true,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",
          /*
          timeout: 0,
          data: null,
          dataType: null,
          username: null,
          password: null,
          cache: null,
          throws: false,
          traditional: false,
          headers: {},
          */
  
          accepts: {
              "*": allTypes,
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript"
          },
  
          contents: {
              xml: /\bxml\b/,
              html: /\bhtml/,
              json: /\bjson\b/
          },
  
          responseFields: {
              xml: "responseXML",
              text: "responseText",
              json: "responseJSON"
          },
  
          // Data converters
          // Keys separate source (or catchall "*") and destination types with a single space
          converters: {
  
              // Convert anything to text
              "* text": String,
  
              // Text to html (true = no transformation)
              "text html": true,
  
              // Evaluate text as a json expression
              "text json": jQuery.parseJSON,
  
              // Parse text as xml
              "text xml": jQuery.parseXML
          },
  
          // For options that shouldn't be deep extended:
          // you can add your own custom options here if
          // and when you create one that shouldn't be
          // deep extended (see ajaxExtend)
          flatOptions: {
              url: true,
              context: true
          }
      },
  
      // Creates a full fledged settings object into target
      // with both ajaxSettings and settings fields.
      // If target is omitted, writes into ajaxSettings.
      ajaxSetup: function( target, settings ) {
          return settings ?
  
              // Building a settings object
              ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
  
              // Extending ajaxSettings
              ajaxExtend( jQuery.ajaxSettings, target );
      },
  
      ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
      ajaxTransport: addToPrefiltersOrTransports( transports ),
  
      // Main method
      ajax: function( url, options ) {
  
          // If url is an object, simulate pre-1.5 signature
          if ( typeof url === "object" ) {
              options = url;
              url = undefined;
          }
  
          // Force options to be an object
          options = options || {};
  
          var
  
              // Cross-domain detection vars
              parts,
  
              // Loop variable
              i,
  
              // URL without anti-cache param
              cacheURL,
  
              // Response headers as string
              responseHeadersString,
  
              // timeout handle
              timeoutTimer,
  
              // To know if global events are to be dispatched
              fireGlobals,
  
              transport,
  
              // Response headers
              responseHeaders,
  
              // Create the final options object
              s = jQuery.ajaxSetup( {}, options ),
  
              // Callbacks context
              callbackContext = s.context || s,
  
              // Context for global events is callbackContext if it is a DOM node or jQuery collection
              globalEventContext = s.context &&
                  ( callbackContext.nodeType || callbackContext.jquery ) ?
                      jQuery( callbackContext ) :
                      jQuery.event,
  
              // Deferreds
              deferred = jQuery.Deferred(),
              completeDeferred = jQuery.Callbacks( "once memory" ),
  
              // Status-dependent callbacks
              statusCode = s.statusCode || {},
  
              // Headers (they are sent all at once)
              requestHeaders = {},
              requestHeadersNames = {},
  
              // The jqXHR state
              state = 0,
  
              // Default abort message
              strAbort = "canceled",
  
              // Fake xhr
              jqXHR = {
                  readyState: 0,
  
                  // Builds headers hashtable if needed
                  getResponseHeader: function( key ) {
                      var match;
                      if ( state === 2 ) {
                          if ( !responseHeaders ) {
                              responseHeaders = {};
                              while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
                                  responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
                              }
                          }
                          match = responseHeaders[ key.toLowerCase() ];
                      }
                      return match == null ? null : match;
                  },
  
                  // Raw string
                  getAllResponseHeaders: function() {
                      return state === 2 ? responseHeadersString : null;
                  },
  
                  // Caches the header
                  setRequestHeader: function( name, value ) {
                      var lname = name.toLowerCase();
                      if ( !state ) {
                          name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                          requestHeaders[ name ] = value;
                      }
                      return this;
                  },
  
                  // Overrides response content-type header
                  overrideMimeType: function( type ) {
                      if ( !state ) {
                          s.mimeType = type;
                      }
                      return this;
                  },
  
                  // Status-dependent callbacks
                  statusCode: function( map ) {
                      var code;
                      if ( map ) {
                          if ( state < 2 ) {
                              for ( code in map ) {
  
                                  // Lazy-add the new callback in a way that preserves old ones
                                  statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                              }
                          } else {
  
                              // Execute the appropriate callbacks
                              jqXHR.always( map[ jqXHR.status ] );
                          }
                      }
                      return this;
                  },
  
                  // Cancel the request
                  abort: function( statusText ) {
                      var finalText = statusText || strAbort;
                      if ( transport ) {
                          transport.abort( finalText );
                      }
                      done( 0, finalText );
                      return this;
                  }
              };
  
          // Attach deferreds
          deferred.promise( jqXHR ).complete = completeDeferred.add;
          jqXHR.success = jqXHR.done;
          jqXHR.error = jqXHR.fail;
  
          // Remove hash character (#7531: and string promotion)
          // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
          // Handle falsy url in the settings object (#10093: consistency with old signature)
          // We also use the url parameter if available
          s.url = ( ( url || s.url || ajaxLocation ) + "" )
              .replace( rhash, "" )
              .replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
  
          // Alias method option to type as per ticket #12004
          s.type = options.method || options.type || s.method || s.type;
  
          // Extract dataTypes list
          s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];
  
          // A cross-domain request is in order when we have a protocol:host:port mismatch
          if ( s.crossDomain == null ) {
              parts = rurl.exec( s.url.toLowerCase() );
              s.crossDomain = !!( parts &&
                  ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                      ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
                          ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
              );
          }
  
          // Convert data if not already a string
          if ( s.data && s.processData && typeof s.data !== "string" ) {
              s.data = jQuery.param( s.data, s.traditional );
          }
  
          // Apply prefilters
          inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
  
          // If request was aborted inside a prefilter, stop there
          if ( state === 2 ) {
              return jqXHR;
          }
  
          // We can fire global events as of now if asked to
          // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
          fireGlobals = jQuery.event && s.global;
  
          // Watch for a new set of requests
          if ( fireGlobals && jQuery.active++ === 0 ) {
              jQuery.event.trigger( "ajaxStart" );
          }
  
          // Uppercase the type
          s.type = s.type.toUpperCase();
  
          // Determine if request has content
          s.hasContent = !rnoContent.test( s.type );
  
          // Save the URL in case we're toying with the If-Modified-Since
          // and/or If-None-Match header later on
          cacheURL = s.url;
  
          // More options handling for requests with no content
          if ( !s.hasContent ) {
  
              // If data is available, append data to url
              if ( s.data ) {
                  cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
  
                  // #9682: remove data so that it's not used in an eventual retry
                  delete s.data;
              }
  
              // Add anti-cache in url if needed
              if ( s.cache === false ) {
                  s.url = rts.test( cacheURL ) ?
  
                      // If there is already a '_' parameter, set its value
                      cacheURL.replace( rts, "$1_=" + nonce++ ) :
  
                      // Otherwise add one to the end
                      cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
              }
          }
  
          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if ( s.ifModified ) {
              if ( jQuery.lastModified[ cacheURL ] ) {
                  jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
              }
              if ( jQuery.etag[ cacheURL ] ) {
                  jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
              }
          }
  
          // Set the correct header, if data is being sent
          if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
              jqXHR.setRequestHeader( "Content-Type", s.contentType );
          }
  
          // Set the Accepts header for the server, depending on the dataType
          jqXHR.setRequestHeader(
              "Accept",
              s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
                  s.accepts[ s.dataTypes[ 0 ] ] +
                      ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                  s.accepts[ "*" ]
          );
  
          // Check for headers option
          for ( i in s.headers ) {
              jqXHR.setRequestHeader( i, s.headers[ i ] );
          }
  
          // Allow custom headers/mimetypes and early abort
          if ( s.beforeSend &&
              ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
  
              // Abort if not done already and return
              return jqXHR.abort();
          }
  
          // aborting is no longer a cancellation
          strAbort = "abort";
  
          // Install callbacks on deferreds
          for ( i in { success: 1, error: 1, complete: 1 } ) {
              jqXHR[ i ]( s[ i ] );
          }
  
          // Get transport
          transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
  
          // If no transport, we auto-abort
          if ( !transport ) {
              done( -1, "No Transport" );
          } else {
              jqXHR.readyState = 1;
  
              // Send global event
              if ( fireGlobals ) {
                  globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
              }
  
              // If request was aborted inside ajaxSend, stop there
              if ( state === 2 ) {
                  return jqXHR;
              }
  
              // Timeout
              if ( s.async && s.timeout > 0 ) {
                  timeoutTimer = window.setTimeout( function() {
                      jqXHR.abort( "timeout" );
                  }, s.timeout );
              }
  
              try {
                  state = 1;
                  transport.send( requestHeaders, done );
              } catch ( e ) {
  
                  // Propagate exception as error if not done
                  if ( state < 2 ) {
                      done( -1, e );
  
                  // Simply rethrow otherwise
                  } else {
                      throw e;
                  }
              }
          }
  
          // Callback for when everything is done
          function done( status, nativeStatusText, responses, headers ) {
              var isSuccess, success, error, response, modified,
                  statusText = nativeStatusText;
  
              // Called once
              if ( state === 2 ) {
                  return;
              }
  
              // State is "done" now
              state = 2;
  
              // Clear timeout if it exists
              if ( timeoutTimer ) {
                  window.clearTimeout( timeoutTimer );
              }
  
              // Dereference transport for early garbage collection
              // (no matter how long the jqXHR object will be used)
              transport = undefined;
  
              // Cache response headers
              responseHeadersString = headers || "";
  
              // Set readyState
              jqXHR.readyState = status > 0 ? 4 : 0;
  
              // Determine if successful
              isSuccess = status >= 200 && status < 300 || status === 304;
  
              // Get response data
              if ( responses ) {
                  response = ajaxHandleResponses( s, jqXHR, responses );
              }
  
              // Convert no matter what (that way responseXXX fields are always set)
              response = ajaxConvert( s, response, jqXHR, isSuccess );
  
              // If successful, handle type chaining
              if ( isSuccess ) {
  
                  // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                  if ( s.ifModified ) {
                      modified = jqXHR.getResponseHeader( "Last-Modified" );
                      if ( modified ) {
                          jQuery.lastModified[ cacheURL ] = modified;
                      }
                      modified = jqXHR.getResponseHeader( "etag" );
                      if ( modified ) {
                          jQuery.etag[ cacheURL ] = modified;
                      }
                  }
  
                  // if no content
                  if ( status === 204 || s.type === "HEAD" ) {
                      statusText = "nocontent";
  
                  // if not modified
                  } else if ( status === 304 ) {
                      statusText = "notmodified";
  
                  // If we have data, let's convert it
                  } else {
                      statusText = response.state;
                      success = response.data;
                      error = response.error;
                      isSuccess = !error;
                  }
              } else {
  
                  // We extract error from statusText
                  // then normalize statusText and status for non-aborts
                  error = statusText;
                  if ( status || !statusText ) {
                      statusText = "error";
                      if ( status < 0 ) {
                          status = 0;
                      }
                  }
              }
  
              // Set data for the fake xhr object
              jqXHR.status = status;
              jqXHR.statusText = ( nativeStatusText || statusText ) + "";
  
              // Success/Error
              if ( isSuccess ) {
                  deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
              } else {
                  deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
              }
  
              // Status-dependent callbacks
              jqXHR.statusCode( statusCode );
              statusCode = undefined;
  
              if ( fireGlobals ) {
                  globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
                      [ jqXHR, s, isSuccess ? success : error ] );
              }
  
              // Complete
              completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
  
              if ( fireGlobals ) {
                  globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
  
                  // Handle the global AJAX counter
                  if ( !( --jQuery.active ) ) {
                      jQuery.event.trigger( "ajaxStop" );
                  }
              }
          }
  
          return jqXHR;
      },
  
      getJSON: function( url, data, callback ) {
          return jQuery.get( url, data, callback, "json" );
      },
  
      getScript: function( url, callback ) {
          return jQuery.get( url, undefined, callback, "script" );
      }
  } );
  
  jQuery.each( [ "get", "post" ], function( i, method ) {
      jQuery[ method ] = function( url, data, callback, type ) {
  
          // shift arguments if data argument was omitted
          if ( jQuery.isFunction( data ) ) {
              type = type || callback;
              callback = data;
              data = undefined;
          }
  
          // The url can be an options object (which then must have .url)
          return jQuery.ajax( jQuery.extend( {
              url: url,
              type: method,
              dataType: type,
              data: data,
              success: callback
          }, jQuery.isPlainObject( url ) && url ) );
      };
  } );
  
  
  jQuery._evalUrl = function( url ) {
      return jQuery.ajax( {
          url: url,
  
          // Make this explicit, since user can override this through ajaxSetup (#11264)
          type: "GET",
          dataType: "script",
          cache: true,
          async: false,
          global: false,
          "throws": true
      } );
  };
  
  
  jQuery.fn.extend( {
      wrapAll: function( html ) {
          if ( jQuery.isFunction( html ) ) {
              return this.each( function( i ) {
                  jQuery( this ).wrapAll( html.call( this, i ) );
              } );
          }
  
          if ( this[ 0 ] ) {
  
              // The elements to wrap the target around
              var wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
  
              if ( this[ 0 ].parentNode ) {
                  wrap.insertBefore( this[ 0 ] );
              }
  
              wrap.map( function() {
                  var elem = this;
  
                  while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
                      elem = elem.firstChild;
                  }
  
                  return elem;
              } ).append( this );
          }
  
          return this;
      },
  
      wrapInner: function( html ) {
          if ( jQuery.isFunction( html ) ) {
              return this.each( function( i ) {
                  jQuery( this ).wrapInner( html.call( this, i ) );
              } );
          }
  
          return this.each( function() {
              var self = jQuery( this ),
                  contents = self.contents();
  
              if ( contents.length ) {
                  contents.wrapAll( html );
  
              } else {
                  self.append( html );
              }
          } );
      },
  
      wrap: function( html ) {
          var isFunction = jQuery.isFunction( html );
  
          return this.each( function( i ) {
              jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
          } );
      },
  
      unwrap: function() {
          return this.parent().each( function() {
              if ( !jQuery.nodeName( this, "body" ) ) {
                  jQuery( this ).replaceWith( this.childNodes );
              }
          } ).end();
      }
  } );
  
  
  function getDisplay( elem ) {
      return elem.style && elem.style.display || jQuery.css( elem, "display" );
  }
  
  function filterHidden( elem ) {
  
      // Disconnected elements are considered hidden
      if ( !jQuery.contains( elem.ownerDocument || document, elem ) ) {
          return true;
      }
      while ( elem && elem.nodeType === 1 ) {
          if ( getDisplay( elem ) === "none" || elem.type === "hidden" ) {
              return true;
          }
          elem = elem.parentNode;
      }
      return false;
  }
  
  jQuery.expr.filters.hidden = function( elem ) {
  
      // Support: Opera <= 12.12
      // Opera reports offsetWidths and offsetHeights less than zero on some elements
      return support.reliableHiddenOffsets() ?
          ( elem.offsetWidth <= 0 && elem.offsetHeight <= 0 &&
              !elem.getClientRects().length ) :
              filterHidden( elem );
  };
  
  jQuery.expr.filters.visible = function( elem ) {
      return !jQuery.expr.filters.hidden( elem );
  };
  
  
  
  
  var r20 = /%20/g,
      rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;
  
  function buildParams( prefix, obj, traditional, add ) {
      var name;
  
      if ( jQuery.isArray( obj ) ) {
  
          // Serialize array item.
          jQuery.each( obj, function( i, v ) {
              if ( traditional || rbracket.test( prefix ) ) {
  
                  // Treat each array item as a scalar.
                  add( prefix, v );
  
              } else {
  
                  // Item is non-scalar (array or object), encode its numeric index.
                  buildParams(
                      prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
                      v,
                      traditional,
                      add
                  );
              }
          } );
  
      } else if ( !traditional && jQuery.type( obj ) === "object" ) {
  
          // Serialize object item.
          for ( name in obj ) {
              buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
          }
  
      } else {
  
          // Serialize scalar item.
          add( prefix, obj );
      }
  }
  
  // Serialize an array of form elements or a set of
  // key/values into a query string
  jQuery.param = function( a, traditional ) {
      var prefix,
          s = [],
          add = function( key, value ) {
  
              // If value is a function, invoke it and return its value
              value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
              s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
          };
  
      // Set traditional to true for jQuery <= 1.3.2 behavior.
      if ( traditional === undefined ) {
          traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
      }
  
      // If an array was passed in, assume that it is an array of form elements.
      if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
  
          // Serialize the form elements
          jQuery.each( a, function() {
              add( this.name, this.value );
          } );
  
      } else {
  
          // If traditional, encode the "old" way (the way 1.3.2 or older
          // did it), otherwise encode params recursively.
          for ( prefix in a ) {
              buildParams( prefix, a[ prefix ], traditional, add );
          }
      }
  
      // Return the resulting serialization
      return s.join( "&" ).replace( r20, "+" );
  };
  
  jQuery.fn.extend( {
      serialize: function() {
          return jQuery.param( this.serializeArray() );
      },
      serializeArray: function() {
          return this.map( function() {
  
              // Can add propHook for "elements" to filter or add form elements
              var elements = jQuery.prop( this, "elements" );
              return elements ? jQuery.makeArray( elements ) : this;
          } )
          .filter( function() {
              var type = this.type;
  
              // Use .is(":disabled") so that fieldset[disabled] works
              return this.name && !jQuery( this ).is( ":disabled" ) &&
                  rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
                  ( this.checked || !rcheckableType.test( type ) );
          } )
          .map( function( i, elem ) {
              var val = jQuery( this ).val();
  
              return val == null ?
                  null :
                  jQuery.isArray( val ) ?
                      jQuery.map( val, function( val ) {
                          return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                      } ) :
                      { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
          } ).get();
      }
  } );
  
  
  // Create the request object
  // (This is still attached to ajaxSettings for backward compatibility)
  jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?
  
      // Support: IE6-IE8
      function() {
  
          // XHR cannot access local files, always use ActiveX for that case
          if ( this.isLocal ) {
              return createActiveXHR();
          }
  
          // Support: IE 9-11
          // IE seems to error on cross-domain PATCH requests when ActiveX XHR
          // is used. In IE 9+ always use the native XHR.
          // Note: this condition won't catch Edge as it doesn't define
          // document.documentMode but it also doesn't support ActiveX so it won't
          // reach this code.
          if ( document.documentMode > 8 ) {
              return createStandardXHR();
          }
  
          // Support: IE<9
          // oldIE XHR does not support non-RFC2616 methods (#13240)
          // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
          // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
          // Although this check for six methods instead of eight
          // since IE also does not support "trace" and "connect"
          return /^(get|post|head|put|delete|options)$/i.test( this.type ) &&
              createStandardXHR() || createActiveXHR();
      } :
  
      // For all other browsers, use the standard XMLHttpRequest object
      createStandardXHR;
  
  var xhrId = 0,
      xhrCallbacks = {},
      xhrSupported = jQuery.ajaxSettings.xhr();
  
  // Support: IE<10
  // Open requests must be manually aborted on unload (#5280)
  // See https://support.microsoft.com/kb/2856746 for more info
  if ( window.attachEvent ) {
      window.attachEvent( "onunload", function() {
          for ( var key in xhrCallbacks ) {
              xhrCallbacks[ key ]( undefined, true );
          }
      } );
  }
  
  // Determine support properties
  support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
  xhrSupported = support.ajax = !!xhrSupported;
  
  // Create transport if the browser can provide an xhr
  if ( xhrSupported ) {
  
      jQuery.ajaxTransport( function( options ) {
  
          // Cross domain only allowed if supported through XMLHttpRequest
          if ( !options.crossDomain || support.cors ) {
  
              var callback;
  
              return {
                  send: function( headers, complete ) {
                      var i,
                          xhr = options.xhr(),
                          id = ++xhrId;
  
                      // Open the socket
                      xhr.open(
                          options.type,
                          options.url,
                          options.async,
                          options.username,
                          options.password
                      );
  
                      // Apply custom fields if provided
                      if ( options.xhrFields ) {
                          for ( i in options.xhrFields ) {
                              xhr[ i ] = options.xhrFields[ i ];
                          }
                      }
  
                      // Override mime type if needed
                      if ( options.mimeType && xhr.overrideMimeType ) {
                          xhr.overrideMimeType( options.mimeType );
                      }
  
                      // X-Requested-With header
                      // For cross-domain requests, seeing as conditions for a preflight are
                      // akin to a jigsaw puzzle, we simply never set it to be sure.
                      // (it can always be set on a per-request basis or even using ajaxSetup)
                      // For same-domain requests, won't change header if already provided.
                      if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
                          headers[ "X-Requested-With" ] = "XMLHttpRequest";
                      }
  
                      // Set headers
                      for ( i in headers ) {
  
                          // Support: IE<9
                          // IE's ActiveXObject throws a 'Type Mismatch' exception when setting
                          // request header to a null-value.
                          //
                          // To keep consistent with other XHR implementations, cast the value
                          // to string and ignore `undefined`.
                          if ( headers[ i ] !== undefined ) {
                              xhr.setRequestHeader( i, headers[ i ] + "" );
                          }
                      }
  
                      // Do send the request
                      // This may raise an exception which is actually
                      // handled in jQuery.ajax (so no try/catch here)
                      xhr.send( ( options.hasContent && options.data ) || null );
  
                      // Listener
                      callback = function( _, isAbort ) {
                          var status, statusText, responses;
  
                          // Was never called and is aborted or complete
                          if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
  
                              // Clean up
                              delete xhrCallbacks[ id ];
                              callback = undefined;
                              xhr.onreadystatechange = jQuery.noop;
  
                              // Abort manually if needed
                              if ( isAbort ) {
                                  if ( xhr.readyState !== 4 ) {
                                      xhr.abort();
                                  }
                              } else {
                                  responses = {};
                                  status = xhr.status;
  
                                  // Support: IE<10
                                  // Accessing binary-data responseText throws an exception
                                  // (#11426)
                                  if ( typeof xhr.responseText === "string" ) {
                                      responses.text = xhr.responseText;
                                  }
  
                                  // Firefox throws an exception when accessing
                                  // statusText for faulty cross-domain requests
                                  try {
                                      statusText = xhr.statusText;
                                  } catch ( e ) {
  
                                      // We normalize with Webkit giving an empty statusText
                                      statusText = "";
                                  }
  
                                  // Filter status for non standard behaviors
  
                                  // If the request is local and we have data: assume a success
                                  // (success with no data won't get notified, that's the best we
                                  // can do given current implementations)
                                  if ( !status && options.isLocal && !options.crossDomain ) {
                                      status = responses.text ? 200 : 404;
  
                                  // IE - #1450: sometimes returns 1223 when it should be 204
                                  } else if ( status === 1223 ) {
                                      status = 204;
                                  }
                              }
                          }
  
                          // Call complete if needed
                          if ( responses ) {
                              complete( status, statusText, responses, xhr.getAllResponseHeaders() );
                          }
                      };
  
                      // Do send the request
                      // `xhr.send` may raise an exception, but it will be
                      // handled in jQuery.ajax (so no try/catch here)
                      if ( !options.async ) {
  
                          // If we're in sync mode we fire the callback
                          callback();
                      } else if ( xhr.readyState === 4 ) {
  
                          // (IE6 & IE7) if it's in cache and has been
                          // retrieved directly we need to fire the callback
                          window.setTimeout( callback );
                      } else {
  
                          // Register the callback, but delay it in case `xhr.send` throws
                          // Add to the list of active xhr callbacks
                          xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
                      }
                  },
  
                  abort: function() {
                      if ( callback ) {
                          callback( undefined, true );
                      }
                  }
              };
          }
      } );
  }
  
  // Functions to create xhrs
  function createStandardXHR() {
      try {
          return new window.XMLHttpRequest();
      } catch ( e ) {}
  }
  
  function createActiveXHR() {
      try {
          return new window.ActiveXObject( "Microsoft.XMLHTTP" );
      } catch ( e ) {}
  }
  
  
  
  
  // Install script dataType
  jQuery.ajaxSetup( {
      accepts: {
          script: "text/javascript, application/javascript, " +
              "application/ecmascript, application/x-ecmascript"
      },
      contents: {
          script: /\b(?:java|ecma)script\b/
      },
      converters: {
          "text script": function( text ) {
              jQuery.globalEval( text );
              return text;
          }
      }
  } );
  
  // Handle cache's special case and global
  jQuery.ajaxPrefilter( "script", function( s ) {
      if ( s.cache === undefined ) {
          s.cache = false;
      }
      if ( s.crossDomain ) {
          s.type = "GET";
          s.global = false;
      }
  } );
  
  // Bind script tag hack transport
  jQuery.ajaxTransport( "script", function( s ) {
  
      // This transport only deals with cross domain requests
      if ( s.crossDomain ) {
  
          var script,
              head = document.head || jQuery( "head" )[ 0 ] || document.documentElement;
  
          return {
  
              send: function( _, callback ) {
  
                  script = document.createElement( "script" );
  
                  script.async = true;
  
                  if ( s.scriptCharset ) {
                      script.charset = s.scriptCharset;
                  }
  
                  script.src = s.url;
  
                  // Attach handlers for all browsers
                  script.onload = script.onreadystatechange = function( _, isAbort ) {
  
                      if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {
  
                          // Handle memory leak in IE
                          script.onload = script.onreadystatechange = null;
  
                          // Remove the script
                          if ( script.parentNode ) {
                              script.parentNode.removeChild( script );
                          }
  
                          // Dereference the script
                          script = null;
  
                          // Callback if not abort
                          if ( !isAbort ) {
                              callback( 200, "success" );
                          }
                      }
                  };
  
                  // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
                  // Use native DOM manipulation to avoid our domManip AJAX trickery
                  head.insertBefore( script, head.firstChild );
              },
  
              abort: function() {
                  if ( script ) {
                      script.onload( undefined, true );
                  }
              }
          };
      }
  } );
  
  
  
  
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/;
  
  // Default jsonp settings
  jQuery.ajaxSetup( {
      jsonp: "callback",
      jsonpCallback: function() {
          var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
          this[ callback ] = true;
          return callback;
      }
  } );
  
  // Detect, normalize options and install callbacks for jsonp requests
  jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
  
      var callbackName, overwritten, responseContainer,
          jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
              "url" :
              typeof s.data === "string" &&
                  ( s.contentType || "" )
                      .indexOf( "application/x-www-form-urlencoded" ) === 0 &&
                  rjsonp.test( s.data ) && "data"
          );
  
      // Handle iff the expected data type is "jsonp" or we have a parameter to set
      if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
  
          // Get callback name, remembering preexisting value associated with it
          callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
              s.jsonpCallback() :
              s.jsonpCallback;
  
          // Insert callback into url or form data
          if ( jsonProp ) {
              s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
          } else if ( s.jsonp !== false ) {
              s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
          }
  
          // Use data converter to retrieve json after script execution
          s.converters[ "script json" ] = function() {
              if ( !responseContainer ) {
                  jQuery.error( callbackName + " was not called" );
              }
              return responseContainer[ 0 ];
          };
  
          // force json dataType
          s.dataTypes[ 0 ] = "json";
  
          // Install callback
          overwritten = window[ callbackName ];
          window[ callbackName ] = function() {
              responseContainer = arguments;
          };
  
          // Clean-up function (fires after converters)
          jqXHR.always( function() {
  
              // If previous value didn't exist - remove it
              if ( overwritten === undefined ) {
                  jQuery( window ).removeProp( callbackName );
  
              // Otherwise restore preexisting value
              } else {
                  window[ callbackName ] = overwritten;
              }
  
              // Save back as free
              if ( s[ callbackName ] ) {
  
                  // make sure that re-using the options doesn't screw things around
                  s.jsonpCallback = originalSettings.jsonpCallback;
  
                  // save the callback name for future use
                  oldCallbacks.push( callbackName );
              }
  
              // Call if it was a function and we have a response
              if ( responseContainer && jQuery.isFunction( overwritten ) ) {
                  overwritten( responseContainer[ 0 ] );
              }
  
              responseContainer = overwritten = undefined;
          } );
  
          // Delegate to script
          return "script";
      }
  } );
  
  
  
  
  // data: string of html
  // context (optional): If specified, the fragment will be created in this context,
  // defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string
  jQuery.parseHTML = function( data, context, keepScripts ) {
      if ( !data || typeof data !== "string" ) {
          return null;
      }
      if ( typeof context === "boolean" ) {
          keepScripts = context;
          context = false;
      }
      context = context || document;
  
      var parsed = rsingleTag.exec( data ),
          scripts = !keepScripts && [];
  
      // Single tag
      if ( parsed ) {
          return [ context.createElement( parsed[ 1 ] ) ];
      }
  
      parsed = buildFragment( [ data ], context, scripts );
  
      if ( scripts && scripts.length ) {
          jQuery( scripts ).remove();
      }
  
      return jQuery.merge( [], parsed.childNodes );
  };
  
  
  // Keep a copy of the old load method
  var _load = jQuery.fn.load;
  
  /**
   * Load a url into a page
   */
  jQuery.fn.load = function( url, params, callback ) {
      if ( typeof url !== "string" && _load ) {
          return _load.apply( this, arguments );
      }
  
      var selector, type, response,
          self = this,
          off = url.indexOf( " " );
  
      if ( off > -1 ) {
          selector = jQuery.trim( url.slice( off, url.length ) );
          url = url.slice( 0, off );
      }
  
      // If it's a function
      if ( jQuery.isFunction( params ) ) {
  
          // We assume that it's the callback
          callback = params;
          params = undefined;
  
      // Otherwise, build a param string
      } else if ( params && typeof params === "object" ) {
          type = "POST";
      }
  
      // If we have elements to modify, make the request
      if ( self.length > 0 ) {
          jQuery.ajax( {
              url: url,
  
              // If "type" variable is undefined, then "GET" method will be used.
              // Make value of this field explicit since
              // user can override it through ajaxSetup method
              type: type || "GET",
              dataType: "html",
              data: params
          } ).done( function( responseText ) {
  
              // Save response for use in complete callback
              response = arguments;
  
              self.html( selector ?
  
                  // If a selector was specified, locate the right elements in a dummy div
                  // Exclude scripts to avoid IE 'Permission Denied' errors
                  jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
  
                  // Otherwise use the full result
                  responseText );
  
          // If the request succeeds, this function gets "data", "status", "jqXHR"
          // but they are ignored because response was set above.
          // If it fails, this function gets "jqXHR", "status", "error"
          } ).always( callback && function( jqXHR, status ) {
              self.each( function() {
                  callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
              } );
          } );
      }
  
      return this;
  };
  
  
  
  
  // Attach a bunch of functions for handling common AJAX events
  jQuery.each( [
      "ajaxStart",
      "ajaxStop",
      "ajaxComplete",
      "ajaxError",
      "ajaxSuccess",
      "ajaxSend"
  ], function( i, type ) {
      jQuery.fn[ type ] = function( fn ) {
          return this.on( type, fn );
      };
  } );
  
  
  
  
  jQuery.expr.filters.animated = function( elem ) {
      return jQuery.grep( jQuery.timers, function( fn ) {
          return elem === fn.elem;
      } ).length;
  };
  
  
  
  
  
  /**
   * Gets a window from an element
   */
  function getWindow( elem ) {
      return jQuery.isWindow( elem ) ?
          elem :
          elem.nodeType === 9 ?
              elem.defaultView || elem.parentWindow :
              false;
  }
  
  jQuery.offset = {
      setOffset: function( elem, options, i ) {
          var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
              position = jQuery.css( elem, "position" ),
              curElem = jQuery( elem ),
              props = {};
  
          // set position first, in-case top/left are set even on static elem
          if ( position === "static" ) {
              elem.style.position = "relative";
          }
  
          curOffset = curElem.offset();
          curCSSTop = jQuery.css( elem, "top" );
          curCSSLeft = jQuery.css( elem, "left" );
          calculatePosition = ( position === "absolute" || position === "fixed" ) &&
              jQuery.inArray( "auto", [ curCSSTop, curCSSLeft ] ) > -1;
  
          // need to be able to calculate position if either top or left
          // is auto and position is either absolute or fixed
          if ( calculatePosition ) {
              curPosition = curElem.position();
              curTop = curPosition.top;
              curLeft = curPosition.left;
          } else {
              curTop = parseFloat( curCSSTop ) || 0;
              curLeft = parseFloat( curCSSLeft ) || 0;
          }
  
          if ( jQuery.isFunction( options ) ) {
  
              // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
              options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
          }
  
          if ( options.top != null ) {
              props.top = ( options.top - curOffset.top ) + curTop;
          }
          if ( options.left != null ) {
              props.left = ( options.left - curOffset.left ) + curLeft;
          }
  
          if ( "using" in options ) {
              options.using.call( elem, props );
          } else {
              curElem.css( props );
          }
      }
  };
  
  jQuery.fn.extend( {
      offset: function( options ) {
          if ( arguments.length ) {
              return options === undefined ?
                  this :
                  this.each( function( i ) {
                      jQuery.offset.setOffset( this, options, i );
                  } );
          }
  
          var docElem, win,
              box = { top: 0, left: 0 },
              elem = this[ 0 ],
              doc = elem && elem.ownerDocument;
  
          if ( !doc ) {
              return;
          }
  
          docElem = doc.documentElement;
  
          // Make sure it's not a disconnected DOM node
          if ( !jQuery.contains( docElem, elem ) ) {
              return box;
          }
  
          // If we don't have gBCR, just use 0,0 rather than error
          // BlackBerry 5, iOS 3 (original iPhone)
          if ( typeof elem.getBoundingClientRect !== "undefined" ) {
              box = elem.getBoundingClientRect();
          }
          win = getWindow( doc );
          return {
              top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
              left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
          };
      },
  
      position: function() {
          if ( !this[ 0 ] ) {
              return;
          }
  
          var offsetParent, offset,
              parentOffset = { top: 0, left: 0 },
              elem = this[ 0 ];
  
          // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
          // because it is its only offset parent
          if ( jQuery.css( elem, "position" ) === "fixed" ) {
  
              // we assume that getBoundingClientRect is available when computed position is fixed
              offset = elem.getBoundingClientRect();
          } else {
  
              // Get *real* offsetParent
              offsetParent = this.offsetParent();
  
              // Get correct offsets
              offset = this.offset();
              if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
                  parentOffset = offsetParent.offset();
              }
  
              // Add offsetParent borders
              parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
              parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
          }
  
          // Subtract parent offsets and element margins
          // note: when an element has margin: auto the offsetLeft and marginLeft
          // are the same in Safari causing offset.left to incorrectly be 0
          return {
              top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
              left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
          };
      },
  
      offsetParent: function() {
          return this.map( function() {
              var offsetParent = this.offsetParent;
  
              while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) &&
                  jQuery.css( offsetParent, "position" ) === "static" ) ) {
                  offsetParent = offsetParent.offsetParent;
              }
              return offsetParent || documentElement;
          } );
      }
  } );
  
  // Create scrollLeft and scrollTop methods
  jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
      var top = /Y/.test( prop );
  
      jQuery.fn[ method ] = function( val ) {
          return access( this, function( elem, method, val ) {
              var win = getWindow( elem );
  
              if ( val === undefined ) {
                  return win ? ( prop in win ) ? win[ prop ] :
                      win.document.documentElement[ method ] :
                      elem[ method ];
              }
  
              if ( win ) {
                  win.scrollTo(
                      !top ? val : jQuery( win ).scrollLeft(),
                      top ? val : jQuery( win ).scrollTop()
                  );
  
              } else {
                  elem[ method ] = val;
              }
          }, method, val, arguments.length, null );
      };
  } );
  
  // Support: Safari<7-8+, Chrome<37-44+
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // getComputedStyle returns percent when specified for top/left/bottom/right
  // rather than make the css module depend on the offset module, we just check for it here
  jQuery.each( [ "top", "left" ], function( i, prop ) {
      jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
          function( elem, computed ) {
              if ( computed ) {
                  computed = curCSS( elem, prop );
  
                  // if curCSS returns percentage, fallback to offset
                  return rnumnonpx.test( computed ) ?
                      jQuery( elem ).position()[ prop ] + "px" :
                      computed;
              }
          }
      );
  } );
  
  
  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
  jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
      jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
      function( defaultExtra, funcName ) {
  
          // margin is only for outerHeight, outerWidth
          jQuery.fn[ funcName ] = function( margin, value ) {
              var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                  extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
  
              return access( this, function( elem, type, value ) {
                  var doc;
  
                  if ( jQuery.isWindow( elem ) ) {
  
                      // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                      // isn't a whole lot we can do. See pull request at this URL for discussion:
                      // https://github.com/jquery/jquery/pull/764
                      return elem.document.documentElement[ "client" + name ];
                  }
  
                  // Get document width or height
                  if ( elem.nodeType === 9 ) {
                      doc = elem.documentElement;
  
                      // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                      // whichever is greatest
                      // unfortunately, this causes bug #3838 in IE6/8 only,
                      // but there is currently no good, small way to fix it.
                      return Math.max(
                          elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                          elem.body[ "offset" + name ], doc[ "offset" + name ],
                          doc[ "client" + name ]
                      );
                  }
  
                  return value === undefined ?
  
                      // Get width or height on the element, requesting but not forcing parseFloat
                      jQuery.css( elem, type, extra ) :
  
                      // Set width or height on the element
                      jQuery.style( elem, type, value, extra );
              }, type, chainable ? margin : undefined, chainable, null );
          };
      } );
  } );
  
  
  jQuery.fn.extend( {
  
      bind: function( types, data, fn ) {
          return this.on( types, null, data, fn );
      },
      unbind: function( types, fn ) {
          return this.off( types, null, fn );
      },
  
      delegate: function( selector, types, data, fn ) {
          return this.on( types, selector, data, fn );
      },
      undelegate: function( selector, types, fn ) {
  
          // ( namespace ) or ( selector, types [, fn] )
          return arguments.length === 1 ?
              this.off( selector, "**" ) :
              this.off( types, selector || "**", fn );
      }
  } );
  
  // The number of elements contained in the matched element set
  jQuery.fn.size = function() {
      return this.length;
  };
  
  jQuery.fn.andSelf = jQuery.fn.addBack;
  
  
  
  
  // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.
  
  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
  
  if ( typeof define === "function" && define.amd ) {
      define( "jquery", [], function() {
          return jQuery;
      } );
  }
  
  
  
  var
  
      // Map over jQuery in case of overwrite
      _jQuery = window.jQuery,
  
      // Map over the $ in case of overwrite
      _$ = window.$;
  
  jQuery.noConflict = function( deep ) {
      if ( window.$ === jQuery ) {
          window.$ = _$;
      }
  
      if ( deep && window.jQuery === jQuery ) {
          window.jQuery = _jQuery;
      }
  
      return jQuery;
  };
  
  // Expose jQuery and $ identifiers, even in
  // AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)
  if ( !noGlobal ) {
      window.jQuery = window.$ = jQuery;
  }
  
  return jQuery;
  }));
  /*! jQuery UI - v1.12.1 - 2016-09-14
  * http://jqueryui.com
  * Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-1-7.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js
  * Copyright jQuery Foundation and other contributors; Licensed MIT */
  
  
  (function(t){"function"==typeof define&&define.amd?define(["jquery"],t):t(jQuery)})(function(t){function e(t){for(var e=t.css("visibility");"inherit"===e;)t=t.parent(),e=t.css("visibility");return"hidden"!==e}function i(t){for(var e,i;t.length&&t[0]!==document;){if(e=t.css("position"),("absolute"===e||"relative"===e||"fixed"===e)&&(i=parseInt(t.css("zIndex"),10),!isNaN(i)&&0!==i))return i;t=t.parent()}return 0}function s(){this._curInst=null,this._keyEvent=!1,this._disabledInputs=[],this._datepickerShowing=!1,this._inDialog=!1,this._mainDivId="ui-datepicker-div",this._inlineClass="ui-datepicker-inline",this._appendClass="ui-datepicker-append",this._triggerClass="ui-datepicker-trigger",this._dialogClass="ui-datepicker-dialog",this._disableClass="ui-datepicker-disabled",this._unselectableClass="ui-datepicker-unselectable",this._currentClass="ui-datepicker-current-day",this._dayOverClass="ui-datepicker-days-cell-over",this.regional=[],this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""},this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:!1,hideIfNoPrevNext:!1,navigationAsDateFormat:!1,gotoCurrent:!1,changeMonth:!1,changeYear:!1,yearRange:"c-10:c+10",showOtherMonths:!1,selectOtherMonths:!1,showWeek:!1,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:!0,showButtonPanel:!1,autoSize:!1,disabled:!1},t.extend(this._defaults,this.regional[""]),this.regional.en=t.extend(!0,{},this.regional[""]),this.regional["en-US"]=t.extend(!0,{},this.regional.en),this.dpDiv=n(t("<div id='"+this._mainDivId+"' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))}function n(e){var i="button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";return e.on("mouseout",i,function(){t(this).removeClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&t(this).removeClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&t(this).removeClass("ui-datepicker-next-hover")}).on("mouseover",i,o)}function o(){t.datepicker._isDisabledDatepicker(m.inline?m.dpDiv.parent()[0]:m.input[0])||(t(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"),t(this).addClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&t(this).addClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&t(this).addClass("ui-datepicker-next-hover"))}function a(e,i){t.extend(e,i);for(var s in i)null==i[s]&&(e[s]=i[s]);return e}function r(t){return function(){var e=this.element.val();t.apply(this,arguments),this._refresh(),e!==this.element.val()&&this._trigger("change")}}t.ui=t.ui||{},t.ui.version="1.12.1";var h=0,l=Array.prototype.slice;t.cleanData=function(e){return function(i){var s,n,o;for(o=0;null!=(n=i[o]);o++)try{s=t._data(n,"events"),s&&s.remove&&t(n).triggerHandler("remove")}catch(a){}e(i)}}(t.cleanData),t.widget=function(e,i,s){var n,o,a,r={},h=e.split(".")[0];e=e.split(".")[1];var l=h+"-"+e;return s||(s=i,i=t.Widget),t.isArray(s)&&(s=t.extend.apply(null,[{}].concat(s))),t.expr[":"][l.toLowerCase()]=function(e){return!!t.data(e,l)},t[h]=t[h]||{},n=t[h][e],o=t[h][e]=function(t,e){return this._createWidget?(arguments.length&&this._createWidget(t,e),void 0):new o(t,e)},t.extend(o,n,{version:s.version,_proto:t.extend({},s),_childConstructors:[]}),a=new i,a.options=t.widget.extend({},a.options),t.each(s,function(e,s){return t.isFunction(s)?(r[e]=function(){function t(){return i.prototype[e].apply(this,arguments)}function n(t){return i.prototype[e].apply(this,t)}return function(){var e,i=this._super,o=this._superApply;return this._super=t,this._superApply=n,e=s.apply(this,arguments),this._super=i,this._superApply=o,e}}(),void 0):(r[e]=s,void 0)}),o.prototype=t.widget.extend(a,{widgetEventPrefix:n?a.widgetEventPrefix||e:e},r,{constructor:o,namespace:h,widgetName:e,widgetFullName:l}),n?(t.each(n._childConstructors,function(e,i){var s=i.prototype;t.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete n._childConstructors):i._childConstructors.push(o),t.widget.bridge(e,o),o},t.widget.extend=function(e){for(var i,s,n=l.call(arguments,1),o=0,a=n.length;a>o;o++)for(i in n[o])s=n[o][i],n[o].hasOwnProperty(i)&&void 0!==s&&(e[i]=t.isPlainObject(s)?t.isPlainObject(e[i])?t.widget.extend({},e[i],s):t.widget.extend({},s):s);return e},t.widget.bridge=function(e,i){var s=i.prototype.widgetFullName||e;t.fn[e]=function(n){var o="string"==typeof n,a=l.call(arguments,1),r=this;return o?this.length||"instance"!==n?this.each(function(){var i,o=t.data(this,s);return"instance"===n?(r=o,!1):o?t.isFunction(o[n])&&"_"!==n.charAt(0)?(i=o[n].apply(o,a),i!==o&&void 0!==i?(r=i&&i.jquery?r.pushStack(i.get()):i,!1):void 0):t.error("no such method '"+n+"' for "+e+" widget instance"):t.error("cannot call methods on "+e+" prior to initialization; "+"attempted to call method '"+n+"'")}):r=void 0:(a.length&&(n=t.widget.extend.apply(null,[n].concat(a))),this.each(function(){var e=t.data(this,s);e?(e.option(n||{}),e._init&&e._init()):t.data(this,s,new i(n,this))})),r}},t.Widget=function(){},t.Widget._childConstructors=[],t.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{classes:{},disabled:!1,create:null},_createWidget:function(e,i){i=t(i||this.defaultElement||this)[0],this.element=t(i),this.uuid=h++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=t(),this.hoverable=t(),this.focusable=t(),this.classesElementLookup={},i!==this&&(t.data(i,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===i&&this.destroy()}}),this.document=t(i.style?i.ownerDocument:i.document||i),this.window=t(this.document[0].defaultView||this.document[0].parentWindow)),this.options=t.widget.extend({},this.options,this._getCreateOptions(),e),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:t.noop,_create:t.noop,_init:t.noop,destroy:function(){var e=this;this._destroy(),t.each(this.classesElementLookup,function(t,i){e._removeClass(i,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr("aria-disabled"),this.bindings.off(this.eventNamespace)},_destroy:t.noop,widget:function(){return this.element},option:function(e,i){var s,n,o,a=e;if(0===arguments.length)return t.widget.extend({},this.options);if("string"==typeof e)if(a={},s=e.split("."),e=s.shift(),s.length){for(n=a[e]=t.widget.extend({},this.options[e]),o=0;s.length-1>o;o++)n[s[o]]=n[s[o]]||{},n=n[s[o]];if(e=s.pop(),1===arguments.length)return void 0===n[e]?null:n[e];n[e]=i}else{if(1===arguments.length)return void 0===this.options[e]?null:this.options[e];a[e]=i}return this._setOptions(a),this},_setOptions:function(t){var e;for(e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return"classes"===t&&this._setOptionClasses(e),this.options[t]=e,"disabled"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(e){var i,s,n;for(i in e)n=this.classesElementLookup[i],e[i]!==this.options.classes[i]&&n&&n.length&&(s=t(n.get()),this._removeClass(n,i),s.addClass(this._classes({element:s,keys:i,classes:e,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!!t),t&&(this._removeClass(this.hoverable,null,"ui-state-hover"),this._removeClass(this.focusable,null,"ui-state-focus"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(e){function i(i,o){var a,r;for(r=0;i.length>r;r++)a=n.classesElementLookup[i[r]]||t(),a=e.add?t(t.unique(a.get().concat(e.element.get()))):t(a.not(e.element).get()),n.classesElementLookup[i[r]]=a,s.push(i[r]),o&&e.classes[i[r]]&&s.push(e.classes[i[r]])}var s=[],n=this;return e=t.extend({element:this.element,classes:this.options.classes||{}},e),this._on(e.element,{remove:"_untrackClassesElement"}),e.keys&&i(e.keys.match(/\S+/g)||[],!0),e.extra&&i(e.extra.match(/\S+/g)||[]),s.join(" ")},_untrackClassesElement:function(e){var i=this;t.each(i.classesElementLookup,function(s,n){-1!==t.inArray(e.target,n)&&(i.classesElementLookup[s]=t(n.not(e.target).get()))})},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){s="boolean"==typeof s?s:i;var n="string"==typeof t||null===t,o={extra:n?e:i,keys:n?t:e,element:n?this.element:t,add:s};return o.element.toggleClass(this._classes(o),s),this},_on:function(e,i,s){var n,o=this;"boolean"!=typeof e&&(s=i,i=e,e=!1),s?(i=n=t(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,n=this.widget()),t.each(s,function(s,a){function r(){return e||o.options.disabled!==!0&&!t(this).hasClass("ui-state-disabled")?("string"==typeof a?o[a]:a).apply(o,arguments):void 0}"string"!=typeof a&&(r.guid=a.guid=a.guid||r.guid||t.guid++);var h=s.match(/^([\w:-]*)\s*(.*)$/),l=h[1]+o.eventNamespace,c=h[2];c?n.on(l,c,r):i.on(l,r)})},_off:function(e,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.off(i).off(i),this.bindings=t(this.bindings.not(e).get()),this.focusable=t(this.focusable.not(e).get()),this.hoverable=t(this.hoverable.not(e).get())},_delay:function(t,e){function i(){return("string"==typeof t?s[t]:t).apply(s,arguments)}var s=this;return setTimeout(i,e||0)},_hoverable:function(e){this.hoverable=this.hoverable.add(e),this._on(e,{mouseenter:function(e){this._addClass(t(e.currentTarget),null,"ui-state-hover")},mouseleave:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-hover")}})},_focusable:function(e){this.focusable=this.focusable.add(e),this._on(e,{focusin:function(e){this._addClass(t(e.currentTarget),null,"ui-state-focus")},focusout:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-focus")}})},_trigger:function(e,i,s){var n,o,a=this.options[e];if(s=s||{},i=t.Event(i),i.type=(e===this.widgetEventPrefix?e:this.widgetEventPrefix+e).toLowerCase(),i.target=this.element[0],o=i.originalEvent)for(n in o)n in i||(i[n]=o[n]);return this.element.trigger(i,s),!(t.isFunction(a)&&a.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},t.each({show:"fadeIn",hide:"fadeOut"},function(e,i){t.Widget.prototype["_"+e]=function(s,n,o){"string"==typeof n&&(n={effect:n});var a,r=n?n===!0||"number"==typeof n?i:n.effect||i:e;n=n||{},"number"==typeof n&&(n={duration:n}),a=!t.isEmptyObject(n),n.complete=o,n.delay&&s.delay(n.delay),a&&t.effects&&t.effects.effect[r]?s[e](n):r!==e&&s[r]?s[r](n.duration,n.easing,o):s.queue(function(i){t(this)[e](),o&&o.call(s[0]),i()})}}),t.widget,function(){function e(t,e,i){return[parseFloat(t[0])*(u.test(t[0])?e/100:1),parseFloat(t[1])*(u.test(t[1])?i/100:1)]}function i(e,i){return parseInt(t.css(e,i),10)||0}function s(e){var i=e[0];return 9===i.nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:t.isWindow(i)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()}}var n,o=Math.max,a=Math.abs,r=/left|center|right/,h=/top|center|bottom/,l=/[\+\-]\d+(\.[\d]+)?%?/,c=/^\w+/,u=/%$/,d=t.fn.position;t.position={scrollbarWidth:function(){if(void 0!==n)return n;var e,i,s=t("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),o=s.children()[0];return t("body").append(s),e=o.offsetWidth,s.css("overflow","scroll"),i=o.offsetWidth,e===i&&(i=s[0].clientWidth),s.remove(),n=e-i},getScrollInfo:function(e){var i=e.isWindow||e.isDocument?"":e.element.css("overflow-x"),s=e.isWindow||e.isDocument?"":e.element.css("overflow-y"),n="scroll"===i||"auto"===i&&e.width<e.element[0].scrollWidth,o="scroll"===s||"auto"===s&&e.height<e.element[0].scrollHeight;return{width:o?t.position.scrollbarWidth():0,height:n?t.position.scrollbarWidth():0}},getWithinInfo:function(e){var i=t(e||window),s=t.isWindow(i[0]),n=!!i[0]&&9===i[0].nodeType,o=!s&&!n;return{element:i,isWindow:s,isDocument:n,offset:o?t(e).offset():{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:i.outerWidth(),height:i.outerHeight()}}},t.fn.position=function(n){if(!n||!n.of)return d.apply(this,arguments);n=t.extend({},n);var u,p,f,g,m,_,v=t(n.of),b=t.position.getWithinInfo(n.within),y=t.position.getScrollInfo(b),w=(n.collision||"flip").split(" "),k={};return _=s(v),v[0].preventDefault&&(n.at="left top"),p=_.width,f=_.height,g=_.offset,m=t.extend({},g),t.each(["my","at"],function(){var t,e,i=(n[this]||"").split(" ");1===i.length&&(i=r.test(i[0])?i.concat(["center"]):h.test(i[0])?["center"].concat(i):["center","center"]),i[0]=r.test(i[0])?i[0]:"center",i[1]=h.test(i[1])?i[1]:"center",t=l.exec(i[0]),e=l.exec(i[1]),k[this]=[t?t[0]:0,e?e[0]:0],n[this]=[c.exec(i[0])[0],c.exec(i[1])[0]]}),1===w.length&&(w[1]=w[0]),"right"===n.at[0]?m.left+=p:"center"===n.at[0]&&(m.left+=p/2),"bottom"===n.at[1]?m.top+=f:"center"===n.at[1]&&(m.top+=f/2),u=e(k.at,p,f),m.left+=u[0],m.top+=u[1],this.each(function(){var s,r,h=t(this),l=h.outerWidth(),c=h.outerHeight(),d=i(this,"marginLeft"),_=i(this,"marginTop"),x=l+d+i(this,"marginRight")+y.width,C=c+_+i(this,"marginBottom")+y.height,D=t.extend({},m),I=e(k.my,h.outerWidth(),h.outerHeight());"right"===n.my[0]?D.left-=l:"center"===n.my[0]&&(D.left-=l/2),"bottom"===n.my[1]?D.top-=c:"center"===n.my[1]&&(D.top-=c/2),D.left+=I[0],D.top+=I[1],s={marginLeft:d,marginTop:_},t.each(["left","top"],function(e,i){t.ui.position[w[e]]&&t.ui.position[w[e]][i](D,{targetWidth:p,targetHeight:f,elemWidth:l,elemHeight:c,collisionPosition:s,collisionWidth:x,collisionHeight:C,offset:[u[0]+I[0],u[1]+I[1]],my:n.my,at:n.at,within:b,elem:h})}),n.using&&(r=function(t){var e=g.left-D.left,i=e+p-l,s=g.top-D.top,r=s+f-c,u={target:{element:v,left:g.left,top:g.top,width:p,height:f},element:{element:h,left:D.left,top:D.top,width:l,height:c},horizontal:0>i?"left":e>0?"right":"center",vertical:0>r?"top":s>0?"bottom":"middle"};l>p&&p>a(e+i)&&(u.horizontal="center"),c>f&&f>a(s+r)&&(u.vertical="middle"),u.important=o(a(e),a(i))>o(a(s),a(r))?"horizontal":"vertical",n.using.call(this,t,u)}),h.offset(t.extend(D,{using:r}))})},t.ui.position={fit:{left:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollLeft:s.offset.left,a=s.width,r=t.left-e.collisionPosition.marginLeft,h=n-r,l=r+e.collisionWidth-a-n;e.collisionWidth>a?h>0&&0>=l?(i=t.left+h+e.collisionWidth-a-n,t.left+=h-i):t.left=l>0&&0>=h?n:h>l?n+a-e.collisionWidth:n:h>0?t.left+=h:l>0?t.left-=l:t.left=o(t.left-r,t.left)},top:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollTop:s.offset.top,a=e.within.height,r=t.top-e.collisionPosition.marginTop,h=n-r,l=r+e.collisionHeight-a-n;e.collisionHeight>a?h>0&&0>=l?(i=t.top+h+e.collisionHeight-a-n,t.top+=h-i):t.top=l>0&&0>=h?n:h>l?n+a-e.collisionHeight:n:h>0?t.top+=h:l>0?t.top-=l:t.top=o(t.top-r,t.top)}},flip:{left:function(t,e){var i,s,n=e.within,o=n.offset.left+n.scrollLeft,r=n.width,h=n.isWindow?n.scrollLeft:n.offset.left,l=t.left-e.collisionPosition.marginLeft,c=l-h,u=l+e.collisionWidth-r-h,d="left"===e.my[0]?-e.elemWidth:"right"===e.my[0]?e.elemWidth:0,p="left"===e.at[0]?e.targetWidth:"right"===e.at[0]?-e.targetWidth:0,f=-2*e.offset[0];0>c?(i=t.left+d+p+f+e.collisionWidth-r-o,(0>i||a(c)>i)&&(t.left+=d+p+f)):u>0&&(s=t.left-e.collisionPosition.marginLeft+d+p+f-h,(s>0||u>a(s))&&(t.left+=d+p+f))},top:function(t,e){var i,s,n=e.within,o=n.offset.top+n.scrollTop,r=n.height,h=n.isWindow?n.scrollTop:n.offset.top,l=t.top-e.collisionPosition.marginTop,c=l-h,u=l+e.collisionHeight-r-h,d="top"===e.my[1],p=d?-e.elemHeight:"bottom"===e.my[1]?e.elemHeight:0,f="top"===e.at[1]?e.targetHeight:"bottom"===e.at[1]?-e.targetHeight:0,g=-2*e.offset[1];0>c?(s=t.top+p+f+g+e.collisionHeight-r-o,(0>s||a(c)>s)&&(t.top+=p+f+g)):u>0&&(i=t.top-e.collisionPosition.marginTop+p+f+g-h,(i>0||u>a(i))&&(t.top+=p+f+g))}},flipfit:{left:function(){t.ui.position.flip.left.apply(this,arguments),t.ui.position.fit.left.apply(this,arguments)},top:function(){t.ui.position.flip.top.apply(this,arguments),t.ui.position.fit.top.apply(this,arguments)}}}}(),t.ui.position,t.extend(t.expr[":"],{data:t.expr.createPseudo?t.expr.createPseudo(function(e){return function(i){return!!t.data(i,e)}}):function(e,i,s){return!!t.data(e,s[3])}}),t.fn.extend({disableSelection:function(){var t="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.on(t+".ui-disableSelection",function(t){t.preventDefault()})}}(),enableSelection:function(){return this.off(".ui-disableSelection")}});var c="ui-effects-",u="ui-effects-style",d="ui-effects-animated",p=t;t.effects={effect:{}},function(t,e){function i(t,e,i){var s=u[e.type]||{};return null==t?i||!e.def?null:e.def:(t=s.floor?~~t:parseFloat(t),isNaN(t)?e.def:s.mod?(t+s.mod)%s.mod:0>t?0:t>s.max?s.max:t)}function s(i){var s=l(),n=s._rgba=[];return i=i.toLowerCase(),f(h,function(t,o){var a,r=o.re.exec(i),h=r&&o.parse(r),l=o.space||"rgba";return h?(a=s[l](h),s[c[l].cache]=a[c[l].cache],n=s._rgba=a._rgba,!1):e}),n.length?("0,0,0,0"===n.join()&&t.extend(n,o.transparent),s):o[i]}function n(t,e,i){return i=(i+1)%1,1>6*i?t+6*(e-t)*i:1>2*i?e:2>3*i?t+6*(e-t)*(2/3-i):t}var o,a="backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",r=/^([\-+])=\s*(\d+\.?\d*)/,h=[{re:/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[t[1],t[2],t[3],t[4]]}},{re:/rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[2.55*t[1],2.55*t[2],2.55*t[3],t[4]]}},{re:/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,parse:function(t){return[parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16)]}},{re:/#([a-f0-9])([a-f0-9])([a-f0-9])/,parse:function(t){return[parseInt(t[1]+t[1],16),parseInt(t[2]+t[2],16),parseInt(t[3]+t[3],16)]}},{re:/hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,space:"hsla",parse:function(t){return[t[1],t[2]/100,t[3]/100,t[4]]}}],l=t.Color=function(e,i,s,n){return new t.Color.fn.parse(e,i,s,n)},c={rgba:{props:{red:{idx:0,type:"byte"},green:{idx:1,type:"byte"},blue:{idx:2,type:"byte"}}},hsla:{props:{hue:{idx:0,type:"degrees"},saturation:{idx:1,type:"percent"},lightness:{idx:2,type:"percent"}}}},u={"byte":{floor:!0,max:255},percent:{max:1},degrees:{mod:360,floor:!0}},d=l.support={},p=t("<p>")[0],f=t.each;p.style.cssText="background-color:rgba(1,1,1,.5)",d.rgba=p.style.backgroundColor.indexOf("rgba")>-1,f(c,function(t,e){e.cache="_"+t,e.props.alpha={idx:3,type:"percent",def:1}}),l.fn=t.extend(l.prototype,{parse:function(n,a,r,h){if(n===e)return this._rgba=[null,null,null,null],this;(n.jquery||n.nodeType)&&(n=t(n).css(a),a=e);var u=this,d=t.type(n),p=this._rgba=[];return a!==e&&(n=[n,a,r,h],d="array"),"string"===d?this.parse(s(n)||o._default):"array"===d?(f(c.rgba.props,function(t,e){p[e.idx]=i(n[e.idx],e)}),this):"object"===d?(n instanceof l?f(c,function(t,e){n[e.cache]&&(u[e.cache]=n[e.cache].slice())}):f(c,function(e,s){var o=s.cache;f(s.props,function(t,e){if(!u[o]&&s.to){if("alpha"===t||null==n[t])return;u[o]=s.to(u._rgba)}u[o][e.idx]=i(n[t],e,!0)}),u[o]&&0>t.inArray(null,u[o].slice(0,3))&&(u[o][3]=1,s.from&&(u._rgba=s.from(u[o])))}),this):e},is:function(t){var i=l(t),s=!0,n=this;return f(c,function(t,o){var a,r=i[o.cache];return r&&(a=n[o.cache]||o.to&&o.to(n._rgba)||[],f(o.props,function(t,i){return null!=r[i.idx]?s=r[i.idx]===a[i.idx]:e})),s}),s},_space:function(){var t=[],e=this;return f(c,function(i,s){e[s.cache]&&t.push(i)}),t.pop()},transition:function(t,e){var s=l(t),n=s._space(),o=c[n],a=0===this.alpha()?l("transparent"):this,r=a[o.cache]||o.to(a._rgba),h=r.slice();return s=s[o.cache],f(o.props,function(t,n){var o=n.idx,a=r[o],l=s[o],c=u[n.type]||{};null!==l&&(null===a?h[o]=l:(c.mod&&(l-a>c.mod/2?a+=c.mod:a-l>c.mod/2&&(a-=c.mod)),h[o]=i((l-a)*e+a,n)))}),this[n](h)},blend:function(e){if(1===this._rgba[3])return this;var i=this._rgba.slice(),s=i.pop(),n=l(e)._rgba;return l(t.map(i,function(t,e){return(1-s)*n[e]+s*t}))},toRgbaString:function(){var e="rgba(",i=t.map(this._rgba,function(t,e){return null==t?e>2?1:0:t});return 1===i[3]&&(i.pop(),e="rgb("),e+i.join()+")"},toHslaString:function(){var e="hsla(",i=t.map(this.hsla(),function(t,e){return null==t&&(t=e>2?1:0),e&&3>e&&(t=Math.round(100*t)+"%"),t});return 1===i[3]&&(i.pop(),e="hsl("),e+i.join()+")"},toHexString:function(e){var i=this._rgba.slice(),s=i.pop();return e&&i.push(~~(255*s)),"#"+t.map(i,function(t){return t=(t||0).toString(16),1===t.length?"0"+t:t}).join("")},toString:function(){return 0===this._rgba[3]?"transparent":this.toRgbaString()}}),l.fn.parse.prototype=l.fn,c.hsla.to=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e,i,s=t[0]/255,n=t[1]/255,o=t[2]/255,a=t[3],r=Math.max(s,n,o),h=Math.min(s,n,o),l=r-h,c=r+h,u=.5*c;return e=h===r?0:s===r?60*(n-o)/l+360:n===r?60*(o-s)/l+120:60*(s-n)/l+240,i=0===l?0:.5>=u?l/c:l/(2-c),[Math.round(e)%360,i,u,null==a?1:a]},c.hsla.from=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e=t[0]/360,i=t[1],s=t[2],o=t[3],a=.5>=s?s*(1+i):s+i-s*i,r=2*s-a;return[Math.round(255*n(r,a,e+1/3)),Math.round(255*n(r,a,e)),Math.round(255*n(r,a,e-1/3)),o]},f(c,function(s,n){var o=n.props,a=n.cache,h=n.to,c=n.from;l.fn[s]=function(s){if(h&&!this[a]&&(this[a]=h(this._rgba)),s===e)return this[a].slice();var n,r=t.type(s),u="array"===r||"object"===r?s:arguments,d=this[a].slice();return f(o,function(t,e){var s=u["object"===r?t:e.idx];null==s&&(s=d[e.idx]),d[e.idx]=i(s,e)}),c?(n=l(c(d)),n[a]=d,n):l(d)},f(o,function(e,i){l.fn[e]||(l.fn[e]=function(n){var o,a=t.type(n),h="alpha"===e?this._hsla?"hsla":"rgba":s,l=this[h](),c=l[i.idx];return"undefined"===a?c:("function"===a&&(n=n.call(this,c),a=t.type(n)),null==n&&i.empty?this:("string"===a&&(o=r.exec(n),o&&(n=c+parseFloat(o[2])*("+"===o[1]?1:-1))),l[i.idx]=n,this[h](l)))})})}),l.hook=function(e){var i=e.split(" ");f(i,function(e,i){t.cssHooks[i]={set:function(e,n){var o,a,r="";if("transparent"!==n&&("string"!==t.type(n)||(o=s(n)))){if(n=l(o||n),!d.rgba&&1!==n._rgba[3]){for(a="backgroundColor"===i?e.parentNode:e;(""===r||"transparent"===r)&&a&&a.style;)try{r=t.css(a,"backgroundColor"),a=a.parentNode}catch(h){}n=n.blend(r&&"transparent"!==r?r:"_default")}n=n.toRgbaString()}try{e.style[i]=n}catch(h){}}},t.fx.step[i]=function(e){e.colorInit||(e.start=l(e.elem,i),e.end=l(e.end),e.colorInit=!0),t.cssHooks[i].set(e.elem,e.start.transition(e.end,e.pos))}})},l.hook(a),t.cssHooks.borderColor={expand:function(t){var e={};return f(["Top","Right","Bottom","Left"],function(i,s){e["border"+s+"Color"]=t}),e}},o=t.Color.names={aqua:"#00ffff",black:"#000000",blue:"#0000ff",fuchsia:"#ff00ff",gray:"#808080",green:"#008000",lime:"#00ff00",maroon:"#800000",navy:"#000080",olive:"#808000",purple:"#800080",red:"#ff0000",silver:"#c0c0c0",teal:"#008080",white:"#ffffff",yellow:"#ffff00",transparent:[null,null,null,0],_default:"#ffffff"}}(p),function(){function e(e){var i,s,n=e.ownerDocument.defaultView?e.ownerDocument.defaultView.getComputedStyle(e,null):e.currentStyle,o={};if(n&&n.length&&n[0]&&n[n[0]])for(s=n.length;s--;)i=n[s],"string"==typeof n[i]&&(o[t.camelCase(i)]=n[i]);else for(i in n)"string"==typeof n[i]&&(o[i]=n[i]);return o}function i(e,i){var s,o,a={};for(s in i)o=i[s],e[s]!==o&&(n[s]||(t.fx.step[s]||!isNaN(parseFloat(o)))&&(a[s]=o));return a}var s=["add","remove","toggle"],n={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};t.each(["borderLeftStyle","borderRightStyle","borderBottomStyle","borderTopStyle"],function(e,i){t.fx.step[i]=function(t){("none"!==t.end&&!t.setAttr||1===t.pos&&!t.setAttr)&&(p.style(t.elem,i,t.end),t.setAttr=!0)}}),t.fn.addBack||(t.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),t.effects.animateClass=function(n,o,a,r){var h=t.speed(o,a,r);return this.queue(function(){var o,a=t(this),r=a.attr("class")||"",l=h.children?a.find("*").addBack():a;l=l.map(function(){var i=t(this);return{el:i,start:e(this)}}),o=function(){t.each(s,function(t,e){n[e]&&a[e+"Class"](n[e])})},o(),l=l.map(function(){return this.end=e(this.el[0]),this.diff=i(this.start,this.end),this}),a.attr("class",r),l=l.map(function(){var e=this,i=t.Deferred(),s=t.extend({},h,{queue:!1,complete:function(){i.resolve(e)}});return this.el.animate(this.diff,s),i.promise()}),t.when.apply(t,l.get()).done(function(){o(),t.each(arguments,function(){var e=this.el;t.each(this.diff,function(t){e.css(t,"")})}),h.complete.call(a[0])})})},t.fn.extend({addClass:function(e){return function(i,s,n,o){return s?t.effects.animateClass.call(this,{add:i},s,n,o):e.apply(this,arguments)}}(t.fn.addClass),removeClass:function(e){return function(i,s,n,o){return arguments.length>1?t.effects.animateClass.call(this,{remove:i},s,n,o):e.apply(this,arguments)}}(t.fn.removeClass),toggleClass:function(e){return function(i,s,n,o,a){return"boolean"==typeof s||void 0===s?n?t.effects.animateClass.call(this,s?{add:i}:{remove:i},n,o,a):e.apply(this,arguments):t.effects.animateClass.call(this,{toggle:i},s,n,o)}}(t.fn.toggleClass),switchClass:function(e,i,s,n,o){return t.effects.animateClass.call(this,{add:i,remove:e},s,n,o)}})}(),function(){function e(e,i,s,n){return t.isPlainObject(e)&&(i=e,e=e.effect),e={effect:e},null==i&&(i={}),t.isFunction(i)&&(n=i,s=null,i={}),("number"==typeof i||t.fx.speeds[i])&&(n=s,s=i,i={}),t.isFunction(s)&&(n=s,s=null),i&&t.extend(e,i),s=s||i.duration,e.duration=t.fx.off?0:"number"==typeof s?s:s in t.fx.speeds?t.fx.speeds[s]:t.fx.speeds._default,e.complete=n||i.complete,e}function i(e){return!e||"number"==typeof e||t.fx.speeds[e]?!0:"string"!=typeof e||t.effects.effect[e]?t.isFunction(e)?!0:"object"!=typeof e||e.effect?!1:!0:!0}function s(t,e){var i=e.outerWidth(),s=e.outerHeight(),n=/^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,o=n.exec(t)||["",0,i,s,0];return{top:parseFloat(o[1])||0,right:"auto"===o[2]?i:parseFloat(o[2]),bottom:"auto"===o[3]?s:parseFloat(o[3]),left:parseFloat(o[4])||0}}t.expr&&t.expr.filters&&t.expr.filters.animated&&(t.expr.filters.animated=function(e){return function(i){return!!t(i).data(d)||e(i)}}(t.expr.filters.animated)),t.uiBackCompat!==!1&&t.extend(t.effects,{save:function(t,e){for(var i=0,s=e.length;s>i;i++)null!==e[i]&&t.data(c+e[i],t[0].style[e[i]])},restore:function(t,e){for(var i,s=0,n=e.length;n>s;s++)null!==e[s]&&(i=t.data(c+e[s]),t.css(e[s],i))},setMode:function(t,e){return"toggle"===e&&(e=t.is(":hidden")?"show":"hide"),e},createWrapper:function(e){if(e.parent().is(".ui-effects-wrapper"))return e.parent();var i={width:e.outerWidth(!0),height:e.outerHeight(!0),"float":e.css("float")},s=t("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),n={width:e.width(),height:e.height()},o=document.activeElement;try{o.id}catch(a){o=document.body}return e.wrap(s),(e[0]===o||t.contains(e[0],o))&&t(o).trigger("focus"),s=e.parent(),"static"===e.css("position")?(s.css({position:"relative"}),e.css({position:"relative"})):(t.extend(i,{position:e.css("position"),zIndex:e.css("z-index")}),t.each(["top","left","bottom","right"],function(t,s){i[s]=e.css(s),isNaN(parseInt(i[s],10))&&(i[s]="auto")}),e.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),e.css(n),s.css(i).show()},removeWrapper:function(e){var i=document.activeElement;return e.parent().is(".ui-effects-wrapper")&&(e.parent().replaceWith(e),(e[0]===i||t.contains(e[0],i))&&t(i).trigger("focus")),e}}),t.extend(t.effects,{version:"1.12.1",define:function(e,i,s){return s||(s=i,i="effect"),t.effects.effect[e]=s,t.effects.effect[e].mode=i,s},scaledDimensions:function(t,e,i){if(0===e)return{height:0,width:0,outerHeight:0,outerWidth:0};var s="horizontal"!==i?(e||100)/100:1,n="vertical"!==i?(e||100)/100:1;return{height:t.height()*n,width:t.width()*s,outerHeight:t.outerHeight()*n,outerWidth:t.outerWidth()*s}},clipToBox:function(t){return{width:t.clip.right-t.clip.left,height:t.clip.bottom-t.clip.top,left:t.clip.left,top:t.clip.top}},unshift:function(t,e,i){var s=t.queue();e>1&&s.splice.apply(s,[1,0].concat(s.splice(e,i))),t.dequeue()},saveStyle:function(t){t.data(u,t[0].style.cssText)},restoreStyle:function(t){t[0].style.cssText=t.data(u)||"",t.removeData(u)},mode:function(t,e){var i=t.is(":hidden");return"toggle"===e&&(e=i?"show":"hide"),(i?"hide"===e:"show"===e)&&(e="none"),e},getBaseline:function(t,e){var i,s;switch(t[0]){case"top":i=0;break;case"middle":i=.5;break;case"bottom":i=1;break;default:i=t[0]/e.height}switch(t[1]){case"left":s=0;break;case"center":s=.5;break;case"right":s=1;break;default:s=t[1]/e.width}return{x:s,y:i}},createPlaceholder:function(e){var i,s=e.css("position"),n=e.position();return e.css({marginTop:e.css("marginTop"),marginBottom:e.css("marginBottom"),marginLeft:e.css("marginLeft"),marginRight:e.css("marginRight")}).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()),/^(static|relative)/.test(s)&&(s="absolute",i=t("<"+e[0].nodeName+">").insertAfter(e).css({display:/^(inline|ruby)/.test(e.css("display"))?"inline-block":"block",visibility:"hidden",marginTop:e.css("marginTop"),marginBottom:e.css("marginBottom"),marginLeft:e.css("marginLeft"),marginRight:e.css("marginRight"),"float":e.css("float")}).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).addClass("ui-effects-placeholder"),e.data(c+"placeholder",i)),e.css({position:s,left:n.left,top:n.top}),i},removePlaceholder:function(t){var e=c+"placeholder",i=t.data(e);i&&(i.remove(),t.removeData(e))},cleanUp:function(e){t.effects.restoreStyle(e),t.effects.removePlaceholder(e)},setTransition:function(e,i,s,n){return n=n||{},t.each(i,function(t,i){var o=e.cssUnit(i);o[0]>0&&(n[i]=o[0]*s+o[1])}),n}}),t.fn.extend({effect:function(){function i(e){function i(){r.removeData(d),t.effects.cleanUp(r),"hide"===s.mode&&r.hide(),a()}function a(){t.isFunction(h)&&h.call(r[0]),t.isFunction(e)&&e()}var r=t(this);s.mode=c.shift(),t.uiBackCompat===!1||o?"none"===s.mode?(r[l](),a()):n.call(r[0],s,i):(r.is(":hidden")?"hide"===l:"show"===l)?(r[l](),a()):n.call(r[0],s,a)}var s=e.apply(this,arguments),n=t.effects.effect[s.effect],o=n.mode,a=s.queue,r=a||"fx",h=s.complete,l=s.mode,c=[],u=function(e){var i=t(this),s=t.effects.mode(i,l)||o;i.data(d,!0),c.push(s),o&&("show"===s||s===o&&"hide"===s)&&i.show(),o&&"none"===s||t.effects.saveStyle(i),t.isFunction(e)&&e()};return t.fx.off||!n?l?this[l](s.duration,h):this.each(function(){h&&h.call(this)}):a===!1?this.each(u).each(i):this.queue(r,u).queue(r,i)},show:function(t){return function(s){if(i(s))return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="show",this.effect.call(this,n)
  }}(t.fn.show),hide:function(t){return function(s){if(i(s))return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="hide",this.effect.call(this,n)}}(t.fn.hide),toggle:function(t){return function(s){if(i(s)||"boolean"==typeof s)return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="toggle",this.effect.call(this,n)}}(t.fn.toggle),cssUnit:function(e){var i=this.css(e),s=[];return t.each(["em","px","%","pt"],function(t,e){i.indexOf(e)>0&&(s=[parseFloat(i),e])}),s},cssClip:function(t){return t?this.css("clip","rect("+t.top+"px "+t.right+"px "+t.bottom+"px "+t.left+"px)"):s(this.css("clip"),this)},transfer:function(e,i){var s=t(this),n=t(e.to),o="fixed"===n.css("position"),a=t("body"),r=o?a.scrollTop():0,h=o?a.scrollLeft():0,l=n.offset(),c={top:l.top-r,left:l.left-h,height:n.innerHeight(),width:n.innerWidth()},u=s.offset(),d=t("<div class='ui-effects-transfer'></div>").appendTo("body").addClass(e.className).css({top:u.top-r,left:u.left-h,height:s.innerHeight(),width:s.innerWidth(),position:o?"fixed":"absolute"}).animate(c,e.duration,e.easing,function(){d.remove(),t.isFunction(i)&&i()})}}),t.fx.step.clip=function(e){e.clipInit||(e.start=t(e.elem).cssClip(),"string"==typeof e.end&&(e.end=s(e.end,e.elem)),e.clipInit=!0),t(e.elem).cssClip({top:e.pos*(e.end.top-e.start.top)+e.start.top,right:e.pos*(e.end.right-e.start.right)+e.start.right,bottom:e.pos*(e.end.bottom-e.start.bottom)+e.start.bottom,left:e.pos*(e.end.left-e.start.left)+e.start.left})}}(),function(){var e={};t.each(["Quad","Cubic","Quart","Quint","Expo"],function(t,i){e[i]=function(e){return Math.pow(e,t+2)}}),t.extend(e,{Sine:function(t){return 1-Math.cos(t*Math.PI/2)},Circ:function(t){return 1-Math.sqrt(1-t*t)},Elastic:function(t){return 0===t||1===t?t:-Math.pow(2,8*(t-1))*Math.sin((80*(t-1)-7.5)*Math.PI/15)},Back:function(t){return t*t*(3*t-2)},Bounce:function(t){for(var e,i=4;((e=Math.pow(2,--i))-1)/11>t;);return 1/Math.pow(4,3-i)-7.5625*Math.pow((3*e-2)/22-t,2)}}),t.each(e,function(e,i){t.easing["easeIn"+e]=i,t.easing["easeOut"+e]=function(t){return 1-i(1-t)},t.easing["easeInOut"+e]=function(t){return.5>t?i(2*t)/2:1-i(-2*t+2)/2}})}();var f=t.effects;t.effects.define("blind","hide",function(e,i){var s={up:["bottom","top"],vertical:["bottom","top"],down:["top","bottom"],left:["right","left"],horizontal:["right","left"],right:["left","right"]},n=t(this),o=e.direction||"up",a=n.cssClip(),r={clip:t.extend({},a)},h=t.effects.createPlaceholder(n);r.clip[s[o][0]]=r.clip[s[o][1]],"show"===e.mode&&(n.cssClip(r.clip),h&&h.css(t.effects.clipToBox(r)),r.clip=a),h&&h.animate(t.effects.clipToBox(r),e.duration,e.easing),n.animate(r,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("bounce",function(e,i){var s,n,o,a=t(this),r=e.mode,h="hide"===r,l="show"===r,c=e.direction||"up",u=e.distance,d=e.times||5,p=2*d+(l||h?1:0),f=e.duration/p,g=e.easing,m="up"===c||"down"===c?"top":"left",_="up"===c||"left"===c,v=0,b=a.queue().length;for(t.effects.createPlaceholder(a),o=a.css(m),u||(u=a["top"===m?"outerHeight":"outerWidth"]()/3),l&&(n={opacity:1},n[m]=o,a.css("opacity",0).css(m,_?2*-u:2*u).animate(n,f,g)),h&&(u/=Math.pow(2,d-1)),n={},n[m]=o;d>v;v++)s={},s[m]=(_?"-=":"+=")+u,a.animate(s,f,g).animate(n,f,g),u=h?2*u:u/2;h&&(s={opacity:0},s[m]=(_?"-=":"+=")+u,a.animate(s,f,g)),a.queue(i),t.effects.unshift(a,b,p+1)}),t.effects.define("clip","hide",function(e,i){var s,n={},o=t(this),a=e.direction||"vertical",r="both"===a,h=r||"horizontal"===a,l=r||"vertical"===a;s=o.cssClip(),n.clip={top:l?(s.bottom-s.top)/2:s.top,right:h?(s.right-s.left)/2:s.right,bottom:l?(s.bottom-s.top)/2:s.bottom,left:h?(s.right-s.left)/2:s.left},t.effects.createPlaceholder(o),"show"===e.mode&&(o.cssClip(n.clip),n.clip=s),o.animate(n,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("drop","hide",function(e,i){var s,n=t(this),o=e.mode,a="show"===o,r=e.direction||"left",h="up"===r||"down"===r?"top":"left",l="up"===r||"left"===r?"-=":"+=",c="+="===l?"-=":"+=",u={opacity:0};t.effects.createPlaceholder(n),s=e.distance||n["top"===h?"outerHeight":"outerWidth"](!0)/2,u[h]=l+s,a&&(n.css(u),u[h]=c+s,u.opacity=1),n.animate(u,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("explode","hide",function(e,i){function s(){b.push(this),b.length===u*d&&n()}function n(){p.css({visibility:"visible"}),t(b).remove(),i()}var o,a,r,h,l,c,u=e.pieces?Math.round(Math.sqrt(e.pieces)):3,d=u,p=t(this),f=e.mode,g="show"===f,m=p.show().css("visibility","hidden").offset(),_=Math.ceil(p.outerWidth()/d),v=Math.ceil(p.outerHeight()/u),b=[];for(o=0;u>o;o++)for(h=m.top+o*v,c=o-(u-1)/2,a=0;d>a;a++)r=m.left+a*_,l=a-(d-1)/2,p.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-a*_,top:-o*v}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:_,height:v,left:r+(g?l*_:0),top:h+(g?c*v:0),opacity:g?0:1}).animate({left:r+(g?0:l*_),top:h+(g?0:c*v),opacity:g?1:0},e.duration||500,e.easing,s)}),t.effects.define("fade","toggle",function(e,i){var s="show"===e.mode;t(this).css("opacity",s?0:1).animate({opacity:s?1:0},{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("fold","hide",function(e,i){var s=t(this),n=e.mode,o="show"===n,a="hide"===n,r=e.size||15,h=/([0-9]+)%/.exec(r),l=!!e.horizFirst,c=l?["right","bottom"]:["bottom","right"],u=e.duration/2,d=t.effects.createPlaceholder(s),p=s.cssClip(),f={clip:t.extend({},p)},g={clip:t.extend({},p)},m=[p[c[0]],p[c[1]]],_=s.queue().length;h&&(r=parseInt(h[1],10)/100*m[a?0:1]),f.clip[c[0]]=r,g.clip[c[0]]=r,g.clip[c[1]]=0,o&&(s.cssClip(g.clip),d&&d.css(t.effects.clipToBox(g)),g.clip=p),s.queue(function(i){d&&d.animate(t.effects.clipToBox(f),u,e.easing).animate(t.effects.clipToBox(g),u,e.easing),i()}).animate(f,u,e.easing).animate(g,u,e.easing).queue(i),t.effects.unshift(s,_,4)}),t.effects.define("highlight","show",function(e,i){var s=t(this),n={backgroundColor:s.css("backgroundColor")};"hide"===e.mode&&(n.opacity=0),t.effects.saveStyle(s),s.css({backgroundImage:"none",backgroundColor:e.color||"#ffff99"}).animate(n,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("size",function(e,i){var s,n,o,a=t(this),r=["fontSize"],h=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],l=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],c=e.mode,u="effect"!==c,d=e.scale||"both",p=e.origin||["middle","center"],f=a.css("position"),g=a.position(),m=t.effects.scaledDimensions(a),_=e.from||m,v=e.to||t.effects.scaledDimensions(a,0);t.effects.createPlaceholder(a),"show"===c&&(o=_,_=v,v=o),n={from:{y:_.height/m.height,x:_.width/m.width},to:{y:v.height/m.height,x:v.width/m.width}},("box"===d||"both"===d)&&(n.from.y!==n.to.y&&(_=t.effects.setTransition(a,h,n.from.y,_),v=t.effects.setTransition(a,h,n.to.y,v)),n.from.x!==n.to.x&&(_=t.effects.setTransition(a,l,n.from.x,_),v=t.effects.setTransition(a,l,n.to.x,v))),("content"===d||"both"===d)&&n.from.y!==n.to.y&&(_=t.effects.setTransition(a,r,n.from.y,_),v=t.effects.setTransition(a,r,n.to.y,v)),p&&(s=t.effects.getBaseline(p,m),_.top=(m.outerHeight-_.outerHeight)*s.y+g.top,_.left=(m.outerWidth-_.outerWidth)*s.x+g.left,v.top=(m.outerHeight-v.outerHeight)*s.y+g.top,v.left=(m.outerWidth-v.outerWidth)*s.x+g.left),a.css(_),("content"===d||"both"===d)&&(h=h.concat(["marginTop","marginBottom"]).concat(r),l=l.concat(["marginLeft","marginRight"]),a.find("*[width]").each(function(){var i=t(this),s=t.effects.scaledDimensions(i),o={height:s.height*n.from.y,width:s.width*n.from.x,outerHeight:s.outerHeight*n.from.y,outerWidth:s.outerWidth*n.from.x},a={height:s.height*n.to.y,width:s.width*n.to.x,outerHeight:s.height*n.to.y,outerWidth:s.width*n.to.x};n.from.y!==n.to.y&&(o=t.effects.setTransition(i,h,n.from.y,o),a=t.effects.setTransition(i,h,n.to.y,a)),n.from.x!==n.to.x&&(o=t.effects.setTransition(i,l,n.from.x,o),a=t.effects.setTransition(i,l,n.to.x,a)),u&&t.effects.saveStyle(i),i.css(o),i.animate(a,e.duration,e.easing,function(){u&&t.effects.restoreStyle(i)})})),a.animate(v,{queue:!1,duration:e.duration,easing:e.easing,complete:function(){var e=a.offset();0===v.opacity&&a.css("opacity",_.opacity),u||(a.css("position","static"===f?"relative":f).offset(e),t.effects.saveStyle(a)),i()}})}),t.effects.define("scale",function(e,i){var s=t(this),n=e.mode,o=parseInt(e.percent,10)||(0===parseInt(e.percent,10)?0:"effect"!==n?0:100),a=t.extend(!0,{from:t.effects.scaledDimensions(s),to:t.effects.scaledDimensions(s,o,e.direction||"both"),origin:e.origin||["middle","center"]},e);e.fade&&(a.from.opacity=1,a.to.opacity=0),t.effects.effect.size.call(this,a,i)}),t.effects.define("puff","hide",function(e,i){var s=t.extend(!0,{},e,{fade:!0,percent:parseInt(e.percent,10)||150});t.effects.effect.scale.call(this,s,i)}),t.effects.define("pulsate","show",function(e,i){var s=t(this),n=e.mode,o="show"===n,a="hide"===n,r=o||a,h=2*(e.times||5)+(r?1:0),l=e.duration/h,c=0,u=1,d=s.queue().length;for((o||!s.is(":visible"))&&(s.css("opacity",0).show(),c=1);h>u;u++)s.animate({opacity:c},l,e.easing),c=1-c;s.animate({opacity:c},l,e.easing),s.queue(i),t.effects.unshift(s,d,h+1)}),t.effects.define("shake",function(e,i){var s=1,n=t(this),o=e.direction||"left",a=e.distance||20,r=e.times||3,h=2*r+1,l=Math.round(e.duration/h),c="up"===o||"down"===o?"top":"left",u="up"===o||"left"===o,d={},p={},f={},g=n.queue().length;for(t.effects.createPlaceholder(n),d[c]=(u?"-=":"+=")+a,p[c]=(u?"+=":"-=")+2*a,f[c]=(u?"-=":"+=")+2*a,n.animate(d,l,e.easing);r>s;s++)n.animate(p,l,e.easing).animate(f,l,e.easing);n.animate(p,l,e.easing).animate(d,l/2,e.easing).queue(i),t.effects.unshift(n,g,h+1)}),t.effects.define("slide","show",function(e,i){var s,n,o=t(this),a={up:["bottom","top"],down:["top","bottom"],left:["right","left"],right:["left","right"]},r=e.mode,h=e.direction||"left",l="up"===h||"down"===h?"top":"left",c="up"===h||"left"===h,u=e.distance||o["top"===l?"outerHeight":"outerWidth"](!0),d={};t.effects.createPlaceholder(o),s=o.cssClip(),n=o.position()[l],d[l]=(c?-1:1)*u+n,d.clip=o.cssClip(),d.clip[a[h][1]]=d.clip[a[h][0]],"show"===r&&(o.cssClip(d.clip),o.css(l,d[l]),d.clip=s,d[l]=n),o.animate(d,{queue:!1,duration:e.duration,easing:e.easing,complete:i})});var f;t.uiBackCompat!==!1&&(f=t.effects.define("transfer",function(e,i){t(this).transfer(e,i)})),t.ui.focusable=function(i,s){var n,o,a,r,h,l=i.nodeName.toLowerCase();return"area"===l?(n=i.parentNode,o=n.name,i.href&&o&&"map"===n.nodeName.toLowerCase()?(a=t("img[usemap='#"+o+"']"),a.length>0&&a.is(":visible")):!1):(/^(input|select|textarea|button|object)$/.test(l)?(r=!i.disabled,r&&(h=t(i).closest("fieldset")[0],h&&(r=!h.disabled))):r="a"===l?i.href||s:s,r&&t(i).is(":visible")&&e(t(i)))},t.extend(t.expr[":"],{focusable:function(e){return t.ui.focusable(e,null!=t.attr(e,"tabindex"))}}),t.ui.focusable,t.fn.form=function(){return"string"==typeof this[0].form?this.closest("form"):t(this[0].form)},t.ui.formResetMixin={_formResetHandler:function(){var e=t(this);setTimeout(function(){var i=e.data("ui-form-reset-instances");t.each(i,function(){this.refresh()})})},_bindFormResetHandler:function(){if(this.form=this.element.form(),this.form.length){var t=this.form.data("ui-form-reset-instances")||[];t.length||this.form.on("reset.ui-form-reset",this._formResetHandler),t.push(this),this.form.data("ui-form-reset-instances",t)}},_unbindFormResetHandler:function(){if(this.form.length){var e=this.form.data("ui-form-reset-instances");e.splice(t.inArray(this,e),1),e.length?this.form.data("ui-form-reset-instances",e):this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset")}}},"1.7"===t.fn.jquery.substring(0,3)&&(t.each(["Width","Height"],function(e,i){function s(e,i,s,o){return t.each(n,function(){i-=parseFloat(t.css(e,"padding"+this))||0,s&&(i-=parseFloat(t.css(e,"border"+this+"Width"))||0),o&&(i-=parseFloat(t.css(e,"margin"+this))||0)}),i}var n="Width"===i?["Left","Right"]:["Top","Bottom"],o=i.toLowerCase(),a={innerWidth:t.fn.innerWidth,innerHeight:t.fn.innerHeight,outerWidth:t.fn.outerWidth,outerHeight:t.fn.outerHeight};t.fn["inner"+i]=function(e){return void 0===e?a["inner"+i].call(this):this.each(function(){t(this).css(o,s(this,e)+"px")})},t.fn["outer"+i]=function(e,n){return"number"!=typeof e?a["outer"+i].call(this,e):this.each(function(){t(this).css(o,s(this,e,!0,n)+"px")})}}),t.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),t.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38},t.ui.escapeSelector=function(){var t=/([!"#$%&'()*+,.\/:;<=>?@[\]^`{|}~])/g;return function(e){return e.replace(t,"\\$1")}}(),t.fn.labels=function(){var e,i,s,n,o;return this[0].labels&&this[0].labels.length?this.pushStack(this[0].labels):(n=this.eq(0).parents("label"),s=this.attr("id"),s&&(e=this.eq(0).parents().last(),o=e.add(e.length?e.siblings():this.siblings()),i="label[for='"+t.ui.escapeSelector(s)+"']",n=n.add(o.find(i).addBack(i))),this.pushStack(n))},t.fn.scrollParent=function(e){var i=this.css("position"),s="absolute"===i,n=e?/(auto|scroll|hidden)/:/(auto|scroll)/,o=this.parents().filter(function(){var e=t(this);return s&&"static"===e.css("position")?!1:n.test(e.css("overflow")+e.css("overflow-y")+e.css("overflow-x"))}).eq(0);return"fixed"!==i&&o.length?o:t(this[0].ownerDocument||document)},t.extend(t.expr[":"],{tabbable:function(e){var i=t.attr(e,"tabindex"),s=null!=i;return(!s||i>=0)&&t.ui.focusable(e,s)}}),t.fn.extend({uniqueId:function(){var t=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++t)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&t(this).removeAttr("id")})}}),t.widget("ui.accordion",{version:"1.12.1",options:{active:0,animate:{},classes:{"ui-accordion-header":"ui-corner-top","ui-accordion-header-collapsed":"ui-corner-all","ui-accordion-content":"ui-corner-bottom"},collapsible:!1,event:"click",header:"> li > :first-child, > :not(li):even",heightStyle:"auto",icons:{activeHeader:"ui-icon-triangle-1-s",header:"ui-icon-triangle-1-e"},activate:null,beforeActivate:null},hideProps:{borderTopWidth:"hide",borderBottomWidth:"hide",paddingTop:"hide",paddingBottom:"hide",height:"hide"},showProps:{borderTopWidth:"show",borderBottomWidth:"show",paddingTop:"show",paddingBottom:"show",height:"show"},_create:function(){var e=this.options;this.prevShow=this.prevHide=t(),this._addClass("ui-accordion","ui-widget ui-helper-reset"),this.element.attr("role","tablist"),e.collapsible||e.active!==!1&&null!=e.active||(e.active=0),this._processPanels(),0>e.active&&(e.active+=this.headers.length),this._refresh()},_getCreateEventData:function(){return{header:this.active,panel:this.active.length?this.active.next():t()}},_createIcons:function(){var e,i,s=this.options.icons;s&&(e=t("<span>"),this._addClass(e,"ui-accordion-header-icon","ui-icon "+s.header),e.prependTo(this.headers),i=this.active.children(".ui-accordion-header-icon"),this._removeClass(i,s.header)._addClass(i,null,s.activeHeader)._addClass(this.headers,"ui-accordion-icons"))},_destroyIcons:function(){this._removeClass(this.headers,"ui-accordion-icons"),this.headers.children(".ui-accordion-header-icon").remove()},_destroy:function(){var t;this.element.removeAttr("role"),this.headers.removeAttr("role aria-expanded aria-selected aria-controls tabIndex").removeUniqueId(),this._destroyIcons(),t=this.headers.next().css("display","").removeAttr("role aria-hidden aria-labelledby").removeUniqueId(),"content"!==this.options.heightStyle&&t.css("height","")},_setOption:function(t,e){return"active"===t?(this._activate(e),void 0):("event"===t&&(this.options.event&&this._off(this.headers,this.options.event),this._setupEvents(e)),this._super(t,e),"collapsible"!==t||e||this.options.active!==!1||this._activate(0),"icons"===t&&(this._destroyIcons(),e&&this._createIcons()),void 0)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t),this._toggleClass(null,"ui-state-disabled",!!t),this._toggleClass(this.headers.add(this.headers.next()),null,"ui-state-disabled",!!t)},_keydown:function(e){if(!e.altKey&&!e.ctrlKey){var i=t.ui.keyCode,s=this.headers.length,n=this.headers.index(e.target),o=!1;switch(e.keyCode){case i.RIGHT:case i.DOWN:o=this.headers[(n+1)%s];break;case i.LEFT:case i.UP:o=this.headers[(n-1+s)%s];break;case i.SPACE:case i.ENTER:this._eventHandler(e);break;case i.HOME:o=this.headers[0];break;case i.END:o=this.headers[s-1]}o&&(t(e.target).attr("tabIndex",-1),t(o).attr("tabIndex",0),t(o).trigger("focus"),e.preventDefault())}},_panelKeyDown:function(e){e.keyCode===t.ui.keyCode.UP&&e.ctrlKey&&t(e.currentTarget).prev().trigger("focus")},refresh:function(){var e=this.options;this._processPanels(),e.active===!1&&e.collapsible===!0||!this.headers.length?(e.active=!1,this.active=t()):e.active===!1?this._activate(0):this.active.length&&!t.contains(this.element[0],this.active[0])?this.headers.length===this.headers.find(".ui-state-disabled").length?(e.active=!1,this.active=t()):this._activate(Math.max(0,e.active-1)):e.active=this.headers.index(this.active),this._destroyIcons(),this._refresh()},_processPanels:function(){var t=this.headers,e=this.panels;this.headers=this.element.find(this.options.header),this._addClass(this.headers,"ui-accordion-header ui-accordion-header-collapsed","ui-state-default"),this.panels=this.headers.next().filter(":not(.ui-accordion-content-active)").hide(),this._addClass(this.panels,"ui-accordion-content","ui-helper-reset ui-widget-content"),e&&(this._off(t.not(this.headers)),this._off(e.not(this.panels)))},_refresh:function(){var e,i=this.options,s=i.heightStyle,n=this.element.parent();this.active=this._findActive(i.active),this._addClass(this.active,"ui-accordion-header-active","ui-state-active")._removeClass(this.active,"ui-accordion-header-collapsed"),this._addClass(this.active.next(),"ui-accordion-content-active"),this.active.next().show(),this.headers.attr("role","tab").each(function(){var e=t(this),i=e.uniqueId().attr("id"),s=e.next(),n=s.uniqueId().attr("id");e.attr("aria-controls",n),s.attr("aria-labelledby",i)}).next().attr("role","tabpanel"),this.headers.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}).next().attr({"aria-hidden":"true"}).hide(),this.active.length?this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}).next().attr({"aria-hidden":"false"}):this.headers.eq(0).attr("tabIndex",0),this._createIcons(),this._setupEvents(i.event),"fill"===s?(e=n.height(),this.element.siblings(":visible").each(function(){var i=t(this),s=i.css("position");"absolute"!==s&&"fixed"!==s&&(e-=i.outerHeight(!0))}),this.headers.each(function(){e-=t(this).outerHeight(!0)}),this.headers.next().each(function(){t(this).height(Math.max(0,e-t(this).innerHeight()+t(this).height()))}).css("overflow","auto")):"auto"===s&&(e=0,this.headers.next().each(function(){var i=t(this).is(":visible");i||t(this).show(),e=Math.max(e,t(this).css("height","").height()),i||t(this).hide()}).height(e))},_activate:function(e){var i=this._findActive(e)[0];i!==this.active[0]&&(i=i||this.active[0],this._eventHandler({target:i,currentTarget:i,preventDefault:t.noop}))},_findActive:function(e){return"number"==typeof e?this.headers.eq(e):t()},_setupEvents:function(e){var i={keydown:"_keydown"};e&&t.each(e.split(" "),function(t,e){i[e]="_eventHandler"}),this._off(this.headers.add(this.headers.next())),this._on(this.headers,i),this._on(this.headers.next(),{keydown:"_panelKeyDown"}),this._hoverable(this.headers),this._focusable(this.headers)},_eventHandler:function(e){var i,s,n=this.options,o=this.active,a=t(e.currentTarget),r=a[0]===o[0],h=r&&n.collapsible,l=h?t():a.next(),c=o.next(),u={oldHeader:o,oldPanel:c,newHeader:h?t():a,newPanel:l};e.preventDefault(),r&&!n.collapsible||this._trigger("beforeActivate",e,u)===!1||(n.active=h?!1:this.headers.index(a),this.active=r?t():a,this._toggle(u),this._removeClass(o,"ui-accordion-header-active","ui-state-active"),n.icons&&(i=o.children(".ui-accordion-header-icon"),this._removeClass(i,null,n.icons.activeHeader)._addClass(i,null,n.icons.header)),r||(this._removeClass(a,"ui-accordion-header-collapsed")._addClass(a,"ui-accordion-header-active","ui-state-active"),n.icons&&(s=a.children(".ui-accordion-header-icon"),this._removeClass(s,null,n.icons.header)._addClass(s,null,n.icons.activeHeader)),this._addClass(a.next(),"ui-accordion-content-active")))},_toggle:function(e){var i=e.newPanel,s=this.prevShow.length?this.prevShow:e.oldPanel;this.prevShow.add(this.prevHide).stop(!0,!0),this.prevShow=i,this.prevHide=s,this.options.animate?this._animate(i,s,e):(s.hide(),i.show(),this._toggleComplete(e)),s.attr({"aria-hidden":"true"}),s.prev().attr({"aria-selected":"false","aria-expanded":"false"}),i.length&&s.length?s.prev().attr({tabIndex:-1,"aria-expanded":"false"}):i.length&&this.headers.filter(function(){return 0===parseInt(t(this).attr("tabIndex"),10)}).attr("tabIndex",-1),i.attr("aria-hidden","false").prev().attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_animate:function(t,e,i){var s,n,o,a=this,r=0,h=t.css("box-sizing"),l=t.length&&(!e.length||t.index()<e.index()),c=this.options.animate||{},u=l&&c.down||c,d=function(){a._toggleComplete(i)};return"number"==typeof u&&(o=u),"string"==typeof u&&(n=u),n=n||u.easing||c.easing,o=o||u.duration||c.duration,e.length?t.length?(s=t.show().outerHeight(),e.animate(this.hideProps,{duration:o,easing:n,step:function(t,e){e.now=Math.round(t)}}),t.hide().animate(this.showProps,{duration:o,easing:n,complete:d,step:function(t,i){i.now=Math.round(t),"height"!==i.prop?"content-box"===h&&(r+=i.now):"content"!==a.options.heightStyle&&(i.now=Math.round(s-e.outerHeight()-r),r=0)}}),void 0):e.animate(this.hideProps,o,n,d):t.animate(this.showProps,o,n,d)},_toggleComplete:function(t){var e=t.oldPanel,i=e.prev();this._removeClass(e,"ui-accordion-content-active"),this._removeClass(i,"ui-accordion-header-active")._addClass(i,"ui-accordion-header-collapsed"),e.length&&(e.parent()[0].className=e.parent()[0].className),this._trigger("activate",null,t)}}),t.ui.safeActiveElement=function(t){var e;try{e=t.activeElement}catch(i){e=t.body}return e||(e=t.body),e.nodeName||(e=t.body),e},t.widget("ui.menu",{version:"1.12.1",defaultElement:"<ul>",delay:300,options:{icons:{submenu:"ui-icon-caret-1-e"},items:"> *",menus:"ul",position:{my:"left top",at:"right top"},role:"menu",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.element.uniqueId().attr({role:this.options.role,tabIndex:0}),this._addClass("ui-menu","ui-widget ui-widget-content"),this._on({"mousedown .ui-menu-item":function(t){t.preventDefault()},"click .ui-menu-item":function(e){var i=t(e.target),s=t(t.ui.safeActiveElement(this.document[0]));!this.mouseHandled&&i.not(".ui-state-disabled").length&&(this.select(e),e.isPropagationStopped()||(this.mouseHandled=!0),i.has(".ui-menu").length?this.expand(e):!this.element.is(":focus")&&s.closest(".ui-menu").length&&(this.element.trigger("focus",[!0]),this.active&&1===this.active.parents(".ui-menu").length&&clearTimeout(this.timer)))},"mouseenter .ui-menu-item":function(e){if(!this.previousFilter){var i=t(e.target).closest(".ui-menu-item"),s=t(e.currentTarget);i[0]===s[0]&&(this._removeClass(s.siblings().children(".ui-state-active"),null,"ui-state-active"),this.focus(e,s))}},mouseleave:"collapseAll","mouseleave .ui-menu":"collapseAll",focus:function(t,e){var i=this.active||this.element.find(this.options.items).eq(0);e||this.focus(t,i)},blur:function(e){this._delay(function(){var i=!t.contains(this.element[0],t.ui.safeActiveElement(this.document[0]));i&&this.collapseAll(e)})},keydown:"_keydown"}),this.refresh(),this._on(this.document,{click:function(t){this._closeOnDocumentClick(t)&&this.collapseAll(t),this.mouseHandled=!1}})},_destroy:function(){var e=this.element.find(".ui-menu-item").removeAttr("role aria-disabled"),i=e.children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex").removeUniqueId().show(),i.children().each(function(){var e=t(this);e.data("ui-menu-submenu-caret")&&e.remove()})},_keydown:function(e){var i,s,n,o,a=!0;switch(e.keyCode){case t.ui.keyCode.PAGE_UP:this.previousPage(e);break;case t.ui.keyCode.PAGE_DOWN:this.nextPage(e);break;case t.ui.keyCode.HOME:this._move("first","first",e);break;case t.ui.keyCode.END:this._move("last","last",e);break;case t.ui.keyCode.UP:this.previous(e);break;case t.ui.keyCode.DOWN:this.next(e);break;case t.ui.keyCode.LEFT:this.collapse(e);break;case t.ui.keyCode.RIGHT:this.active&&!this.active.is(".ui-state-disabled")&&this.expand(e);break;case t.ui.keyCode.ENTER:case t.ui.keyCode.SPACE:this._activate(e);break;case t.ui.keyCode.ESCAPE:this.collapse(e);break;default:a=!1,s=this.previousFilter||"",o=!1,n=e.keyCode>=96&&105>=e.keyCode?""+(e.keyCode-96):String.fromCharCode(e.keyCode),clearTimeout(this.filterTimer),n===s?o=!0:n=s+n,i=this._filterMenuItems(n),i=o&&-1!==i.index(this.active.next())?this.active.nextAll(".ui-menu-item"):i,i.length||(n=String.fromCharCode(e.keyCode),i=this._filterMenuItems(n)),i.length?(this.focus(e,i),this.previousFilter=n,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter}a&&e.preventDefault()},_activate:function(t){this.active&&!this.active.is(".ui-state-disabled")&&(this.active.children("[aria-haspopup='true']").length?this.expand(t):this.select(t))},refresh:function(){var e,i,s,n,o,a=this,r=this.options.icons.submenu,h=this.element.find(this.options.menus);this._toggleClass("ui-menu-icons",null,!!this.element.find(".ui-icon").length),s=h.filter(":not(.ui-menu)").hide().attr({role:this.options.role,"aria-hidden":"true","aria-expanded":"false"}).each(function(){var e=t(this),i=e.prev(),s=t("<span>").data("ui-menu-submenu-caret",!0);a._addClass(s,"ui-menu-icon","ui-icon "+r),i.attr("aria-haspopup","true").prepend(s),e.attr("aria-labelledby",i.attr("id"))}),this._addClass(s,"ui-menu","ui-widget ui-widget-content ui-front"),e=h.add(this.element),i=e.find(this.options.items),i.not(".ui-menu-item").each(function(){var e=t(this);a._isDivider(e)&&a._addClass(e,"ui-menu-divider","ui-widget-content")}),n=i.not(".ui-menu-item, .ui-menu-divider"),o=n.children().not(".ui-menu").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),this._addClass(n,"ui-menu-item")._addClass(o,"ui-menu-item-wrapper"),i.filter(".ui-state-disabled").attr("aria-disabled","true"),this.active&&!t.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:"menuitem",listbox:"option"}[this.options.role]},_setOption:function(t,e){if("icons"===t){var i=this.element.find(".ui-menu-icon");this._removeClass(i,null,this.options.icons.submenu)._addClass(i,null,e.submenu)}this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t+""),this._toggleClass(null,"ui-state-disabled",!!t)},focus:function(t,e){var i,s,n;this.blur(t,t&&"focus"===t.type),this._scrollIntoView(e),this.active=e.first(),s=this.active.children(".ui-menu-item-wrapper"),this._addClass(s,null,"ui-state-active"),this.options.role&&this.element.attr("aria-activedescendant",s.attr("id")),n=this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper"),this._addClass(n,null,"ui-state-active"),t&&"keydown"===t.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),i=e.children(".ui-menu"),i.length&&t&&/^mouse/.test(t.type)&&this._startOpening(i),this.activeMenu=e.parent(),this._trigger("focus",t,{item:e})},_scrollIntoView:function(e){var i,s,n,o,a,r;this._hasScroll()&&(i=parseFloat(t.css(this.activeMenu[0],"borderTopWidth"))||0,s=parseFloat(t.css(this.activeMenu[0],"paddingTop"))||0,n=e.offset().top-this.activeMenu.offset().top-i-s,o=this.activeMenu.scrollTop(),a=this.activeMenu.height(),r=e.outerHeight(),0>n?this.activeMenu.scrollTop(o+n):n+r>a&&this.activeMenu.scrollTop(o+n-a+r))},blur:function(t,e){e||clearTimeout(this.timer),this.active&&(this._removeClass(this.active.children(".ui-menu-item-wrapper"),null,"ui-state-active"),this._trigger("blur",t,{item:this.active}),this.active=null)},_startOpening:function(t){clearTimeout(this.timer),"true"===t.attr("aria-hidden")&&(this.timer=this._delay(function(){this._close(),this._open(t)},this.delay))},_open:function(e){var i=t.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(".ui-menu").not(e.parents(".ui-menu")).hide().attr("aria-hidden","true"),e.show().removeAttr("aria-hidden").attr("aria-expanded","true").position(i)},collapseAll:function(e,i){clearTimeout(this.timer),this.timer=this._delay(function(){var s=i?this.element:t(e&&e.target).closest(this.element.find(".ui-menu"));s.length||(s=this.element),this._close(s),this.blur(e),this._removeClass(s.find(".ui-state-active"),null,"ui-state-active"),this.activeMenu=s},this.delay)},_close:function(t){t||(t=this.active?this.active.parent():this.element),t.find(".ui-menu").hide().attr("aria-hidden","true").attr("aria-expanded","false")},_closeOnDocumentClick:function(e){return!t(e.target).closest(".ui-menu").length},_isDivider:function(t){return!/[^\-\u2014\u2013\s]/.test(t.text())},collapse:function(t){var e=this.active&&this.active.parent().closest(".ui-menu-item",this.element);e&&e.length&&(this._close(),this.focus(t,e))},expand:function(t){var e=this.active&&this.active.children(".ui-menu ").find(this.options.items).first();e&&e.length&&(this._open(e.parent()),this._delay(function(){this.focus(t,e)}))},next:function(t){this._move("next","first",t)},previous:function(t){this._move("prev","last",t)},isFirstItem:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},isLastItem:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},_move:function(t,e,i){var s;this.active&&(s="first"===t||"last"===t?this.active["first"===t?"prevAll":"nextAll"](".ui-menu-item").eq(-1):this.active[t+"All"](".ui-menu-item").eq(0)),s&&s.length&&this.active||(s=this.activeMenu.find(this.options.items)[e]()),this.focus(i,s)},nextPage:function(e){var i,s,n;return this.active?(this.isLastItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.nextAll(".ui-menu-item").each(function(){return i=t(this),0>i.offset().top-s-n}),this.focus(e,i)):this.focus(e,this.activeMenu.find(this.options.items)[this.active?"last":"first"]())),void 0):(this.next(e),void 0)},previousPage:function(e){var i,s,n;return this.active?(this.isFirstItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.prevAll(".ui-menu-item").each(function(){return i=t(this),i.offset().top-s+n>0}),this.focus(e,i)):this.focus(e,this.activeMenu.find(this.options.items).first())),void 0):(this.next(e),void 0)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop("scrollHeight")},select:function(e){this.active=this.active||t(e.target).closest(".ui-menu-item");var i={item:this.active};this.active.has(".ui-menu").length||this.collapseAll(e,!0),this._trigger("select",e,i)},_filterMenuItems:function(e){var i=e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&"),s=RegExp("^"+i,"i");return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function(){return s.test(t.trim(t(this).children(".ui-menu-item-wrapper").text()))})}}),t.widget("ui.autocomplete",{version:"1.12.1",defaultElement:"<input>",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,_create:function(){var e,i,s,n=this.element[0].nodeName.toLowerCase(),o="textarea"===n,a="input"===n;
  this.isMultiLine=o||!a&&this._isContentEditable(this.element),this.valueMethod=this.element[o||a?"val":"text"],this.isNewMenu=!0,this._addClass("ui-autocomplete-input"),this.element.attr("autocomplete","off"),this._on(this.element,{keydown:function(n){if(this.element.prop("readOnly"))return e=!0,s=!0,i=!0,void 0;e=!1,s=!1,i=!1;var o=t.ui.keyCode;switch(n.keyCode){case o.PAGE_UP:e=!0,this._move("previousPage",n);break;case o.PAGE_DOWN:e=!0,this._move("nextPage",n);break;case o.UP:e=!0,this._keyEvent("previous",n);break;case o.DOWN:e=!0,this._keyEvent("next",n);break;case o.ENTER:this.menu.active&&(e=!0,n.preventDefault(),this.menu.select(n));break;case o.TAB:this.menu.active&&this.menu.select(n);break;case o.ESCAPE:this.menu.element.is(":visible")&&(this.isMultiLine||this._value(this.term),this.close(n),n.preventDefault());break;default:i=!0,this._searchTimeout(n)}},keypress:function(s){if(e)return e=!1,(!this.isMultiLine||this.menu.element.is(":visible"))&&s.preventDefault(),void 0;if(!i){var n=t.ui.keyCode;switch(s.keyCode){case n.PAGE_UP:this._move("previousPage",s);break;case n.PAGE_DOWN:this._move("nextPage",s);break;case n.UP:this._keyEvent("previous",s);break;case n.DOWN:this._keyEvent("next",s)}}},input:function(t){return s?(s=!1,t.preventDefault(),void 0):(this._searchTimeout(t),void 0)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(t){return this.cancelBlur?(delete this.cancelBlur,void 0):(clearTimeout(this.searching),this.close(t),this._change(t),void 0)}}),this._initSource(),this.menu=t("<ul>").appendTo(this._appendTo()).menu({role:null}).hide().menu("instance"),this._addClass(this.menu.element,"ui-autocomplete","ui-front"),this._on(this.menu.element,{mousedown:function(e){e.preventDefault(),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,this.element[0]!==t.ui.safeActiveElement(this.document[0])&&this.element.trigger("focus")})},menufocus:function(e,i){var s,n;return this.isNewMenu&&(this.isNewMenu=!1,e.originalEvent&&/^mouse/.test(e.originalEvent.type))?(this.menu.blur(),this.document.one("mousemove",function(){t(e.target).trigger(e.originalEvent)}),void 0):(n=i.item.data("ui-autocomplete-item"),!1!==this._trigger("focus",e,{item:n})&&e.originalEvent&&/^key/.test(e.originalEvent.type)&&this._value(n.value),s=i.item.attr("aria-label")||n.value,s&&t.trim(s).length&&(this.liveRegion.children().hide(),t("<div>").text(s).appendTo(this.liveRegion)),void 0)},menuselect:function(e,i){var s=i.item.data("ui-autocomplete-item"),n=this.previous;this.element[0]!==t.ui.safeActiveElement(this.document[0])&&(this.element.trigger("focus"),this.previous=n,this._delay(function(){this.previous=n,this.selectedItem=s})),!1!==this._trigger("select",e,{item:s})&&this._value(s.value),this.term=this._value(),this.close(e),this.selectedItem=s}}),this.liveRegion=t("<div>",{role:"status","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeAttr("autocomplete"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(t,e){this._super(t,e),"source"===t&&this._initSource(),"appendTo"===t&&this.menu.element.appendTo(this._appendTo()),"disabled"===t&&e&&this.xhr&&this.xhr.abort()},_isEventTargetInWidget:function(e){var i=this.menu.element[0];return e.target===this.element[0]||e.target===i||t.contains(i,e.target)},_closeOnClickOutside:function(t){this._isEventTargetInWidget(t)||this.close()},_appendTo:function(){var e=this.options.appendTo;return e&&(e=e.jquery||e.nodeType?t(e):this.document.find(e).eq(0)),e&&e[0]||(e=this.element.closest(".ui-front, dialog")),e.length||(e=this.document[0].body),e},_initSource:function(){var e,i,s=this;t.isArray(this.options.source)?(e=this.options.source,this.source=function(i,s){s(t.ui.autocomplete.filter(e,i.term))}):"string"==typeof this.options.source?(i=this.options.source,this.source=function(e,n){s.xhr&&s.xhr.abort(),s.xhr=t.ajax({url:i,data:e,dataType:"json",success:function(t){n(t)},error:function(){n([])}})}):this.source=this.options.source},_searchTimeout:function(t){clearTimeout(this.searching),this.searching=this._delay(function(){var e=this.term===this._value(),i=this.menu.element.is(":visible"),s=t.altKey||t.ctrlKey||t.metaKey||t.shiftKey;(!e||e&&!i&&!s)&&(this.selectedItem=null,this.search(null,t))},this.options.delay)},search:function(t,e){return t=null!=t?t:this._value(),this.term=this._value(),t.length<this.options.minLength?this.close(e):this._trigger("search",e)!==!1?this._search(t):void 0},_search:function(t){this.pending++,this._addClass("ui-autocomplete-loading"),this.cancelSearch=!1,this.source({term:t},this._response())},_response:function(){var e=++this.requestIndex;return t.proxy(function(t){e===this.requestIndex&&this.__response(t),this.pending--,this.pending||this._removeClass("ui-autocomplete-loading")},this)},__response:function(t){t&&(t=this._normalize(t)),this._trigger("response",null,{content:t}),!this.options.disabled&&t&&t.length&&!this.cancelSearch?(this._suggest(t),this._trigger("open")):this._close()},close:function(t){this.cancelSearch=!0,this._close(t)},_close:function(t){this._off(this.document,"mousedown"),this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger("close",t))},_change:function(t){this.previous!==this._value()&&this._trigger("change",t,{item:this.selectedItem})},_normalize:function(e){return e.length&&e[0].label&&e[0].value?e:t.map(e,function(e){return"string"==typeof e?{label:e,value:e}:t.extend({},e,{label:e.label||e.value,value:e.value||e.label})})},_suggest:function(e){var i=this.menu.element.empty();this._renderMenu(i,e),this.isNewMenu=!0,this.menu.refresh(),i.show(),this._resizeMenu(),i.position(t.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next(),this._on(this.document,{mousedown:"_closeOnClickOutside"})},_resizeMenu:function(){var t=this.menu.element;t.outerWidth(Math.max(t.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(e,i){var s=this;t.each(i,function(t,i){s._renderItemData(e,i)})},_renderItemData:function(t,e){return this._renderItem(t,e).data("ui-autocomplete-item",e)},_renderItem:function(e,i){return t("<li>").append(t("<div>").text(i.label)).appendTo(e)},_move:function(t,e){return this.menu.element.is(":visible")?this.menu.isFirstItem()&&/^previous/.test(t)||this.menu.isLastItem()&&/^next/.test(t)?(this.isMultiLine||this._value(this.term),this.menu.blur(),void 0):(this.menu[t](e),void 0):(this.search(null,e),void 0)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(t,e){(!this.isMultiLine||this.menu.element.is(":visible"))&&(this._move(t,e),e.preventDefault())},_isContentEditable:function(t){if(!t.length)return!1;var e=t.prop("contentEditable");return"inherit"===e?this._isContentEditable(t.parent()):"true"===e}}),t.extend(t.ui.autocomplete,{escapeRegex:function(t){return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")},filter:function(e,i){var s=RegExp(t.ui.autocomplete.escapeRegex(i),"i");return t.grep(e,function(t){return s.test(t.label||t.value||t)})}}),t.widget("ui.autocomplete",t.ui.autocomplete,{options:{messages:{noResults:"No search results.",results:function(t){return t+(t>1?" results are":" result is")+" available, use up and down arrow keys to navigate."}}},__response:function(e){var i;this._superApply(arguments),this.options.disabled||this.cancelSearch||(i=e&&e.length?this.options.messages.results(e.length):this.options.messages.noResults,this.liveRegion.children().hide(),t("<div>").text(i).appendTo(this.liveRegion))}}),t.ui.autocomplete;var g=/ui-corner-([a-z]){2,6}/g;t.widget("ui.controlgroup",{version:"1.12.1",defaultElement:"<div>",options:{direction:"horizontal",disabled:null,onlyVisible:!0,items:{button:"input[type=button], input[type=submit], input[type=reset], button, a",controlgroupLabel:".ui-controlgroup-label",checkboxradio:"input[type='checkbox'], input[type='radio']",selectmenu:"select",spinner:".ui-spinner-input"}},_create:function(){this._enhance()},_enhance:function(){this.element.attr("role","toolbar"),this.refresh()},_destroy:function(){this._callChildMethod("destroy"),this.childWidgets.removeData("ui-controlgroup-data"),this.element.removeAttr("role"),this.options.items.controlgroupLabel&&this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap()},_initWidgets:function(){var e=this,i=[];t.each(this.options.items,function(s,n){var o,a={};return n?"controlgroupLabel"===s?(o=e.element.find(n),o.each(function(){var e=t(this);e.children(".ui-controlgroup-label-contents").length||e.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>")}),e._addClass(o,null,"ui-widget ui-widget-content ui-state-default"),i=i.concat(o.get()),void 0):(t.fn[s]&&(a=e["_"+s+"Options"]?e["_"+s+"Options"]("middle"):{classes:{}},e.element.find(n).each(function(){var n=t(this),o=n[s]("instance"),r=t.widget.extend({},a);if("button"!==s||!n.parent(".ui-spinner").length){o||(o=n[s]()[s]("instance")),o&&(r.classes=e._resolveClassesValues(r.classes,o)),n[s](r);var h=n[s]("widget");t.data(h[0],"ui-controlgroup-data",o?o:n[s]("instance")),i.push(h[0])}})),void 0):void 0}),this.childWidgets=t(t.unique(i)),this._addClass(this.childWidgets,"ui-controlgroup-item")},_callChildMethod:function(e){this.childWidgets.each(function(){var i=t(this),s=i.data("ui-controlgroup-data");s&&s[e]&&s[e]()})},_updateCornerClass:function(t,e){var i="ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all",s=this._buildSimpleOptions(e,"label").classes.label;this._removeClass(t,null,i),this._addClass(t,null,s)},_buildSimpleOptions:function(t,e){var i="vertical"===this.options.direction,s={classes:{}};return s.classes[e]={middle:"",first:"ui-corner-"+(i?"top":"left"),last:"ui-corner-"+(i?"bottom":"right"),only:"ui-corner-all"}[t],s},_spinnerOptions:function(t){var e=this._buildSimpleOptions(t,"ui-spinner");return e.classes["ui-spinner-up"]="",e.classes["ui-spinner-down"]="",e},_buttonOptions:function(t){return this._buildSimpleOptions(t,"ui-button")},_checkboxradioOptions:function(t){return this._buildSimpleOptions(t,"ui-checkboxradio-label")},_selectmenuOptions:function(t){var e="vertical"===this.options.direction;return{width:e?"auto":!1,classes:{middle:{"ui-selectmenu-button-open":"","ui-selectmenu-button-closed":""},first:{"ui-selectmenu-button-open":"ui-corner-"+(e?"top":"tl"),"ui-selectmenu-button-closed":"ui-corner-"+(e?"top":"left")},last:{"ui-selectmenu-button-open":e?"":"ui-corner-tr","ui-selectmenu-button-closed":"ui-corner-"+(e?"bottom":"right")},only:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"}}[t]}},_resolveClassesValues:function(e,i){var s={};return t.each(e,function(n){var o=i.options.classes[n]||"";o=t.trim(o.replace(g,"")),s[n]=(o+" "+e[n]).replace(/\s+/g," ")}),s},_setOption:function(t,e){return"direction"===t&&this._removeClass("ui-controlgroup-"+this.options.direction),this._super(t,e),"disabled"===t?(this._callChildMethod(e?"disable":"enable"),void 0):(this.refresh(),void 0)},refresh:function(){var e,i=this;this._addClass("ui-controlgroup ui-controlgroup-"+this.options.direction),"horizontal"===this.options.direction&&this._addClass(null,"ui-helper-clearfix"),this._initWidgets(),e=this.childWidgets,this.options.onlyVisible&&(e=e.filter(":visible")),e.length&&(t.each(["first","last"],function(t,s){var n=e[s]().data("ui-controlgroup-data");if(n&&i["_"+n.widgetName+"Options"]){var o=i["_"+n.widgetName+"Options"](1===e.length?"only":s);o.classes=i._resolveClassesValues(o.classes,n),n.element[n.widgetName](o)}else i._updateCornerClass(e[s](),s)}),this._callChildMethod("refresh"))}}),t.widget("ui.checkboxradio",[t.ui.formResetMixin,{version:"1.12.1",options:{disabled:null,label:null,icon:!0,classes:{"ui-checkboxradio-label":"ui-corner-all","ui-checkboxradio-icon":"ui-corner-all"}},_getCreateOptions:function(){var e,i,s=this,n=this._super()||{};return this._readType(),i=this.element.labels(),this.label=t(i[i.length-1]),this.label.length||t.error("No label found for checkboxradio widget"),this.originalLabel="",this.label.contents().not(this.element[0]).each(function(){s.originalLabel+=3===this.nodeType?t(this).text():this.outerHTML}),this.originalLabel&&(n.label=this.originalLabel),e=this.element[0].disabled,null!=e&&(n.disabled=e),n},_create:function(){var t=this.element[0].checked;this._bindFormResetHandler(),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled),this._setOption("disabled",this.options.disabled),this._addClass("ui-checkboxradio","ui-helper-hidden-accessible"),this._addClass(this.label,"ui-checkboxradio-label","ui-button ui-widget"),"radio"===this.type&&this._addClass(this.label,"ui-checkboxradio-radio-label"),this.options.label&&this.options.label!==this.originalLabel?this._updateLabel():this.originalLabel&&(this.options.label=this.originalLabel),this._enhance(),t&&(this._addClass(this.label,"ui-checkboxradio-checked","ui-state-active"),this.icon&&this._addClass(this.icon,null,"ui-state-hover")),this._on({change:"_toggleClasses",focus:function(){this._addClass(this.label,null,"ui-state-focus ui-visual-focus")},blur:function(){this._removeClass(this.label,null,"ui-state-focus ui-visual-focus")}})},_readType:function(){var e=this.element[0].nodeName.toLowerCase();this.type=this.element[0].type,"input"===e&&/radio|checkbox/.test(this.type)||t.error("Can't create checkboxradio on element.nodeName="+e+" and element.type="+this.type)},_enhance:function(){this._updateIcon(this.element[0].checked)},widget:function(){return this.label},_getRadioGroup:function(){var e,i=this.element[0].name,s="input[name='"+t.ui.escapeSelector(i)+"']";return i?(e=this.form.length?t(this.form[0].elements).filter(s):t(s).filter(function(){return 0===t(this).form().length}),e.not(this.element)):t([])},_toggleClasses:function(){var e=this.element[0].checked;this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",e),this.options.icon&&"checkbox"===this.type&&this._toggleClass(this.icon,null,"ui-icon-check ui-state-checked",e)._toggleClass(this.icon,null,"ui-icon-blank",!e),"radio"===this.type&&this._getRadioGroup().each(function(){var e=t(this).checkboxradio("instance");e&&e._removeClass(e.label,"ui-checkboxradio-checked","ui-state-active")})},_destroy:function(){this._unbindFormResetHandler(),this.icon&&(this.icon.remove(),this.iconSpace.remove())},_setOption:function(t,e){return"label"!==t||e?(this._super(t,e),"disabled"===t?(this._toggleClass(this.label,null,"ui-state-disabled",e),this.element[0].disabled=e,void 0):(this.refresh(),void 0)):void 0},_updateIcon:function(e){var i="ui-icon ui-icon-background ";this.options.icon?(this.icon||(this.icon=t("<span>"),this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-checkboxradio-icon-space")),"checkbox"===this.type?(i+=e?"ui-icon-check ui-state-checked":"ui-icon-blank",this._removeClass(this.icon,null,e?"ui-icon-blank":"ui-icon-check")):i+="ui-icon-blank",this._addClass(this.icon,"ui-checkboxradio-icon",i),e||this._removeClass(this.icon,null,"ui-icon-check ui-state-checked"),this.icon.prependTo(this.label).after(this.iconSpace)):void 0!==this.icon&&(this.icon.remove(),this.iconSpace.remove(),delete this.icon)},_updateLabel:function(){var t=this.label.contents().not(this.element[0]);this.icon&&(t=t.not(this.icon[0])),this.iconSpace&&(t=t.not(this.iconSpace[0])),t.remove(),this.label.append(this.options.label)},refresh:function(){var t=this.element[0].checked,e=this.element[0].disabled;this._updateIcon(t),this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",t),null!==this.options.label&&this._updateLabel(),e!==this.options.disabled&&this._setOptions({disabled:e})}}]),t.ui.checkboxradio,t.widget("ui.button",{version:"1.12.1",defaultElement:"<button>",options:{classes:{"ui-button":"ui-corner-all"},disabled:null,icon:null,iconPosition:"beginning",label:null,showLabel:!0},_getCreateOptions:function(){var t,e=this._super()||{};return this.isInput=this.element.is("input"),t=this.element[0].disabled,null!=t&&(e.disabled=t),this.originalLabel=this.isInput?this.element.val():this.element.html(),this.originalLabel&&(e.label=this.originalLabel),e},_create:function(){!this.option.showLabel&!this.options.icon&&(this.options.showLabel=!0),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled||!1),this.hasTitle=!!this.element.attr("title"),this.options.label&&this.options.label!==this.originalLabel&&(this.isInput?this.element.val(this.options.label):this.element.html(this.options.label)),this._addClass("ui-button","ui-widget"),this._setOption("disabled",this.options.disabled),this._enhance(),this.element.is("a")&&this._on({keyup:function(e){e.keyCode===t.ui.keyCode.SPACE&&(e.preventDefault(),this.element[0].click?this.element[0].click():this.element.trigger("click"))}})},_enhance:function(){this.element.is("button")||this.element.attr("role","button"),this.options.icon&&(this._updateIcon("icon",this.options.icon),this._updateTooltip())},_updateTooltip:function(){this.title=this.element.attr("title"),this.options.showLabel||this.title||this.element.attr("title",this.options.label)},_updateIcon:function(e,i){var s="iconPosition"!==e,n=s?this.options.iconPosition:i,o="top"===n||"bottom"===n;this.icon?s&&this._removeClass(this.icon,null,this.options.icon):(this.icon=t("<span>"),this._addClass(this.icon,"ui-button-icon","ui-icon"),this.options.showLabel||this._addClass("ui-button-icon-only")),s&&this._addClass(this.icon,null,i),this._attachIcon(n),o?(this._addClass(this.icon,null,"ui-widget-icon-block"),this.iconSpace&&this.iconSpace.remove()):(this.iconSpace||(this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-button-icon-space")),this._removeClass(this.icon,null,"ui-wiget-icon-block"),this._attachIconSpace(n))},_destroy:function(){this.element.removeAttr("role"),this.icon&&this.icon.remove(),this.iconSpace&&this.iconSpace.remove(),this.hasTitle||this.element.removeAttr("title")},_attachIconSpace:function(t){this.icon[/^(?:end|bottom)/.test(t)?"before":"after"](this.iconSpace)},_attachIcon:function(t){this.element[/^(?:end|bottom)/.test(t)?"append":"prepend"](this.icon)},_setOptions:function(t){var e=void 0===t.showLabel?this.options.showLabel:t.showLabel,i=void 0===t.icon?this.options.icon:t.icon;e||i||(t.showLabel=!0),this._super(t)},_setOption:function(t,e){"icon"===t&&(e?this._updateIcon(t,e):this.icon&&(this.icon.remove(),this.iconSpace&&this.iconSpace.remove())),"iconPosition"===t&&this._updateIcon(t,e),"showLabel"===t&&(this._toggleClass("ui-button-icon-only",null,!e),this._updateTooltip()),"label"===t&&(this.isInput?this.element.val(e):(this.element.html(e),this.icon&&(this._attachIcon(this.options.iconPosition),this._attachIconSpace(this.options.iconPosition)))),this._super(t,e),"disabled"===t&&(this._toggleClass(null,"ui-state-disabled",e),this.element[0].disabled=e,e&&this.element.blur())},refresh:function(){var t=this.element.is("input, button")?this.element[0].disabled:this.element.hasClass("ui-button-disabled");t!==this.options.disabled&&this._setOptions({disabled:t}),this._updateTooltip()}}),t.uiBackCompat!==!1&&(t.widget("ui.button",t.ui.button,{options:{text:!0,icons:{primary:null,secondary:null}},_create:function(){this.options.showLabel&&!this.options.text&&(this.options.showLabel=this.options.text),!this.options.showLabel&&this.options.text&&(this.options.text=this.options.showLabel),this.options.icon||!this.options.icons.primary&&!this.options.icons.secondary?this.options.icon&&(this.options.icons.primary=this.options.icon):this.options.icons.primary?this.options.icon=this.options.icons.primary:(this.options.icon=this.options.icons.secondary,this.options.iconPosition="end"),this._super()},_setOption:function(t,e){return"text"===t?(this._super("showLabel",e),void 0):("showLabel"===t&&(this.options.text=e),"icon"===t&&(this.options.icons.primary=e),"icons"===t&&(e.primary?(this._super("icon",e.primary),this._super("iconPosition","beginning")):e.secondary&&(this._super("icon",e.secondary),this._super("iconPosition","end"))),this._superApply(arguments),void 0)}}),t.fn.button=function(e){return function(){return!this.length||this.length&&"INPUT"!==this[0].tagName||this.length&&"INPUT"===this[0].tagName&&"checkbox"!==this.attr("type")&&"radio"!==this.attr("type")?e.apply(this,arguments):(t.ui.checkboxradio||t.error("Checkboxradio widget missing"),0===arguments.length?this.checkboxradio({icon:!1}):this.checkboxradio.apply(this,arguments))}}(t.fn.button),t.fn.buttonset=function(){return t.ui.controlgroup||t.error("Controlgroup widget missing"),"option"===arguments[0]&&"items"===arguments[1]&&arguments[2]?this.controlgroup.apply(this,[arguments[0],"items.button",arguments[2]]):"option"===arguments[0]&&"items"===arguments[1]?this.controlgroup.apply(this,[arguments[0],"items.button"]):("object"==typeof arguments[0]&&arguments[0].items&&(arguments[0].items={button:arguments[0].items}),this.controlgroup.apply(this,arguments))}),t.ui.button,t.extend(t.ui,{datepicker:{version:"1.12.1"}});var m;t.extend(s.prototype,{markerClassName:"hasDatepicker",maxRows:4,_widgetDatepicker:function(){return this.dpDiv},setDefaults:function(t){return a(this._defaults,t||{}),this},_attachDatepicker:function(e,i){var s,n,o;s=e.nodeName.toLowerCase(),n="div"===s||"span"===s,e.id||(this.uuid+=1,e.id="dp"+this.uuid),o=this._newInst(t(e),n),o.settings=t.extend({},i||{}),"input"===s?this._connectDatepicker(e,o):n&&this._inlineDatepicker(e,o)},_newInst:function(e,i){var s=e[0].id.replace(/([^A-Za-z0-9_\-])/g,"\\\\$1");return{id:s,input:e,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:i,dpDiv:i?n(t("<div class='"+this._inlineClass+" ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")):this.dpDiv}},_connectDatepicker:function(e,i){var s=t(e);i.append=t([]),i.trigger=t([]),s.hasClass(this.markerClassName)||(this._attachments(s,i),s.addClass(this.markerClassName).on("keydown",this._doKeyDown).on("keypress",this._doKeyPress).on("keyup",this._doKeyUp),this._autoSize(i),t.data(e,"datepicker",i),i.settings.disabled&&this._disableDatepicker(e))},_attachments:function(e,i){var s,n,o,a=this._get(i,"appendText"),r=this._get(i,"isRTL");i.append&&i.append.remove(),a&&(i.append=t("<span class='"+this._appendClass+"'>"+a+"</span>"),e[r?"before":"after"](i.append)),e.off("focus",this._showDatepicker),i.trigger&&i.trigger.remove(),s=this._get(i,"showOn"),("focus"===s||"both"===s)&&e.on("focus",this._showDatepicker),("button"===s||"both"===s)&&(n=this._get(i,"buttonText"),o=this._get(i,"buttonImage"),i.trigger=t(this._get(i,"buttonImageOnly")?t("<img/>").addClass(this._triggerClass).attr({src:o,alt:n,title:n}):t("<button type='button'></button>").addClass(this._triggerClass).html(o?t("<img/>").attr({src:o,alt:n,title:n}):n)),e[r?"before":"after"](i.trigger),i.trigger.on("click",function(){return t.datepicker._datepickerShowing&&t.datepicker._lastInput===e[0]?t.datepicker._hideDatepicker():t.datepicker._datepickerShowing&&t.datepicker._lastInput!==e[0]?(t.datepicker._hideDatepicker(),t.datepicker._showDatepicker(e[0])):t.datepicker._showDatepicker(e[0]),!1}))},_autoSize:function(t){if(this._get(t,"autoSize")&&!t.inline){var e,i,s,n,o=new Date(2009,11,20),a=this._get(t,"dateFormat");a.match(/[DM]/)&&(e=function(t){for(i=0,s=0,n=0;t.length>n;n++)t[n].length>i&&(i=t[n].length,s=n);return s},o.setMonth(e(this._get(t,a.match(/MM/)?"monthNames":"monthNamesShort"))),o.setDate(e(this._get(t,a.match(/DD/)?"dayNames":"dayNamesShort"))+20-o.getDay())),t.input.attr("size",this._formatDate(t,o).length)}},_inlineDatepicker:function(e,i){var s=t(e);s.hasClass(this.markerClassName)||(s.addClass(this.markerClassName).append(i.dpDiv),t.data(e,"datepicker",i),this._setDate(i,this._getDefaultDate(i),!0),this._updateDatepicker(i),this._updateAlternate(i),i.settings.disabled&&this._disableDatepicker(e),i.dpDiv.css("display","block"))},_dialogDatepicker:function(e,i,s,n,o){var r,h,l,c,u,d=this._dialogInst;return d||(this.uuid+=1,r="dp"+this.uuid,this._dialogInput=t("<input type='text' id='"+r+"' style='position: absolute; top: -100px; width: 0px;'/>"),this._dialogInput.on("keydown",this._doKeyDown),t("body").append(this._dialogInput),d=this._dialogInst=this._newInst(this._dialogInput,!1),d.settings={},t.data(this._dialogInput[0],"datepicker",d)),a(d.settings,n||{}),i=i&&i.constructor===Date?this._formatDate(d,i):i,this._dialogInput.val(i),this._pos=o?o.length?o:[o.pageX,o.pageY]:null,this._pos||(h=document.documentElement.clientWidth,l=document.documentElement.clientHeight,c=document.documentElement.scrollLeft||document.body.scrollLeft,u=document.documentElement.scrollTop||document.body.scrollTop,this._pos=[h/2-100+c,l/2-150+u]),this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px"),d.settings.onSelect=s,this._inDialog=!0,this.dpDiv.addClass(this._dialogClass),this._showDatepicker(this._dialogInput[0]),t.blockUI&&t.blockUI(this.dpDiv),t.data(this._dialogInput[0],"datepicker",d),this},_destroyDatepicker:function(e){var i,s=t(e),n=t.data(e,"datepicker");s.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),t.removeData(e,"datepicker"),"input"===i?(n.append.remove(),n.trigger.remove(),s.removeClass(this.markerClassName).off("focus",this._showDatepicker).off("keydown",this._doKeyDown).off("keypress",this._doKeyPress).off("keyup",this._doKeyUp)):("div"===i||"span"===i)&&s.removeClass(this.markerClassName).empty(),m===n&&(m=null))},_enableDatepicker:function(e){var i,s,n=t(e),o=t.data(e,"datepicker");n.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),"input"===i?(e.disabled=!1,o.trigger.filter("button").each(function(){this.disabled=!1}).end().filter("img").css({opacity:"1.0",cursor:""})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().removeClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!1)),this._disabledInputs=t.map(this._disabledInputs,function(t){return t===e?null:t}))},_disableDatepicker:function(e){var i,s,n=t(e),o=t.data(e,"datepicker");n.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),"input"===i?(e.disabled=!0,o.trigger.filter("button").each(function(){this.disabled=!0}).end().filter("img").css({opacity:"0.5",cursor:"default"})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().addClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!0)),this._disabledInputs=t.map(this._disabledInputs,function(t){return t===e?null:t}),this._disabledInputs[this._disabledInputs.length]=e)},_isDisabledDatepicker:function(t){if(!t)return!1;for(var e=0;this._disabledInputs.length>e;e++)if(this._disabledInputs[e]===t)return!0;return!1},_getInst:function(e){try{return t.data(e,"datepicker")}catch(i){throw"Missing instance data for this datepicker"}},_optionDatepicker:function(e,i,s){var n,o,r,h,l=this._getInst(e);return 2===arguments.length&&"string"==typeof i?"defaults"===i?t.extend({},t.datepicker._defaults):l?"all"===i?t.extend({},l.settings):this._get(l,i):null:(n=i||{},"string"==typeof i&&(n={},n[i]=s),l&&(this._curInst===l&&this._hideDatepicker(),o=this._getDateDatepicker(e,!0),r=this._getMinMaxDate(l,"min"),h=this._getMinMaxDate(l,"max"),a(l.settings,n),null!==r&&void 0!==n.dateFormat&&void 0===n.minDate&&(l.settings.minDate=this._formatDate(l,r)),null!==h&&void 0!==n.dateFormat&&void 0===n.maxDate&&(l.settings.maxDate=this._formatDate(l,h)),"disabled"in n&&(n.disabled?this._disableDatepicker(e):this._enableDatepicker(e)),this._attachments(t(e),l),this._autoSize(l),this._setDate(l,o),this._updateAlternate(l),this._updateDatepicker(l)),void 0)},_changeDatepicker:function(t,e,i){this._optionDatepicker(t,e,i)},_refreshDatepicker:function(t){var e=this._getInst(t);e&&this._updateDatepicker(e)},_setDateDatepicker:function(t,e){var i=this._getInst(t);i&&(this._setDate(i,e),this._updateDatepicker(i),this._updateAlternate(i))},_getDateDatepicker:function(t,e){var i=this._getInst(t);return i&&!i.inline&&this._setDateFromField(i,e),i?this._getDate(i):null},_doKeyDown:function(e){var i,s,n,o=t.datepicker._getInst(e.target),a=!0,r=o.dpDiv.is(".ui-datepicker-rtl");if(o._keyEvent=!0,t.datepicker._datepickerShowing)switch(e.keyCode){case 9:t.datepicker._hideDatepicker(),a=!1;break;case 13:return n=t("td."+t.datepicker._dayOverClass+":not(."+t.datepicker._currentClass+")",o.dpDiv),n[0]&&t.datepicker._selectDay(e.target,o.selectedMonth,o.selectedYear,n[0]),i=t.datepicker._get(o,"onSelect"),i?(s=t.datepicker._formatDate(o),i.apply(o.input?o.input[0]:null,[s,o])):t.datepicker._hideDatepicker(),!1;case 27:t.datepicker._hideDatepicker();break;case 33:t.datepicker._adjustDate(e.target,e.ctrlKey?-t.datepicker._get(o,"stepBigMonths"):-t.datepicker._get(o,"stepMonths"),"M");break;case 34:t.datepicker._adjustDate(e.target,e.ctrlKey?+t.datepicker._get(o,"stepBigMonths"):+t.datepicker._get(o,"stepMonths"),"M");break;case 35:(e.ctrlKey||e.metaKey)&&t.datepicker._clearDate(e.target),a=e.ctrlKey||e.metaKey;break;case 36:(e.ctrlKey||e.metaKey)&&t.datepicker._gotoToday(e.target),a=e.ctrlKey||e.metaKey;break;case 37:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,r?1:-1,"D"),a=e.ctrlKey||e.metaKey,e.originalEvent.altKey&&t.datepicker._adjustDate(e.target,e.ctrlKey?-t.datepicker._get(o,"stepBigMonths"):-t.datepicker._get(o,"stepMonths"),"M");break;case 38:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,-7,"D"),a=e.ctrlKey||e.metaKey;break;case 39:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,r?-1:1,"D"),a=e.ctrlKey||e.metaKey,e.originalEvent.altKey&&t.datepicker._adjustDate(e.target,e.ctrlKey?+t.datepicker._get(o,"stepBigMonths"):+t.datepicker._get(o,"stepMonths"),"M");break;case 40:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,7,"D"),a=e.ctrlKey||e.metaKey;break;default:a=!1}else 36===e.keyCode&&e.ctrlKey?t.datepicker._showDatepicker(this):a=!1;a&&(e.preventDefault(),e.stopPropagation())},_doKeyPress:function(e){var i,s,n=t.datepicker._getInst(e.target);return t.datepicker._get(n,"constrainInput")?(i=t.datepicker._possibleChars(t.datepicker._get(n,"dateFormat")),s=String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),e.ctrlKey||e.metaKey||" ">s||!i||i.indexOf(s)>-1):void 0},_doKeyUp:function(e){var i,s=t.datepicker._getInst(e.target);if(s.input.val()!==s.lastVal)try{i=t.datepicker.parseDate(t.datepicker._get(s,"dateFormat"),s.input?s.input.val():null,t.datepicker._getFormatConfig(s)),i&&(t.datepicker._setDateFromField(s),t.datepicker._updateAlternate(s),t.datepicker._updateDatepicker(s))}catch(n){}return!0},_showDatepicker:function(e){if(e=e.target||e,"input"!==e.nodeName.toLowerCase()&&(e=t("input",e.parentNode)[0]),!t.datepicker._isDisabledDatepicker(e)&&t.datepicker._lastInput!==e){var s,n,o,r,h,l,c;s=t.datepicker._getInst(e),t.datepicker._curInst&&t.datepicker._curInst!==s&&(t.datepicker._curInst.dpDiv.stop(!0,!0),s&&t.datepicker._datepickerShowing&&t.datepicker._hideDatepicker(t.datepicker._curInst.input[0])),n=t.datepicker._get(s,"beforeShow"),o=n?n.apply(e,[e,s]):{},o!==!1&&(a(s.settings,o),s.lastVal=null,t.datepicker._lastInput=e,t.datepicker._setDateFromField(s),t.datepicker._inDialog&&(e.value=""),t.datepicker._pos||(t.datepicker._pos=t.datepicker._findPos(e),t.datepicker._pos[1]+=e.offsetHeight),r=!1,t(e).parents().each(function(){return r|="fixed"===t(this).css("position"),!r}),h={left:t.datepicker._pos[0],top:t.datepicker._pos[1]},t.datepicker._pos=null,s.dpDiv.empty(),s.dpDiv.css({position:"absolute",display:"block",top:"-1000px"}),t.datepicker._updateDatepicker(s),h=t.datepicker._checkOffset(s,h,r),s.dpDiv.css({position:t.datepicker._inDialog&&t.blockUI?"static":r?"fixed":"absolute",display:"none",left:h.left+"px",top:h.top+"px"}),s.inline||(l=t.datepicker._get(s,"showAnim"),c=t.datepicker._get(s,"duration"),s.dpDiv.css("z-index",i(t(e))+1),t.datepicker._datepickerShowing=!0,t.effects&&t.effects.effect[l]?s.dpDiv.show(l,t.datepicker._get(s,"showOptions"),c):s.dpDiv[l||"show"](l?c:null),t.datepicker._shouldFocusInput(s)&&s.input.trigger("focus"),t.datepicker._curInst=s))
  }},_updateDatepicker:function(e){this.maxRows=4,m=e,e.dpDiv.empty().append(this._generateHTML(e)),this._attachHandlers(e);var i,s=this._getNumberOfMonths(e),n=s[1],a=17,r=e.dpDiv.find("."+this._dayOverClass+" a");r.length>0&&o.apply(r.get(0)),e.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""),n>1&&e.dpDiv.addClass("ui-datepicker-multi-"+n).css("width",a*n+"em"),e.dpDiv[(1!==s[0]||1!==s[1]?"add":"remove")+"Class"]("ui-datepicker-multi"),e.dpDiv[(this._get(e,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl"),e===t.datepicker._curInst&&t.datepicker._datepickerShowing&&t.datepicker._shouldFocusInput(e)&&e.input.trigger("focus"),e.yearshtml&&(i=e.yearshtml,setTimeout(function(){i===e.yearshtml&&e.yearshtml&&e.dpDiv.find("select.ui-datepicker-year:first").replaceWith(e.yearshtml),i=e.yearshtml=null},0))},_shouldFocusInput:function(t){return t.input&&t.input.is(":visible")&&!t.input.is(":disabled")&&!t.input.is(":focus")},_checkOffset:function(e,i,s){var n=e.dpDiv.outerWidth(),o=e.dpDiv.outerHeight(),a=e.input?e.input.outerWidth():0,r=e.input?e.input.outerHeight():0,h=document.documentElement.clientWidth+(s?0:t(document).scrollLeft()),l=document.documentElement.clientHeight+(s?0:t(document).scrollTop());return i.left-=this._get(e,"isRTL")?n-a:0,i.left-=s&&i.left===e.input.offset().left?t(document).scrollLeft():0,i.top-=s&&i.top===e.input.offset().top+r?t(document).scrollTop():0,i.left-=Math.min(i.left,i.left+n>h&&h>n?Math.abs(i.left+n-h):0),i.top-=Math.min(i.top,i.top+o>l&&l>o?Math.abs(o+r):0),i},_findPos:function(e){for(var i,s=this._getInst(e),n=this._get(s,"isRTL");e&&("hidden"===e.type||1!==e.nodeType||t.expr.filters.hidden(e));)e=e[n?"previousSibling":"nextSibling"];return i=t(e).offset(),[i.left,i.top]},_hideDatepicker:function(e){var i,s,n,o,a=this._curInst;!a||e&&a!==t.data(e,"datepicker")||this._datepickerShowing&&(i=this._get(a,"showAnim"),s=this._get(a,"duration"),n=function(){t.datepicker._tidyDialog(a)},t.effects&&(t.effects.effect[i]||t.effects[i])?a.dpDiv.hide(i,t.datepicker._get(a,"showOptions"),s,n):a.dpDiv["slideDown"===i?"slideUp":"fadeIn"===i?"fadeOut":"hide"](i?s:null,n),i||n(),this._datepickerShowing=!1,o=this._get(a,"onClose"),o&&o.apply(a.input?a.input[0]:null,[a.input?a.input.val():"",a]),this._lastInput=null,this._inDialog&&(this._dialogInput.css({position:"absolute",left:"0",top:"-100px"}),t.blockUI&&(t.unblockUI(),t("body").append(this.dpDiv))),this._inDialog=!1)},_tidyDialog:function(t){t.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar")},_checkExternalClick:function(e){if(t.datepicker._curInst){var i=t(e.target),s=t.datepicker._getInst(i[0]);(i[0].id!==t.datepicker._mainDivId&&0===i.parents("#"+t.datepicker._mainDivId).length&&!i.hasClass(t.datepicker.markerClassName)&&!i.closest("."+t.datepicker._triggerClass).length&&t.datepicker._datepickerShowing&&(!t.datepicker._inDialog||!t.blockUI)||i.hasClass(t.datepicker.markerClassName)&&t.datepicker._curInst!==s)&&t.datepicker._hideDatepicker()}},_adjustDate:function(e,i,s){var n=t(e),o=this._getInst(n[0]);this._isDisabledDatepicker(n[0])||(this._adjustInstDate(o,i+("M"===s?this._get(o,"showCurrentAtPos"):0),s),this._updateDatepicker(o))},_gotoToday:function(e){var i,s=t(e),n=this._getInst(s[0]);this._get(n,"gotoCurrent")&&n.currentDay?(n.selectedDay=n.currentDay,n.drawMonth=n.selectedMonth=n.currentMonth,n.drawYear=n.selectedYear=n.currentYear):(i=new Date,n.selectedDay=i.getDate(),n.drawMonth=n.selectedMonth=i.getMonth(),n.drawYear=n.selectedYear=i.getFullYear()),this._notifyChange(n),this._adjustDate(s)},_selectMonthYear:function(e,i,s){var n=t(e),o=this._getInst(n[0]);o["selected"+("M"===s?"Month":"Year")]=o["draw"+("M"===s?"Month":"Year")]=parseInt(i.options[i.selectedIndex].value,10),this._notifyChange(o),this._adjustDate(n)},_selectDay:function(e,i,s,n){var o,a=t(e);t(n).hasClass(this._unselectableClass)||this._isDisabledDatepicker(a[0])||(o=this._getInst(a[0]),o.selectedDay=o.currentDay=t("a",n).html(),o.selectedMonth=o.currentMonth=i,o.selectedYear=o.currentYear=s,this._selectDate(e,this._formatDate(o,o.currentDay,o.currentMonth,o.currentYear)))},_clearDate:function(e){var i=t(e);this._selectDate(i,"")},_selectDate:function(e,i){var s,n=t(e),o=this._getInst(n[0]);i=null!=i?i:this._formatDate(o),o.input&&o.input.val(i),this._updateAlternate(o),s=this._get(o,"onSelect"),s?s.apply(o.input?o.input[0]:null,[i,o]):o.input&&o.input.trigger("change"),o.inline?this._updateDatepicker(o):(this._hideDatepicker(),this._lastInput=o.input[0],"object"!=typeof o.input[0]&&o.input.trigger("focus"),this._lastInput=null)},_updateAlternate:function(e){var i,s,n,o=this._get(e,"altField");o&&(i=this._get(e,"altFormat")||this._get(e,"dateFormat"),s=this._getDate(e),n=this.formatDate(i,s,this._getFormatConfig(e)),t(o).val(n))},noWeekends:function(t){var e=t.getDay();return[e>0&&6>e,""]},iso8601Week:function(t){var e,i=new Date(t.getTime());return i.setDate(i.getDate()+4-(i.getDay()||7)),e=i.getTime(),i.setMonth(0),i.setDate(1),Math.floor(Math.round((e-i)/864e5)/7)+1},parseDate:function(e,i,s){if(null==e||null==i)throw"Invalid arguments";if(i="object"==typeof i?""+i:i+"",""===i)return null;var n,o,a,r,h=0,l=(s?s.shortYearCutoff:null)||this._defaults.shortYearCutoff,c="string"!=typeof l?l:(new Date).getFullYear()%100+parseInt(l,10),u=(s?s.dayNamesShort:null)||this._defaults.dayNamesShort,d=(s?s.dayNames:null)||this._defaults.dayNames,p=(s?s.monthNamesShort:null)||this._defaults.monthNamesShort,f=(s?s.monthNames:null)||this._defaults.monthNames,g=-1,m=-1,_=-1,v=-1,b=!1,y=function(t){var i=e.length>n+1&&e.charAt(n+1)===t;return i&&n++,i},w=function(t){var e=y(t),s="@"===t?14:"!"===t?20:"y"===t&&e?4:"o"===t?3:2,n="y"===t?s:1,o=RegExp("^\\d{"+n+","+s+"}"),a=i.substring(h).match(o);if(!a)throw"Missing number at position "+h;return h+=a[0].length,parseInt(a[0],10)},k=function(e,s,n){var o=-1,a=t.map(y(e)?n:s,function(t,e){return[[e,t]]}).sort(function(t,e){return-(t[1].length-e[1].length)});if(t.each(a,function(t,e){var s=e[1];return i.substr(h,s.length).toLowerCase()===s.toLowerCase()?(o=e[0],h+=s.length,!1):void 0}),-1!==o)return o+1;throw"Unknown name at position "+h},x=function(){if(i.charAt(h)!==e.charAt(n))throw"Unexpected literal at position "+h;h++};for(n=0;e.length>n;n++)if(b)"'"!==e.charAt(n)||y("'")?x():b=!1;else switch(e.charAt(n)){case"d":_=w("d");break;case"D":k("D",u,d);break;case"o":v=w("o");break;case"m":m=w("m");break;case"M":m=k("M",p,f);break;case"y":g=w("y");break;case"@":r=new Date(w("@")),g=r.getFullYear(),m=r.getMonth()+1,_=r.getDate();break;case"!":r=new Date((w("!")-this._ticksTo1970)/1e4),g=r.getFullYear(),m=r.getMonth()+1,_=r.getDate();break;case"'":y("'")?x():b=!0;break;default:x()}if(i.length>h&&(a=i.substr(h),!/^\s+/.test(a)))throw"Extra/unparsed characters found in date: "+a;if(-1===g?g=(new Date).getFullYear():100>g&&(g+=(new Date).getFullYear()-(new Date).getFullYear()%100+(c>=g?0:-100)),v>-1)for(m=1,_=v;;){if(o=this._getDaysInMonth(g,m-1),o>=_)break;m++,_-=o}if(r=this._daylightSavingAdjust(new Date(g,m-1,_)),r.getFullYear()!==g||r.getMonth()+1!==m||r.getDate()!==_)throw"Invalid date";return r},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:1e7*60*60*24*(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925)),formatDate:function(t,e,i){if(!e)return"";var s,n=(i?i.dayNamesShort:null)||this._defaults.dayNamesShort,o=(i?i.dayNames:null)||this._defaults.dayNames,a=(i?i.monthNamesShort:null)||this._defaults.monthNamesShort,r=(i?i.monthNames:null)||this._defaults.monthNames,h=function(e){var i=t.length>s+1&&t.charAt(s+1)===e;return i&&s++,i},l=function(t,e,i){var s=""+e;if(h(t))for(;i>s.length;)s="0"+s;return s},c=function(t,e,i,s){return h(t)?s[e]:i[e]},u="",d=!1;if(e)for(s=0;t.length>s;s++)if(d)"'"!==t.charAt(s)||h("'")?u+=t.charAt(s):d=!1;else switch(t.charAt(s)){case"d":u+=l("d",e.getDate(),2);break;case"D":u+=c("D",e.getDay(),n,o);break;case"o":u+=l("o",Math.round((new Date(e.getFullYear(),e.getMonth(),e.getDate()).getTime()-new Date(e.getFullYear(),0,0).getTime())/864e5),3);break;case"m":u+=l("m",e.getMonth()+1,2);break;case"M":u+=c("M",e.getMonth(),a,r);break;case"y":u+=h("y")?e.getFullYear():(10>e.getFullYear()%100?"0":"")+e.getFullYear()%100;break;case"@":u+=e.getTime();break;case"!":u+=1e4*e.getTime()+this._ticksTo1970;break;case"'":h("'")?u+="'":d=!0;break;default:u+=t.charAt(s)}return u},_possibleChars:function(t){var e,i="",s=!1,n=function(i){var s=t.length>e+1&&t.charAt(e+1)===i;return s&&e++,s};for(e=0;t.length>e;e++)if(s)"'"!==t.charAt(e)||n("'")?i+=t.charAt(e):s=!1;else switch(t.charAt(e)){case"d":case"m":case"y":case"@":i+="0123456789";break;case"D":case"M":return null;case"'":n("'")?i+="'":s=!0;break;default:i+=t.charAt(e)}return i},_get:function(t,e){return void 0!==t.settings[e]?t.settings[e]:this._defaults[e]},_setDateFromField:function(t,e){if(t.input.val()!==t.lastVal){var i=this._get(t,"dateFormat"),s=t.lastVal=t.input?t.input.val():null,n=this._getDefaultDate(t),o=n,a=this._getFormatConfig(t);try{o=this.parseDate(i,s,a)||n}catch(r){s=e?"":s}t.selectedDay=o.getDate(),t.drawMonth=t.selectedMonth=o.getMonth(),t.drawYear=t.selectedYear=o.getFullYear(),t.currentDay=s?o.getDate():0,t.currentMonth=s?o.getMonth():0,t.currentYear=s?o.getFullYear():0,this._adjustInstDate(t)}},_getDefaultDate:function(t){return this._restrictMinMax(t,this._determineDate(t,this._get(t,"defaultDate"),new Date))},_determineDate:function(e,i,s){var n=function(t){var e=new Date;return e.setDate(e.getDate()+t),e},o=function(i){try{return t.datepicker.parseDate(t.datepicker._get(e,"dateFormat"),i,t.datepicker._getFormatConfig(e))}catch(s){}for(var n=(i.toLowerCase().match(/^c/)?t.datepicker._getDate(e):null)||new Date,o=n.getFullYear(),a=n.getMonth(),r=n.getDate(),h=/([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,l=h.exec(i);l;){switch(l[2]||"d"){case"d":case"D":r+=parseInt(l[1],10);break;case"w":case"W":r+=7*parseInt(l[1],10);break;case"m":case"M":a+=parseInt(l[1],10),r=Math.min(r,t.datepicker._getDaysInMonth(o,a));break;case"y":case"Y":o+=parseInt(l[1],10),r=Math.min(r,t.datepicker._getDaysInMonth(o,a))}l=h.exec(i)}return new Date(o,a,r)},a=null==i||""===i?s:"string"==typeof i?o(i):"number"==typeof i?isNaN(i)?s:n(i):new Date(i.getTime());return a=a&&"Invalid Date"==""+a?s:a,a&&(a.setHours(0),a.setMinutes(0),a.setSeconds(0),a.setMilliseconds(0)),this._daylightSavingAdjust(a)},_daylightSavingAdjust:function(t){return t?(t.setHours(t.getHours()>12?t.getHours()+2:0),t):null},_setDate:function(t,e,i){var s=!e,n=t.selectedMonth,o=t.selectedYear,a=this._restrictMinMax(t,this._determineDate(t,e,new Date));t.selectedDay=t.currentDay=a.getDate(),t.drawMonth=t.selectedMonth=t.currentMonth=a.getMonth(),t.drawYear=t.selectedYear=t.currentYear=a.getFullYear(),n===t.selectedMonth&&o===t.selectedYear||i||this._notifyChange(t),this._adjustInstDate(t),t.input&&t.input.val(s?"":this._formatDate(t))},_getDate:function(t){var e=!t.currentYear||t.input&&""===t.input.val()?null:this._daylightSavingAdjust(new Date(t.currentYear,t.currentMonth,t.currentDay));return e},_attachHandlers:function(e){var i=this._get(e,"stepMonths"),s="#"+e.id.replace(/\\\\/g,"\\");e.dpDiv.find("[data-handler]").map(function(){var e={prev:function(){t.datepicker._adjustDate(s,-i,"M")},next:function(){t.datepicker._adjustDate(s,+i,"M")},hide:function(){t.datepicker._hideDatepicker()},today:function(){t.datepicker._gotoToday(s)},selectDay:function(){return t.datepicker._selectDay(s,+this.getAttribute("data-month"),+this.getAttribute("data-year"),this),!1},selectMonth:function(){return t.datepicker._selectMonthYear(s,this,"M"),!1},selectYear:function(){return t.datepicker._selectMonthYear(s,this,"Y"),!1}};t(this).on(this.getAttribute("data-event"),e[this.getAttribute("data-handler")])})},_generateHTML:function(t){var e,i,s,n,o,a,r,h,l,c,u,d,p,f,g,m,_,v,b,y,w,k,x,C,D,I,T,P,M,S,H,z,O,A,N,W,E,F,L,R=new Date,B=this._daylightSavingAdjust(new Date(R.getFullYear(),R.getMonth(),R.getDate())),Y=this._get(t,"isRTL"),j=this._get(t,"showButtonPanel"),q=this._get(t,"hideIfNoPrevNext"),K=this._get(t,"navigationAsDateFormat"),U=this._getNumberOfMonths(t),V=this._get(t,"showCurrentAtPos"),$=this._get(t,"stepMonths"),X=1!==U[0]||1!==U[1],G=this._daylightSavingAdjust(t.currentDay?new Date(t.currentYear,t.currentMonth,t.currentDay):new Date(9999,9,9)),Q=this._getMinMaxDate(t,"min"),J=this._getMinMaxDate(t,"max"),Z=t.drawMonth-V,te=t.drawYear;if(0>Z&&(Z+=12,te--),J)for(e=this._daylightSavingAdjust(new Date(J.getFullYear(),J.getMonth()-U[0]*U[1]+1,J.getDate())),e=Q&&Q>e?Q:e;this._daylightSavingAdjust(new Date(te,Z,1))>e;)Z--,0>Z&&(Z=11,te--);for(t.drawMonth=Z,t.drawYear=te,i=this._get(t,"prevText"),i=K?this.formatDate(i,this._daylightSavingAdjust(new Date(te,Z-$,1)),this._getFormatConfig(t)):i,s=this._canAdjustMonth(t,-1,te,Z)?"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>":q?"":"<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>",n=this._get(t,"nextText"),n=K?this.formatDate(n,this._daylightSavingAdjust(new Date(te,Z+$,1)),this._getFormatConfig(t)):n,o=this._canAdjustMonth(t,1,te,Z)?"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>":q?"":"<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>",a=this._get(t,"currentText"),r=this._get(t,"gotoCurrent")&&t.currentDay?G:B,a=K?this.formatDate(a,r,this._getFormatConfig(t)):a,h=t.inline?"":"<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>"+this._get(t,"closeText")+"</button>",l=j?"<div class='ui-datepicker-buttonpane ui-widget-content'>"+(Y?h:"")+(this._isInRange(t,r)?"<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>"+a+"</button>":"")+(Y?"":h)+"</div>":"",c=parseInt(this._get(t,"firstDay"),10),c=isNaN(c)?0:c,u=this._get(t,"showWeek"),d=this._get(t,"dayNames"),p=this._get(t,"dayNamesMin"),f=this._get(t,"monthNames"),g=this._get(t,"monthNamesShort"),m=this._get(t,"beforeShowDay"),_=this._get(t,"showOtherMonths"),v=this._get(t,"selectOtherMonths"),b=this._getDefaultDate(t),y="",k=0;U[0]>k;k++){for(x="",this.maxRows=4,C=0;U[1]>C;C++){if(D=this._daylightSavingAdjust(new Date(te,Z,t.selectedDay)),I=" ui-corner-all",T="",X){if(T+="<div class='ui-datepicker-group",U[1]>1)switch(C){case 0:T+=" ui-datepicker-group-first",I=" ui-corner-"+(Y?"right":"left");break;case U[1]-1:T+=" ui-datepicker-group-last",I=" ui-corner-"+(Y?"left":"right");break;default:T+=" ui-datepicker-group-middle",I=""}T+="'>"}for(T+="<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix"+I+"'>"+(/all|left/.test(I)&&0===k?Y?o:s:"")+(/all|right/.test(I)&&0===k?Y?s:o:"")+this._generateMonthYearHeader(t,Z,te,Q,J,k>0||C>0,f,g)+"</div><table class='ui-datepicker-calendar'><thead>"+"<tr>",P=u?"<th class='ui-datepicker-week-col'>"+this._get(t,"weekHeader")+"</th>":"",w=0;7>w;w++)M=(w+c)%7,P+="<th scope='col'"+((w+c+6)%7>=5?" class='ui-datepicker-week-end'":"")+">"+"<span title='"+d[M]+"'>"+p[M]+"</span></th>";for(T+=P+"</tr></thead><tbody>",S=this._getDaysInMonth(te,Z),te===t.selectedYear&&Z===t.selectedMonth&&(t.selectedDay=Math.min(t.selectedDay,S)),H=(this._getFirstDayOfMonth(te,Z)-c+7)%7,z=Math.ceil((H+S)/7),O=X?this.maxRows>z?this.maxRows:z:z,this.maxRows=O,A=this._daylightSavingAdjust(new Date(te,Z,1-H)),N=0;O>N;N++){for(T+="<tr>",W=u?"<td class='ui-datepicker-week-col'>"+this._get(t,"calculateWeek")(A)+"</td>":"",w=0;7>w;w++)E=m?m.apply(t.input?t.input[0]:null,[A]):[!0,""],F=A.getMonth()!==Z,L=F&&!v||!E[0]||Q&&Q>A||J&&A>J,W+="<td class='"+((w+c+6)%7>=5?" ui-datepicker-week-end":"")+(F?" ui-datepicker-other-month":"")+(A.getTime()===D.getTime()&&Z===t.selectedMonth&&t._keyEvent||b.getTime()===A.getTime()&&b.getTime()===D.getTime()?" "+this._dayOverClass:"")+(L?" "+this._unselectableClass+" ui-state-disabled":"")+(F&&!_?"":" "+E[1]+(A.getTime()===G.getTime()?" "+this._currentClass:"")+(A.getTime()===B.getTime()?" ui-datepicker-today":""))+"'"+(F&&!_||!E[2]?"":" title='"+E[2].replace(/'/g,"&#39;")+"'")+(L?"":" data-handler='selectDay' data-event='click' data-month='"+A.getMonth()+"' data-year='"+A.getFullYear()+"'")+">"+(F&&!_?"&#xa0;":L?"<span class='ui-state-default'>"+A.getDate()+"</span>":"<a class='ui-state-default"+(A.getTime()===B.getTime()?" ui-state-highlight":"")+(A.getTime()===G.getTime()?" ui-state-active":"")+(F?" ui-priority-secondary":"")+"' href='#'>"+A.getDate()+"</a>")+"</td>",A.setDate(A.getDate()+1),A=this._daylightSavingAdjust(A);T+=W+"</tr>"}Z++,Z>11&&(Z=0,te++),T+="</tbody></table>"+(X?"</div>"+(U[0]>0&&C===U[1]-1?"<div class='ui-datepicker-row-break'></div>":""):""),x+=T}y+=x}return y+=l,t._keyEvent=!1,y},_generateMonthYearHeader:function(t,e,i,s,n,o,a,r){var h,l,c,u,d,p,f,g,m=this._get(t,"changeMonth"),_=this._get(t,"changeYear"),v=this._get(t,"showMonthAfterYear"),b="<div class='ui-datepicker-title'>",y="";if(o||!m)y+="<span class='ui-datepicker-month'>"+a[e]+"</span>";else{for(h=s&&s.getFullYear()===i,l=n&&n.getFullYear()===i,y+="<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>",c=0;12>c;c++)(!h||c>=s.getMonth())&&(!l||n.getMonth()>=c)&&(y+="<option value='"+c+"'"+(c===e?" selected='selected'":"")+">"+r[c]+"</option>");y+="</select>"}if(v||(b+=y+(!o&&m&&_?"":"&#xa0;")),!t.yearshtml)if(t.yearshtml="",o||!_)b+="<span class='ui-datepicker-year'>"+i+"</span>";else{for(u=this._get(t,"yearRange").split(":"),d=(new Date).getFullYear(),p=function(t){var e=t.match(/c[+\-].*/)?i+parseInt(t.substring(1),10):t.match(/[+\-].*/)?d+parseInt(t,10):parseInt(t,10);return isNaN(e)?d:e},f=p(u[0]),g=Math.max(f,p(u[1]||"")),f=s?Math.max(f,s.getFullYear()):f,g=n?Math.min(g,n.getFullYear()):g,t.yearshtml+="<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";g>=f;f++)t.yearshtml+="<option value='"+f+"'"+(f===i?" selected='selected'":"")+">"+f+"</option>";t.yearshtml+="</select>",b+=t.yearshtml,t.yearshtml=null}return b+=this._get(t,"yearSuffix"),v&&(b+=(!o&&m&&_?"":"&#xa0;")+y),b+="</div>"},_adjustInstDate:function(t,e,i){var s=t.selectedYear+("Y"===i?e:0),n=t.selectedMonth+("M"===i?e:0),o=Math.min(t.selectedDay,this._getDaysInMonth(s,n))+("D"===i?e:0),a=this._restrictMinMax(t,this._daylightSavingAdjust(new Date(s,n,o)));t.selectedDay=a.getDate(),t.drawMonth=t.selectedMonth=a.getMonth(),t.drawYear=t.selectedYear=a.getFullYear(),("M"===i||"Y"===i)&&this._notifyChange(t)},_restrictMinMax:function(t,e){var i=this._getMinMaxDate(t,"min"),s=this._getMinMaxDate(t,"max"),n=i&&i>e?i:e;return s&&n>s?s:n},_notifyChange:function(t){var e=this._get(t,"onChangeMonthYear");e&&e.apply(t.input?t.input[0]:null,[t.selectedYear,t.selectedMonth+1,t])},_getNumberOfMonths:function(t){var e=this._get(t,"numberOfMonths");return null==e?[1,1]:"number"==typeof e?[1,e]:e},_getMinMaxDate:function(t,e){return this._determineDate(t,this._get(t,e+"Date"),null)},_getDaysInMonth:function(t,e){return 32-this._daylightSavingAdjust(new Date(t,e,32)).getDate()},_getFirstDayOfMonth:function(t,e){return new Date(t,e,1).getDay()},_canAdjustMonth:function(t,e,i,s){var n=this._getNumberOfMonths(t),o=this._daylightSavingAdjust(new Date(i,s+(0>e?e:n[0]*n[1]),1));return 0>e&&o.setDate(this._getDaysInMonth(o.getFullYear(),o.getMonth())),this._isInRange(t,o)},_isInRange:function(t,e){var i,s,n=this._getMinMaxDate(t,"min"),o=this._getMinMaxDate(t,"max"),a=null,r=null,h=this._get(t,"yearRange");return h&&(i=h.split(":"),s=(new Date).getFullYear(),a=parseInt(i[0],10),r=parseInt(i[1],10),i[0].match(/[+\-].*/)&&(a+=s),i[1].match(/[+\-].*/)&&(r+=s)),(!n||e.getTime()>=n.getTime())&&(!o||e.getTime()<=o.getTime())&&(!a||e.getFullYear()>=a)&&(!r||r>=e.getFullYear())},_getFormatConfig:function(t){var e=this._get(t,"shortYearCutoff");return e="string"!=typeof e?e:(new Date).getFullYear()%100+parseInt(e,10),{shortYearCutoff:e,dayNamesShort:this._get(t,"dayNamesShort"),dayNames:this._get(t,"dayNames"),monthNamesShort:this._get(t,"monthNamesShort"),monthNames:this._get(t,"monthNames")}},_formatDate:function(t,e,i,s){e||(t.currentDay=t.selectedDay,t.currentMonth=t.selectedMonth,t.currentYear=t.selectedYear);var n=e?"object"==typeof e?e:this._daylightSavingAdjust(new Date(s,i,e)):this._daylightSavingAdjust(new Date(t.currentYear,t.currentMonth,t.currentDay));return this.formatDate(this._get(t,"dateFormat"),n,this._getFormatConfig(t))}}),t.fn.datepicker=function(e){if(!this.length)return this;t.datepicker.initialized||(t(document).on("mousedown",t.datepicker._checkExternalClick),t.datepicker.initialized=!0),0===t("#"+t.datepicker._mainDivId).length&&t("body").append(t.datepicker.dpDiv);var i=Array.prototype.slice.call(arguments,1);return"string"!=typeof e||"isDisabled"!==e&&"getDate"!==e&&"widget"!==e?"option"===e&&2===arguments.length&&"string"==typeof arguments[1]?t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this[0]].concat(i)):this.each(function(){"string"==typeof e?t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this].concat(i)):t.datepicker._attachDatepicker(this,e)}):t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this[0]].concat(i))},t.datepicker=new s,t.datepicker.initialized=!1,t.datepicker.uuid=(new Date).getTime(),t.datepicker.version="1.12.1",t.datepicker,t.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());var _=!1;t(document).on("mouseup",function(){_=!1}),t.widget("ui.mouse",{version:"1.12.1",options:{cancel:"input, textarea, button, select, option",distance:1,delay:0},_mouseInit:function(){var e=this;this.element.on("mousedown."+this.widgetName,function(t){return e._mouseDown(t)}).on("click."+this.widgetName,function(i){return!0===t.data(i.target,e.widgetName+".preventClickEvent")?(t.removeData(i.target,e.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.off("."+this.widgetName),this._mouseMoveDelegate&&this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(e){if(!_){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(e),this._mouseDownEvent=e;var i=this,s=1===e.which,n="string"==typeof this.options.cancel&&e.target.nodeName?t(e.target).closest(this.options.cancel).length:!1;return s&&!n&&this._mouseCapture(e)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){i.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(e)!==!1,!this._mouseStarted)?(e.preventDefault(),!0):(!0===t.data(e.target,this.widgetName+".preventClickEvent")&&t.removeData(e.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(t){return i._mouseMove(t)},this._mouseUpDelegate=function(t){return i._mouseUp(t)},this.document.on("mousemove."+this.widgetName,this._mouseMoveDelegate).on("mouseup."+this.widgetName,this._mouseUpDelegate),e.preventDefault(),_=!0,!0)):!0}},_mouseMove:function(e){if(this._mouseMoved){if(t.ui.ie&&(!document.documentMode||9>document.documentMode)&&!e.button)return this._mouseUp(e);if(!e.which)if(e.originalEvent.altKey||e.originalEvent.ctrlKey||e.originalEvent.metaKey||e.originalEvent.shiftKey)this.ignoreMissingWhich=!0;else if(!this.ignoreMissingWhich)return this._mouseUp(e)}return(e.which||e.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(e),e.preventDefault()):(this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,e)!==!1,this._mouseStarted?this._mouseDrag(e):this._mouseUp(e)),!this._mouseStarted)},_mouseUp:function(e){this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,e.target===this._mouseDownEvent.target&&t.data(e.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(e)),this._mouseDelayTimer&&(clearTimeout(this._mouseDelayTimer),delete this._mouseDelayTimer),this.ignoreMissingWhich=!1,_=!1,e.preventDefault()},_mouseDistanceMet:function(t){return Math.max(Math.abs(this._mouseDownEvent.pageX-t.pageX),Math.abs(this._mouseDownEvent.pageY-t.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),t.ui.plugin={add:function(e,i,s){var n,o=t.ui[e].prototype;for(n in s)o.plugins[n]=o.plugins[n]||[],o.plugins[n].push([i,s[n]])},call:function(t,e,i,s){var n,o=t.plugins[e];if(o&&(s||t.element[0].parentNode&&11!==t.element[0].parentNode.nodeType))for(n=0;o.length>n;n++)t.options[o[n][0]]&&o[n][1].apply(t.element,i)}},t.ui.safeBlur=function(e){e&&"body"!==e.nodeName.toLowerCase()&&t(e).trigger("blur")},t.widget("ui.draggable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this._addClass("ui-draggable"),this._setHandleClassName(),this._mouseInit()},_setOption:function(t,e){this._super(t,e),"handle"===t&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?(this.destroyOnClear=!0,void 0):(this._removeHandleClassName(),this._mouseDestroy(),void 0)},_mouseCapture:function(e){var i=this.options;return this.helper||i.disabled||t(e.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(e),this.handle?(this._blurActiveElement(e),this._blockFrames(i.iframeFix===!0?"iframe":i.iframeFix),!0):!1)},_blockFrames:function(e){this.iframeBlocks=this.document.find(e).map(function(){var e=t(this);return t("<div>").css("position","absolute").appendTo(e.parent()).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(e){var i=t.ui.safeActiveElement(this.document[0]),s=t(e.target);s.closest(i).length||t.ui.safeBlur(i)},_mouseStart:function(e){var i=this.options;return this.helper=this._createHelper(e),this._addClass(this.helper,"ui-draggable-dragging"),this._cacheHelperProportions(),t.ui.ddmanager&&(t.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=this.helper.parents().filter(function(){return"fixed"===t(this).css("position")}).length>0,this.positionAbs=this.element.offset(),this._refreshOffsets(e),this.originalPosition=this.position=this._generatePosition(e,!1),this.originalPageX=e.pageX,this.originalPageY=e.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",e)===!1?(this._clear(),!1):(this._cacheHelperProportions(),t.ui.ddmanager&&!i.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this._mouseDrag(e,!0),t.ui.ddmanager&&t.ui.ddmanager.dragStart(this,e),!0)},_refreshOffsets:function(t){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:t.pageX-this.offset.left,top:t.pageY-this.offset.top}},_mouseDrag:function(e,i){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(e,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",e,s)===!1)return this._mouseUp(new t.Event("mouseup",e)),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),!1},_mouseStop:function(e){var i=this,s=!1;return t.ui.ddmanager&&!this.options.dropBehaviour&&(s=t.ui.ddmanager.drop(this,e)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||this.options.revert===!0||t.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?t(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",e)!==!1&&i._clear()}):this._trigger("stop",e)!==!1&&this._clear(),!1},_mouseUp:function(e){return this._unblockFrames(),t.ui.ddmanager&&t.ui.ddmanager.dragStop(this,e),this.handleElement.is(e.target)&&this.element.trigger("focus"),t.ui.mouse.prototype._mouseUp.call(this,e)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp(new t.Event("mouseup",{target:this.element[0]})):this._clear(),this},_getHandle:function(e){return this.options.handle?!!t(e.target).closest(this.element.find(this.options.handle)).length:!0},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this._addClass(this.handleElement,"ui-draggable-handle")},_removeHandleClassName:function(){this._removeClass(this.handleElement,"ui-draggable-handle")},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper),n=s?t(i.helper.apply(this.element[0],[e])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return n.parents("body").length||n.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s&&n[0]===this.element[0]&&this._setPositionRelative(),n[0]===this.element[0]||/(fixed|absolute)/.test(n.css("position"))||n.css("position","absolute"),n},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_isRootNode:function(t){return/(html|body)/i.test(t.tagName)||t===this.document[0]},_getParentOffset:function(){var e=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var t=this.element.position(),e=this._isRootNode(this.scrollParent[0]);return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+(e?0:this.scrollParent.scrollTop()),left:t.left-(parseInt(this.helper.css("left"),10)||0)+(e?0:this.scrollParent.scrollLeft())}
  },_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,n=this.options,o=this.document[0];return this.relativeContainer=null,n.containment?"window"===n.containment?(this.containment=[t(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,t(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,t(window).scrollLeft()+t(window).width()-this.helperProportions.width-this.margins.left,t(window).scrollTop()+(t(window).height()||o.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):"document"===n.containment?(this.containment=[0,0,t(o).width()-this.helperProportions.width-this.margins.left,(t(o).height()||o.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):n.containment.constructor===Array?(this.containment=n.containment,void 0):("parent"===n.containment&&(n.containment=this.helper[0].parentNode),i=t(n.containment),s=i[0],s&&(e=/(scroll|auto)/.test(i.css("overflow")),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(e?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(e?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=i),void 0):(this.containment=null,void 0)},_convertPositionTo:function(t,e){e||(e=this.position);var i="absolute"===t?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:e.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:e.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(t,e){var i,s,n,o,a=this.options,r=this._isRootNode(this.scrollParent[0]),h=t.pageX,l=t.pageY;return r&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),e&&(this.containment&&(this.relativeContainer?(s=this.relativeContainer.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,t.pageX-this.offset.click.left<i[0]&&(h=i[0]+this.offset.click.left),t.pageY-this.offset.click.top<i[1]&&(l=i[1]+this.offset.click.top),t.pageX-this.offset.click.left>i[2]&&(h=i[2]+this.offset.click.left),t.pageY-this.offset.click.top>i[3]&&(l=i[3]+this.offset.click.top)),a.grid&&(n=a.grid[1]?this.originalPageY+Math.round((l-this.originalPageY)/a.grid[1])*a.grid[1]:this.originalPageY,l=i?n-this.offset.click.top>=i[1]||n-this.offset.click.top>i[3]?n:n-this.offset.click.top>=i[1]?n-a.grid[1]:n+a.grid[1]:n,o=a.grid[0]?this.originalPageX+Math.round((h-this.originalPageX)/a.grid[0])*a.grid[0]:this.originalPageX,h=i?o-this.offset.click.left>=i[0]||o-this.offset.click.left>i[2]?o:o-this.offset.click.left>=i[0]?o-a.grid[0]:o+a.grid[0]:o),"y"===a.axis&&(h=this.originalPageX),"x"===a.axis&&(l=this.originalPageY)),{top:l-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:r?0:this.offset.scroll.top),left:h-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:r?0:this.offset.scroll.left)}},_clear:function(){this._removeClass(this.helper,"ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_trigger:function(e,i,s){return s=s||this._uiHash(),t.ui.plugin.call(this,e,[i,s,this],!0),/^(drag|start|stop)/.test(e)&&(this.positionAbs=this._convertPositionTo("absolute"),s.offset=this.positionAbs),t.Widget.prototype._trigger.call(this,e,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),t.ui.plugin.add("draggable","connectToSortable",{start:function(e,i,s){var n=t.extend({},i,{item:s.element});s.sortables=[],t(s.options.connectToSortable).each(function(){var i=t(this).sortable("instance");i&&!i.options.disabled&&(s.sortables.push(i),i.refreshPositions(),i._trigger("activate",e,n))})},stop:function(e,i,s){var n=t.extend({},i,{item:s.element});s.cancelHelperRemoval=!1,t.each(s.sortables,function(){var t=this;t.isOver?(t.isOver=0,s.cancelHelperRemoval=!0,t.cancelHelperRemoval=!1,t._storedCSS={position:t.placeholder.css("position"),top:t.placeholder.css("top"),left:t.placeholder.css("left")},t._mouseStop(e),t.options.helper=t.options._helper):(t.cancelHelperRemoval=!0,t._trigger("deactivate",e,n))})},drag:function(e,i,s){t.each(s.sortables,function(){var n=!1,o=this;o.positionAbs=s.positionAbs,o.helperProportions=s.helperProportions,o.offset.click=s.offset.click,o._intersectsWith(o.containerCache)&&(n=!0,t.each(s.sortables,function(){return this.positionAbs=s.positionAbs,this.helperProportions=s.helperProportions,this.offset.click=s.offset.click,this!==o&&this._intersectsWith(this.containerCache)&&t.contains(o.element[0],this.element[0])&&(n=!1),n})),n?(o.isOver||(o.isOver=1,s._parent=i.helper.parent(),o.currentItem=i.helper.appendTo(o.element).data("ui-sortable-item",!0),o.options._helper=o.options.helper,o.options.helper=function(){return i.helper[0]},e.target=o.currentItem[0],o._mouseCapture(e,!0),o._mouseStart(e,!0,!0),o.offset.click.top=s.offset.click.top,o.offset.click.left=s.offset.click.left,o.offset.parent.left-=s.offset.parent.left-o.offset.parent.left,o.offset.parent.top-=s.offset.parent.top-o.offset.parent.top,s._trigger("toSortable",e),s.dropped=o.element,t.each(s.sortables,function(){this.refreshPositions()}),s.currentItem=s.element,o.fromOutside=s),o.currentItem&&(o._mouseDrag(e),i.position=o.position)):o.isOver&&(o.isOver=0,o.cancelHelperRemoval=!0,o.options._revert=o.options.revert,o.options.revert=!1,o._trigger("out",e,o._uiHash(o)),o._mouseStop(e,!0),o.options.revert=o.options._revert,o.options.helper=o.options._helper,o.placeholder&&o.placeholder.remove(),i.helper.appendTo(s._parent),s._refreshOffsets(e),i.position=s._generatePosition(e,!0),s._trigger("fromSortable",e),s.dropped=!1,t.each(s.sortables,function(){this.refreshPositions()}))})}}),t.ui.plugin.add("draggable","cursor",{start:function(e,i,s){var n=t("body"),o=s.options;n.css("cursor")&&(o._cursor=n.css("cursor")),n.css("cursor",o.cursor)},stop:function(e,i,s){var n=s.options;n._cursor&&t("body").css("cursor",n._cursor)}}),t.ui.plugin.add("draggable","opacity",{start:function(e,i,s){var n=t(i.helper),o=s.options;n.css("opacity")&&(o._opacity=n.css("opacity")),n.css("opacity",o.opacity)},stop:function(e,i,s){var n=s.options;n._opacity&&t(i.helper).css("opacity",n._opacity)}}),t.ui.plugin.add("draggable","scroll",{start:function(t,e,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(e,i,s){var n=s.options,o=!1,a=s.scrollParentNotHidden[0],r=s.document[0];a!==r&&"HTML"!==a.tagName?(n.axis&&"x"===n.axis||(s.overflowOffset.top+a.offsetHeight-e.pageY<n.scrollSensitivity?a.scrollTop=o=a.scrollTop+n.scrollSpeed:e.pageY-s.overflowOffset.top<n.scrollSensitivity&&(a.scrollTop=o=a.scrollTop-n.scrollSpeed)),n.axis&&"y"===n.axis||(s.overflowOffset.left+a.offsetWidth-e.pageX<n.scrollSensitivity?a.scrollLeft=o=a.scrollLeft+n.scrollSpeed:e.pageX-s.overflowOffset.left<n.scrollSensitivity&&(a.scrollLeft=o=a.scrollLeft-n.scrollSpeed))):(n.axis&&"x"===n.axis||(e.pageY-t(r).scrollTop()<n.scrollSensitivity?o=t(r).scrollTop(t(r).scrollTop()-n.scrollSpeed):t(window).height()-(e.pageY-t(r).scrollTop())<n.scrollSensitivity&&(o=t(r).scrollTop(t(r).scrollTop()+n.scrollSpeed))),n.axis&&"y"===n.axis||(e.pageX-t(r).scrollLeft()<n.scrollSensitivity?o=t(r).scrollLeft(t(r).scrollLeft()-n.scrollSpeed):t(window).width()-(e.pageX-t(r).scrollLeft())<n.scrollSensitivity&&(o=t(r).scrollLeft(t(r).scrollLeft()+n.scrollSpeed)))),o!==!1&&t.ui.ddmanager&&!n.dropBehaviour&&t.ui.ddmanager.prepareOffsets(s,e)}}),t.ui.plugin.add("draggable","snap",{start:function(e,i,s){var n=s.options;s.snapElements=[],t(n.snap.constructor!==String?n.snap.items||":data(ui-draggable)":n.snap).each(function(){var e=t(this),i=e.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:e.outerWidth(),height:e.outerHeight(),top:i.top,left:i.left})})},drag:function(e,i,s){var n,o,a,r,h,l,c,u,d,p,f=s.options,g=f.snapTolerance,m=i.offset.left,_=m+s.helperProportions.width,v=i.offset.top,b=v+s.helperProportions.height;for(d=s.snapElements.length-1;d>=0;d--)h=s.snapElements[d].left-s.margins.left,l=h+s.snapElements[d].width,c=s.snapElements[d].top-s.margins.top,u=c+s.snapElements[d].height,h-g>_||m>l+g||c-g>b||v>u+g||!t.contains(s.snapElements[d].item.ownerDocument,s.snapElements[d].item)?(s.snapElements[d].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[d].item})),s.snapElements[d].snapping=!1):("inner"!==f.snapMode&&(n=g>=Math.abs(c-b),o=g>=Math.abs(u-v),a=g>=Math.abs(h-_),r=g>=Math.abs(l-m),n&&(i.position.top=s._convertPositionTo("relative",{top:c-s.helperProportions.height,left:0}).top),o&&(i.position.top=s._convertPositionTo("relative",{top:u,left:0}).top),a&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h-s.helperProportions.width}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left)),p=n||o||a||r,"outer"!==f.snapMode&&(n=g>=Math.abs(c-v),o=g>=Math.abs(u-b),a=g>=Math.abs(h-m),r=g>=Math.abs(l-_),n&&(i.position.top=s._convertPositionTo("relative",{top:c,left:0}).top),o&&(i.position.top=s._convertPositionTo("relative",{top:u-s.helperProportions.height,left:0}).top),a&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left)),!s.snapElements[d].snapping&&(n||o||a||r||p)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[d].item})),s.snapElements[d].snapping=n||o||a||r||p)}}),t.ui.plugin.add("draggable","stack",{start:function(e,i,s){var n,o=s.options,a=t.makeArray(t(o.stack)).sort(function(e,i){return(parseInt(t(e).css("zIndex"),10)||0)-(parseInt(t(i).css("zIndex"),10)||0)});a.length&&(n=parseInt(t(a[0]).css("zIndex"),10)||0,t(a).each(function(e){t(this).css("zIndex",n+e)}),this.css("zIndex",n+a.length))}}),t.ui.plugin.add("draggable","zIndex",{start:function(e,i,s){var n=t(i.helper),o=s.options;n.css("zIndex")&&(o._zIndex=n.css("zIndex")),n.css("zIndex",o.zIndex)},stop:function(e,i,s){var n=s.options;n._zIndex&&t(i.helper).css("zIndex",n._zIndex)}}),t.ui.draggable,t.widget("ui.resizable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,classes:{"ui-resizable-se":"ui-icon ui-icon-gripsmall-diagonal-se"},containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_num:function(t){return parseFloat(t)||0},_isNumber:function(t){return!isNaN(parseFloat(t))},_hasScroll:function(e,i){if("hidden"===t(e).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",n=!1;return e[s]>0?!0:(e[s]=1,n=e[s]>0,e[s]=0,n)},_create:function(){var e,i=this.options,s=this;this._addClass("ui-resizable"),t.extend(this,{_aspectRatio:!!i.aspectRatio,aspectRatio:i.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:i.helper||i.ghost||i.animate?i.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)&&(this.element.wrap(t("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.resizable("instance")),this.elementIsWrapper=!0,e={marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom"),marginLeft:this.originalElement.css("marginLeft")},this.element.css(e),this.originalElement.css("margin",0),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css(e),this._proportionallyResize()),this._setupHandles(),i.autoHide&&t(this.element).on("mouseenter",function(){i.disabled||(s._removeClass("ui-resizable-autohide"),s._handles.show())}).on("mouseleave",function(){i.disabled||s.resizing||(s._addClass("ui-resizable-autohide"),s._handles.hide())}),this._mouseInit()},_destroy:function(){this._mouseDestroy();var e,i=function(e){t(e).removeData("resizable").removeData("ui-resizable").off(".resizable").find(".ui-resizable-handle").remove()};return this.elementIsWrapper&&(i(this.element),e=this.element,this.originalElement.css({position:e.css("position"),width:e.outerWidth(),height:e.outerHeight(),top:e.css("top"),left:e.css("left")}).insertAfter(e),e.remove()),this.originalElement.css("resize",this.originalResizeStyle),i(this.originalElement),this},_setOption:function(t,e){switch(this._super(t,e),t){case"handles":this._removeHandles(),this._setupHandles();break;default:}},_setupHandles:function(){var e,i,s,n,o,a=this.options,r=this;if(this.handles=a.handles||(t(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this._handles=t(),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),s=this.handles.split(","),this.handles={},i=0;s.length>i;i++)e=t.trim(s[i]),n="ui-resizable-"+e,o=t("<div>"),this._addClass(o,"ui-resizable-handle "+n),o.css({zIndex:a.zIndex}),this.handles[e]=".ui-resizable-"+e,this.element.append(o);this._renderAxis=function(e){var i,s,n,o;e=e||this.element;for(i in this.handles)this.handles[i].constructor===String?this.handles[i]=this.element.children(this.handles[i]).first().show():(this.handles[i].jquery||this.handles[i].nodeType)&&(this.handles[i]=t(this.handles[i]),this._on(this.handles[i],{mousedown:r._mouseDown})),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)&&(s=t(this.handles[i],this.element),o=/sw|ne|nw|se|n|s/.test(i)?s.outerHeight():s.outerWidth(),n=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join(""),e.css(n,o),this._proportionallyResize()),this._handles=this._handles.add(this.handles[i])},this._renderAxis(this.element),this._handles=this._handles.add(this.element.find(".ui-resizable-handle")),this._handles.disableSelection(),this._handles.on("mouseover",function(){r.resizing||(this.className&&(o=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),r.axis=o&&o[1]?o[1]:"se")}),a.autoHide&&(this._handles.hide(),this._addClass("ui-resizable-autohide"))},_removeHandles:function(){this._handles.remove()},_mouseCapture:function(e){var i,s,n=!1;for(i in this.handles)s=t(this.handles[i])[0],(s===e.target||t.contains(s,e.target))&&(n=!0);return!this.options.disabled&&n},_mouseStart:function(e){var i,s,n,o=this.options,a=this.element;return this.resizing=!0,this._renderProxy(),i=this._num(this.helper.css("left")),s=this._num(this.helper.css("top")),o.containment&&(i+=t(o.containment).scrollLeft()||0,s+=t(o.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:i,top:s},this.size=this._helper?{width:this.helper.width(),height:this.helper.height()}:{width:a.width(),height:a.height()},this.originalSize=this._helper?{width:a.outerWidth(),height:a.outerHeight()}:{width:a.width(),height:a.height()},this.sizeDiff={width:a.outerWidth()-a.width(),height:a.outerHeight()-a.height()},this.originalPosition={left:i,top:s},this.originalMousePosition={left:e.pageX,top:e.pageY},this.aspectRatio="number"==typeof o.aspectRatio?o.aspectRatio:this.originalSize.width/this.originalSize.height||1,n=t(".ui-resizable-"+this.axis).css("cursor"),t("body").css("cursor","auto"===n?this.axis+"-resize":n),this._addClass("ui-resizable-resizing"),this._propagate("start",e),!0},_mouseDrag:function(e){var i,s,n=this.originalMousePosition,o=this.axis,a=e.pageX-n.left||0,r=e.pageY-n.top||0,h=this._change[o];return this._updatePrevProperties(),h?(i=h.apply(this,[e,a,r]),this._updateVirtualBoundaries(e.shiftKey),(this._aspectRatio||e.shiftKey)&&(i=this._updateRatio(i,e)),i=this._respectSize(i,e),this._updateCache(i),this._propagate("resize",e),s=this._applyChanges(),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),t.isEmptyObject(s)||(this._updatePrevProperties(),this._trigger("resize",e,this.ui()),this._applyChanges()),!1):!1},_mouseStop:function(e){this.resizing=!1;var i,s,n,o,a,r,h,l=this.options,c=this;return this._helper&&(i=this._proportionallyResizeElements,s=i.length&&/textarea/i.test(i[0].nodeName),n=s&&this._hasScroll(i[0],"left")?0:c.sizeDiff.height,o=s?0:c.sizeDiff.width,a={width:c.helper.width()-o,height:c.helper.height()-n},r=parseFloat(c.element.css("left"))+(c.position.left-c.originalPosition.left)||null,h=parseFloat(c.element.css("top"))+(c.position.top-c.originalPosition.top)||null,l.animate||this.element.css(t.extend(a,{top:h,left:r})),c.helper.height(c.size.height),c.helper.width(c.size.width),this._helper&&!l.animate&&this._proportionallyResize()),t("body").css("cursor","auto"),this._removeClass("ui-resizable-resizing"),this._propagate("stop",e),this._helper&&this.helper.remove(),!1},_updatePrevProperties:function(){this.prevPosition={top:this.position.top,left:this.position.left},this.prevSize={width:this.size.width,height:this.size.height}},_applyChanges:function(){var t={};return this.position.top!==this.prevPosition.top&&(t.top=this.position.top+"px"),this.position.left!==this.prevPosition.left&&(t.left=this.position.left+"px"),this.size.width!==this.prevSize.width&&(t.width=this.size.width+"px"),this.size.height!==this.prevSize.height&&(t.height=this.size.height+"px"),this.helper.css(t),t},_updateVirtualBoundaries:function(t){var e,i,s,n,o,a=this.options;o={minWidth:this._isNumber(a.minWidth)?a.minWidth:0,maxWidth:this._isNumber(a.maxWidth)?a.maxWidth:1/0,minHeight:this._isNumber(a.minHeight)?a.minHeight:0,maxHeight:this._isNumber(a.maxHeight)?a.maxHeight:1/0},(this._aspectRatio||t)&&(e=o.minHeight*this.aspectRatio,s=o.minWidth/this.aspectRatio,i=o.maxHeight*this.aspectRatio,n=o.maxWidth/this.aspectRatio,e>o.minWidth&&(o.minWidth=e),s>o.minHeight&&(o.minHeight=s),o.maxWidth>i&&(o.maxWidth=i),o.maxHeight>n&&(o.maxHeight=n)),this._vBoundaries=o},_updateCache:function(t){this.offset=this.helper.offset(),this._isNumber(t.left)&&(this.position.left=t.left),this._isNumber(t.top)&&(this.position.top=t.top),this._isNumber(t.height)&&(this.size.height=t.height),this._isNumber(t.width)&&(this.size.width=t.width)},_updateRatio:function(t){var e=this.position,i=this.size,s=this.axis;return this._isNumber(t.height)?t.width=t.height*this.aspectRatio:this._isNumber(t.width)&&(t.height=t.width/this.aspectRatio),"sw"===s&&(t.left=e.left+(i.width-t.width),t.top=null),"nw"===s&&(t.top=e.top+(i.height-t.height),t.left=e.left+(i.width-t.width)),t},_respectSize:function(t){var e=this._vBoundaries,i=this.axis,s=this._isNumber(t.width)&&e.maxWidth&&e.maxWidth<t.width,n=this._isNumber(t.height)&&e.maxHeight&&e.maxHeight<t.height,o=this._isNumber(t.width)&&e.minWidth&&e.minWidth>t.width,a=this._isNumber(t.height)&&e.minHeight&&e.minHeight>t.height,r=this.originalPosition.left+this.originalSize.width,h=this.originalPosition.top+this.originalSize.height,l=/sw|nw|w/.test(i),c=/nw|ne|n/.test(i);return o&&(t.width=e.minWidth),a&&(t.height=e.minHeight),s&&(t.width=e.maxWidth),n&&(t.height=e.maxHeight),o&&l&&(t.left=r-e.minWidth),s&&l&&(t.left=r-e.maxWidth),a&&c&&(t.top=h-e.minHeight),n&&c&&(t.top=h-e.maxHeight),t.width||t.height||t.left||!t.top?t.width||t.height||t.top||!t.left||(t.left=null):t.top=null,t},_getPaddingPlusBorderDimensions:function(t){for(var e=0,i=[],s=[t.css("borderTopWidth"),t.css("borderRightWidth"),t.css("borderBottomWidth"),t.css("borderLeftWidth")],n=[t.css("paddingTop"),t.css("paddingRight"),t.css("paddingBottom"),t.css("paddingLeft")];4>e;e++)i[e]=parseFloat(s[e])||0,i[e]+=parseFloat(n[e])||0;return{height:i[0]+i[2],width:i[1]+i[3]}},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var t,e=0,i=this.helper||this.element;this._proportionallyResizeElements.length>e;e++)t=this._proportionallyResizeElements[e],this.outerDimensions||(this.outerDimensions=this._getPaddingPlusBorderDimensions(t)),t.css({height:i.height()-this.outerDimensions.height||0,width:i.width()-this.outerDimensions.width||0})},_renderProxy:function(){var e=this.element,i=this.options;this.elementOffset=e.offset(),this._helper?(this.helper=this.helper||t("<div style='overflow:hidden;'></div>"),this._addClass(this.helper,this._helper),this.helper.css({width:this.element.outerWidth(),height:this.element.outerHeight(),position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++i.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(t,e){return{width:this.originalSize.width+e}},w:function(t,e){var i=this.originalSize,s=this.originalPosition;return{left:s.left+e,width:i.width-e}},n:function(t,e,i){var s=this.originalSize,n=this.originalPosition;return{top:n.top+i,height:s.height-i}},s:function(t,e,i){return{height:this.originalSize.height+i}},se:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},sw:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[e,i,s]))},ne:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},nw:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[e,i,s]))}},_propagate:function(e,i){t.ui.plugin.call(this,e,[i,this.ui()]),"resize"!==e&&this._trigger(e,i,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),t.ui.plugin.add("resizable","animate",{stop:function(e){var i=t(this).resizable("instance"),s=i.options,n=i._proportionallyResizeElements,o=n.length&&/textarea/i.test(n[0].nodeName),a=o&&i._hasScroll(n[0],"left")?0:i.sizeDiff.height,r=o?0:i.sizeDiff.width,h={width:i.size.width-r,height:i.size.height-a},l=parseFloat(i.element.css("left"))+(i.position.left-i.originalPosition.left)||null,c=parseFloat(i.element.css("top"))+(i.position.top-i.originalPosition.top)||null;i.element.animate(t.extend(h,c&&l?{top:c,left:l}:{}),{duration:s.animateDuration,easing:s.animateEasing,step:function(){var s={width:parseFloat(i.element.css("width")),height:parseFloat(i.element.css("height")),top:parseFloat(i.element.css("top")),left:parseFloat(i.element.css("left"))};n&&n.length&&t(n[0]).css({width:s.width,height:s.height}),i._updateCache(s),i._propagate("resize",e)}})}}),t.ui.plugin.add("resizable","containment",{start:function(){var e,i,s,n,o,a,r,h=t(this).resizable("instance"),l=h.options,c=h.element,u=l.containment,d=u instanceof t?u.get(0):/parent/.test(u)?c.parent().get(0):u;d&&(h.containerElement=t(d),/document/.test(u)||u===document?(h.containerOffset={left:0,top:0},h.containerPosition={left:0,top:0},h.parentData={element:t(document),left:0,top:0,width:t(document).width(),height:t(document).height()||document.body.parentNode.scrollHeight}):(e=t(d),i=[],t(["Top","Right","Left","Bottom"]).each(function(t,s){i[t]=h._num(e.css("padding"+s))}),h.containerOffset=e.offset(),h.containerPosition=e.position(),h.containerSize={height:e.innerHeight()-i[3],width:e.innerWidth()-i[1]},s=h.containerOffset,n=h.containerSize.height,o=h.containerSize.width,a=h._hasScroll(d,"left")?d.scrollWidth:o,r=h._hasScroll(d)?d.scrollHeight:n,h.parentData={element:d,left:s.left,top:s.top,width:a,height:r}))},resize:function(e){var i,s,n,o,a=t(this).resizable("instance"),r=a.options,h=a.containerOffset,l=a.position,c=a._aspectRatio||e.shiftKey,u={top:0,left:0},d=a.containerElement,p=!0;d[0]!==document&&/static/.test(d.css("position"))&&(u=h),l.left<(a._helper?h.left:0)&&(a.size.width=a.size.width+(a._helper?a.position.left-h.left:a.position.left-u.left),c&&(a.size.height=a.size.width/a.aspectRatio,p=!1),a.position.left=r.helper?h.left:0),l.top<(a._helper?h.top:0)&&(a.size.height=a.size.height+(a._helper?a.position.top-h.top:a.position.top),c&&(a.size.width=a.size.height*a.aspectRatio,p=!1),a.position.top=a._helper?h.top:0),n=a.containerElement.get(0)===a.element.parent().get(0),o=/relative|absolute/.test(a.containerElement.css("position")),n&&o?(a.offset.left=a.parentData.left+a.position.left,a.offset.top=a.parentData.top+a.position.top):(a.offset.left=a.element.offset().left,a.offset.top=a.element.offset().top),i=Math.abs(a.sizeDiff.width+(a._helper?a.offset.left-u.left:a.offset.left-h.left)),s=Math.abs(a.sizeDiff.height+(a._helper?a.offset.top-u.top:a.offset.top-h.top)),i+a.size.width>=a.parentData.width&&(a.size.width=a.parentData.width-i,c&&(a.size.height=a.size.width/a.aspectRatio,p=!1)),s+a.size.height>=a.parentData.height&&(a.size.height=a.parentData.height-s,c&&(a.size.width=a.size.height*a.aspectRatio,p=!1)),p||(a.position.left=a.prevPosition.left,a.position.top=a.prevPosition.top,a.size.width=a.prevSize.width,a.size.height=a.prevSize.height)},stop:function(){var e=t(this).resizable("instance"),i=e.options,s=e.containerOffset,n=e.containerPosition,o=e.containerElement,a=t(e.helper),r=a.offset(),h=a.outerWidth()-e.sizeDiff.width,l=a.outerHeight()-e.sizeDiff.height;e._helper&&!i.animate&&/relative/.test(o.css("position"))&&t(this).css({left:r.left-n.left-s.left,width:h,height:l}),e._helper&&!i.animate&&/static/.test(o.css("position"))&&t(this).css({left:r.left-n.left-s.left,width:h,height:l})}}),t.ui.plugin.add("resizable","alsoResize",{start:function(){var e=t(this).resizable("instance"),i=e.options;t(i.alsoResize).each(function(){var e=t(this);e.data("ui-resizable-alsoresize",{width:parseFloat(e.width()),height:parseFloat(e.height()),left:parseFloat(e.css("left")),top:parseFloat(e.css("top"))})})},resize:function(e,i){var s=t(this).resizable("instance"),n=s.options,o=s.originalSize,a=s.originalPosition,r={height:s.size.height-o.height||0,width:s.size.width-o.width||0,top:s.position.top-a.top||0,left:s.position.left-a.left||0};t(n.alsoResize).each(function(){var e=t(this),s=t(this).data("ui-resizable-alsoresize"),n={},o=e.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];t.each(o,function(t,e){var i=(s[e]||0)+(r[e]||0);i&&i>=0&&(n[e]=i||null)}),e.css(n)})},stop:function(){t(this).removeData("ui-resizable-alsoresize")}}),t.ui.plugin.add("resizable","ghost",{start:function(){var e=t(this).resizable("instance"),i=e.size;e.ghost=e.originalElement.clone(),e.ghost.css({opacity:.25,display:"block",position:"relative",height:i.height,width:i.width,margin:0,left:0,top:0}),e._addClass(e.ghost,"ui-resizable-ghost"),t.uiBackCompat!==!1&&"string"==typeof e.options.ghost&&e.ghost.addClass(this.options.ghost),e.ghost.appendTo(e.helper)},resize:function(){var e=t(this).resizable("instance");e.ghost&&e.ghost.css({position:"relative",height:e.size.height,width:e.size.width})},stop:function(){var e=t(this).resizable("instance");e.ghost&&e.helper&&e.helper.get(0).removeChild(e.ghost.get(0))}}),t.ui.plugin.add("resizable","grid",{resize:function(){var e,i=t(this).resizable("instance"),s=i.options,n=i.size,o=i.originalSize,a=i.originalPosition,r=i.axis,h="number"==typeof s.grid?[s.grid,s.grid]:s.grid,l=h[0]||1,c=h[1]||1,u=Math.round((n.width-o.width)/l)*l,d=Math.round((n.height-o.height)/c)*c,p=o.width+u,f=o.height+d,g=s.maxWidth&&p>s.maxWidth,m=s.maxHeight&&f>s.maxHeight,_=s.minWidth&&s.minWidth>p,v=s.minHeight&&s.minHeight>f;s.grid=h,_&&(p+=l),v&&(f+=c),g&&(p-=l),m&&(f-=c),/^(se|s|e)$/.test(r)?(i.size.width=p,i.size.height=f):/^(ne)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.top=a.top-d):/^(sw)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.left=a.left-u):((0>=f-c||0>=p-l)&&(e=i._getPaddingPlusBorderDimensions(this)),f-c>0?(i.size.height=f,i.position.top=a.top-d):(f=c-e.height,i.size.height=f,i.position.top=a.top+o.height-f),p-l>0?(i.size.width=p,i.position.left=a.left-u):(p=l-e.width,i.size.width=p,i.position.left=a.left+o.width-p))}}),t.ui.resizable,t.widget("ui.dialog",{version:"1.12.1",options:{appendTo:"body",autoOpen:!0,buttons:[],classes:{"ui-dialog":"ui-corner-all","ui-dialog-titlebar":"ui-corner-all"},closeOnEscape:!0,closeText:"Close",draggable:!0,hide:null,height:"auto",maxHeight:null,maxWidth:null,minHeight:150,minWidth:150,modal:!1,position:{my:"center",at:"center",of:window,collision:"fit",using:function(e){var i=t(this).css(e).offset().top;0>i&&t(this).css("top",e.top-i)}},resizable:!0,show:null,title:null,width:300,beforeClose:null,close:null,drag:null,dragStart:null,dragStop:null,focus:null,open:null,resize:null,resizeStart:null,resizeStop:null},sizeRelatedOptions:{buttons:!0,height:!0,maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0,width:!0},resizableRelatedOptions:{maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0},_create:function(){this.originalCss={display:this.element[0].style.display,width:this.element[0].style.width,minHeight:this.element[0].style.minHeight,maxHeight:this.element[0].style.maxHeight,height:this.element[0].style.height},this.originalPosition={parent:this.element.parent(),index:this.element.parent().children().index(this.element)},this.originalTitle=this.element.attr("title"),null==this.options.title&&null!=this.originalTitle&&(this.options.title=this.originalTitle),this.options.disabled&&(this.options.disabled=!1),this._createWrapper(),this.element.show().removeAttr("title").appendTo(this.uiDialog),this._addClass("ui-dialog-content","ui-widget-content"),this._createTitlebar(),this._createButtonPane(),this.options.draggable&&t.fn.draggable&&this._makeDraggable(),this.options.resizable&&t.fn.resizable&&this._makeResizable(),this._isOpen=!1,this._trackFocus()},_init:function(){this.options.autoOpen&&this.open()},_appendTo:function(){var e=this.options.appendTo;return e&&(e.jquery||e.nodeType)?t(e):this.document.find(e||"body").eq(0)},_destroy:function(){var t,e=this.originalPosition;this._untrackInstance(),this._destroyOverlay(),this.element.removeUniqueId().css(this.originalCss).detach(),this.uiDialog.remove(),this.originalTitle&&this.element.attr("title",this.originalTitle),t=e.parent.children().eq(e.index),t.length&&t[0]!==this.element[0]?t.before(this.element):e.parent.append(this.element)},widget:function(){return this.uiDialog
  },disable:t.noop,enable:t.noop,close:function(e){var i=this;this._isOpen&&this._trigger("beforeClose",e)!==!1&&(this._isOpen=!1,this._focusedElement=null,this._destroyOverlay(),this._untrackInstance(),this.opener.filter(":focusable").trigger("focus").length||t.ui.safeBlur(t.ui.safeActiveElement(this.document[0])),this._hide(this.uiDialog,this.options.hide,function(){i._trigger("close",e)}))},isOpen:function(){return this._isOpen},moveToTop:function(){this._moveToTop()},_moveToTop:function(e,i){var s=!1,n=this.uiDialog.siblings(".ui-front:visible").map(function(){return+t(this).css("z-index")}).get(),o=Math.max.apply(null,n);return o>=+this.uiDialog.css("z-index")&&(this.uiDialog.css("z-index",o+1),s=!0),s&&!i&&this._trigger("focus",e),s},open:function(){var e=this;return this._isOpen?(this._moveToTop()&&this._focusTabbable(),void 0):(this._isOpen=!0,this.opener=t(t.ui.safeActiveElement(this.document[0])),this._size(),this._position(),this._createOverlay(),this._moveToTop(null,!0),this.overlay&&this.overlay.css("z-index",this.uiDialog.css("z-index")-1),this._show(this.uiDialog,this.options.show,function(){e._focusTabbable(),e._trigger("focus")}),this._makeFocusTarget(),this._trigger("open"),void 0)},_focusTabbable:function(){var t=this._focusedElement;t||(t=this.element.find("[autofocus]")),t.length||(t=this.element.find(":tabbable")),t.length||(t=this.uiDialogButtonPane.find(":tabbable")),t.length||(t=this.uiDialogTitlebarClose.filter(":tabbable")),t.length||(t=this.uiDialog),t.eq(0).trigger("focus")},_keepFocus:function(e){function i(){var e=t.ui.safeActiveElement(this.document[0]),i=this.uiDialog[0]===e||t.contains(this.uiDialog[0],e);i||this._focusTabbable()}e.preventDefault(),i.call(this),this._delay(i)},_createWrapper:function(){this.uiDialog=t("<div>").hide().attr({tabIndex:-1,role:"dialog"}).appendTo(this._appendTo()),this._addClass(this.uiDialog,"ui-dialog","ui-widget ui-widget-content ui-front"),this._on(this.uiDialog,{keydown:function(e){if(this.options.closeOnEscape&&!e.isDefaultPrevented()&&e.keyCode&&e.keyCode===t.ui.keyCode.ESCAPE)return e.preventDefault(),this.close(e),void 0;if(e.keyCode===t.ui.keyCode.TAB&&!e.isDefaultPrevented()){var i=this.uiDialog.find(":tabbable"),s=i.filter(":first"),n=i.filter(":last");e.target!==n[0]&&e.target!==this.uiDialog[0]||e.shiftKey?e.target!==s[0]&&e.target!==this.uiDialog[0]||!e.shiftKey||(this._delay(function(){n.trigger("focus")}),e.preventDefault()):(this._delay(function(){s.trigger("focus")}),e.preventDefault())}},mousedown:function(t){this._moveToTop(t)&&this._focusTabbable()}}),this.element.find("[aria-describedby]").length||this.uiDialog.attr({"aria-describedby":this.element.uniqueId().attr("id")})},_createTitlebar:function(){var e;this.uiDialogTitlebar=t("<div>"),this._addClass(this.uiDialogTitlebar,"ui-dialog-titlebar","ui-widget-header ui-helper-clearfix"),this._on(this.uiDialogTitlebar,{mousedown:function(e){t(e.target).closest(".ui-dialog-titlebar-close")||this.uiDialog.trigger("focus")}}),this.uiDialogTitlebarClose=t("<button type='button'></button>").button({label:t("<a>").text(this.options.closeText).html(),icon:"ui-icon-closethick",showLabel:!1}).appendTo(this.uiDialogTitlebar),this._addClass(this.uiDialogTitlebarClose,"ui-dialog-titlebar-close"),this._on(this.uiDialogTitlebarClose,{click:function(t){t.preventDefault(),this.close(t)}}),e=t("<span>").uniqueId().prependTo(this.uiDialogTitlebar),this._addClass(e,"ui-dialog-title"),this._title(e),this.uiDialogTitlebar.prependTo(this.uiDialog),this.uiDialog.attr({"aria-labelledby":e.attr("id")})},_title:function(t){this.options.title?t.text(this.options.title):t.html("&#160;")},_createButtonPane:function(){this.uiDialogButtonPane=t("<div>"),this._addClass(this.uiDialogButtonPane,"ui-dialog-buttonpane","ui-widget-content ui-helper-clearfix"),this.uiButtonSet=t("<div>").appendTo(this.uiDialogButtonPane),this._addClass(this.uiButtonSet,"ui-dialog-buttonset"),this._createButtons()},_createButtons:function(){var e=this,i=this.options.buttons;return this.uiDialogButtonPane.remove(),this.uiButtonSet.empty(),t.isEmptyObject(i)||t.isArray(i)&&!i.length?(this._removeClass(this.uiDialog,"ui-dialog-buttons"),void 0):(t.each(i,function(i,s){var n,o;s=t.isFunction(s)?{click:s,text:i}:s,s=t.extend({type:"button"},s),n=s.click,o={icon:s.icon,iconPosition:s.iconPosition,showLabel:s.showLabel,icons:s.icons,text:s.text},delete s.click,delete s.icon,delete s.iconPosition,delete s.showLabel,delete s.icons,"boolean"==typeof s.text&&delete s.text,t("<button></button>",s).button(o).appendTo(e.uiButtonSet).on("click",function(){n.apply(e.element[0],arguments)})}),this._addClass(this.uiDialog,"ui-dialog-buttons"),this.uiDialogButtonPane.appendTo(this.uiDialog),void 0)},_makeDraggable:function(){function e(t){return{position:t.position,offset:t.offset}}var i=this,s=this.options;this.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(s,n){i._addClass(t(this),"ui-dialog-dragging"),i._blockFrames(),i._trigger("dragStart",s,e(n))},drag:function(t,s){i._trigger("drag",t,e(s))},stop:function(n,o){var a=o.offset.left-i.document.scrollLeft(),r=o.offset.top-i.document.scrollTop();s.position={my:"left top",at:"left"+(a>=0?"+":"")+a+" "+"top"+(r>=0?"+":"")+r,of:i.window},i._removeClass(t(this),"ui-dialog-dragging"),i._unblockFrames(),i._trigger("dragStop",n,e(o))}})},_makeResizable:function(){function e(t){return{originalPosition:t.originalPosition,originalSize:t.originalSize,position:t.position,size:t.size}}var i=this,s=this.options,n=s.resizable,o=this.uiDialog.css("position"),a="string"==typeof n?n:"n,e,s,w,se,sw,ne,nw";this.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:this.element,maxWidth:s.maxWidth,maxHeight:s.maxHeight,minWidth:s.minWidth,minHeight:this._minHeight(),handles:a,start:function(s,n){i._addClass(t(this),"ui-dialog-resizing"),i._blockFrames(),i._trigger("resizeStart",s,e(n))},resize:function(t,s){i._trigger("resize",t,e(s))},stop:function(n,o){var a=i.uiDialog.offset(),r=a.left-i.document.scrollLeft(),h=a.top-i.document.scrollTop();s.height=i.uiDialog.height(),s.width=i.uiDialog.width(),s.position={my:"left top",at:"left"+(r>=0?"+":"")+r+" "+"top"+(h>=0?"+":"")+h,of:i.window},i._removeClass(t(this),"ui-dialog-resizing"),i._unblockFrames(),i._trigger("resizeStop",n,e(o))}}).css("position",o)},_trackFocus:function(){this._on(this.widget(),{focusin:function(e){this._makeFocusTarget(),this._focusedElement=t(e.target)}})},_makeFocusTarget:function(){this._untrackInstance(),this._trackingInstances().unshift(this)},_untrackInstance:function(){var e=this._trackingInstances(),i=t.inArray(this,e);-1!==i&&e.splice(i,1)},_trackingInstances:function(){var t=this.document.data("ui-dialog-instances");return t||(t=[],this.document.data("ui-dialog-instances",t)),t},_minHeight:function(){var t=this.options;return"auto"===t.height?t.minHeight:Math.min(t.minHeight,t.height)},_position:function(){var t=this.uiDialog.is(":visible");t||this.uiDialog.show(),this.uiDialog.position(this.options.position),t||this.uiDialog.hide()},_setOptions:function(e){var i=this,s=!1,n={};t.each(e,function(t,e){i._setOption(t,e),t in i.sizeRelatedOptions&&(s=!0),t in i.resizableRelatedOptions&&(n[t]=e)}),s&&(this._size(),this._position()),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option",n)},_setOption:function(e,i){var s,n,o=this.uiDialog;"disabled"!==e&&(this._super(e,i),"appendTo"===e&&this.uiDialog.appendTo(this._appendTo()),"buttons"===e&&this._createButtons(),"closeText"===e&&this.uiDialogTitlebarClose.button({label:t("<a>").text(""+this.options.closeText).html()}),"draggable"===e&&(s=o.is(":data(ui-draggable)"),s&&!i&&o.draggable("destroy"),!s&&i&&this._makeDraggable()),"position"===e&&this._position(),"resizable"===e&&(n=o.is(":data(ui-resizable)"),n&&!i&&o.resizable("destroy"),n&&"string"==typeof i&&o.resizable("option","handles",i),n||i===!1||this._makeResizable()),"title"===e&&this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))},_size:function(){var t,e,i,s=this.options;this.element.show().css({width:"auto",minHeight:0,maxHeight:"none",height:0}),s.minWidth>s.width&&(s.width=s.minWidth),t=this.uiDialog.css({height:"auto",width:s.width}).outerHeight(),e=Math.max(0,s.minHeight-t),i="number"==typeof s.maxHeight?Math.max(0,s.maxHeight-t):"none","auto"===s.height?this.element.css({minHeight:e,maxHeight:i,height:"auto"}):this.element.height(Math.max(0,s.height-t)),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())},_blockFrames:function(){this.iframeBlocks=this.document.find("iframe").map(function(){var e=t(this);return t("<div>").css({position:"absolute",width:e.outerWidth(),height:e.outerHeight()}).appendTo(e.parent()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_allowInteraction:function(e){return t(e.target).closest(".ui-dialog").length?!0:!!t(e.target).closest(".ui-datepicker").length},_createOverlay:function(){if(this.options.modal){var e=!0;this._delay(function(){e=!1}),this.document.data("ui-dialog-overlays")||this._on(this.document,{focusin:function(t){e||this._allowInteraction(t)||(t.preventDefault(),this._trackingInstances()[0]._focusTabbable())}}),this.overlay=t("<div>").appendTo(this._appendTo()),this._addClass(this.overlay,null,"ui-widget-overlay ui-front"),this._on(this.overlay,{mousedown:"_keepFocus"}),this.document.data("ui-dialog-overlays",(this.document.data("ui-dialog-overlays")||0)+1)}},_destroyOverlay:function(){if(this.options.modal&&this.overlay){var t=this.document.data("ui-dialog-overlays")-1;t?this.document.data("ui-dialog-overlays",t):(this._off(this.document,"focusin"),this.document.removeData("ui-dialog-overlays")),this.overlay.remove(),this.overlay=null}}}),t.uiBackCompat!==!1&&t.widget("ui.dialog",t.ui.dialog,{options:{dialogClass:""},_createWrapper:function(){this._super(),this.uiDialog.addClass(this.options.dialogClass)},_setOption:function(t,e){"dialogClass"===t&&this.uiDialog.removeClass(this.options.dialogClass).addClass(e),this._superApply(arguments)}}),t.ui.dialog,t.widget("ui.droppable",{version:"1.12.1",widgetEventPrefix:"drop",options:{accept:"*",addClasses:!0,greedy:!1,scope:"default",tolerance:"intersect",activate:null,deactivate:null,drop:null,out:null,over:null},_create:function(){var e,i=this.options,s=i.accept;this.isover=!1,this.isout=!0,this.accept=t.isFunction(s)?s:function(t){return t.is(s)},this.proportions=function(){return arguments.length?(e=arguments[0],void 0):e?e:e={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight}},this._addToManager(i.scope),i.addClasses&&this._addClass("ui-droppable")},_addToManager:function(e){t.ui.ddmanager.droppables[e]=t.ui.ddmanager.droppables[e]||[],t.ui.ddmanager.droppables[e].push(this)},_splice:function(t){for(var e=0;t.length>e;e++)t[e]===this&&t.splice(e,1)},_destroy:function(){var e=t.ui.ddmanager.droppables[this.options.scope];this._splice(e)},_setOption:function(e,i){if("accept"===e)this.accept=t.isFunction(i)?i:function(t){return t.is(i)};else if("scope"===e){var s=t.ui.ddmanager.droppables[this.options.scope];this._splice(s),this._addToManager(i)}this._super(e,i)},_activate:function(e){var i=t.ui.ddmanager.current;this._addActiveClass(),i&&this._trigger("activate",e,this.ui(i))},_deactivate:function(e){var i=t.ui.ddmanager.current;this._removeActiveClass(),i&&this._trigger("deactivate",e,this.ui(i))},_over:function(e){var i=t.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this._addHoverClass(),this._trigger("over",e,this.ui(i)))},_out:function(e){var i=t.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this._removeHoverClass(),this._trigger("out",e,this.ui(i)))},_drop:function(e,i){var s=i||t.ui.ddmanager.current,n=!1;return s&&(s.currentItem||s.element)[0]!==this.element[0]?(this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function(){var i=t(this).droppable("instance");return i.options.greedy&&!i.options.disabled&&i.options.scope===s.options.scope&&i.accept.call(i.element[0],s.currentItem||s.element)&&v(s,t.extend(i,{offset:i.element.offset()}),i.options.tolerance,e)?(n=!0,!1):void 0}),n?!1:this.accept.call(this.element[0],s.currentItem||s.element)?(this._removeActiveClass(),this._removeHoverClass(),this._trigger("drop",e,this.ui(s)),this.element):!1):!1},ui:function(t){return{draggable:t.currentItem||t.element,helper:t.helper,position:t.position,offset:t.positionAbs}},_addHoverClass:function(){this._addClass("ui-droppable-hover")},_removeHoverClass:function(){this._removeClass("ui-droppable-hover")},_addActiveClass:function(){this._addClass("ui-droppable-active")},_removeActiveClass:function(){this._removeClass("ui-droppable-active")}});var v=t.ui.intersect=function(){function t(t,e,i){return t>=e&&e+i>t}return function(e,i,s,n){if(!i.offset)return!1;var o=(e.positionAbs||e.position.absolute).left+e.margins.left,a=(e.positionAbs||e.position.absolute).top+e.margins.top,r=o+e.helperProportions.width,h=a+e.helperProportions.height,l=i.offset.left,c=i.offset.top,u=l+i.proportions().width,d=c+i.proportions().height;switch(s){case"fit":return o>=l&&u>=r&&a>=c&&d>=h;case"intersect":return o+e.helperProportions.width/2>l&&u>r-e.helperProportions.width/2&&a+e.helperProportions.height/2>c&&d>h-e.helperProportions.height/2;case"pointer":return t(n.pageY,c,i.proportions().height)&&t(n.pageX,l,i.proportions().width);case"touch":return(a>=c&&d>=a||h>=c&&d>=h||c>a&&h>d)&&(o>=l&&u>=o||r>=l&&u>=r||l>o&&r>u);default:return!1}}}();t.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(e,i){var s,n,o=t.ui.ddmanager.droppables[e.options.scope]||[],a=i?i.type:null,r=(e.currentItem||e.element).find(":data(ui-droppable)").addBack();t:for(s=0;o.length>s;s++)if(!(o[s].options.disabled||e&&!o[s].accept.call(o[s].element[0],e.currentItem||e.element))){for(n=0;r.length>n;n++)if(r[n]===o[s].element[0]){o[s].proportions().height=0;continue t}o[s].visible="none"!==o[s].element.css("display"),o[s].visible&&("mousedown"===a&&o[s]._activate.call(o[s],i),o[s].offset=o[s].element.offset(),o[s].proportions({width:o[s].element[0].offsetWidth,height:o[s].element[0].offsetHeight}))}},drop:function(e,i){var s=!1;return t.each((t.ui.ddmanager.droppables[e.options.scope]||[]).slice(),function(){this.options&&(!this.options.disabled&&this.visible&&v(e,this,this.options.tolerance,i)&&(s=this._drop.call(this,i)||s),!this.options.disabled&&this.visible&&this.accept.call(this.element[0],e.currentItem||e.element)&&(this.isout=!0,this.isover=!1,this._deactivate.call(this,i)))}),s},dragStart:function(e,i){e.element.parentsUntil("body").on("scroll.droppable",function(){e.options.refreshPositions||t.ui.ddmanager.prepareOffsets(e,i)})},drag:function(e,i){e.options.refreshPositions&&t.ui.ddmanager.prepareOffsets(e,i),t.each(t.ui.ddmanager.droppables[e.options.scope]||[],function(){if(!this.options.disabled&&!this.greedyChild&&this.visible){var s,n,o,a=v(e,this,this.options.tolerance,i),r=!a&&this.isover?"isout":a&&!this.isover?"isover":null;r&&(this.options.greedy&&(n=this.options.scope,o=this.element.parents(":data(ui-droppable)").filter(function(){return t(this).droppable("instance").options.scope===n}),o.length&&(s=t(o[0]).droppable("instance"),s.greedyChild="isover"===r)),s&&"isover"===r&&(s.isover=!1,s.isout=!0,s._out.call(s,i)),this[r]=!0,this["isout"===r?"isover":"isout"]=!1,this["isover"===r?"_over":"_out"].call(this,i),s&&"isout"===r&&(s.isout=!1,s.isover=!0,s._over.call(s,i)))}})},dragStop:function(e,i){e.element.parentsUntil("body").off("scroll.droppable"),e.options.refreshPositions||t.ui.ddmanager.prepareOffsets(e,i)}},t.uiBackCompat!==!1&&t.widget("ui.droppable",t.ui.droppable,{options:{hoverClass:!1,activeClass:!1},_addActiveClass:function(){this._super(),this.options.activeClass&&this.element.addClass(this.options.activeClass)},_removeActiveClass:function(){this._super(),this.options.activeClass&&this.element.removeClass(this.options.activeClass)},_addHoverClass:function(){this._super(),this.options.hoverClass&&this.element.addClass(this.options.hoverClass)},_removeHoverClass:function(){this._super(),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass)}}),t.ui.droppable,t.widget("ui.progressbar",{version:"1.12.1",options:{classes:{"ui-progressbar":"ui-corner-all","ui-progressbar-value":"ui-corner-left","ui-progressbar-complete":"ui-corner-right"},max:100,value:0,change:null,complete:null},min:0,_create:function(){this.oldValue=this.options.value=this._constrainedValue(),this.element.attr({role:"progressbar","aria-valuemin":this.min}),this._addClass("ui-progressbar","ui-widget ui-widget-content"),this.valueDiv=t("<div>").appendTo(this.element),this._addClass(this.valueDiv,"ui-progressbar-value","ui-widget-header"),this._refreshValue()},_destroy:function(){this.element.removeAttr("role aria-valuemin aria-valuemax aria-valuenow"),this.valueDiv.remove()},value:function(t){return void 0===t?this.options.value:(this.options.value=this._constrainedValue(t),this._refreshValue(),void 0)},_constrainedValue:function(t){return void 0===t&&(t=this.options.value),this.indeterminate=t===!1,"number"!=typeof t&&(t=0),this.indeterminate?!1:Math.min(this.options.max,Math.max(this.min,t))},_setOptions:function(t){var e=t.value;delete t.value,this._super(t),this.options.value=this._constrainedValue(e),this._refreshValue()},_setOption:function(t,e){"max"===t&&(e=Math.max(this.min,e)),this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t),this._toggleClass(null,"ui-state-disabled",!!t)},_percentage:function(){return this.indeterminate?100:100*(this.options.value-this.min)/(this.options.max-this.min)},_refreshValue:function(){var e=this.options.value,i=this._percentage();this.valueDiv.toggle(this.indeterminate||e>this.min).width(i.toFixed(0)+"%"),this._toggleClass(this.valueDiv,"ui-progressbar-complete",null,e===this.options.max)._toggleClass("ui-progressbar-indeterminate",null,this.indeterminate),this.indeterminate?(this.element.removeAttr("aria-valuenow"),this.overlayDiv||(this.overlayDiv=t("<div>").appendTo(this.valueDiv),this._addClass(this.overlayDiv,"ui-progressbar-overlay"))):(this.element.attr({"aria-valuemax":this.options.max,"aria-valuenow":e}),this.overlayDiv&&(this.overlayDiv.remove(),this.overlayDiv=null)),this.oldValue!==e&&(this.oldValue=e,this._trigger("change")),e===this.options.max&&this._trigger("complete")}}),t.widget("ui.selectable",t.ui.mouse,{version:"1.12.1",options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch",selected:null,selecting:null,start:null,stop:null,unselected:null,unselecting:null},_create:function(){var e=this;this._addClass("ui-selectable"),this.dragged=!1,this.refresh=function(){e.elementPos=t(e.element[0]).offset(),e.selectees=t(e.options.filter,e.element[0]),e._addClass(e.selectees,"ui-selectee"),e.selectees.each(function(){var i=t(this),s=i.offset(),n={left:s.left-e.elementPos.left,top:s.top-e.elementPos.top};t.data(this,"selectable-item",{element:this,$element:i,left:n.left,top:n.top,right:n.left+i.outerWidth(),bottom:n.top+i.outerHeight(),startselected:!1,selected:i.hasClass("ui-selected"),selecting:i.hasClass("ui-selecting"),unselecting:i.hasClass("ui-unselecting")})})},this.refresh(),this._mouseInit(),this.helper=t("<div>"),this._addClass(this.helper,"ui-selectable-helper")},_destroy:function(){this.selectees.removeData("selectable-item"),this._mouseDestroy()},_mouseStart:function(e){var i=this,s=this.options;this.opos=[e.pageX,e.pageY],this.elementPos=t(this.element[0]).offset(),this.options.disabled||(this.selectees=t(s.filter,this.element[0]),this._trigger("start",e),t(s.appendTo).append(this.helper),this.helper.css({left:e.pageX,top:e.pageY,width:0,height:0}),s.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var s=t.data(this,"selectable-item");s.startselected=!0,e.metaKey||e.ctrlKey||(i._removeClass(s.$element,"ui-selected"),s.selected=!1,i._addClass(s.$element,"ui-unselecting"),s.unselecting=!0,i._trigger("unselecting",e,{unselecting:s.element}))}),t(e.target).parents().addBack().each(function(){var s,n=t.data(this,"selectable-item");return n?(s=!e.metaKey&&!e.ctrlKey||!n.$element.hasClass("ui-selected"),i._removeClass(n.$element,s?"ui-unselecting":"ui-selected")._addClass(n.$element,s?"ui-selecting":"ui-unselecting"),n.unselecting=!s,n.selecting=s,n.selected=s,s?i._trigger("selecting",e,{selecting:n.element}):i._trigger("unselecting",e,{unselecting:n.element}),!1):void 0}))},_mouseDrag:function(e){if(this.dragged=!0,!this.options.disabled){var i,s=this,n=this.options,o=this.opos[0],a=this.opos[1],r=e.pageX,h=e.pageY;return o>r&&(i=r,r=o,o=i),a>h&&(i=h,h=a,a=i),this.helper.css({left:o,top:a,width:r-o,height:h-a}),this.selectees.each(function(){var i=t.data(this,"selectable-item"),l=!1,c={};i&&i.element!==s.element[0]&&(c.left=i.left+s.elementPos.left,c.right=i.right+s.elementPos.left,c.top=i.top+s.elementPos.top,c.bottom=i.bottom+s.elementPos.top,"touch"===n.tolerance?l=!(c.left>r||o>c.right||c.top>h||a>c.bottom):"fit"===n.tolerance&&(l=c.left>o&&r>c.right&&c.top>a&&h>c.bottom),l?(i.selected&&(s._removeClass(i.$element,"ui-selected"),i.selected=!1),i.unselecting&&(s._removeClass(i.$element,"ui-unselecting"),i.unselecting=!1),i.selecting||(s._addClass(i.$element,"ui-selecting"),i.selecting=!0,s._trigger("selecting",e,{selecting:i.element}))):(i.selecting&&((e.metaKey||e.ctrlKey)&&i.startselected?(s._removeClass(i.$element,"ui-selecting"),i.selecting=!1,s._addClass(i.$element,"ui-selected"),i.selected=!0):(s._removeClass(i.$element,"ui-selecting"),i.selecting=!1,i.startselected&&(s._addClass(i.$element,"ui-unselecting"),i.unselecting=!0),s._trigger("unselecting",e,{unselecting:i.element}))),i.selected&&(e.metaKey||e.ctrlKey||i.startselected||(s._removeClass(i.$element,"ui-selected"),i.selected=!1,s._addClass(i.$element,"ui-unselecting"),i.unselecting=!0,s._trigger("unselecting",e,{unselecting:i.element})))))}),!1}},_mouseStop:function(e){var i=this;return this.dragged=!1,t(".ui-unselecting",this.element[0]).each(function(){var s=t.data(this,"selectable-item");i._removeClass(s.$element,"ui-unselecting"),s.unselecting=!1,s.startselected=!1,i._trigger("unselected",e,{unselected:s.element})}),t(".ui-selecting",this.element[0]).each(function(){var s=t.data(this,"selectable-item");i._removeClass(s.$element,"ui-selecting")._addClass(s.$element,"ui-selected"),s.selecting=!1,s.selected=!0,s.startselected=!0,i._trigger("selected",e,{selected:s.element})}),this._trigger("stop",e),this.helper.remove(),!1}}),t.widget("ui.selectmenu",[t.ui.formResetMixin,{version:"1.12.1",defaultElement:"<select>",options:{appendTo:null,classes:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"},disabled:null,icons:{button:"ui-icon-triangle-1-s"},position:{my:"left top",at:"left bottom",collision:"none"},width:!1,change:null,close:null,focus:null,open:null,select:null},_create:function(){var e=this.element.uniqueId().attr("id");this.ids={element:e,button:e+"-button",menu:e+"-menu"},this._drawButton(),this._drawMenu(),this._bindFormResetHandler(),this._rendered=!1,this.menuItems=t()},_drawButton:function(){var e,i=this,s=this._parseOption(this.element.find("option:selected"),this.element[0].selectedIndex);this.labels=this.element.labels().attr("for",this.ids.button),this._on(this.labels,{click:function(t){this.button.focus(),t.preventDefault()}}),this.element.hide(),this.button=t("<span>",{tabindex:this.options.disabled?-1:0,id:this.ids.button,role:"combobox","aria-expanded":"false","aria-autocomplete":"list","aria-owns":this.ids.menu,"aria-haspopup":"true",title:this.element.attr("title")}).insertAfter(this.element),this._addClass(this.button,"ui-selectmenu-button ui-selectmenu-button-closed","ui-button ui-widget"),e=t("<span>").appendTo(this.button),this._addClass(e,"ui-selectmenu-icon","ui-icon "+this.options.icons.button),this.buttonItem=this._renderButtonItem(s).appendTo(this.button),this.options.width!==!1&&this._resizeButton(),this._on(this.button,this._buttonEvents),this.button.one("focusin",function(){i._rendered||i._refreshMenu()})},_drawMenu:function(){var e=this;this.menu=t("<ul>",{"aria-hidden":"true","aria-labelledby":this.ids.button,id:this.ids.menu}),this.menuWrap=t("<div>").append(this.menu),this._addClass(this.menuWrap,"ui-selectmenu-menu","ui-front"),this.menuWrap.appendTo(this._appendTo()),this.menuInstance=this.menu.menu({classes:{"ui-menu":"ui-corner-bottom"},role:"listbox",select:function(t,i){t.preventDefault(),e._setSelection(),e._select(i.item.data("ui-selectmenu-item"),t)},focus:function(t,i){var s=i.item.data("ui-selectmenu-item");null!=e.focusIndex&&s.index!==e.focusIndex&&(e._trigger("focus",t,{item:s}),e.isOpen||e._select(s,t)),e.focusIndex=s.index,e.button.attr("aria-activedescendant",e.menuItems.eq(s.index).attr("id"))}}).menu("instance"),this.menuInstance._off(this.menu,"mouseleave"),this.menuInstance._closeOnDocumentClick=function(){return!1},this.menuInstance._isDivider=function(){return!1}},refresh:function(){this._refreshMenu(),this.buttonItem.replaceWith(this.buttonItem=this._renderButtonItem(this._getSelectedItem().data("ui-selectmenu-item")||{})),null===this.options.width&&this._resizeButton()},_refreshMenu:function(){var t,e=this.element.find("option");this.menu.empty(),this._parseOptions(e),this._renderMenu(this.menu,this.items),this.menuInstance.refresh(),this.menuItems=this.menu.find("li").not(".ui-selectmenu-optgroup").find(".ui-menu-item-wrapper"),this._rendered=!0,e.length&&(t=this._getSelectedItem(),this.menuInstance.focus(null,t),this._setAria(t.data("ui-selectmenu-item")),this._setOption("disabled",this.element.prop("disabled")))},open:function(t){this.options.disabled||(this._rendered?(this._removeClass(this.menu.find(".ui-state-active"),null,"ui-state-active"),this.menuInstance.focus(null,this._getSelectedItem())):this._refreshMenu(),this.menuItems.length&&(this.isOpen=!0,this._toggleAttr(),this._resizeMenu(),this._position(),this._on(this.document,this._documentClick),this._trigger("open",t)))},_position:function(){this.menuWrap.position(t.extend({of:this.button},this.options.position))},close:function(t){this.isOpen&&(this.isOpen=!1,this._toggleAttr(),this.range=null,this._off(this.document),this._trigger("close",t))},widget:function(){return this.button},menuWidget:function(){return this.menu},_renderButtonItem:function(e){var i=t("<span>");return this._setText(i,e.label),this._addClass(i,"ui-selectmenu-text"),i},_renderMenu:function(e,i){var s=this,n="";t.each(i,function(i,o){var a;o.optgroup!==n&&(a=t("<li>",{text:o.optgroup}),s._addClass(a,"ui-selectmenu-optgroup","ui-menu-divider"+(o.element.parent("optgroup").prop("disabled")?" ui-state-disabled":"")),a.appendTo(e),n=o.optgroup),s._renderItemData(e,o)})},_renderItemData:function(t,e){return this._renderItem(t,e).data("ui-selectmenu-item",e)},_renderItem:function(e,i){var s=t("<li>"),n=t("<div>",{title:i.element.attr("title")});return i.disabled&&this._addClass(s,null,"ui-state-disabled"),this._setText(n,i.label),s.append(n).appendTo(e)},_setText:function(t,e){e?t.text(e):t.html("&#160;")},_move:function(t,e){var i,s,n=".ui-menu-item";this.isOpen?i=this.menuItems.eq(this.focusIndex).parent("li"):(i=this.menuItems.eq(this.element[0].selectedIndex).parent("li"),n+=":not(.ui-state-disabled)"),s="first"===t||"last"===t?i["first"===t?"prevAll":"nextAll"](n).eq(-1):i[t+"All"](n).eq(0),s.length&&this.menuInstance.focus(e,s)},_getSelectedItem:function(){return this.menuItems.eq(this.element[0].selectedIndex).parent("li")},_toggle:function(t){this[this.isOpen?"close":"open"](t)},_setSelection:function(){var t;this.range&&(window.getSelection?(t=window.getSelection(),t.removeAllRanges(),t.addRange(this.range)):this.range.select(),this.button.focus())},_documentClick:{mousedown:function(e){this.isOpen&&(t(e.target).closest(".ui-selectmenu-menu, #"+t.ui.escapeSelector(this.ids.button)).length||this.close(e))}},_buttonEvents:{mousedown:function(){var t;window.getSelection?(t=window.getSelection(),t.rangeCount&&(this.range=t.getRangeAt(0))):this.range=document.selection.createRange()},click:function(t){this._setSelection(),this._toggle(t)},keydown:function(e){var i=!0;switch(e.keyCode){case t.ui.keyCode.TAB:case t.ui.keyCode.ESCAPE:this.close(e),i=!1;break;case t.ui.keyCode.ENTER:this.isOpen&&this._selectFocusedItem(e);break;case t.ui.keyCode.UP:e.altKey?this._toggle(e):this._move("prev",e);break;case t.ui.keyCode.DOWN:e.altKey?this._toggle(e):this._move("next",e);break;case t.ui.keyCode.SPACE:this.isOpen?this._selectFocusedItem(e):this._toggle(e);break;case t.ui.keyCode.LEFT:this._move("prev",e);break;case t.ui.keyCode.RIGHT:this._move("next",e);break;case t.ui.keyCode.HOME:case t.ui.keyCode.PAGE_UP:this._move("first",e);break;case t.ui.keyCode.END:case t.ui.keyCode.PAGE_DOWN:this._move("last",e);break;default:this.menu.trigger(e),i=!1}i&&e.preventDefault()}},_selectFocusedItem:function(t){var e=this.menuItems.eq(this.focusIndex).parent("li");e.hasClass("ui-state-disabled")||this._select(e.data("ui-selectmenu-item"),t)},_select:function(t,e){var i=this.element[0].selectedIndex;this.element[0].selectedIndex=t.index,this.buttonItem.replaceWith(this.buttonItem=this._renderButtonItem(t)),this._setAria(t),this._trigger("select",e,{item:t}),t.index!==i&&this._trigger("change",e,{item:t}),this.close(e)},_setAria:function(t){var e=this.menuItems.eq(t.index).attr("id");this.button.attr({"aria-labelledby":e,"aria-activedescendant":e}),this.menu.attr("aria-activedescendant",e)},_setOption:function(t,e){if("icons"===t){var i=this.button.find("span.ui-icon");this._removeClass(i,null,this.options.icons.button)._addClass(i,null,e.button)}this._super(t,e),"appendTo"===t&&this.menuWrap.appendTo(this._appendTo()),"width"===t&&this._resizeButton()},_setOptionDisabled:function(t){this._super(t),this.menuInstance.option("disabled",t),this.button.attr("aria-disabled",t),this._toggleClass(this.button,null,"ui-state-disabled",t),this.element.prop("disabled",t),t?(this.button.attr("tabindex",-1),this.close()):this.button.attr("tabindex",0)},_appendTo:function(){var e=this.options.appendTo;return e&&(e=e.jquery||e.nodeType?t(e):this.document.find(e).eq(0)),e&&e[0]||(e=this.element.closest(".ui-front, dialog")),e.length||(e=this.document[0].body),e},_toggleAttr:function(){this.button.attr("aria-expanded",this.isOpen),this._removeClass(this.button,"ui-selectmenu-button-"+(this.isOpen?"closed":"open"))._addClass(this.button,"ui-selectmenu-button-"+(this.isOpen?"open":"closed"))._toggleClass(this.menuWrap,"ui-selectmenu-open",null,this.isOpen),this.menu.attr("aria-hidden",!this.isOpen)},_resizeButton:function(){var t=this.options.width;return t===!1?(this.button.css("width",""),void 0):(null===t&&(t=this.element.show().outerWidth(),this.element.hide()),this.button.outerWidth(t),void 0)},_resizeMenu:function(){this.menu.outerWidth(Math.max(this.button.outerWidth(),this.menu.width("").outerWidth()+1))},_getCreateOptions:function(){var t=this._super();return t.disabled=this.element.prop("disabled"),t},_parseOptions:function(e){var i=this,s=[];e.each(function(e,n){s.push(i._parseOption(t(n),e))}),this.items=s},_parseOption:function(t,e){var i=t.parent("optgroup");return{element:t,index:e,value:t.val(),label:t.text(),optgroup:i.attr("label")||"",disabled:i.prop("disabled")||t.prop("disabled")}},_destroy:function(){this._unbindFormResetHandler(),this.menuWrap.remove(),this.button.remove(),this.element.show(),this.element.removeUniqueId(),this.labels.attr("for",this.ids.element)}}]),t.widget("ui.slider",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"slide",options:{animate:!1,classes:{"ui-slider":"ui-corner-all","ui-slider-handle":"ui-corner-all","ui-slider-range":"ui-corner-all ui-widget-header"},distance:0,max:100,min:0,orientation:"horizontal",range:!1,step:1,value:0,values:null,change:null,slide:null,start:null,stop:null},numPages:5,_create:function(){this._keySliding=!1,this._mouseSliding=!1,this._animateOff=!0,this._handleIndex=null,this._detectOrientation(),this._mouseInit(),this._calculateNewMax(),this._addClass("ui-slider ui-slider-"+this.orientation,"ui-widget ui-widget-content"),this._refresh(),this._animateOff=!1
  },_refresh:function(){this._createRange(),this._createHandles(),this._setupEvents(),this._refreshValue()},_createHandles:function(){var e,i,s=this.options,n=this.element.find(".ui-slider-handle"),o="<span tabindex='0'></span>",a=[];for(i=s.values&&s.values.length||1,n.length>i&&(n.slice(i).remove(),n=n.slice(0,i)),e=n.length;i>e;e++)a.push(o);this.handles=n.add(t(a.join("")).appendTo(this.element)),this._addClass(this.handles,"ui-slider-handle","ui-state-default"),this.handle=this.handles.eq(0),this.handles.each(function(e){t(this).data("ui-slider-handle-index",e).attr("tabIndex",0)})},_createRange:function(){var e=this.options;e.range?(e.range===!0&&(e.values?e.values.length&&2!==e.values.length?e.values=[e.values[0],e.values[0]]:t.isArray(e.values)&&(e.values=e.values.slice(0)):e.values=[this._valueMin(),this._valueMin()]),this.range&&this.range.length?(this._removeClass(this.range,"ui-slider-range-min ui-slider-range-max"),this.range.css({left:"",bottom:""})):(this.range=t("<div>").appendTo(this.element),this._addClass(this.range,"ui-slider-range")),("min"===e.range||"max"===e.range)&&this._addClass(this.range,"ui-slider-range-"+e.range)):(this.range&&this.range.remove(),this.range=null)},_setupEvents:function(){this._off(this.handles),this._on(this.handles,this._handleEvents),this._hoverable(this.handles),this._focusable(this.handles)},_destroy:function(){this.handles.remove(),this.range&&this.range.remove(),this._mouseDestroy()},_mouseCapture:function(e){var i,s,n,o,a,r,h,l,c=this,u=this.options;return u.disabled?!1:(this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()},this.elementOffset=this.element.offset(),i={x:e.pageX,y:e.pageY},s=this._normValueFromMouse(i),n=this._valueMax()-this._valueMin()+1,this.handles.each(function(e){var i=Math.abs(s-c.values(e));(n>i||n===i&&(e===c._lastChangedValue||c.values(e)===u.min))&&(n=i,o=t(this),a=e)}),r=this._start(e,a),r===!1?!1:(this._mouseSliding=!0,this._handleIndex=a,this._addClass(o,null,"ui-state-active"),o.trigger("focus"),h=o.offset(),l=!t(e.target).parents().addBack().is(".ui-slider-handle"),this._clickOffset=l?{left:0,top:0}:{left:e.pageX-h.left-o.width()/2,top:e.pageY-h.top-o.height()/2-(parseInt(o.css("borderTopWidth"),10)||0)-(parseInt(o.css("borderBottomWidth"),10)||0)+(parseInt(o.css("marginTop"),10)||0)},this.handles.hasClass("ui-state-hover")||this._slide(e,a,s),this._animateOff=!0,!0))},_mouseStart:function(){return!0},_mouseDrag:function(t){var e={x:t.pageX,y:t.pageY},i=this._normValueFromMouse(e);return this._slide(t,this._handleIndex,i),!1},_mouseStop:function(t){return this._removeClass(this.handles,null,"ui-state-active"),this._mouseSliding=!1,this._stop(t,this._handleIndex),this._change(t,this._handleIndex),this._handleIndex=null,this._clickOffset=null,this._animateOff=!1,!1},_detectOrientation:function(){this.orientation="vertical"===this.options.orientation?"vertical":"horizontal"},_normValueFromMouse:function(t){var e,i,s,n,o;return"horizontal"===this.orientation?(e=this.elementSize.width,i=t.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)):(e=this.elementSize.height,i=t.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)),s=i/e,s>1&&(s=1),0>s&&(s=0),"vertical"===this.orientation&&(s=1-s),n=this._valueMax()-this._valueMin(),o=this._valueMin()+s*n,this._trimAlignValue(o)},_uiHash:function(t,e,i){var s={handle:this.handles[t],handleIndex:t,value:void 0!==e?e:this.value()};return this._hasMultipleValues()&&(s.value=void 0!==e?e:this.values(t),s.values=i||this.values()),s},_hasMultipleValues:function(){return this.options.values&&this.options.values.length},_start:function(t,e){return this._trigger("start",t,this._uiHash(e))},_slide:function(t,e,i){var s,n,o=this.value(),a=this.values();this._hasMultipleValues()&&(n=this.values(e?0:1),o=this.values(e),2===this.options.values.length&&this.options.range===!0&&(i=0===e?Math.min(n,i):Math.max(n,i)),a[e]=i),i!==o&&(s=this._trigger("slide",t,this._uiHash(e,i,a)),s!==!1&&(this._hasMultipleValues()?this.values(e,i):this.value(i)))},_stop:function(t,e){this._trigger("stop",t,this._uiHash(e))},_change:function(t,e){this._keySliding||this._mouseSliding||(this._lastChangedValue=e,this._trigger("change",t,this._uiHash(e)))},value:function(t){return arguments.length?(this.options.value=this._trimAlignValue(t),this._refreshValue(),this._change(null,0),void 0):this._value()},values:function(e,i){var s,n,o;if(arguments.length>1)return this.options.values[e]=this._trimAlignValue(i),this._refreshValue(),this._change(null,e),void 0;if(!arguments.length)return this._values();if(!t.isArray(arguments[0]))return this._hasMultipleValues()?this._values(e):this.value();for(s=this.options.values,n=arguments[0],o=0;s.length>o;o+=1)s[o]=this._trimAlignValue(n[o]),this._change(null,o);this._refreshValue()},_setOption:function(e,i){var s,n=0;switch("range"===e&&this.options.range===!0&&("min"===i?(this.options.value=this._values(0),this.options.values=null):"max"===i&&(this.options.value=this._values(this.options.values.length-1),this.options.values=null)),t.isArray(this.options.values)&&(n=this.options.values.length),this._super(e,i),e){case"orientation":this._detectOrientation(),this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-"+this.orientation),this._refreshValue(),this.options.range&&this._refreshRange(i),this.handles.css("horizontal"===i?"bottom":"left","");break;case"value":this._animateOff=!0,this._refreshValue(),this._change(null,0),this._animateOff=!1;break;case"values":for(this._animateOff=!0,this._refreshValue(),s=n-1;s>=0;s--)this._change(null,s);this._animateOff=!1;break;case"step":case"min":case"max":this._animateOff=!0,this._calculateNewMax(),this._refreshValue(),this._animateOff=!1;break;case"range":this._animateOff=!0,this._refresh(),this._animateOff=!1}},_setOptionDisabled:function(t){this._super(t),this._toggleClass(null,"ui-state-disabled",!!t)},_value:function(){var t=this.options.value;return t=this._trimAlignValue(t)},_values:function(t){var e,i,s;if(arguments.length)return e=this.options.values[t],e=this._trimAlignValue(e);if(this._hasMultipleValues()){for(i=this.options.values.slice(),s=0;i.length>s;s+=1)i[s]=this._trimAlignValue(i[s]);return i}return[]},_trimAlignValue:function(t){if(this._valueMin()>=t)return this._valueMin();if(t>=this._valueMax())return this._valueMax();var e=this.options.step>0?this.options.step:1,i=(t-this._valueMin())%e,s=t-i;return 2*Math.abs(i)>=e&&(s+=i>0?e:-e),parseFloat(s.toFixed(5))},_calculateNewMax:function(){var t=this.options.max,e=this._valueMin(),i=this.options.step,s=Math.round((t-e)/i)*i;t=s+e,t>this.options.max&&(t-=i),this.max=parseFloat(t.toFixed(this._precision()))},_precision:function(){var t=this._precisionOf(this.options.step);return null!==this.options.min&&(t=Math.max(t,this._precisionOf(this.options.min))),t},_precisionOf:function(t){var e=""+t,i=e.indexOf(".");return-1===i?0:e.length-i-1},_valueMin:function(){return this.options.min},_valueMax:function(){return this.max},_refreshRange:function(t){"vertical"===t&&this.range.css({width:"",left:""}),"horizontal"===t&&this.range.css({height:"",bottom:""})},_refreshValue:function(){var e,i,s,n,o,a=this.options.range,r=this.options,h=this,l=this._animateOff?!1:r.animate,c={};this._hasMultipleValues()?this.handles.each(function(s){i=100*((h.values(s)-h._valueMin())/(h._valueMax()-h._valueMin())),c["horizontal"===h.orientation?"left":"bottom"]=i+"%",t(this).stop(1,1)[l?"animate":"css"](c,r.animate),h.options.range===!0&&("horizontal"===h.orientation?(0===s&&h.range.stop(1,1)[l?"animate":"css"]({left:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({width:i-e+"%"},{queue:!1,duration:r.animate})):(0===s&&h.range.stop(1,1)[l?"animate":"css"]({bottom:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({height:i-e+"%"},{queue:!1,duration:r.animate}))),e=i}):(s=this.value(),n=this._valueMin(),o=this._valueMax(),i=o!==n?100*((s-n)/(o-n)):0,c["horizontal"===this.orientation?"left":"bottom"]=i+"%",this.handle.stop(1,1)[l?"animate":"css"](c,r.animate),"min"===a&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:i+"%"},r.animate),"max"===a&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:100-i+"%"},r.animate),"min"===a&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:i+"%"},r.animate),"max"===a&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:100-i+"%"},r.animate))},_handleEvents:{keydown:function(e){var i,s,n,o,a=t(e.target).data("ui-slider-handle-index");switch(e.keyCode){case t.ui.keyCode.HOME:case t.ui.keyCode.END:case t.ui.keyCode.PAGE_UP:case t.ui.keyCode.PAGE_DOWN:case t.ui.keyCode.UP:case t.ui.keyCode.RIGHT:case t.ui.keyCode.DOWN:case t.ui.keyCode.LEFT:if(e.preventDefault(),!this._keySliding&&(this._keySliding=!0,this._addClass(t(e.target),null,"ui-state-active"),i=this._start(e,a),i===!1))return}switch(o=this.options.step,s=n=this._hasMultipleValues()?this.values(a):this.value(),e.keyCode){case t.ui.keyCode.HOME:n=this._valueMin();break;case t.ui.keyCode.END:n=this._valueMax();break;case t.ui.keyCode.PAGE_UP:n=this._trimAlignValue(s+(this._valueMax()-this._valueMin())/this.numPages);break;case t.ui.keyCode.PAGE_DOWN:n=this._trimAlignValue(s-(this._valueMax()-this._valueMin())/this.numPages);break;case t.ui.keyCode.UP:case t.ui.keyCode.RIGHT:if(s===this._valueMax())return;n=this._trimAlignValue(s+o);break;case t.ui.keyCode.DOWN:case t.ui.keyCode.LEFT:if(s===this._valueMin())return;n=this._trimAlignValue(s-o)}this._slide(e,a,n)},keyup:function(e){var i=t(e.target).data("ui-slider-handle-index");this._keySliding&&(this._keySliding=!1,this._stop(e,i),this._change(e,i),this._removeClass(t(e.target),null,"ui-state-active"))}}}),t.widget("ui.sortable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(t,e,i){return t>=e&&e+i>t},_isFloating:function(t){return/left|right/.test(t.css("float"))||/inline|table-cell/.test(t.css("display"))},_create:function(){this.containerCache={},this._addClass("ui-sortable"),this.refresh(),this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!0},_setOption:function(t,e){this._super(t,e),"handle"===t&&this._setHandleClassName()},_setHandleClassName:function(){var e=this;this._removeClass(this.element.find(".ui-sortable-handle"),"ui-sortable-handle"),t.each(this.items,function(){e._addClass(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item,"ui-sortable-handle")})},_destroy:function(){this._mouseDestroy();for(var t=this.items.length-1;t>=0;t--)this.items[t].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(e,i){var s=null,n=!1,o=this;return this.reverting?!1:this.options.disabled||"static"===this.options.type?!1:(this._refreshItems(e),t(e.target).parents().each(function(){return t.data(this,o.widgetName+"-item")===o?(s=t(this),!1):void 0}),t.data(e.target,o.widgetName+"-item")===o&&(s=t(e.target)),s?!this.options.handle||i||(t(this.options.handle,s).find("*").addBack().each(function(){this===e.target&&(n=!0)}),n)?(this.currentItem=s,this._removeCurrentsFromItems(),!0):!1:!1)},_mouseStart:function(e,i,s){var n,o,a=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(e),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},t.extend(this.offset,{click:{left:e.pageX-this.offset.left,top:e.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(e),this.originalPageX=e.pageX,this.originalPageY=e.pageY,a.cursorAt&&this._adjustOffsetFromHelper(a.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),a.containment&&this._setContainment(),a.cursor&&"auto"!==a.cursor&&(o=this.document.find("body"),this.storedCursor=o.css("cursor"),o.css("cursor",a.cursor),this.storedStylesheet=t("<style>*{ cursor: "+a.cursor+" !important; }</style>").appendTo(o)),a.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",a.opacity)),a.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",a.zIndex)),this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",e,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(n=this.containers.length-1;n>=0;n--)this.containers[n]._trigger("activate",e,this._uiHash(this));return t.ui.ddmanager&&(t.ui.ddmanager.current=this),t.ui.ddmanager&&!a.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this.dragging=!0,this._addClass(this.helper,"ui-sortable-helper"),this._mouseDrag(e),!0},_mouseDrag:function(e){var i,s,n,o,a=this.options,r=!1;for(this.position=this._generatePosition(e),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-e.pageY<a.scrollSensitivity?this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop+a.scrollSpeed:e.pageY-this.overflowOffset.top<a.scrollSensitivity&&(this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop-a.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-e.pageX<a.scrollSensitivity?this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft+a.scrollSpeed:e.pageX-this.overflowOffset.left<a.scrollSensitivity&&(this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft-a.scrollSpeed)):(e.pageY-this.document.scrollTop()<a.scrollSensitivity?r=this.document.scrollTop(this.document.scrollTop()-a.scrollSpeed):this.window.height()-(e.pageY-this.document.scrollTop())<a.scrollSensitivity&&(r=this.document.scrollTop(this.document.scrollTop()+a.scrollSpeed)),e.pageX-this.document.scrollLeft()<a.scrollSensitivity?r=this.document.scrollLeft(this.document.scrollLeft()-a.scrollSpeed):this.window.width()-(e.pageX-this.document.scrollLeft())<a.scrollSensitivity&&(r=this.document.scrollLeft(this.document.scrollLeft()+a.scrollSpeed))),r!==!1&&t.ui.ddmanager&&!a.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(s=this.items[i],n=s.item[0],o=this._intersectsWithPointer(s),o&&s.instance===this.currentContainer&&n!==this.currentItem[0]&&this.placeholder[1===o?"next":"prev"]()[0]!==n&&!t.contains(this.placeholder[0],n)&&("semi-dynamic"===this.options.type?!t.contains(this.element[0],n):!0)){if(this.direction=1===o?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;this._rearrange(e,s),this._trigger("change",e,this._uiHash());break}return this._contactContainers(e),t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),this._trigger("sort",e,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(e,i){if(e){if(t.ui.ddmanager&&!this.options.dropBehaviour&&t.ui.ddmanager.drop(this,e),this.options.revert){var s=this,n=this.placeholder.offset(),o=this.options.axis,a={};o&&"x"!==o||(a.left=n.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollLeft)),o&&"y"!==o||(a.top=n.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,t(this.helper).animate(a,parseInt(this.options.revert,10)||500,function(){s._clear(e)})}else this._clear(e,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp(new t.Event("mouseup",{target:null})),"original"===this.options.helper?(this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")):this.currentItem.show();for(var e=this.containers.length-1;e>=0;e--)this.containers[e]._trigger("deactivate",null,this._uiHash(this)),this.containers[e].containerCache.over&&(this.containers[e]._trigger("out",null,this._uiHash(this)),this.containers[e].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),t.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?t(this.domPosition.prev).after(this.currentItem):t(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},t(i).each(function(){var i=(t(e.item||this).attr(e.attribute||"id")||"").match(e.expression||/(.+)[\-=_](.+)/);i&&s.push((e.key||i[1]+"[]")+"="+(e.key&&e.expression?i[1]:i[2]))}),!s.length&&e.key&&s.push(e.key+"="),s.join("&")},toArray:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},i.each(function(){s.push(t(e.item||this).attr(e.attribute||"id")||"")}),s},_intersectsWith:function(t){var e=this.positionAbs.left,i=e+this.helperProportions.width,s=this.positionAbs.top,n=s+this.helperProportions.height,o=t.left,a=o+t.width,r=t.top,h=r+t.height,l=this.offset.click.top,c=this.offset.click.left,u="x"===this.options.axis||s+l>r&&h>s+l,d="y"===this.options.axis||e+c>o&&a>e+c,p=u&&d;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>t[this.floating?"width":"height"]?p:e+this.helperProportions.width/2>o&&a>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>r&&h>n-this.helperProportions.height/2},_intersectsWithPointer:function(t){var e,i,s="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top,t.height),n="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left,t.width),o=s&&n;return o?(e=this._getDragVerticalDirection(),i=this._getDragHorizontalDirection(),this.floating?"right"===i||"down"===e?2:1:e&&("down"===e?2:1)):!1},_intersectsWithSides:function(t){var e=this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top+t.height/2,t.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left+t.width/2,t.width),s=this._getDragVerticalDirection(),n=this._getDragHorizontalDirection();return this.floating&&n?"right"===n&&i||"left"===n&&!i:s&&("down"===s&&e||"up"===s&&!e)},_getDragVerticalDirection:function(){var t=this.positionAbs.top-this.lastPositionAbs.top;return 0!==t&&(t>0?"down":"up")},_getDragHorizontalDirection:function(){var t=this.positionAbs.left-this.lastPositionAbs.left;return 0!==t&&(t>0?"right":"left")},refresh:function(t){return this._refreshItems(t),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var t=this.options;return t.connectWith.constructor===String?[t.connectWith]:t.connectWith},_getItemsAsjQuery:function(e){function i(){r.push(this)}var s,n,o,a,r=[],h=[],l=this._connectWith();if(l&&e)for(s=l.length-1;s>=0;s--)for(o=t(l[s],this.document[0]),n=o.length-1;n>=0;n--)a=t.data(o[n],this.widgetFullName),a&&a!==this&&!a.options.disabled&&h.push([t.isFunction(a.options.items)?a.options.items.call(a.element):t(a.options.items,a.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),a]);for(h.push([t.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):t(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=h.length-1;s>=0;s--)h[s][0].each(i);return t(r)},_removeCurrentsFromItems:function(){var e=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=t.grep(this.items,function(t){for(var i=0;e.length>i;i++)if(e[i]===t.item[0])return!1;return!0})},_refreshItems:function(e){this.items=[],this.containers=[this];var i,s,n,o,a,r,h,l,c=this.items,u=[[t.isFunction(this.options.items)?this.options.items.call(this.element[0],e,{item:this.currentItem}):t(this.options.items,this.element),this]],d=this._connectWith();if(d&&this.ready)for(i=d.length-1;i>=0;i--)for(n=t(d[i],this.document[0]),s=n.length-1;s>=0;s--)o=t.data(n[s],this.widgetFullName),o&&o!==this&&!o.options.disabled&&(u.push([t.isFunction(o.options.items)?o.options.items.call(o.element[0],e,{item:this.currentItem}):t(o.options.items,o.element),o]),this.containers.push(o));for(i=u.length-1;i>=0;i--)for(a=u[i][1],r=u[i][0],s=0,l=r.length;l>s;s++)h=t(r[s]),h.data(this.widgetName+"-item",a),c.push({item:h,instance:a,width:0,height:0,left:0,top:0})},refreshPositions:function(e){this.floating=this.items.length?"x"===this.options.axis||this._isFloating(this.items[0].item):!1,this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());var i,s,n,o;for(i=this.items.length-1;i>=0;i--)s=this.items[i],s.instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(n=this.options.toleranceElement?t(this.options.toleranceElement,s.item):s.item,e||(s.width=n.outerWidth(),s.height=n.outerHeight()),o=n.offset(),s.left=o.left,s.top=o.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)o=this.containers[i].element.offset(),this.containers[i].containerCache.left=o.left,this.containers[i].containerCache.top=o.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(e){e=e||this;var i,s=e.options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=e.currentItem[0].nodeName.toLowerCase(),n=t("<"+s+">",e.document[0]);return e._addClass(n,"ui-sortable-placeholder",i||e.currentItem[0].className)._removeClass(n,"ui-sortable-helper"),"tbody"===s?e._createTrPlaceholder(e.currentItem.find("tr").eq(0),t("<tr>",e.document[0]).appendTo(n)):"tr"===s?e._createTrPlaceholder(e.currentItem,n):"img"===s&&n.attr("src",e.currentItem.attr("src")),i||n.css("visibility","hidden"),n},update:function(t,n){(!i||s.forcePlaceholderSize)&&(n.height()||n.height(e.currentItem.innerHeight()-parseInt(e.currentItem.css("paddingTop")||0,10)-parseInt(e.currentItem.css("paddingBottom")||0,10)),n.width()||n.width(e.currentItem.innerWidth()-parseInt(e.currentItem.css("paddingLeft")||0,10)-parseInt(e.currentItem.css("paddingRight")||0,10)))}}),e.placeholder=t(s.placeholder.element.call(e.element,e.currentItem)),e.currentItem.after(e.placeholder),s.placeholder.update(e,e.placeholder)},_createTrPlaceholder:function(e,i){var s=this;e.children().each(function(){t("<td>&#160;</td>",s.document[0]).attr("colspan",t(this).attr("colspan")||1).appendTo(i)})},_contactContainers:function(e){var i,s,n,o,a,r,h,l,c,u,d=null,p=null;for(i=this.containers.length-1;i>=0;i--)if(!t.contains(this.currentItem[0],this.containers[i].element[0]))if(this._intersectsWith(this.containers[i].containerCache)){if(d&&t.contains(this.containers[i].element[0],d.element[0]))continue;d=this.containers[i],p=i}else this.containers[i].containerCache.over&&(this.containers[i]._trigger("out",e,this._uiHash(this)),this.containers[i].containerCache.over=0);if(d)if(1===this.containers.length)this.containers[p].containerCache.over||(this.containers[p]._trigger("over",e,this._uiHash(this)),this.containers[p].containerCache.over=1);else{for(n=1e4,o=null,c=d.floating||this._isFloating(this.currentItem),a=c?"left":"top",r=c?"width":"height",u=c?"pageX":"pageY",s=this.items.length-1;s>=0;s--)t.contains(this.containers[p].element[0],this.items[s].item[0])&&this.items[s].item[0]!==this.currentItem[0]&&(h=this.items[s].item.offset()[a],l=!1,e[u]-h>this.items[s][r]/2&&(l=!0),n>Math.abs(e[u]-h)&&(n=Math.abs(e[u]-h),o=this.items[s],this.direction=l?"up":"down"));if(!o&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[p])return this.currentContainer.containerCache.over||(this.containers[p]._trigger("over",e,this._uiHash()),this.currentContainer.containerCache.over=1),void 0;o?this._rearrange(e,o,null,!0):this._rearrange(e,null,this.containers[p].element,!0),this._trigger("change",e,this._uiHash()),this.containers[p]._trigger("change",e,this._uiHash(this)),this.currentContainer=this.containers[p],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[p]._trigger("over",e,this._uiHash(this)),this.containers[p].containerCache.over=1}},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper)?t(i.helper.apply(this.element[0],[e,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||t("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var e=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===this.document[0].body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&t.ui.ie)&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var t=this.currentItem.position();return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:t.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,n=this.options;"parent"===n.containment&&(n.containment=this.helper[0].parentNode),("document"===n.containment||"window"===n.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,"document"===n.containment?this.document.width():this.window.width()-this.helperProportions.width-this.margins.left,("document"===n.containment?this.document.height()||document.body.parentNode.scrollHeight:this.window.height()||this.document[0].body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(n.containment)||(e=t(n.containment)[0],i=t(n.containment).offset(),s="hidden"!==t(e).css("overflow"),this.containment=[i.left+(parseInt(t(e).css("borderLeftWidth"),10)||0)+(parseInt(t(e).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(t(e).css("borderTopWidth"),10)||0)+(parseInt(t(e).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(e.scrollWidth,e.offsetWidth):e.offsetWidth)-(parseInt(t(e).css("borderLeftWidth"),10)||0)-(parseInt(t(e).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(e.scrollHeight,e.offsetHeight):e.offsetHeight)-(parseInt(t(e).css("borderTopWidth"),10)||0)-(parseInt(t(e).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(e,i){i||(i=this.position);var s="absolute"===e?1:-1,n="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,o=/(html|body)/i.test(n[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():o?0:n.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():o?0:n.scrollLeft())*s}},_generatePosition:function(e){var i,s,n=this.options,o=e.pageX,a=e.pageY,r="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,h=/(html|body)/i.test(r[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(e.pageX-this.offset.click.left<this.containment[0]&&(o=this.containment[0]+this.offset.click.left),e.pageY-this.offset.click.top<this.containment[1]&&(a=this.containment[1]+this.offset.click.top),e.pageX-this.offset.click.left>this.containment[2]&&(o=this.containment[2]+this.offset.click.left),e.pageY-this.offset.click.top>this.containment[3]&&(a=this.containment[3]+this.offset.click.top)),n.grid&&(i=this.originalPageY+Math.round((a-this.originalPageY)/n.grid[1])*n.grid[1],a=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-n.grid[1]:i+n.grid[1]:i,s=this.originalPageX+Math.round((o-this.originalPageX)/n.grid[0])*n.grid[0],o=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-n.grid[0]:s+n.grid[0]:s)),{top:a-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():h?0:r.scrollTop()),left:o-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():h?0:r.scrollLeft())}},_rearrange:function(t,e,i,s){i?i[0].appendChild(this.placeholder[0]):e.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?e.item[0]:e.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var n=this.counter;
  this._delay(function(){n===this.counter&&this.refreshPositions(!s)})},_clear:function(t,e){function i(t,e,i){return function(s){i._trigger(t,s,e._uiHash(e))}}this.reverting=!1;var s,n=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!e&&n.push(function(t){this._trigger("receive",t,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||e||n.push(function(t){this._trigger("update",t,this._uiHash())}),this!==this.currentContainer&&(e||(n.push(function(t){this._trigger("remove",t,this._uiHash())}),n.push(function(t){return function(e){t._trigger("receive",e,this._uiHash(this))}}.call(this,this.currentContainer)),n.push(function(t){return function(e){t._trigger("update",e,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)e||n.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(n.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,e||this._trigger("beforeStop",t,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.cancelHelperRemoval||(this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null),!e){for(s=0;n.length>s;s++)n[s].call(this,t);this._trigger("stop",t,this._uiHash())}return this.fromOutside=!1,!this.cancelHelperRemoval},_trigger:function(){t.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(e){var i=e||this;return{helper:i.helper,placeholder:i.placeholder||t([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:e?e.element:null}}}),t.widget("ui.spinner",{version:"1.12.1",defaultElement:"<input>",widgetEventPrefix:"spin",options:{classes:{"ui-spinner":"ui-corner-all","ui-spinner-down":"ui-corner-br","ui-spinner-up":"ui-corner-tr"},culture:null,icons:{down:"ui-icon-triangle-1-s",up:"ui-icon-triangle-1-n"},incremental:!0,max:null,min:null,numberFormat:null,page:10,step:1,change:null,spin:null,start:null,stop:null},_create:function(){this._setOption("max",this.options.max),this._setOption("min",this.options.min),this._setOption("step",this.options.step),""!==this.value()&&this._value(this.element.val(),!0),this._draw(),this._on(this._events),this._refresh(),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_getCreateOptions:function(){var e=this._super(),i=this.element;return t.each(["min","max","step"],function(t,s){var n=i.attr(s);null!=n&&n.length&&(e[s]=n)}),e},_events:{keydown:function(t){this._start(t)&&this._keydown(t)&&t.preventDefault()},keyup:"_stop",focus:function(){this.previous=this.element.val()},blur:function(t){return this.cancelBlur?(delete this.cancelBlur,void 0):(this._stop(),this._refresh(),this.previous!==this.element.val()&&this._trigger("change",t),void 0)},mousewheel:function(t,e){if(e){if(!this.spinning&&!this._start(t))return!1;this._spin((e>0?1:-1)*this.options.step,t),clearTimeout(this.mousewheelTimer),this.mousewheelTimer=this._delay(function(){this.spinning&&this._stop(t)},100),t.preventDefault()}},"mousedown .ui-spinner-button":function(e){function i(){var e=this.element[0]===t.ui.safeActiveElement(this.document[0]);e||(this.element.trigger("focus"),this.previous=s,this._delay(function(){this.previous=s}))}var s;s=this.element[0]===t.ui.safeActiveElement(this.document[0])?this.previous:this.element.val(),e.preventDefault(),i.call(this),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,i.call(this)}),this._start(e)!==!1&&this._repeat(null,t(e.currentTarget).hasClass("ui-spinner-up")?1:-1,e)},"mouseup .ui-spinner-button":"_stop","mouseenter .ui-spinner-button":function(e){return t(e.currentTarget).hasClass("ui-state-active")?this._start(e)===!1?!1:(this._repeat(null,t(e.currentTarget).hasClass("ui-spinner-up")?1:-1,e),void 0):void 0},"mouseleave .ui-spinner-button":"_stop"},_enhance:function(){this.uiSpinner=this.element.attr("autocomplete","off").wrap("<span>").parent().append("<a></a><a></a>")},_draw:function(){this._enhance(),this._addClass(this.uiSpinner,"ui-spinner","ui-widget ui-widget-content"),this._addClass("ui-spinner-input"),this.element.attr("role","spinbutton"),this.buttons=this.uiSpinner.children("a").attr("tabIndex",-1).attr("aria-hidden",!0).button({classes:{"ui-button":""}}),this._removeClass(this.buttons,"ui-corner-all"),this._addClass(this.buttons.first(),"ui-spinner-button ui-spinner-up"),this._addClass(this.buttons.last(),"ui-spinner-button ui-spinner-down"),this.buttons.first().button({icon:this.options.icons.up,showLabel:!1}),this.buttons.last().button({icon:this.options.icons.down,showLabel:!1}),this.buttons.height()>Math.ceil(.5*this.uiSpinner.height())&&this.uiSpinner.height()>0&&this.uiSpinner.height(this.uiSpinner.height())},_keydown:function(e){var i=this.options,s=t.ui.keyCode;switch(e.keyCode){case s.UP:return this._repeat(null,1,e),!0;case s.DOWN:return this._repeat(null,-1,e),!0;case s.PAGE_UP:return this._repeat(null,i.page,e),!0;case s.PAGE_DOWN:return this._repeat(null,-i.page,e),!0}return!1},_start:function(t){return this.spinning||this._trigger("start",t)!==!1?(this.counter||(this.counter=1),this.spinning=!0,!0):!1},_repeat:function(t,e,i){t=t||500,clearTimeout(this.timer),this.timer=this._delay(function(){this._repeat(40,e,i)},t),this._spin(e*this.options.step,i)},_spin:function(t,e){var i=this.value()||0;this.counter||(this.counter=1),i=this._adjustValue(i+t*this._increment(this.counter)),this.spinning&&this._trigger("spin",e,{value:i})===!1||(this._value(i),this.counter++)},_increment:function(e){var i=this.options.incremental;return i?t.isFunction(i)?i(e):Math.floor(e*e*e/5e4-e*e/500+17*e/200+1):1},_precision:function(){var t=this._precisionOf(this.options.step);return null!==this.options.min&&(t=Math.max(t,this._precisionOf(this.options.min))),t},_precisionOf:function(t){var e=""+t,i=e.indexOf(".");return-1===i?0:e.length-i-1},_adjustValue:function(t){var e,i,s=this.options;return e=null!==s.min?s.min:0,i=t-e,i=Math.round(i/s.step)*s.step,t=e+i,t=parseFloat(t.toFixed(this._precision())),null!==s.max&&t>s.max?s.max:null!==s.min&&s.min>t?s.min:t},_stop:function(t){this.spinning&&(clearTimeout(this.timer),clearTimeout(this.mousewheelTimer),this.counter=0,this.spinning=!1,this._trigger("stop",t))},_setOption:function(t,e){var i,s,n;return"culture"===t||"numberFormat"===t?(i=this._parse(this.element.val()),this.options[t]=e,this.element.val(this._format(i)),void 0):(("max"===t||"min"===t||"step"===t)&&"string"==typeof e&&(e=this._parse(e)),"icons"===t&&(s=this.buttons.first().find(".ui-icon"),this._removeClass(s,null,this.options.icons.up),this._addClass(s,null,e.up),n=this.buttons.last().find(".ui-icon"),this._removeClass(n,null,this.options.icons.down),this._addClass(n,null,e.down)),this._super(t,e),void 0)},_setOptionDisabled:function(t){this._super(t),this._toggleClass(this.uiSpinner,null,"ui-state-disabled",!!t),this.element.prop("disabled",!!t),this.buttons.button(t?"disable":"enable")},_setOptions:r(function(t){this._super(t)}),_parse:function(t){return"string"==typeof t&&""!==t&&(t=window.Globalize&&this.options.numberFormat?Globalize.parseFloat(t,10,this.options.culture):+t),""===t||isNaN(t)?null:t},_format:function(t){return""===t?"":window.Globalize&&this.options.numberFormat?Globalize.format(t,this.options.numberFormat,this.options.culture):t},_refresh:function(){this.element.attr({"aria-valuemin":this.options.min,"aria-valuemax":this.options.max,"aria-valuenow":this._parse(this.element.val())})},isValid:function(){var t=this.value();return null===t?!1:t===this._adjustValue(t)},_value:function(t,e){var i;""!==t&&(i=this._parse(t),null!==i&&(e||(i=this._adjustValue(i)),t=this._format(i))),this.element.val(t),this._refresh()},_destroy:function(){this.element.prop("disabled",!1).removeAttr("autocomplete role aria-valuemin aria-valuemax aria-valuenow"),this.uiSpinner.replaceWith(this.element)},stepUp:r(function(t){this._stepUp(t)}),_stepUp:function(t){this._start()&&(this._spin((t||1)*this.options.step),this._stop())},stepDown:r(function(t){this._stepDown(t)}),_stepDown:function(t){this._start()&&(this._spin((t||1)*-this.options.step),this._stop())},pageUp:r(function(t){this._stepUp((t||1)*this.options.page)}),pageDown:r(function(t){this._stepDown((t||1)*this.options.page)}),value:function(t){return arguments.length?(r(this._value).call(this,t),void 0):this._parse(this.element.val())},widget:function(){return this.uiSpinner}}),t.uiBackCompat!==!1&&t.widget("ui.spinner",t.ui.spinner,{_enhance:function(){this.uiSpinner=this.element.attr("autocomplete","off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml())},_uiSpinnerHtml:function(){return"<span>"},_buttonHtml:function(){return"<a></a><a></a>"}}),t.ui.spinner,t.widget("ui.tabs",{version:"1.12.1",delay:300,options:{active:null,classes:{"ui-tabs":"ui-corner-all","ui-tabs-nav":"ui-corner-all","ui-tabs-panel":"ui-corner-bottom","ui-tabs-tab":"ui-corner-top"},collapsible:!1,event:"click",heightStyle:"content",hide:null,show:null,activate:null,beforeActivate:null,beforeLoad:null,load:null},_isLocal:function(){var t=/#.*$/;return function(e){var i,s;i=e.href.replace(t,""),s=location.href.replace(t,"");try{i=decodeURIComponent(i)}catch(n){}try{s=decodeURIComponent(s)}catch(n){}return e.hash.length>1&&i===s}}(),_create:function(){var e=this,i=this.options;this.running=!1,this._addClass("ui-tabs","ui-widget ui-widget-content"),this._toggleClass("ui-tabs-collapsible",null,i.collapsible),this._processTabs(),i.active=this._initialActive(),t.isArray(i.disabled)&&(i.disabled=t.unique(i.disabled.concat(t.map(this.tabs.filter(".ui-state-disabled"),function(t){return e.tabs.index(t)}))).sort()),this.active=this.options.active!==!1&&this.anchors.length?this._findActive(i.active):t(),this._refresh(),this.active.length&&this.load(i.active)},_initialActive:function(){var e=this.options.active,i=this.options.collapsible,s=location.hash.substring(1);return null===e&&(s&&this.tabs.each(function(i,n){return t(n).attr("aria-controls")===s?(e=i,!1):void 0}),null===e&&(e=this.tabs.index(this.tabs.filter(".ui-tabs-active"))),(null===e||-1===e)&&(e=this.tabs.length?0:!1)),e!==!1&&(e=this.tabs.index(this.tabs.eq(e)),-1===e&&(e=i?!1:0)),!i&&e===!1&&this.anchors.length&&(e=0),e},_getCreateEventData:function(){return{tab:this.active,panel:this.active.length?this._getPanelForTab(this.active):t()}},_tabKeydown:function(e){var i=t(t.ui.safeActiveElement(this.document[0])).closest("li"),s=this.tabs.index(i),n=!0;if(!this._handlePageNav(e)){switch(e.keyCode){case t.ui.keyCode.RIGHT:case t.ui.keyCode.DOWN:s++;break;case t.ui.keyCode.UP:case t.ui.keyCode.LEFT:n=!1,s--;break;case t.ui.keyCode.END:s=this.anchors.length-1;break;case t.ui.keyCode.HOME:s=0;break;case t.ui.keyCode.SPACE:return e.preventDefault(),clearTimeout(this.activating),this._activate(s),void 0;case t.ui.keyCode.ENTER:return e.preventDefault(),clearTimeout(this.activating),this._activate(s===this.options.active?!1:s),void 0;default:return}e.preventDefault(),clearTimeout(this.activating),s=this._focusNextTab(s,n),e.ctrlKey||e.metaKey||(i.attr("aria-selected","false"),this.tabs.eq(s).attr("aria-selected","true"),this.activating=this._delay(function(){this.option("active",s)},this.delay))}},_panelKeydown:function(e){this._handlePageNav(e)||e.ctrlKey&&e.keyCode===t.ui.keyCode.UP&&(e.preventDefault(),this.active.trigger("focus"))},_handlePageNav:function(e){return e.altKey&&e.keyCode===t.ui.keyCode.PAGE_UP?(this._activate(this._focusNextTab(this.options.active-1,!1)),!0):e.altKey&&e.keyCode===t.ui.keyCode.PAGE_DOWN?(this._activate(this._focusNextTab(this.options.active+1,!0)),!0):void 0},_findNextTab:function(e,i){function s(){return e>n&&(e=0),0>e&&(e=n),e}for(var n=this.tabs.length-1;-1!==t.inArray(s(),this.options.disabled);)e=i?e+1:e-1;return e},_focusNextTab:function(t,e){return t=this._findNextTab(t,e),this.tabs.eq(t).trigger("focus"),t},_setOption:function(t,e){return"active"===t?(this._activate(e),void 0):(this._super(t,e),"collapsible"===t&&(this._toggleClass("ui-tabs-collapsible",null,e),e||this.options.active!==!1||this._activate(0)),"event"===t&&this._setupEvents(e),"heightStyle"===t&&this._setupHeightStyle(e),void 0)},_sanitizeSelector:function(t){return t?t.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g,"\\$&"):""},refresh:function(){var e=this.options,i=this.tablist.children(":has(a[href])");e.disabled=t.map(i.filter(".ui-state-disabled"),function(t){return i.index(t)}),this._processTabs(),e.active!==!1&&this.anchors.length?this.active.length&&!t.contains(this.tablist[0],this.active[0])?this.tabs.length===e.disabled.length?(e.active=!1,this.active=t()):this._activate(this._findNextTab(Math.max(0,e.active-1),!1)):e.active=this.tabs.index(this.active):(e.active=!1,this.active=t()),this._refresh()},_refresh:function(){this._setOptionDisabled(this.options.disabled),this._setupEvents(this.options.event),this._setupHeightStyle(this.options.heightStyle),this.tabs.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}),this.panels.not(this._getPanelForTab(this.active)).hide().attr({"aria-hidden":"true"}),this.active.length?(this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}),this._addClass(this.active,"ui-tabs-active","ui-state-active"),this._getPanelForTab(this.active).show().attr({"aria-hidden":"false"})):this.tabs.eq(0).attr("tabIndex",0)},_processTabs:function(){var e=this,i=this.tabs,s=this.anchors,n=this.panels;this.tablist=this._getList().attr("role","tablist"),this._addClass(this.tablist,"ui-tabs-nav","ui-helper-reset ui-helper-clearfix ui-widget-header"),this.tablist.on("mousedown"+this.eventNamespace,"> li",function(e){t(this).is(".ui-state-disabled")&&e.preventDefault()}).on("focus"+this.eventNamespace,".ui-tabs-anchor",function(){t(this).closest("li").is(".ui-state-disabled")&&this.blur()}),this.tabs=this.tablist.find("> li:has(a[href])").attr({role:"tab",tabIndex:-1}),this._addClass(this.tabs,"ui-tabs-tab","ui-state-default"),this.anchors=this.tabs.map(function(){return t("a",this)[0]}).attr({role:"presentation",tabIndex:-1}),this._addClass(this.anchors,"ui-tabs-anchor"),this.panels=t(),this.anchors.each(function(i,s){var n,o,a,r=t(s).uniqueId().attr("id"),h=t(s).closest("li"),l=h.attr("aria-controls");e._isLocal(s)?(n=s.hash,a=n.substring(1),o=e.element.find(e._sanitizeSelector(n))):(a=h.attr("aria-controls")||t({}).uniqueId()[0].id,n="#"+a,o=e.element.find(n),o.length||(o=e._createPanel(a),o.insertAfter(e.panels[i-1]||e.tablist)),o.attr("aria-live","polite")),o.length&&(e.panels=e.panels.add(o)),l&&h.data("ui-tabs-aria-controls",l),h.attr({"aria-controls":a,"aria-labelledby":r}),o.attr("aria-labelledby",r)}),this.panels.attr("role","tabpanel"),this._addClass(this.panels,"ui-tabs-panel","ui-widget-content"),i&&(this._off(i.not(this.tabs)),this._off(s.not(this.anchors)),this._off(n.not(this.panels)))},_getList:function(){return this.tablist||this.element.find("ol, ul").eq(0)},_createPanel:function(e){return t("<div>").attr("id",e).data("ui-tabs-destroy",!0)},_setOptionDisabled:function(e){var i,s,n;for(t.isArray(e)&&(e.length?e.length===this.anchors.length&&(e=!0):e=!1),n=0;s=this.tabs[n];n++)i=t(s),e===!0||-1!==t.inArray(n,e)?(i.attr("aria-disabled","true"),this._addClass(i,null,"ui-state-disabled")):(i.removeAttr("aria-disabled"),this._removeClass(i,null,"ui-state-disabled"));this.options.disabled=e,this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,e===!0)},_setupEvents:function(e){var i={};e&&t.each(e.split(" "),function(t,e){i[e]="_eventHandler"}),this._off(this.anchors.add(this.tabs).add(this.panels)),this._on(!0,this.anchors,{click:function(t){t.preventDefault()}}),this._on(this.anchors,i),this._on(this.tabs,{keydown:"_tabKeydown"}),this._on(this.panels,{keydown:"_panelKeydown"}),this._focusable(this.tabs),this._hoverable(this.tabs)},_setupHeightStyle:function(e){var i,s=this.element.parent();"fill"===e?(i=s.height(),i-=this.element.outerHeight()-this.element.height(),this.element.siblings(":visible").each(function(){var e=t(this),s=e.css("position");"absolute"!==s&&"fixed"!==s&&(i-=e.outerHeight(!0))}),this.element.children().not(this.panels).each(function(){i-=t(this).outerHeight(!0)}),this.panels.each(function(){t(this).height(Math.max(0,i-t(this).innerHeight()+t(this).height()))}).css("overflow","auto")):"auto"===e&&(i=0,this.panels.each(function(){i=Math.max(i,t(this).height("").height())}).height(i))},_eventHandler:function(e){var i=this.options,s=this.active,n=t(e.currentTarget),o=n.closest("li"),a=o[0]===s[0],r=a&&i.collapsible,h=r?t():this._getPanelForTab(o),l=s.length?this._getPanelForTab(s):t(),c={oldTab:s,oldPanel:l,newTab:r?t():o,newPanel:h};e.preventDefault(),o.hasClass("ui-state-disabled")||o.hasClass("ui-tabs-loading")||this.running||a&&!i.collapsible||this._trigger("beforeActivate",e,c)===!1||(i.active=r?!1:this.tabs.index(o),this.active=a?t():o,this.xhr&&this.xhr.abort(),l.length||h.length||t.error("jQuery UI Tabs: Mismatching fragment identifier."),h.length&&this.load(this.tabs.index(o),e),this._toggle(e,c))},_toggle:function(e,i){function s(){o.running=!1,o._trigger("activate",e,i)}function n(){o._addClass(i.newTab.closest("li"),"ui-tabs-active","ui-state-active"),a.length&&o.options.show?o._show(a,o.options.show,s):(a.show(),s())}var o=this,a=i.newPanel,r=i.oldPanel;this.running=!0,r.length&&this.options.hide?this._hide(r,this.options.hide,function(){o._removeClass(i.oldTab.closest("li"),"ui-tabs-active","ui-state-active"),n()}):(this._removeClass(i.oldTab.closest("li"),"ui-tabs-active","ui-state-active"),r.hide(),n()),r.attr("aria-hidden","true"),i.oldTab.attr({"aria-selected":"false","aria-expanded":"false"}),a.length&&r.length?i.oldTab.attr("tabIndex",-1):a.length&&this.tabs.filter(function(){return 0===t(this).attr("tabIndex")}).attr("tabIndex",-1),a.attr("aria-hidden","false"),i.newTab.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_activate:function(e){var i,s=this._findActive(e);s[0]!==this.active[0]&&(s.length||(s=this.active),i=s.find(".ui-tabs-anchor")[0],this._eventHandler({target:i,currentTarget:i,preventDefault:t.noop}))},_findActive:function(e){return e===!1?t():this.tabs.eq(e)},_getIndex:function(e){return"string"==typeof e&&(e=this.anchors.index(this.anchors.filter("[href$='"+t.ui.escapeSelector(e)+"']"))),e},_destroy:function(){this.xhr&&this.xhr.abort(),this.tablist.removeAttr("role").off(this.eventNamespace),this.anchors.removeAttr("role tabIndex").removeUniqueId(),this.tabs.add(this.panels).each(function(){t.data(this,"ui-tabs-destroy")?t(this).remove():t(this).removeAttr("role tabIndex aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded")}),this.tabs.each(function(){var e=t(this),i=e.data("ui-tabs-aria-controls");i?e.attr("aria-controls",i).removeData("ui-tabs-aria-controls"):e.removeAttr("aria-controls")}),this.panels.show(),"content"!==this.options.heightStyle&&this.panels.css("height","")},enable:function(e){var i=this.options.disabled;i!==!1&&(void 0===e?i=!1:(e=this._getIndex(e),i=t.isArray(i)?t.map(i,function(t){return t!==e?t:null}):t.map(this.tabs,function(t,i){return i!==e?i:null})),this._setOptionDisabled(i))},disable:function(e){var i=this.options.disabled;if(i!==!0){if(void 0===e)i=!0;else{if(e=this._getIndex(e),-1!==t.inArray(e,i))return;i=t.isArray(i)?t.merge([e],i).sort():[e]}this._setOptionDisabled(i)}},load:function(e,i){e=this._getIndex(e);var s=this,n=this.tabs.eq(e),o=n.find(".ui-tabs-anchor"),a=this._getPanelForTab(n),r={tab:n,panel:a},h=function(t,e){"abort"===e&&s.panels.stop(!1,!0),s._removeClass(n,"ui-tabs-loading"),a.removeAttr("aria-busy"),t===s.xhr&&delete s.xhr};this._isLocal(o[0])||(this.xhr=t.ajax(this._ajaxSettings(o,i,r)),this.xhr&&"canceled"!==this.xhr.statusText&&(this._addClass(n,"ui-tabs-loading"),a.attr("aria-busy","true"),this.xhr.done(function(t,e,n){setTimeout(function(){a.html(t),s._trigger("load",i,r),h(n,e)},1)}).fail(function(t,e){setTimeout(function(){h(t,e)},1)})))},_ajaxSettings:function(e,i,s){var n=this;return{url:e.attr("href").replace(/#.*$/,""),beforeSend:function(e,o){return n._trigger("beforeLoad",i,t.extend({jqXHR:e,ajaxSettings:o},s))}}},_getPanelForTab:function(e){var i=t(e).attr("aria-controls");return this.element.find(this._sanitizeSelector("#"+i))}}),t.uiBackCompat!==!1&&t.widget("ui.tabs",t.ui.tabs,{_processTabs:function(){this._superApply(arguments),this._addClass(this.tabs,"ui-tab")}}),t.ui.tabs,t.widget("ui.tooltip",{version:"1.12.1",options:{classes:{"ui-tooltip":"ui-corner-all ui-widget-shadow"},content:function(){var e=t(this).attr("title")||"";return t("<a>").text(e).html()},hide:!0,items:"[title]:not([disabled])",position:{my:"left top+15",at:"left bottom",collision:"flipfit flip"},show:!0,track:!1,close:null,open:null},_addDescribedBy:function(e,i){var s=(e.attr("aria-describedby")||"").split(/\s+/);s.push(i),e.data("ui-tooltip-id",i).attr("aria-describedby",t.trim(s.join(" ")))},_removeDescribedBy:function(e){var i=e.data("ui-tooltip-id"),s=(e.attr("aria-describedby")||"").split(/\s+/),n=t.inArray(i,s);-1!==n&&s.splice(n,1),e.removeData("ui-tooltip-id"),s=t.trim(s.join(" ")),s?e.attr("aria-describedby",s):e.removeAttr("aria-describedby")},_create:function(){this._on({mouseover:"open",focusin:"open"}),this.tooltips={},this.parents={},this.liveRegion=t("<div>").attr({role:"log","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this.disabledTitles=t([])},_setOption:function(e,i){var s=this;this._super(e,i),"content"===e&&t.each(this.tooltips,function(t,e){s._updateContent(e.element)})},_setOptionDisabled:function(t){this[t?"_disable":"_enable"]()},_disable:function(){var e=this;t.each(this.tooltips,function(i,s){var n=t.Event("blur");n.target=n.currentTarget=s.element[0],e.close(n,!0)}),this.disabledTitles=this.disabledTitles.add(this.element.find(this.options.items).addBack().filter(function(){var e=t(this);return e.is("[title]")?e.data("ui-tooltip-title",e.attr("title")).removeAttr("title"):void 0}))},_enable:function(){this.disabledTitles.each(function(){var e=t(this);e.data("ui-tooltip-title")&&e.attr("title",e.data("ui-tooltip-title"))}),this.disabledTitles=t([])},open:function(e){var i=this,s=t(e?e.target:this.element).closest(this.options.items);s.length&&!s.data("ui-tooltip-id")&&(s.attr("title")&&s.data("ui-tooltip-title",s.attr("title")),s.data("ui-tooltip-open",!0),e&&"mouseover"===e.type&&s.parents().each(function(){var e,s=t(this);s.data("ui-tooltip-open")&&(e=t.Event("blur"),e.target=e.currentTarget=this,i.close(e,!0)),s.attr("title")&&(s.uniqueId(),i.parents[this.id]={element:this,title:s.attr("title")},s.attr("title",""))}),this._registerCloseHandlers(e,s),this._updateContent(s,e))},_updateContent:function(t,e){var i,s=this.options.content,n=this,o=e?e.type:null;return"string"==typeof s||s.nodeType||s.jquery?this._open(e,t,s):(i=s.call(t[0],function(i){n._delay(function(){t.data("ui-tooltip-open")&&(e&&(e.type=o),this._open(e,t,i))})}),i&&this._open(e,t,i),void 0)},_open:function(e,i,s){function n(t){l.of=t,a.is(":hidden")||a.position(l)}var o,a,r,h,l=t.extend({},this.options.position);if(s){if(o=this._find(i))return o.tooltip.find(".ui-tooltip-content").html(s),void 0;i.is("[title]")&&(e&&"mouseover"===e.type?i.attr("title",""):i.removeAttr("title")),o=this._tooltip(i),a=o.tooltip,this._addDescribedBy(i,a.attr("id")),a.find(".ui-tooltip-content").html(s),this.liveRegion.children().hide(),h=t("<div>").html(a.find(".ui-tooltip-content").html()),h.removeAttr("name").find("[name]").removeAttr("name"),h.removeAttr("id").find("[id]").removeAttr("id"),h.appendTo(this.liveRegion),this.options.track&&e&&/^mouse/.test(e.type)?(this._on(this.document,{mousemove:n}),n(e)):a.position(t.extend({of:i},this.options.position)),a.hide(),this._show(a,this.options.show),this.options.track&&this.options.show&&this.options.show.delay&&(r=this.delayedShow=setInterval(function(){a.is(":visible")&&(n(l.of),clearInterval(r))},t.fx.interval)),this._trigger("open",e,{tooltip:a})}},_registerCloseHandlers:function(e,i){var s={keyup:function(e){if(e.keyCode===t.ui.keyCode.ESCAPE){var s=t.Event(e);s.currentTarget=i[0],this.close(s,!0)}}};i[0]!==this.element[0]&&(s.remove=function(){this._removeTooltip(this._find(i).tooltip)}),e&&"mouseover"!==e.type||(s.mouseleave="close"),e&&"focusin"!==e.type||(s.focusout="close"),this._on(!0,i,s)},close:function(e){var i,s=this,n=t(e?e.currentTarget:this.element),o=this._find(n);return o?(i=o.tooltip,o.closing||(clearInterval(this.delayedShow),n.data("ui-tooltip-title")&&!n.attr("title")&&n.attr("title",n.data("ui-tooltip-title")),this._removeDescribedBy(n),o.hiding=!0,i.stop(!0),this._hide(i,this.options.hide,function(){s._removeTooltip(t(this))}),n.removeData("ui-tooltip-open"),this._off(n,"mouseleave focusout keyup"),n[0]!==this.element[0]&&this._off(n,"remove"),this._off(this.document,"mousemove"),e&&"mouseleave"===e.type&&t.each(this.parents,function(e,i){t(i.element).attr("title",i.title),delete s.parents[e]}),o.closing=!0,this._trigger("close",e,{tooltip:i}),o.hiding||(o.closing=!1)),void 0):(n.removeData("ui-tooltip-open"),void 0)},_tooltip:function(e){var i=t("<div>").attr("role","tooltip"),s=t("<div>").appendTo(i),n=i.uniqueId().attr("id");return this._addClass(s,"ui-tooltip-content"),this._addClass(i,"ui-tooltip","ui-widget ui-widget-content"),i.appendTo(this._appendTo(e)),this.tooltips[n]={element:e,tooltip:i}},_find:function(t){var e=t.data("ui-tooltip-id");return e?this.tooltips[e]:null},_removeTooltip:function(t){t.remove(),delete this.tooltips[t.attr("id")]},_appendTo:function(t){var e=t.closest(".ui-front, dialog");return e.length||(e=this.document[0].body),e},_destroy:function(){var e=this;t.each(this.tooltips,function(i,s){var n=t.Event("blur"),o=s.element;n.target=n.currentTarget=o[0],e.close(n,!0),t("#"+i).remove(),o.data("ui-tooltip-title")&&(o.attr("title")||o.attr("title",o.data("ui-tooltip-title")),o.removeData("ui-tooltip-title"))}),this.liveRegion.remove()}}),t.uiBackCompat!==!1&&t.widget("ui.tooltip",t.ui.tooltip,{options:{tooltipClass:null},_tooltip:function(){var t=this._superApply(arguments);return this.options.tooltipClass&&t.tooltip.addClass(this.options.tooltipClass),t}}),t.ui.tooltip});
  // Yeah, this is empty right now. It used to have stuff. 
  // We're leaving it here, so if in future versions of advanced_search it has
  // stuff, existing apps will already be linked in. 
  
  //Is this a bad idea, it should just be removed? Not sure. 
  ;
  Blacklight = function() {
    var buffer = new Array;
    return {
      onLoad: function(func) {
        buffer.push(func);
      },
  
      activate: function() {
        for(var i = 0; i < buffer.length; i++) {
          buffer[i].call();
        }
      }
    };
  }();
  
  // turbolinks triggers page:load events on page transition
  // If app isn't using turbolinks, this event will never be triggered, no prob.
  // $(document).on('ready') is deprecated in JQuery 1.8
  if (typeof Turbolinks !== 'undefined' && Turbolinks.supported) {
    // Turbolinks 5
    if (Turbolinks.BrowserAdapter) {
      $(document).on('turbolinks:load', function() { Blacklight.activate(); });
    } else {
      // Turbolinks < 5
      $(document).on('page:load', function() { Blacklight.activate(); });
      $(document).ready(function() { Blacklight.activate(); });
    }
  } else {
    $(document).ready(function() { Blacklight.activate(); });
  }
  ;
  (function($) {
    Blacklight.do_search_autofocus_fallback = function() {
      if (typeof Modernizer != "undefined") {
        if (Modernizr.autofocus) {
          return;
        }
      }
  
      $('input[autofocus]').focus();
    }
  
    Blacklight.onLoad(function() {
      Blacklight.do_search_autofocus_fallback();
    });
  })(jQuery);
  /* A JQuery plugin (should this be implemented as a widget instead? not sure)
     that will convert a "toggle" form, with single submit button to add/remove
     something, like used for Bookmarks, into an AJAXy checkbox instead. 
     
     Apply to a form. Does require certain assumption about the form:
      1) The same form 'action' href must be used for both ADD and REMOVE
         actions, with the different being the hidden input name="_method"
         being set to "put" or "delete" -- that's the Rails method to pretend
         to be doing a certain HTTP verb. So same URL, PUT to add, DELETE
         to remove. This plugin assumes that. 
         
         Plus, the form this is applied to should provide a data-doc-id 
         attribute (HTML5-style doc-*) that contains the id/primary key
         of the object in question -- used by plugin for a unique value for
         DOM id's. 
  
    Uses HTML for a checkbox compatible with Bootstrap 3. 
         
     Pass in options for your class name and labels:
     $("form.something").bl_checkbox_submit({    
          checked_label: "Selected",
          unchecked_label: "Select",
          progress_label: "Saving...",
          //css_class is added to elements added, plus used for id base
          css_class: "toggle_my_kinda_form",
          success: function(after_success_check_state) {
            #optional callback
          }
     });
  */
  
  (function($) {    
      $.fn.bl_checkbox_submit = function(arg_opts) {              
        
        this.each(function() {
          var options = $.extend({}, $.fn.bl_checkbox_submit.defaults, arg_opts);
                                    
            
          var form = $(this);
          form.children().hide();
          //We're going to use the existing form to actually send our add/removes
          //This works conveneintly because the exact same action href is used
          //for both bookmarks/$doc_id.  But let's take out the irrelevant parts
          //of the form to avoid any future confusion. 
          form.find("input[type=submit]").remove();
          form.addClass('form-horizontal');
          
          //View needs to set data-doc-id so we know a unique value
          //for making DOM id
          var unique_id = form.attr("data-doc-id") || Math.random();
          // if form is currently using method delete to change state, 
          // then checkbox is currently checked
          var checked = (form.find("input[name=_method][value=delete]").length != 0);
              
          var checkbox = $('<input type="checkbox">')	    
            .addClass( options.css_class )
            .attr("id", options.css_class + "_" + unique_id);	  
          var label = $('<label>')
            .addClass( options.css_class )
            .attr("for", options.css_class + '_' + unique_id)
            .attr("title", form.attr("title") || "");
          var span = $('<span>');
  
          label.append(checkbox);
          label.append(" ");
          label.append(span);  
  
          var checkbox_div = $("<div class='checkbox' />")
            .addClass(options.css_class)
            .append(label);
            
          function update_state_for(state) {
              checkbox.prop("checked", state);
              label.toggleClass("checked", state);
              if (state) {    
                 //Set the Rails hidden field that fakes an HTTP verb
                 //properly for current state action. 
                 form.find("input[name=_method]").val("delete");
                 span.text(form.attr('data-present'));
              } else {
                 form.find("input[name=_method]").val("put");
                 span.text(form.attr('data-absent'));
              }
            }
          
          form.append(checkbox_div);
          update_state_for(checked);
          
          checkbox.click(function() {
              span.text(form.attr('data-inprogress'));
              label.attr("disabled", "disabled");  
              checkbox.attr("disabled", "disabled");
                              
              $.ajax({
                  url: form.attr("action"),
                  dataType: 'json',
                  type: form.attr("method").toUpperCase(),
                  data: form.serialize(),
                  error: function() {
                     alert("Error");
                     update_state_for(checked);
                     label.removeAttr("disabled");
                     checkbox.removeAttr("disabled");
                  },
                  success: function(data, status, xhr) {
                    //if app isn't running at all, xhr annoyingly
                    //reports success with status 0. 
                    if (xhr.status != 0) {
                      checked = ! checked;
                      update_state_for(checked);
                      label.removeAttr("disabled");
                      checkbox.removeAttr("disabled");
                      options.success.call(form, checked, xhr.responseJSON);
                    } else {
                      alert("Error");
                      update_state_for(checked);
                      label.removeAttr("disabled");
                      checkbox.removeAttr("disabled");
                    }
                  }
              });
              
              return false;
          }); //checkbox.click
          
          
        }); //this.each      
        return this;
      };
      
    $.fn.bl_checkbox_submit.defaults =  {
              //css_class is added to elements added, plus used for id base
              css_class: "bl_checkbox_submit",
              success: function() {} //callback
    };
  })(jQuery);
  
  
  (function($) {
  //change form submit toggle to checkbox
      Blacklight.do_bookmark_toggle_behavior = function() {
        $(Blacklight.do_bookmark_toggle_behavior.selector).bl_checkbox_submit({
           //css_class is added to elements added, plus used for id base
           css_class: "toggle_bookmark",
           success: function(checked, response) {
             if (response.bookmarks) {
               $('[data-role=bookmark-counter]').text(response.bookmarks.count);
             }
           }
        });
      };
      Blacklight.do_bookmark_toggle_behavior.selector = "form.bookmark_toggle"; 
  
  Blacklight.onLoad(function() {
    Blacklight.do_bookmark_toggle_behavior();  
  });
    
  
  })(jQuery);
  
  
  /*
    The ajax_modal plugin can display some interactions inside a Bootstrap
    modal window, including some multi-page interactions.
  
    It supports unobtrusive Javascript, where a link or form that would have caused
    a new page load is changed to display it's results inside a modal dialog,
    by this plugin.  The plugin assumes there is a Bootstrap modal div
    on the page with id #ajax-modal to use as the modal -- the standard Blacklight
    layout provides this.
  
    To make a link or form have their results display inside a modal, add
    `data-ajax-modal="trigger"` to the link or form. (Note, form itself not submit input)
    With Rails link_to helper, you'd do that like:
  
        link_to something, link, :data => {:ajax_modal => "trigger"}
  
    The results of the link href or form submit will be displayed inside
    a modal -- they should include the proper HTML markup for a bootstrap modal's
    contents. Also, you ordinarily won't want the Rails template with wrapping
    navigational elements to be used.  The Rails controller could suppress
    the layout when a JS AJAX request is detected, OR the response
    can include a `<div data-ajax-modal="container">` -- only the contents
    of the container will be placed inside the modal, the rest of the
    page will be ignored.
  
    If you'd like to have a link or button that closes the modal,
    you can just add a `data-dismiss="modal"` to the link,
    standard Bootstrap convention. But you can also have
    an href on this link for non-JS contexts, we'll make sure
    inside the modal it closes the modal and the link is NOT followed.
  
    Link or forms inside the modal will ordinarily cause page loads
    when they are triggered. However, if you'd like their results
    to stay within the modal, just add `data-ajax-modal="preserve"`
    to the link or form.
  
    Here's an example of what might be returned, demonstrating most of the devices available:
  
      <div data-ajax-modal="container">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal" aria-hidden="true">×</button>
          <h3 class="modal-title">Request Placed</h3>
        </div>
  
        <div class="modal-body">
          <p>Some message</p>
          <%= link_to "This result will still be within modal", some_link, :data => {:ajax_modal => "preserve"} %>
        </div>
  
  
        <div class="modal-footer">
          <%= link_to "Close the modal", request_done_path, :class => "submit button dialog-close", :data => {:dismiss => "modal"} %>
        </div>
      </div>
  
  
    One additional feature. If the content returned from the AJAX modal load
    has an element with `data-ajax-modal=close`, that will trigger the modal
    to be closed. And if this element includes a node with class "flash_messages",
    the flash-messages node will be added to the main page inside #main-flahses.
  
    == Events
  
    We'll send out an event 'loaded.blacklight.ajax-modal' with the #ajax-modal
    dialog as the target, right after content is loaded into the modal but before
    it is shown (if not already a shown modal).  In an event handler, you can
    inspect loaded content by looking inside $(this).  If you call event.preventDefault(),
    we won't 'show' the dialog (although it may already have been shown, you may want to
    $(this).modal("hide") if you want to ensure hidden/closed.
  
    The data-ajax-modal=close behavior is implemented with this event, see for example.
  */
  
  // We keep all our data in Blacklight.ajaxModal object.
  // Create lazily if someone else created first.
  if (Blacklight.ajaxModal === undefined) {
    Blacklight.ajaxModal = {};
  }
  
  
  // a Bootstrap modal div that should be already on the page hidden
  Blacklight.ajaxModal.modalSelector = "#ajax-modal";
  
  // Trigger selectors identify forms or hyperlinks that should open
  // inside a modal dialog.
  Blacklight.ajaxModal.triggerLinkSelector  = "a[data-ajax-modal~=trigger], a.lightboxLink,a.more_facets_link,.ajax_modal_launch";
  Blacklight.ajaxModal.triggerFormSelector  = "form[data-ajax-modal~=trigger], form.ajax_form";
  
  // preserve selectors identify forms or hyperlinks that, if activated already
  // inside a modal dialog, should have destinations remain inside the modal -- but
  // won't trigger a modal if not already in one.
  //
  // No need to repeat selectors from trigger selectors, those will already
  // be preserved. MUST be manually prefixed with the modal selector,
  // so they only apply to things inside a modal.
  Blacklight.ajaxModal.preserveLinkSelector = Blacklight.ajaxModal.modalSelector + ' a[data-ajax-modal~=preserve]';
  Blacklight.ajaxModal.preserveFormSelector = Blacklight.ajaxModal.modalSelector + ' form[data-ajax-modal~=preserve]'
  
  Blacklight.ajaxModal.containerSelector    = "[data-ajax-modal~=container]";
  
  Blacklight.ajaxModal.modalCloseSelector   = "[data-ajax-modal~=close], span.ajax-close-modal";
  
  // Called on fatal failure of ajax load, function returns content
  // to show to user in modal.  Right now called only for extreme
  // network errors.
  Blacklight.ajaxModal.onFailure = function(data) {
    var contents =  "<div class='modal-header'>" +
             "<button type='button' class='close' data-dismiss='modal' aria-hidden='true'>×</button>" +
             "Network Error</div>";
    $(Blacklight.ajaxModal.modalSelector).find('.modal-content').html(contents);
    $(Blacklight.ajaxModal.modalSelector).modal('show');
  }
  
  Blacklight.ajaxModal.receiveAjax = function (contents) {
      // does it have a data- selector for container?
      // important we don't execute script tags, we shouldn't.
      // code modelled off of JQuery ajax.load. https://github.com/jquery/jquery/blob/master/src/ajax/load.js?source=c#L62
      var container =  $("<div>").
        append( jQuery.parseHTML(contents) ).find( Blacklight.ajaxModal.containerSelector ).first();
      if (container.length !== 0) {
        contents = container.html();
      }
  
      $(Blacklight.ajaxModal.modalSelector).find('.modal-content').html(contents);
  
      // send custom event with the modal dialog div as the target
      var e    = $.Event('loaded.blacklight.ajax-modal');
      $(Blacklight.ajaxModal.modalSelector).trigger(e);
      // if they did preventDefault, don't show the dialog
      if (e.isDefaultPrevented()) return;
  
      $(Blacklight.ajaxModal.modalSelector).modal('show');
  };
  
  
  Blacklight.ajaxModal.modalAjaxLinkClick = function(e) {
    e.preventDefault();
  
    $.ajax({
      url: $(this).attr('href')
    })
    .fail(Blacklight.ajaxModal.onFailure)
    .done(Blacklight.ajaxModal.receiveAjax)
  };
  
  Blacklight.ajaxModal.modalAjaxFormSubmit = function(e) {
      e.preventDefault();
  
      $.ajax({
        url: $(this).attr('action'),
        data: $(this).serialize(),
        type: $(this).attr('method') // POST
      })
      .fail(Blacklight.ajaxModal.onFailure)
      .done(Blacklight.ajaxModal.receiveAjax)
  }
  
  
  
  Blacklight.ajaxModal.setup_modal = function() {
      // Event indicating blacklight is setting up a modal link,
    // you can catch it and call e.preventDefault() to abort
    // setup.
      var e = $.Event('setup.blacklight.ajax-modal');
      $("body").trigger(e);
      if (e.isDefaultPrevented()) return;
  
    // Register both trigger and preserve selectors in ONE event handler, combining
    // into one selector with a comma, so if something matches BOTH selectors, it
    // still only gets the event handler called once.
    $("body").on("click", Blacklight.ajaxModal.triggerLinkSelector  + ", " + Blacklight.ajaxModal.preserveLinkSelector,
      Blacklight.ajaxModal.modalAjaxLinkClick);
    $("body").on("submit", Blacklight.ajaxModal.triggerFormSelector + ", " + Blacklight.ajaxModal.preserveFormSelector,
      Blacklight.ajaxModal.modalAjaxFormSubmit);
  
    // Catch our own custom loaded event to implement data-ajax-modal=closed
    $("body").on("loaded.blacklight.ajax-modal", Blacklight.ajaxModal.check_close_ajax_modal);
  
    // we support doing data-dismiss=modal on a <a> with a href for non-ajax
    // use, we need to suppress following the a's href that's there for
    // non-JS contexts.
    $("body ").on("click", Blacklight.ajaxModal.modalSelector + " a[data-dismiss~=modal]", function (e) {
      e.preventDefault();
    });
  };
  
  // A function used as an event handler on loaded.blacklight.ajax-modal
  // to catch contained data-ajax-modal=closed directions
  Blacklight.ajaxModal.check_close_ajax_modal = function(event) {
    if ($(event.target).find(Blacklight.ajaxModal.modalCloseSelector).length) {
      modal_flashes = $(this).find('.flash_messages');
  
      $(event.target).modal("hide");
      event.preventDefault();
  
      main_flashes = $('#main-flashes');
      main_flashes.append(modal_flashes);
      modal_flashes.fadeIn(500);
    }
  }
  
  Blacklight.onLoad(function() {
    Blacklight.ajaxModal.setup_modal();
  });
  (function($) {
    Blacklight.do_search_context_behavior = function() {
      $('a[data-context-href]').on('click.search-context', Blacklight.handleSearchContextMethod);
    };
  
    // this is the $.rails.handleMethod with a couple adjustments, described inline:
    // first, we're attaching this directly to the event handler, so we can check for meta-keys
    Blacklight.handleSearchContextMethod = function(event) {
      var link = $(this);
  
      // instead of using the normal href, we need to use the context href instead
      var href = link.data('context-href'),
        method = 'post',
        target = link.attr('target'),
        csrfToken = $('meta[name=csrf-token]').attr('content'),
        csrfParam = $('meta[name=csrf-param]').attr('content'),
        form = $('<form method="post" action="' + href + '"></form>'),
        metadataInput = '<input name="_method" value="' + method + '" type="hidden" />',
        redirectHref = '<input name="redirect" value="' + link.attr('href') + '" type="hidden" />';
  
      // check for meta keys.. if set, we should open in a new tab
      if(event.metaKey || event.ctrlKey) {
        target = '_blank';
      }
  
      if (csrfParam !== undefined && csrfToken !== undefined) {
        metadataInput += '<input name="' + csrfParam + '" value="' + csrfToken + '" type="hidden" />';
      }
  
      if (target) { form.attr('target', target); }
  
      form.hide().append(metadataInput).append(redirectHref).appendTo('body');
      form.submit();
  
      return false;
    };
  
    Blacklight.onLoad(function() {
      Blacklight.do_search_context_behavior();
    });
  })(jQuery);
  (function($) {
    Blacklight.onLoad(function() {
      // when clicking on a link that toggles the collapsing behavior, don't do anything
      // with the hash or the page could jump around.
      $(document).on("click", "a[data-toggle=collapse][href='#'], [data-toggle=collapse] a[href='#']", function(event) {
        event.preventDefault();
      });
    });
  })(jQuery);
  /*global Blacklight */
  
  
  (function($) {
    'use strict';
    
    Blacklight.doResizeFacetLabelsAndCounts = function() {
      // adjust width of facet columns to fit their contents
      function longer (a,b){ return b.textContent.length - a.textContent.length; }
  
      $('ul.facet-values, ul.pivot-facet').each(function(){
        var longest = $(this).find('span.facet-count').sort(longer).first();
        var clone = longest.clone()
          .css('visibility','hidden').css('width', 'auto');
        $('body').append(clone);
        $(this).find('.facet-count').first().width(clone.width());
        clone.remove();
      });
    };
  
    Blacklight.onLoad(function() {
      Blacklight.doResizeFacetLabelsAndCounts();
    });
  })(jQuery);
  /*global Bloodhound */
  
  
  Blacklight.onLoad(function() {
    'use strict';
  
    $('[data-autocomplete-enabled="true"]').each(function() {
      var $el = $(this);
      if($el.hasClass('tt-hint')) {
        return;
      }
      var suggestUrl = $el.data().autocompletePath;
      
      var terms = new Bloodhound({
        datumTokenizer: Bloodhound.tokenizers.obj.whitespace('value'),
        queryTokenizer: Bloodhound.tokenizers.whitespace,
        remote: {
          url: suggestUrl + '?q=%QUERY',
          wildcard: '%QUERY'
        }
      });
      
      terms.initialize();
  
      $el.typeahead({
        hint: true,
        highlight: true,
        minLength: 2
      },
      {
        name: 'terms',
        displayKey: 'term',
        source: terms.ttAdapter()
      });
    });
  });
  /* ========================================================================
   * Bootstrap: transition.js v3.4.0
   * https://getbootstrap.com/docs/3.4/javascript/#transitions
   * ========================================================================
   * Copyright 2011-2018 Twitter, Inc.
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * ======================================================================== */
  
  
  
  +function ($) {
    'use strict';
  
    // CSS TRANSITION SUPPORT (Shoutout: https://modernizr.com/)
    // ============================================================
  
    function transitionEnd() {
      var el = document.createElement('bootstrap')
  
      var transEndEventNames = {
        WebkitTransition : 'webkitTransitionEnd',
        MozTransition    : 'transitionend',
        OTransition      : 'oTransitionEnd otransitionend',
        transition       : 'transitionend'
      }
  
      for (var name in transEndEventNames) {
        if (el.style[name] !== undefined) {
          return { end: transEndEventNames[name] }
        }
      }
  
      return false // explicit for ie8 (  ._.)
    }
  
    // https://blog.alexmaccaw.com/css-transitions
    $.fn.emulateTransitionEnd = function (duration) {
      var called = false
      var $el = this
      $(this).one('bsTransitionEnd', function () { called = true })
      var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
      setTimeout(callback, duration)
      return this
    }
  
    $(function () {
      $.support.transition = transitionEnd()
  
      if (!$.support.transition) return
  
      $.event.special.bsTransitionEnd = {
        bindType: $.support.transition.end,
        delegateType: $.support.transition.end,
        handle: function (e) {
          if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
        }
      }
    })
  
  }(jQuery);
  /* ========================================================================
   * Bootstrap: collapse.js v3.4.0
   * https://getbootstrap.com/docs/3.4/javascript/#collapse
   * ========================================================================
   * Copyright 2011-2018 Twitter, Inc.
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * ======================================================================== */
  
  /* jshint latedef: false */
  
  
  +function ($) {
    'use strict';
  
    // COLLAPSE PUBLIC CLASS DEFINITION
    // ================================
  
    var Collapse = function (element, options) {
      this.$element      = $(element)
      this.options       = $.extend({}, Collapse.DEFAULTS, options)
      this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
                             '[data-toggle="collapse"][data-target="#' + element.id + '"]')
      this.transitioning = null
  
      if (this.options.parent) {
        this.$parent = this.getParent()
      } else {
        this.addAriaAndCollapsedClass(this.$element, this.$trigger)
      }
  
      if (this.options.toggle) this.toggle()
    }
  
    Collapse.VERSION  = '3.4.0'
  
    Collapse.TRANSITION_DURATION = 350
  
    Collapse.DEFAULTS = {
      toggle: true
    }
  
    Collapse.prototype.dimension = function () {
      var hasWidth = this.$element.hasClass('width')
      return hasWidth ? 'width' : 'height'
    }
  
    Collapse.prototype.show = function () {
      if (this.transitioning || this.$element.hasClass('in')) return
  
      var activesData
      var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')
  
      if (actives && actives.length) {
        activesData = actives.data('bs.collapse')
        if (activesData && activesData.transitioning) return
      }
  
      var startEvent = $.Event('show.bs.collapse')
      this.$element.trigger(startEvent)
      if (startEvent.isDefaultPrevented()) return
  
      if (actives && actives.length) {
        Plugin.call(actives, 'hide')
        activesData || actives.data('bs.collapse', null)
      }
  
      var dimension = this.dimension()
  
      this.$element
        .removeClass('collapse')
        .addClass('collapsing')[dimension](0)
        .attr('aria-expanded', true)
  
      this.$trigger
        .removeClass('collapsed')
        .attr('aria-expanded', true)
  
      this.transitioning = 1
  
      var complete = function () {
        this.$element
          .removeClass('collapsing')
          .addClass('collapse in')[dimension]('')
        this.transitioning = 0
        this.$element
          .trigger('shown.bs.collapse')
      }
  
      if (!$.support.transition) return complete.call(this)
  
      var scrollSize = $.camelCase(['scroll', dimension].join('-'))
  
      this.$element
        .one('bsTransitionEnd', $.proxy(complete, this))
        .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
    }
  
    Collapse.prototype.hide = function () {
      if (this.transitioning || !this.$element.hasClass('in')) return
  
      var startEvent = $.Event('hide.bs.collapse')
      this.$element.trigger(startEvent)
      if (startEvent.isDefaultPrevented()) return
  
      var dimension = this.dimension()
  
      this.$element[dimension](this.$element[dimension]())[0].offsetHeight
  
      this.$element
        .addClass('collapsing')
        .removeClass('collapse in')
        .attr('aria-expanded', false)
  
      this.$trigger
        .addClass('collapsed')
        .attr('aria-expanded', false)
  
      this.transitioning = 1
  
      var complete = function () {
        this.transitioning = 0
        this.$element
          .removeClass('collapsing')
          .addClass('collapse')
          .trigger('hidden.bs.collapse')
      }
  
      if (!$.support.transition) return complete.call(this)
  
      this.$element
        [dimension](0)
        .one('bsTransitionEnd', $.proxy(complete, this))
        .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
    }
  
    Collapse.prototype.toggle = function () {
      this[this.$element.hasClass('in') ? 'hide' : 'show']()
    }
  
    Collapse.prototype.getParent = function () {
      return $(document).find(this.options.parent)
        .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
        .each($.proxy(function (i, element) {
          var $element = $(element)
          this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
        }, this))
        .end()
    }
  
    Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
      var isOpen = $element.hasClass('in')
  
      $element.attr('aria-expanded', isOpen)
      $trigger
        .toggleClass('collapsed', !isOpen)
        .attr('aria-expanded', isOpen)
    }
  
    function getTargetFromTrigger($trigger) {
      var href
      var target = $trigger.attr('data-target')
        || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7
  
      return $(document).find(target)
    }
  
  
    // COLLAPSE PLUGIN DEFINITION
    // ==========================
  
    function Plugin(option) {
      return this.each(function () {
        var $this   = $(this)
        var data    = $this.data('bs.collapse')
        var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)
  
        if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
        if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
        if (typeof option == 'string') data[option]()
      })
    }
  
    var old = $.fn.collapse
  
    $.fn.collapse             = Plugin
    $.fn.collapse.Constructor = Collapse
  
  
    // COLLAPSE NO CONFLICT
    // ====================
  
    $.fn.collapse.noConflict = function () {
      $.fn.collapse = old
      return this
    }
  
  
    // COLLAPSE DATA-API
    // =================
  
    $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
      var $this   = $(this)
  
      if (!$this.attr('data-target')) e.preventDefault()
  
      var $target = getTargetFromTrigger($this)
      var data    = $target.data('bs.collapse')
      var option  = data ? 'toggle' : $this.data()
  
      Plugin.call($target, option)
    })
  
  }(jQuery);
  /* ========================================================================
   * Bootstrap: dropdown.js v3.4.0
   * https://getbootstrap.com/docs/3.4/javascript/#dropdowns
   * ========================================================================
   * Copyright 2011-2018 Twitter, Inc.
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * ======================================================================== */
  
  
  
  +function ($) {
    'use strict';
  
    // DROPDOWN CLASS DEFINITION
    // =========================
  
    var backdrop = '.dropdown-backdrop'
    var toggle   = '[data-toggle="dropdown"]'
    var Dropdown = function (element) {
      $(element).on('click.bs.dropdown', this.toggle)
    }
  
    Dropdown.VERSION = '3.4.0'
  
    function getParent($this) {
      var selector = $this.attr('data-target')
  
      if (!selector) {
        selector = $this.attr('href')
        selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
      }
  
      var $parent = selector && $(document).find(selector)
  
      return $parent && $parent.length ? $parent : $this.parent()
    }
  
    function clearMenus(e) {
      if (e && e.which === 3) return
      $(backdrop).remove()
      $(toggle).each(function () {
        var $this         = $(this)
        var $parent       = getParent($this)
        var relatedTarget = { relatedTarget: this }
  
        if (!$parent.hasClass('open')) return
  
        if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return
  
        $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))
  
        if (e.isDefaultPrevented()) return
  
        $this.attr('aria-expanded', 'false')
        $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
      })
    }
  
    Dropdown.prototype.toggle = function (e) {
      var $this = $(this)
  
      if ($this.is('.disabled, :disabled')) return
  
      var $parent  = getParent($this)
      var isActive = $parent.hasClass('open')
  
      clearMenus()
  
      if (!isActive) {
        if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
          // if mobile we use a backdrop because click events don't delegate
          $(document.createElement('div'))
            .addClass('dropdown-backdrop')
            .insertAfter($(this))
            .on('click', clearMenus)
        }
  
        var relatedTarget = { relatedTarget: this }
        $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))
  
        if (e.isDefaultPrevented()) return
  
        $this
          .trigger('focus')
          .attr('aria-expanded', 'true')
  
        $parent
          .toggleClass('open')
          .trigger($.Event('shown.bs.dropdown', relatedTarget))
      }
  
      return false
    }
  
    Dropdown.prototype.keydown = function (e) {
      if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return
  
      var $this = $(this)
  
      e.preventDefault()
      e.stopPropagation()
  
      if ($this.is('.disabled, :disabled')) return
  
      var $parent  = getParent($this)
      var isActive = $parent.hasClass('open')
  
      if (!isActive && e.which != 27 || isActive && e.which == 27) {
        if (e.which == 27) $parent.find(toggle).trigger('focus')
        return $this.trigger('click')
      }
  
      var desc = ' li:not(.disabled):visible a'
      var $items = $parent.find('.dropdown-menu' + desc)
  
      if (!$items.length) return
  
      var index = $items.index(e.target)
  
      if (e.which == 38 && index > 0)                 index--         // up
      if (e.which == 40 && index < $items.length - 1) index++         // down
      if (!~index)                                    index = 0
  
      $items.eq(index).trigger('focus')
    }
  
  
    // DROPDOWN PLUGIN DEFINITION
    // ==========================
  
    function Plugin(option) {
      return this.each(function () {
        var $this = $(this)
        var data  = $this.data('bs.dropdown')
  
        if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
        if (typeof option == 'string') data[option].call($this)
      })
    }
  
    var old = $.fn.dropdown
  
    $.fn.dropdown             = Plugin
    $.fn.dropdown.Constructor = Dropdown
  
  
    // DROPDOWN NO CONFLICT
    // ====================
  
    $.fn.dropdown.noConflict = function () {
      $.fn.dropdown = old
      return this
    }
  
  
    // APPLY TO STANDARD DROPDOWN ELEMENTS
    // ===================================
  
    $(document)
      .on('click.bs.dropdown.data-api', clearMenus)
      .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
      .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
      .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
      .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)
  
  }(jQuery);
  /* ========================================================================
   * Bootstrap: alert.js v3.4.0
   * https://getbootstrap.com/docs/3.4/javascript/#alerts
   * ========================================================================
   * Copyright 2011-2018 Twitter, Inc.
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * ======================================================================== */
  
  
  
  +function ($) {
    'use strict';
  
    // ALERT CLASS DEFINITION
    // ======================
  
    var dismiss = '[data-dismiss="alert"]'
    var Alert   = function (el) {
      $(el).on('click', dismiss, this.close)
    }
  
    Alert.VERSION = '3.4.0'
  
    Alert.TRANSITION_DURATION = 150
  
    Alert.prototype.close = function (e) {
      var $this    = $(this)
      var selector = $this.attr('data-target')
  
      if (!selector) {
        selector = $this.attr('href')
        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
      }
  
      selector    = selector === '#' ? [] : selector
      var $parent = $(document).find(selector)
  
      if (e) e.preventDefault()
  
      if (!$parent.length) {
        $parent = $this.closest('.alert')
      }
  
      $parent.trigger(e = $.Event('close.bs.alert'))
  
      if (e.isDefaultPrevented()) return
  
      $parent.removeClass('in')
  
      function removeElement() {
        // detach from parent, fire event then clean up data
        $parent.detach().trigger('closed.bs.alert').remove()
      }
  
      $.support.transition && $parent.hasClass('fade') ?
        $parent
          .one('bsTransitionEnd', removeElement)
          .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
        removeElement()
    }
  
  
    // ALERT PLUGIN DEFINITION
    // =======================
  
    function Plugin(option) {
      return this.each(function () {
        var $this = $(this)
        var data  = $this.data('bs.alert')
  
        if (!data) $this.data('bs.alert', (data = new Alert(this)))
        if (typeof option == 'string') data[option].call($this)
      })
    }
  
    var old = $.fn.alert
  
    $.fn.alert             = Plugin
    $.fn.alert.Constructor = Alert
  
  
    // ALERT NO CONFLICT
    // =================
  
    $.fn.alert.noConflict = function () {
      $.fn.alert = old
      return this
    }
  
  
    // ALERT DATA-API
    // ==============
  
    $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)
  
  }(jQuery);
  /* ========================================================================
   * Bootstrap: modal.js v3.4.0
   * https://getbootstrap.com/docs/3.4/javascript/#modals
   * ========================================================================
   * Copyright 2011-2018 Twitter, Inc.
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * ======================================================================== */
  
  
  
  +function ($) {
    'use strict';
  
    // MODAL CLASS DEFINITION
    // ======================
  
    var Modal = function (element, options) {
      this.options = options
      this.$body = $(document.body)
      this.$element = $(element)
      this.$dialog = this.$element.find('.modal-dialog')
      this.$backdrop = null
      this.isShown = null
      this.originalBodyPad = null
      this.scrollbarWidth = 0
      this.ignoreBackdropClick = false
      this.fixedContent = '.navbar-fixed-top, .navbar-fixed-bottom'
  
      if (this.options.remote) {
        this.$element
          .find('.modal-content')
          .load(this.options.remote, $.proxy(function () {
            this.$element.trigger('loaded.bs.modal')
          }, this))
      }
    }
  
    Modal.VERSION = '3.4.0'
  
    Modal.TRANSITION_DURATION = 300
    Modal.BACKDROP_TRANSITION_DURATION = 150
  
    Modal.DEFAULTS = {
      backdrop: true,
      keyboard: true,
      show: true
    }
  
    Modal.prototype.toggle = function (_relatedTarget) {
      return this.isShown ? this.hide() : this.show(_relatedTarget)
    }
  
    Modal.prototype.show = function (_relatedTarget) {
      var that = this
      var e = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })
  
      this.$element.trigger(e)
  
      if (this.isShown || e.isDefaultPrevented()) return
  
      this.isShown = true
  
      this.checkScrollbar()
      this.setScrollbar()
      this.$body.addClass('modal-open')
  
      this.escape()
      this.resize()
  
      this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))
  
      this.$dialog.on('mousedown.dismiss.bs.modal', function () {
        that.$element.one('mouseup.dismiss.bs.modal', function (e) {
          if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
        })
      })
  
      this.backdrop(function () {
        var transition = $.support.transition && that.$element.hasClass('fade')
  
        if (!that.$element.parent().length) {
          that.$element.appendTo(that.$body) // don't move modals dom position
        }
  
        that.$element
          .show()
          .scrollTop(0)
  
        that.adjustDialog()
  
        if (transition) {
          that.$element[0].offsetWidth // force reflow
        }
  
        that.$element.addClass('in')
  
        that.enforceFocus()
  
        var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })
  
        transition ?
          that.$dialog // wait for modal to slide in
            .one('bsTransitionEnd', function () {
              that.$element.trigger('focus').trigger(e)
            })
            .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
          that.$element.trigger('focus').trigger(e)
      })
    }
  
    Modal.prototype.hide = function (e) {
      if (e) e.preventDefault()
  
      e = $.Event('hide.bs.modal')
  
      this.$element.trigger(e)
  
      if (!this.isShown || e.isDefaultPrevented()) return
  
      this.isShown = false
  
      this.escape()
      this.resize()
  
      $(document).off('focusin.bs.modal')
  
      this.$element
        .removeClass('in')
        .off('click.dismiss.bs.modal')
        .off('mouseup.dismiss.bs.modal')
  
      this.$dialog.off('mousedown.dismiss.bs.modal')
  
      $.support.transition && this.$element.hasClass('fade') ?
        this.$element
          .one('bsTransitionEnd', $.proxy(this.hideModal, this))
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        this.hideModal()
    }
  
    Modal.prototype.enforceFocus = function () {
      $(document)
        .off('focusin.bs.modal') // guard against infinite focus loop
        .on('focusin.bs.modal', $.proxy(function (e) {
          if (document !== e.target &&
            this.$element[0] !== e.target &&
            !this.$element.has(e.target).length) {
            this.$element.trigger('focus')
          }
        }, this))
    }
  
    Modal.prototype.escape = function () {
      if (this.isShown && this.options.keyboard) {
        this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
          e.which == 27 && this.hide()
        }, this))
      } else if (!this.isShown) {
        this.$element.off('keydown.dismiss.bs.modal')
      }
    }
  
    Modal.prototype.resize = function () {
      if (this.isShown) {
        $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
      } else {
        $(window).off('resize.bs.modal')
      }
    }
  
    Modal.prototype.hideModal = function () {
      var that = this
      this.$element.hide()
      this.backdrop(function () {
        that.$body.removeClass('modal-open')
        that.resetAdjustments()
        that.resetScrollbar()
        that.$element.trigger('hidden.bs.modal')
      })
    }
  
    Modal.prototype.removeBackdrop = function () {
      this.$backdrop && this.$backdrop.remove()
      this.$backdrop = null
    }
  
    Modal.prototype.backdrop = function (callback) {
      var that = this
      var animate = this.$element.hasClass('fade') ? 'fade' : ''
  
      if (this.isShown && this.options.backdrop) {
        var doAnimate = $.support.transition && animate
  
        this.$backdrop = $(document.createElement('div'))
          .addClass('modal-backdrop ' + animate)
          .appendTo(this.$body)
  
        this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
          if (this.ignoreBackdropClick) {
            this.ignoreBackdropClick = false
            return
          }
          if (e.target !== e.currentTarget) return
          this.options.backdrop == 'static'
            ? this.$element[0].focus()
            : this.hide()
        }, this))
  
        if (doAnimate) this.$backdrop[0].offsetWidth // force reflow
  
        this.$backdrop.addClass('in')
  
        if (!callback) return
  
        doAnimate ?
          this.$backdrop
            .one('bsTransitionEnd', callback)
            .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
          callback()
  
      } else if (!this.isShown && this.$backdrop) {
        this.$backdrop.removeClass('in')
  
        var callbackRemove = function () {
          that.removeBackdrop()
          callback && callback()
        }
        $.support.transition && this.$element.hasClass('fade') ?
          this.$backdrop
            .one('bsTransitionEnd', callbackRemove)
            .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
          callbackRemove()
  
      } else if (callback) {
        callback()
      }
    }
  
    // these following methods are used to handle overflowing modals
  
    Modal.prototype.handleUpdate = function () {
      this.adjustDialog()
    }
  
    Modal.prototype.adjustDialog = function () {
      var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight
  
      this.$element.css({
        paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
        paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
      })
    }
  
    Modal.prototype.resetAdjustments = function () {
      this.$element.css({
        paddingLeft: '',
        paddingRight: ''
      })
    }
  
    Modal.prototype.checkScrollbar = function () {
      var fullWindowWidth = window.innerWidth
      if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
        var documentElementRect = document.documentElement.getBoundingClientRect()
        fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
      }
      this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
      this.scrollbarWidth = this.measureScrollbar()
    }
  
    Modal.prototype.setScrollbar = function () {
      var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
      this.originalBodyPad = document.body.style.paddingRight || ''
      var scrollbarWidth = this.scrollbarWidth
      if (this.bodyIsOverflowing) {
        this.$body.css('padding-right', bodyPad + scrollbarWidth)
        $(this.fixedContent).each(function (index, element) {
          var actualPadding = element.style.paddingRight
          var calculatedPadding = $(element).css('padding-right')
          $(element)
            .data('padding-right', actualPadding)
            .css('padding-right', parseFloat(calculatedPadding) + scrollbarWidth + 'px')
        })
      }
    }
  
    Modal.prototype.resetScrollbar = function () {
      this.$body.css('padding-right', this.originalBodyPad)
      $(this.fixedContent).each(function (index, element) {
        var padding = $(element).data('padding-right')
        $(element).removeData('padding-right')
        element.style.paddingRight = padding ? padding : ''
      })
    }
  
    Modal.prototype.measureScrollbar = function () { // thx walsh
      var scrollDiv = document.createElement('div')
      scrollDiv.className = 'modal-scrollbar-measure'
      this.$body.append(scrollDiv)
      var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
      this.$body[0].removeChild(scrollDiv)
      return scrollbarWidth
    }
  
  
    // MODAL PLUGIN DEFINITION
    // =======================
  
    function Plugin(option, _relatedTarget) {
      return this.each(function () {
        var $this = $(this)
        var data = $this.data('bs.modal')
        var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)
  
        if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
        if (typeof option == 'string') data[option](_relatedTarget)
        else if (options.show) data.show(_relatedTarget)
      })
    }
  
    var old = $.fn.modal
  
    $.fn.modal = Plugin
    $.fn.modal.Constructor = Modal
  
  
    // MODAL NO CONFLICT
    // =================
  
    $.fn.modal.noConflict = function () {
      $.fn.modal = old
      return this
    }
  
  
    // MODAL DATA-API
    // ==============
  
    $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
      var $this = $(this)
      var href = $this.attr('href')
      var target = $this.attr('data-target') ||
        (href && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
  
      var $target = $(document).find(target)
      var option = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())
  
      if ($this.is('a')) e.preventDefault()
  
      $target.one('show.bs.modal', function (showEvent) {
        if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
        $target.one('hidden.bs.modal', function () {
          $this.is(':visible') && $this.trigger('focus')
        })
      })
      Plugin.call($target, option, this)
    })
  
  }(jQuery);
  /*!
   * typeahead.js 0.11.1
   * https://github.com/twitter/typeahead.js
   * Copyright 2013-2015 Twitter, Inc. and other contributors; Licensed MIT
   */
  
  
  (function(root, factory) {
      if (typeof define === "function" && define.amd) {
          define([ "jquery" ], function(a0) {
              return root["Bloodhound"] = factory(a0);
          });
      } else if (typeof exports === "object") {
          module.exports = factory(require("jquery"));
      } else {
          root["Bloodhound"] = factory(jQuery);
      }
  })(this, function($) {
      var _ = function() {
          "use strict";
          return {
              isMsie: function() {
                  return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;
              },
              isBlankString: function(str) {
                  return !str || /^\s*$/.test(str);
              },
              escapeRegExChars: function(str) {
                  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
              },
              isString: function(obj) {
                  return typeof obj === "string";
              },
              isNumber: function(obj) {
                  return typeof obj === "number";
              },
              isArray: $.isArray,
              isFunction: $.isFunction,
              isObject: $.isPlainObject,
              isUndefined: function(obj) {
                  return typeof obj === "undefined";
              },
              isElement: function(obj) {
                  return !!(obj && obj.nodeType === 1);
              },
              isJQuery: function(obj) {
                  return obj instanceof $;
              },
              toStr: function toStr(s) {
                  return _.isUndefined(s) || s === null ? "" : s + "";
              },
              bind: $.proxy,
              each: function(collection, cb) {
                  $.each(collection, reverseArgs);
                  function reverseArgs(index, value) {
                      return cb(value, index);
                  }
              },
              map: $.map,
              filter: $.grep,
              every: function(obj, test) {
                  var result = true;
                  if (!obj) {
                      return result;
                  }
                  $.each(obj, function(key, val) {
                      if (!(result = test.call(null, val, key, obj))) {
                          return false;
                      }
                  });
                  return !!result;
              },
              some: function(obj, test) {
                  var result = false;
                  if (!obj) {
                      return result;
                  }
                  $.each(obj, function(key, val) {
                      if (result = test.call(null, val, key, obj)) {
                          return false;
                      }
                  });
                  return !!result;
              },
              mixin: $.extend,
              identity: function(x) {
                  return x;
              },
              clone: function(obj) {
                  return $.extend(true, {}, obj);
              },
              getIdGenerator: function() {
                  var counter = 0;
                  return function() {
                      return counter++;
                  };
              },
              templatify: function templatify(obj) {
                  return $.isFunction(obj) ? obj : template;
                  function template() {
                      return String(obj);
                  }
              },
              defer: function(fn) {
                  setTimeout(fn, 0);
              },
              debounce: function(func, wait, immediate) {
                  var timeout, result;
                  return function() {
                      var context = this, args = arguments, later, callNow;
                      later = function() {
                          timeout = null;
                          if (!immediate) {
                              result = func.apply(context, args);
                          }
                      };
                      callNow = immediate && !timeout;
                      clearTimeout(timeout);
                      timeout = setTimeout(later, wait);
                      if (callNow) {
                          result = func.apply(context, args);
                      }
                      return result;
                  };
              },
              throttle: function(func, wait) {
                  var context, args, timeout, result, previous, later;
                  previous = 0;
                  later = function() {
                      previous = new Date();
                      timeout = null;
                      result = func.apply(context, args);
                  };
                  return function() {
                      var now = new Date(), remaining = wait - (now - previous);
                      context = this;
                      args = arguments;
                      if (remaining <= 0) {
                          clearTimeout(timeout);
                          timeout = null;
                          previous = now;
                          result = func.apply(context, args);
                      } else if (!timeout) {
                          timeout = setTimeout(later, remaining);
                      }
                      return result;
                  };
              },
              stringify: function(val) {
                  return _.isString(val) ? val : JSON.stringify(val);
              },
              noop: function() {}
          };
      }();
      var VERSION = "0.11.1";
      var tokenizers = function() {
          "use strict";
          return {
              nonword: nonword,
              whitespace: whitespace,
              obj: {
                  nonword: getObjTokenizer(nonword),
                  whitespace: getObjTokenizer(whitespace)
              }
          };
          function whitespace(str) {
              str = _.toStr(str);
              return str ? str.split(/\s+/) : [];
          }
          function nonword(str) {
              str = _.toStr(str);
              return str ? str.split(/\W+/) : [];
          }
          function getObjTokenizer(tokenizer) {
              return function setKey(keys) {
                  keys = _.isArray(keys) ? keys : [].slice.call(arguments, 0);
                  return function tokenize(o) {
                      var tokens = [];
                      _.each(keys, function(k) {
                          tokens = tokens.concat(tokenizer(_.toStr(o[k])));
                      });
                      return tokens;
                  };
              };
          }
      }();
      var LruCache = function() {
          "use strict";
          function LruCache(maxSize) {
              this.maxSize = _.isNumber(maxSize) ? maxSize : 100;
              this.reset();
              if (this.maxSize <= 0) {
                  this.set = this.get = $.noop;
              }
          }
          _.mixin(LruCache.prototype, {
              set: function set(key, val) {
                  var tailItem = this.list.tail, node;
                  if (this.size >= this.maxSize) {
                      this.list.remove(tailItem);
                      delete this.hash[tailItem.key];
                      this.size--;
                  }
                  if (node = this.hash[key]) {
                      node.val = val;
                      this.list.moveToFront(node);
                  } else {
                      node = new Node(key, val);
                      this.list.add(node);
                      this.hash[key] = node;
                      this.size++;
                  }
              },
              get: function get(key) {
                  var node = this.hash[key];
                  if (node) {
                      this.list.moveToFront(node);
                      return node.val;
                  }
              },
              reset: function reset() {
                  this.size = 0;
                  this.hash = {};
                  this.list = new List();
              }
          });
          function List() {
              this.head = this.tail = null;
          }
          _.mixin(List.prototype, {
              add: function add(node) {
                  if (this.head) {
                      node.next = this.head;
                      this.head.prev = node;
                  }
                  this.head = node;
                  this.tail = this.tail || node;
              },
              remove: function remove(node) {
                  node.prev ? node.prev.next = node.next : this.head = node.next;
                  node.next ? node.next.prev = node.prev : this.tail = node.prev;
              },
              moveToFront: function(node) {
                  this.remove(node);
                  this.add(node);
              }
          });
          function Node(key, val) {
              this.key = key;
              this.val = val;
              this.prev = this.next = null;
          }
          return LruCache;
      }();
      var PersistentStorage = function() {
          "use strict";
          var LOCAL_STORAGE;
          try {
              LOCAL_STORAGE = window.localStorage;
              LOCAL_STORAGE.setItem("~~~", "!");
              LOCAL_STORAGE.removeItem("~~~");
          } catch (err) {
              LOCAL_STORAGE = null;
          }
          function PersistentStorage(namespace, override) {
              this.prefix = [ "__", namespace, "__" ].join("");
              this.ttlKey = "__ttl__";
              this.keyMatcher = new RegExp("^" + _.escapeRegExChars(this.prefix));
              this.ls = override || LOCAL_STORAGE;
              !this.ls && this._noop();
          }
          _.mixin(PersistentStorage.prototype, {
              _prefix: function(key) {
                  return this.prefix + key;
              },
              _ttlKey: function(key) {
                  return this._prefix(key) + this.ttlKey;
              },
              _noop: function() {
                  this.get = this.set = this.remove = this.clear = this.isExpired = _.noop;
              },
              _safeSet: function(key, val) {
                  try {
                      this.ls.setItem(key, val);
                  } catch (err) {
                      if (err.name === "QuotaExceededError") {
                          this.clear();
                          this._noop();
                      }
                  }
              },
              get: function(key) {
                  if (this.isExpired(key)) {
                      this.remove(key);
                  }
                  return decode(this.ls.getItem(this._prefix(key)));
              },
              set: function(key, val, ttl) {
                  if (_.isNumber(ttl)) {
                      this._safeSet(this._ttlKey(key), encode(now() + ttl));
                  } else {
                      this.ls.removeItem(this._ttlKey(key));
                  }
                  return this._safeSet(this._prefix(key), encode(val));
              },
              remove: function(key) {
                  this.ls.removeItem(this._ttlKey(key));
                  this.ls.removeItem(this._prefix(key));
                  return this;
              },
              clear: function() {
                  var i, keys = gatherMatchingKeys(this.keyMatcher);
                  for (i = keys.length; i--; ) {
                      this.remove(keys[i]);
                  }
                  return this;
              },
              isExpired: function(key) {
                  var ttl = decode(this.ls.getItem(this._ttlKey(key)));
                  return _.isNumber(ttl) && now() > ttl ? true : false;
              }
          });
          return PersistentStorage;
          function now() {
              return new Date().getTime();
          }
          function encode(val) {
              return JSON.stringify(_.isUndefined(val) ? null : val);
          }
          function decode(val) {
              return $.parseJSON(val);
          }
          function gatherMatchingKeys(keyMatcher) {
              var i, key, keys = [], len = LOCAL_STORAGE.length;
              for (i = 0; i < len; i++) {
                  if ((key = LOCAL_STORAGE.key(i)).match(keyMatcher)) {
                      keys.push(key.replace(keyMatcher, ""));
                  }
              }
              return keys;
          }
      }();
      var Transport = function() {
          "use strict";
          var pendingRequestsCount = 0, pendingRequests = {}, maxPendingRequests = 6, sharedCache = new LruCache(10);
          function Transport(o) {
              o = o || {};
              this.cancelled = false;
              this.lastReq = null;
              this._send = o.transport;
              this._get = o.limiter ? o.limiter(this._get) : this._get;
              this._cache = o.cache === false ? new LruCache(0) : sharedCache;
          }
          Transport.setMaxPendingRequests = function setMaxPendingRequests(num) {
              maxPendingRequests = num;
          };
          Transport.resetCache = function resetCache() {
              sharedCache.reset();
          };
          _.mixin(Transport.prototype, {
              _fingerprint: function fingerprint(o) {
                  o = o || {};
                  return o.url + o.type + $.param(o.data || {});
              },
              _get: function(o, cb) {
                  var that = this, fingerprint, jqXhr;
                  fingerprint = this._fingerprint(o);
                  if (this.cancelled || fingerprint !== this.lastReq) {
                      return;
                  }
                  if (jqXhr = pendingRequests[fingerprint]) {
                      jqXhr.done(done).fail(fail);
                  } else if (pendingRequestsCount < maxPendingRequests) {
                      pendingRequestsCount++;
                      pendingRequests[fingerprint] = this._send(o).done(done).fail(fail).always(always);
                  } else {
                      this.onDeckRequestArgs = [].slice.call(arguments, 0);
                  }
                  function done(resp) {
                      cb(null, resp);
                      that._cache.set(fingerprint, resp);
                  }
                  function fail() {
                      cb(true);
                  }
                  function always() {
                      pendingRequestsCount--;
                      delete pendingRequests[fingerprint];
                      if (that.onDeckRequestArgs) {
                          that._get.apply(that, that.onDeckRequestArgs);
                          that.onDeckRequestArgs = null;
                      }
                  }
              },
              get: function(o, cb) {
                  var resp, fingerprint;
                  cb = cb || $.noop;
                  o = _.isString(o) ? {
                      url: o
                  } : o || {};
                  fingerprint = this._fingerprint(o);
                  this.cancelled = false;
                  this.lastReq = fingerprint;
                  if (resp = this._cache.get(fingerprint)) {
                      cb(null, resp);
                  } else {
                      this._get(o, cb);
                  }
              },
              cancel: function() {
                  this.cancelled = true;
              }
          });
          return Transport;
      }();
      var SearchIndex = window.SearchIndex = function() {
          "use strict";
          var CHILDREN = "c", IDS = "i";
          function SearchIndex(o) {
              o = o || {};
              if (!o.datumTokenizer || !o.queryTokenizer) {
                  $.error("datumTokenizer and queryTokenizer are both required");
              }
              this.identify = o.identify || _.stringify;
              this.datumTokenizer = o.datumTokenizer;
              this.queryTokenizer = o.queryTokenizer;
              this.matchAnyQueryToken = o.matchAnyQueryToken;
              this.reset();
          }
          _.mixin(SearchIndex.prototype, {
              bootstrap: function bootstrap(o) {
                  this.datums = o.datums;
                  this.trie = o.trie;
              },
              add: function(data) {
                  var that = this;
                  data = _.isArray(data) ? data : [ data ];
                  _.each(data, function(datum) {
                      var id, tokens;
                      that.datums[id = that.identify(datum)] = datum;
                      tokens = normalizeTokens(that.datumTokenizer(datum));
                      _.each(tokens, function(token) {
                          var node, chars, ch;
                          node = that.trie;
                          chars = token.split("");
                          while (ch = chars.shift()) {
                              node = node[CHILDREN][ch] || (node[CHILDREN][ch] = newNode());
                              node[IDS].push(id);
                          }
                      });
                  });
              },
              get: function get(ids) {
                  var that = this;
                  return _.map(ids, function(id) {
                      return that.datums[id];
                  });
              },
              search: function search(query) {
                  var that = this, tokens, matches;
                  tokens = normalizeTokens(this.queryTokenizer(query));
                  _.each(tokens, function(token) {
                      var node, chars, ch, ids;
                      if (matches && matches.length === 0 && !that.matchAnyQueryToken) {
                          return false;
                      }
                      node = that.trie;
                      chars = token.split("");
                      while (node && (ch = chars.shift())) {
                          node = node[CHILDREN][ch];
                      }
                      if (node && chars.length === 0) {
                          ids = node[IDS].slice(0);
                          matches = matches ? getIntersection(matches, ids) : ids;
                      } else {
                          if (!that.matchAnyQueryToken) {
                              matches = [];
                              return false;
                          }
                      }
                  });
                  return matches ? _.map(unique(matches), function(id) {
                      return that.datums[id];
                  }) : [];
              },
              all: function all() {
                  var values = [];
                  for (var key in this.datums) {
                      values.push(this.datums[key]);
                  }
                  return values;
              },
              reset: function reset() {
                  this.datums = {};
                  this.trie = newNode();
              },
              serialize: function serialize() {
                  return {
                      datums: this.datums,
                      trie: this.trie
                  };
              }
          });
          return SearchIndex;
          function normalizeTokens(tokens) {
              tokens = _.filter(tokens, function(token) {
                  return !!token;
              });
              tokens = _.map(tokens, function(token) {
                  return token.toLowerCase();
              });
              return tokens;
          }
          function newNode() {
              var node = {};
              node[IDS] = [];
              node[CHILDREN] = {};
              return node;
          }
          function unique(array) {
              var seen = {}, uniques = [];
              for (var i = 0, len = array.length; i < len; i++) {
                  if (!seen[array[i]]) {
                      seen[array[i]] = true;
                      uniques.push(array[i]);
                  }
              }
              return uniques;
          }
          function getIntersection(arrayA, arrayB) {
              var ai = 0, bi = 0, intersection = [];
              arrayA = arrayA.sort();
              arrayB = arrayB.sort();
              var lenArrayA = arrayA.length, lenArrayB = arrayB.length;
              while (ai < lenArrayA && bi < lenArrayB) {
                  if (arrayA[ai] < arrayB[bi]) {
                      ai++;
                  } else if (arrayA[ai] > arrayB[bi]) {
                      bi++;
                  } else {
                      intersection.push(arrayA[ai]);
                      ai++;
                      bi++;
                  }
              }
              return intersection;
          }
      }();
      var Prefetch = function() {
          "use strict";
          var keys;
          keys = {
              data: "data",
              protocol: "protocol",
              thumbprint: "thumbprint"
          };
          function Prefetch(o) {
              this.url = o.url;
              this.ttl = o.ttl;
              this.cache = o.cache;
              this.prepare = o.prepare;
              this.transform = o.transform;
              this.transport = o.transport;
              this.thumbprint = o.thumbprint;
              this.storage = new PersistentStorage(o.cacheKey);
          }
          _.mixin(Prefetch.prototype, {
              _settings: function settings() {
                  return {
                      url: this.url,
                      type: "GET",
                      dataType: "json"
                  };
              },
              store: function store(data) {
                  if (!this.cache) {
                      return;
                  }
                  this.storage.set(keys.data, data, this.ttl);
                  this.storage.set(keys.protocol, location.protocol, this.ttl);
                  this.storage.set(keys.thumbprint, this.thumbprint, this.ttl);
              },
              fromCache: function fromCache() {
                  var stored = {}, isExpired;
                  if (!this.cache) {
                      return null;
                  }
                  stored.data = this.storage.get(keys.data);
                  stored.protocol = this.storage.get(keys.protocol);
                  stored.thumbprint = this.storage.get(keys.thumbprint);
                  isExpired = stored.thumbprint !== this.thumbprint || stored.protocol !== location.protocol;
                  return stored.data && !isExpired ? stored.data : null;
              },
              fromNetwork: function(cb) {
                  var that = this, settings;
                  if (!cb) {
                      return;
                  }
                  settings = this.prepare(this._settings());
                  this.transport(settings).fail(onError).done(onResponse);
                  function onError() {
                      cb(true);
                  }
                  function onResponse(resp) {
                      cb(null, that.transform(resp));
                  }
              },
              clear: function clear() {
                  this.storage.clear();
                  return this;
              }
          });
          return Prefetch;
      }();
      var Remote = function() {
          "use strict";
          function Remote(o) {
              this.url = o.url;
              this.prepare = o.prepare;
              this.transform = o.transform;
              this.indexResponse = o.indexResponse;
              this.transport = new Transport({
                  cache: o.cache,
                  limiter: o.limiter,
                  transport: o.transport
              });
          }
          _.mixin(Remote.prototype, {
              _settings: function settings() {
                  return {
                      url: this.url,
                      type: "GET",
                      dataType: "json"
                  };
              },
              get: function get(query, cb) {
                  var that = this, settings;
                  if (!cb) {
                      return;
                  }
                  query = query || "";
                  settings = this.prepare(query, this._settings());
                  return this.transport.get(settings, onResponse);
                  function onResponse(err, resp) {
                      err ? cb([]) : cb(that.transform(resp));
                  }
              },
              cancelLastRequest: function cancelLastRequest() {
                  this.transport.cancel();
              }
          });
          return Remote;
      }();
      var oParser = function() {
          "use strict";
          return function parse(o) {
              var defaults, sorter;
              defaults = {
                  initialize: true,
                  identify: _.stringify,
                  datumTokenizer: null,
                  queryTokenizer: null,
                  matchAnyQueryToken: false,
                  sufficient: 5,
                  indexRemote: false,
                  sorter: null,
                  local: [],
                  prefetch: null,
                  remote: null
              };
              o = _.mixin(defaults, o || {});
              !o.datumTokenizer && $.error("datumTokenizer is required");
              !o.queryTokenizer && $.error("queryTokenizer is required");
              sorter = o.sorter;
              o.sorter = sorter ? function(x) {
                  return x.sort(sorter);
              } : _.identity;
              o.local = _.isFunction(o.local) ? o.local() : o.local;
              o.prefetch = parsePrefetch(o.prefetch);
              o.remote = parseRemote(o.remote);
              return o;
          };
          function parsePrefetch(o) {
              var defaults;
              if (!o) {
                  return null;
              }
              defaults = {
                  url: null,
                  ttl: 24 * 60 * 60 * 1e3,
                  cache: true,
                  cacheKey: null,
                  thumbprint: "",
                  prepare: _.identity,
                  transform: _.identity,
                  transport: null
              };
              o = _.isString(o) ? {
                  url: o
              } : o;
              o = _.mixin(defaults, o);
              !o.url && $.error("prefetch requires url to be set");
              o.transform = o.filter || o.transform;
              o.cacheKey = o.cacheKey || o.url;
              o.thumbprint = VERSION + o.thumbprint;
              o.transport = o.transport ? callbackToDeferred(o.transport) : $.ajax;
              return o;
          }
          function parseRemote(o) {
              var defaults;
              if (!o) {
                  return;
              }
              defaults = {
                  url: null,
                  cache: true,
                  prepare: null,
                  replace: null,
                  wildcard: null,
                  limiter: null,
                  rateLimitBy: "debounce",
                  rateLimitWait: 300,
                  transform: _.identity,
                  transport: null
              };
              o = _.isString(o) ? {
                  url: o
              } : o;
              o = _.mixin(defaults, o);
              !o.url && $.error("remote requires url to be set");
              o.transform = o.filter || o.transform;
              o.prepare = toRemotePrepare(o);
              o.limiter = toLimiter(o);
              o.transport = o.transport ? callbackToDeferred(o.transport) : $.ajax;
              delete o.replace;
              delete o.wildcard;
              delete o.rateLimitBy;
              delete o.rateLimitWait;
              return o;
          }
          function toRemotePrepare(o) {
              var prepare, replace, wildcard;
              prepare = o.prepare;
              replace = o.replace;
              wildcard = o.wildcard;
              if (prepare) {
                  return prepare;
              }
              if (replace) {
                  prepare = prepareByReplace;
              } else if (o.wildcard) {
                  prepare = prepareByWildcard;
              } else {
                  prepare = idenityPrepare;
              }
              return prepare;
              function prepareByReplace(query, settings) {
                  settings.url = replace(settings.url, query);
                  return settings;
              }
              function prepareByWildcard(query, settings) {
                  settings.url = settings.url.replace(wildcard, encodeURIComponent(query));
                  return settings;
              }
              function idenityPrepare(query, settings) {
                  return settings;
              }
          }
          function toLimiter(o) {
              var limiter, method, wait;
              limiter = o.limiter;
              method = o.rateLimitBy;
              wait = o.rateLimitWait;
              if (!limiter) {
                  limiter = /^throttle$/i.test(method) ? throttle(wait) : debounce(wait);
              }
              return limiter;
              function debounce(wait) {
                  return function debounce(fn) {
                      return _.debounce(fn, wait);
                  };
              }
              function throttle(wait) {
                  return function throttle(fn) {
                      return _.throttle(fn, wait);
                  };
              }
          }
          function callbackToDeferred(fn) {
              return function wrapper(o) {
                  var deferred = $.Deferred();
                  fn(o, onSuccess, onError);
                  return deferred;
                  function onSuccess(resp) {
                      _.defer(function() {
                          deferred.resolve(resp);
                      });
                  }
                  function onError(err) {
                      _.defer(function() {
                          deferred.reject(err);
                      });
                  }
              };
          }
      }();
      var Bloodhound = function() {
          "use strict";
          var old;
          old = window && window.Bloodhound;
          function Bloodhound(o) {
              o = oParser(o);
              this.sorter = o.sorter;
              this.identify = o.identify;
              this.sufficient = o.sufficient;
              this.indexRemote = o.indexRemote;
              this.local = o.local;
              this.remote = o.remote ? new Remote(o.remote) : null;
              this.prefetch = o.prefetch ? new Prefetch(o.prefetch) : null;
              this.index = new SearchIndex({
                  identify: this.identify,
                  datumTokenizer: o.datumTokenizer,
                  queryTokenizer: o.queryTokenizer
              });
              o.initialize !== false && this.initialize();
          }
          Bloodhound.noConflict = function noConflict() {
              window && (window.Bloodhound = old);
              return Bloodhound;
          };
          Bloodhound.tokenizers = tokenizers;
          _.mixin(Bloodhound.prototype, {
              __ttAdapter: function ttAdapter() {
                  var that = this;
                  return this.remote ? withAsync : withoutAsync;
                  function withAsync(query, sync, async) {
                      return that.search(query, sync, async);
                  }
                  function withoutAsync(query, sync) {
                      return that.search(query, sync);
                  }
              },
              _loadPrefetch: function loadPrefetch() {
                  var that = this, deferred, serialized;
                  deferred = $.Deferred();
                  if (!this.prefetch) {
                      deferred.resolve();
                  } else if (serialized = this.prefetch.fromCache()) {
                      this.index.bootstrap(serialized);
                      deferred.resolve();
                  } else {
                      this.prefetch.fromNetwork(done);
                  }
                  return deferred.promise();
                  function done(err, data) {
                      if (err) {
                          return deferred.reject();
                      }
                      that.add(data);
                      that.prefetch.store(that.index.serialize());
                      deferred.resolve();
                  }
              },
              _initialize: function initialize() {
                  var that = this, deferred;
                  this.clear();
                  (this.initPromise = this._loadPrefetch()).done(addLocalToIndex);
                  return this.initPromise;
                  function addLocalToIndex() {
                      that.add(that.local);
                  }
              },
              initialize: function initialize(force) {
                  return !this.initPromise || force ? this._initialize() : this.initPromise;
              },
              add: function add(data) {
                  this.index.add(data);
                  return this;
              },
              get: function get(ids) {
                  ids = _.isArray(ids) ? ids : [].slice.call(arguments);
                  return this.index.get(ids);
              },
              search: function search(query, sync, async) {
                  var that = this, local;
                  sync = sync || _.noop;
                  async = async || _.noop;
                  local = this.sorter(this.index.search(query));
                  sync(this.remote ? local.slice() : local);
                  if (this.remote && local.length < this.sufficient) {
                      this.remote.get(query, processRemote);
                  } else if (this.remote) {
                      this.remote.cancelLastRequest();
                  }
                  return this;
                  function processRemote(remote) {
                      var nonDuplicates = [];
                      _.each(remote, function(r) {
                          !_.some(local, function(l) {
                              return that.identify(r) === that.identify(l);
                          }) && nonDuplicates.push(r);
                      });
                      that.indexRemote && that.add(nonDuplicates);
                      async(nonDuplicates);
                  }
              },
              all: function all() {
                  return this.index.all();
              },
              clear: function clear() {
                  this.index.reset();
                  return this;
              },
              clearPrefetchCache: function clearPrefetchCache() {
                  this.prefetch && this.prefetch.clear();
                  return this;
              },
              clearRemoteCache: function clearRemoteCache() {
                  Transport.resetCache();
                  return this;
              },
              ttAdapter: function ttAdapter() {
                  return this.__ttAdapter();
              }
          });
          return Bloodhound;
      }();
      return Bloodhound;
  });
  
  (function(root, factory) {
      if (typeof define === "function" && define.amd) {
          define([ "jquery" ], function(a0) {
              return factory(a0);
          });
      } else if (typeof exports === "object") {
          module.exports = factory(require("jquery"));
      } else {
          factory(jQuery);
      }
  })(this, function($) {
      var _ = function() {
          "use strict";
          return {
              isMsie: function() {
                  return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;
              },
              isBlankString: function(str) {
                  return !str || /^\s*$/.test(str);
              },
              escapeRegExChars: function(str) {
                  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
              },
              isString: function(obj) {
                  return typeof obj === "string";
              },
              isNumber: function(obj) {
                  return typeof obj === "number";
              },
              isArray: $.isArray,
              isFunction: $.isFunction,
              isObject: $.isPlainObject,
              isUndefined: function(obj) {
                  return typeof obj === "undefined";
              },
              isElement: function(obj) {
                  return !!(obj && obj.nodeType === 1);
              },
              isJQuery: function(obj) {
                  return obj instanceof $;
              },
              toStr: function toStr(s) {
                  return _.isUndefined(s) || s === null ? "" : s + "";
              },
              bind: $.proxy,
              each: function(collection, cb) {
                  $.each(collection, reverseArgs);
                  function reverseArgs(index, value) {
                      return cb(value, index);
                  }
              },
              map: $.map,
              filter: $.grep,
              every: function(obj, test) {
                  var result = true;
                  if (!obj) {
                      return result;
                  }
                  $.each(obj, function(key, val) {
                      if (!(result = test.call(null, val, key, obj))) {
                          return false;
                      }
                  });
                  return !!result;
              },
              some: function(obj, test) {
                  var result = false;
                  if (!obj) {
                      return result;
                  }
                  $.each(obj, function(key, val) {
                      if (result = test.call(null, val, key, obj)) {
                          return false;
                      }
                  });
                  return !!result;
              },
              mixin: $.extend,
              identity: function(x) {
                  return x;
              },
              clone: function(obj) {
                  return $.extend(true, {}, obj);
              },
              getIdGenerator: function() {
                  var counter = 0;
                  return function() {
                      return counter++;
                  };
              },
              templatify: function templatify(obj) {
                  return $.isFunction(obj) ? obj : template;
                  function template() {
                      return String(obj);
                  }
              },
              defer: function(fn) {
                  setTimeout(fn, 0);
              },
              debounce: function(func, wait, immediate) {
                  var timeout, result;
                  return function() {
                      var context = this, args = arguments, later, callNow;
                      later = function() {
                          timeout = null;
                          if (!immediate) {
                              result = func.apply(context, args);
                          }
                      };
                      callNow = immediate && !timeout;
                      clearTimeout(timeout);
                      timeout = setTimeout(later, wait);
                      if (callNow) {
                          result = func.apply(context, args);
                      }
                      return result;
                  };
              },
              throttle: function(func, wait) {
                  var context, args, timeout, result, previous, later;
                  previous = 0;
                  later = function() {
                      previous = new Date();
                      timeout = null;
                      result = func.apply(context, args);
                  };
                  return function() {
                      var now = new Date(), remaining = wait - (now - previous);
                      context = this;
                      args = arguments;
                      if (remaining <= 0) {
                          clearTimeout(timeout);
                          timeout = null;
                          previous = now;
                          result = func.apply(context, args);
                      } else if (!timeout) {
                          timeout = setTimeout(later, remaining);
                      }
                      return result;
                  };
              },
              stringify: function(val) {
                  return _.isString(val) ? val : JSON.stringify(val);
              },
              noop: function() {}
          };
      }();
      var WWW = function() {
          "use strict";
          var defaultClassNames = {
              wrapper: "twitter-typeahead",
              input: "tt-input",
              hint: "tt-hint",
              menu: "tt-menu",
              dataset: "tt-dataset",
              suggestion: "tt-suggestion",
              selectable: "tt-selectable",
              empty: "tt-empty",
              open: "tt-open",
              cursor: "tt-cursor",
              highlight: "tt-highlight"
          };
          return build;
          function build(o) {
              var www, classes;
              classes = _.mixin({}, defaultClassNames, o);
              www = {
                  css: buildCss(),
                  classes: classes,
                  html: buildHtml(classes),
                  selectors: buildSelectors(classes)
              };
              return {
                  css: www.css,
                  html: www.html,
                  classes: www.classes,
                  selectors: www.selectors,
                  mixin: function(o) {
                      _.mixin(o, www);
                  }
              };
          }
          function buildHtml(c) {
              return {
                  wrapper: '<span class="' + c.wrapper + '"></span>',
                  menu: '<div class="' + c.menu + '"></div>'
              };
          }
          function buildSelectors(classes) {
              var selectors = {};
              _.each(classes, function(v, k) {
                  selectors[k] = "." + v;
              });
              return selectors;
          }
          function buildCss() {
              var css = {
                  wrapper: {
                      position: "relative",
                      display: "inline-block"
                  },
                  hint: {
                      position: "absolute",
                      top: "0",
                      left: "0",
                      borderColor: "transparent",
                      boxShadow: "none",
                      opacity: "1"
                  },
                  input: {
                      position: "relative",
                      verticalAlign: "top",
                      backgroundColor: "transparent"
                  },
                  inputWithNoHint: {
                      position: "relative",
                      verticalAlign: "top"
                  },
                  menu: {
                      position: "absolute",
                      top: "100%",
                      left: "0",
                      zIndex: "100",
                      display: "none"
                  },
                  ltr: {
                      left: "0",
                      right: "auto"
                  },
                  rtl: {
                      left: "auto",
                      right: " 0"
                  }
              };
              if (_.isMsie()) {
                  _.mixin(css.input, {
                      backgroundImage: "url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"
                  });
              }
              return css;
          }
      }();
      var EventBus = function() {
          "use strict";
          var namespace, deprecationMap;
          namespace = "typeahead:";
          deprecationMap = {
              render: "rendered",
              cursorchange: "cursorchanged",
              select: "selected",
              autocomplete: "autocompleted"
          };
          function EventBus(o) {
              if (!o || !o.el) {
                  $.error("EventBus initialized without el");
              }
              this.$el = $(o.el);
          }
          _.mixin(EventBus.prototype, {
              _trigger: function(type, args) {
                  var $e;
                  $e = $.Event(namespace + type);
                  (args = args || []).unshift($e);
                  this.$el.trigger.apply(this.$el, args);
                  return $e;
              },
              before: function(type) {
                  var args, $e;
                  args = [].slice.call(arguments, 1);
                  $e = this._trigger("before" + type, args);
                  return $e.isDefaultPrevented();
              },
              trigger: function(type) {
                  var deprecatedType;
                  this._trigger(type, [].slice.call(arguments, 1));
                  if (deprecatedType = deprecationMap[type]) {
                      this._trigger(deprecatedType, [].slice.call(arguments, 1));
                  }
              }
          });
          return EventBus;
      }();
      var EventEmitter = function() {
          "use strict";
          var splitter = /\s+/, nextTick = getNextTick();
          return {
              onSync: onSync,
              onAsync: onAsync,
              off: off,
              trigger: trigger
          };
          function on(method, types, cb, context) {
              var type;
              if (!cb) {
                  return this;
              }
              types = types.split(splitter);
              cb = context ? bindContext(cb, context) : cb;
              this._callbacks = this._callbacks || {};
              while (type = types.shift()) {
                  this._callbacks[type] = this._callbacks[type] || {
                      sync: [],
                      async: []
                  };
                  this._callbacks[type][method].push(cb);
              }
              return this;
          }
          function onAsync(types, cb, context) {
              return on.call(this, "async", types, cb, context);
          }
          function onSync(types, cb, context) {
              return on.call(this, "sync", types, cb, context);
          }
          function off(types) {
              var type;
              if (!this._callbacks) {
                  return this;
              }
              types = types.split(splitter);
              while (type = types.shift()) {
                  delete this._callbacks[type];
              }
              return this;
          }
          function trigger(types) {
              var type, callbacks, args, syncFlush, asyncFlush;
              if (!this._callbacks) {
                  return this;
              }
              types = types.split(splitter);
              args = [].slice.call(arguments, 1);
              while ((type = types.shift()) && (callbacks = this._callbacks[type])) {
                  syncFlush = getFlush(callbacks.sync, this, [ type ].concat(args));
                  asyncFlush = getFlush(callbacks.async, this, [ type ].concat(args));
                  syncFlush() && nextTick(asyncFlush);
              }
              return this;
          }
          function getFlush(callbacks, context, args) {
              return flush;
              function flush() {
                  var cancelled;
                  for (var i = 0, len = callbacks.length; !cancelled && i < len; i += 1) {
                      cancelled = callbacks[i].apply(context, args) === false;
                  }
                  return !cancelled;
              }
          }
          function getNextTick() {
              var nextTickFn;
              if (window.setImmediate) {
                  nextTickFn = function nextTickSetImmediate(fn) {
                      setImmediate(function() {
                          fn();
                      });
                  };
              } else {
                  nextTickFn = function nextTickSetTimeout(fn) {
                      setTimeout(function() {
                          fn();
                      }, 0);
                  };
              }
              return nextTickFn;
          }
          function bindContext(fn, context) {
              return fn.bind ? fn.bind(context) : function() {
                  fn.apply(context, [].slice.call(arguments, 0));
              };
          }
      }();
      var highlight = function(doc) {
          "use strict";
          var defaults = {
              node: null,
              pattern: null,
              tagName: "strong",
              className: null,
              wordsOnly: false,
              caseSensitive: false
          };
          return function hightlight(o) {
              var regex;
              o = _.mixin({}, defaults, o);
              if (!o.node || !o.pattern) {
                  return;
              }
              o.pattern = _.isArray(o.pattern) ? o.pattern : [ o.pattern ];
              regex = getRegex(o.pattern, o.caseSensitive, o.wordsOnly);
              traverse(o.node, hightlightTextNode);
              function hightlightTextNode(textNode) {
                  var match, patternNode, wrapperNode;
                  if (match = regex.exec(textNode.data)) {
                      wrapperNode = doc.createElement(o.tagName);
                      o.className && (wrapperNode.className = o.className);
                      patternNode = textNode.splitText(match.index);
                      patternNode.splitText(match[0].length);
                      wrapperNode.appendChild(patternNode.cloneNode(true));
                      textNode.parentNode.replaceChild(wrapperNode, patternNode);
                  }
                  return !!match;
              }
              function traverse(el, hightlightTextNode) {
                  var childNode, TEXT_NODE_TYPE = 3;
                  for (var i = 0; i < el.childNodes.length; i++) {
                      childNode = el.childNodes[i];
                      if (childNode.nodeType === TEXT_NODE_TYPE) {
                          i += hightlightTextNode(childNode) ? 1 : 0;
                      } else {
                          traverse(childNode, hightlightTextNode);
                      }
                  }
              }
          };
          function getRegex(patterns, caseSensitive, wordsOnly) {
              var escapedPatterns = [], regexStr;
              for (var i = 0, len = patterns.length; i < len; i++) {
                  escapedPatterns.push(_.escapeRegExChars(patterns[i]));
              }
              regexStr = wordsOnly ? "\\b(" + escapedPatterns.join("|") + ")\\b" : "(" + escapedPatterns.join("|") + ")";
              return caseSensitive ? new RegExp(regexStr) : new RegExp(regexStr, "i");
          }
      }(window.document);
      var Input = function() {
          "use strict";
          var specialKeyCodeMap;
          specialKeyCodeMap = {
              9: "tab",
              27: "esc",
              37: "left",
              39: "right",
              13: "enter",
              38: "up",
              40: "down"
          };
          function Input(o, www) {
              o = o || {};
              if (!o.input) {
                  $.error("input is missing");
              }
              www.mixin(this);
              this.$hint = $(o.hint);
              this.$input = $(o.input);
              this.query = this.$input.val();
              this.queryWhenFocused = this.hasFocus() ? this.query : null;
              this.$overflowHelper = buildOverflowHelper(this.$input);
              this._checkLanguageDirection();
              if (this.$hint.length === 0) {
                  this.setHint = this.getHint = this.clearHint = this.clearHintIfInvalid = _.noop;
              }
          }
          Input.normalizeQuery = function(str) {
              return _.toStr(str).replace(/^\s*/g, "").replace(/\s{2,}/g, " ");
          };
          _.mixin(Input.prototype, EventEmitter, {
              _onBlur: function onBlur() {
                  this.resetInputValue();
                  this.trigger("blurred");
              },
              _onFocus: function onFocus() {
                  this.queryWhenFocused = this.query;
                  this.trigger("focused");
              },
              _onKeydown: function onKeydown($e) {
                  var keyName = specialKeyCodeMap[$e.which || $e.keyCode];
                  this._managePreventDefault(keyName, $e);
                  if (keyName && this._shouldTrigger(keyName, $e)) {
                      this.trigger(keyName + "Keyed", $e);
                  }
              },
              _onInput: function onInput() {
                  this._setQuery(this.getInputValue());
                  this.clearHintIfInvalid();
                  this._checkLanguageDirection();
              },
              _managePreventDefault: function managePreventDefault(keyName, $e) {
                  var preventDefault;
                  switch (keyName) {
                    case "up":
                    case "down":
                      preventDefault = !withModifier($e);
                      break;
  
                    default:
                      preventDefault = false;
                  }
                  preventDefault && $e.preventDefault();
              },
              _shouldTrigger: function shouldTrigger(keyName, $e) {
                  var trigger;
                  switch (keyName) {
                    case "tab":
                      trigger = !withModifier($e);
                      break;
  
                    default:
                      trigger = true;
                  }
                  return trigger;
              },
              _checkLanguageDirection: function checkLanguageDirection() {
                  var dir = (this.$input.css("direction") || "ltr").toLowerCase();
                  if (this.dir !== dir) {
                      this.dir = dir;
                      this.$hint.attr("dir", dir);
                      this.trigger("langDirChanged", dir);
                  }
              },
              _setQuery: function setQuery(val, silent) {
                  var areEquivalent, hasDifferentWhitespace;
                  areEquivalent = areQueriesEquivalent(val, this.query);
                  hasDifferentWhitespace = areEquivalent ? this.query.length !== val.length : false;
                  this.query = val;
                  if (!silent && !areEquivalent) {
                      this.trigger("queryChanged", this.query);
                  } else if (!silent && hasDifferentWhitespace) {
                      this.trigger("whitespaceChanged", this.query);
                  }
              },
              bind: function() {
                  var that = this, onBlur, onFocus, onKeydown, onInput;
                  onBlur = _.bind(this._onBlur, this);
                  onFocus = _.bind(this._onFocus, this);
                  onKeydown = _.bind(this._onKeydown, this);
                  onInput = _.bind(this._onInput, this);
                  this.$input.on("blur.tt", onBlur).on("focus.tt", onFocus).on("keydown.tt", onKeydown);
                  if (!_.isMsie() || _.isMsie() > 9) {
                      this.$input.on("input.tt", onInput);
                  } else {
                      this.$input.on("keydown.tt keypress.tt cut.tt paste.tt", function($e) {
                          if (specialKeyCodeMap[$e.which || $e.keyCode]) {
                              return;
                          }
                          _.defer(_.bind(that._onInput, that, $e));
                      });
                  }
                  return this;
              },
              focus: function focus() {
                  this.$input.focus();
              },
              blur: function blur() {
                  this.$input.blur();
              },
              getLangDir: function getLangDir() {
                  return this.dir;
              },
              getQuery: function getQuery() {
                  return this.query || "";
              },
              setQuery: function setQuery(val, silent) {
                  this.setInputValue(val);
                  this._setQuery(val, silent);
              },
              hasQueryChangedSinceLastFocus: function hasQueryChangedSinceLastFocus() {
                  return this.query !== this.queryWhenFocused;
              },
              getInputValue: function getInputValue() {
                  return this.$input.val();
              },
              setInputValue: function setInputValue(value) {
                  this.$input.val(value);
                  this.clearHintIfInvalid();
                  this._checkLanguageDirection();
              },
              resetInputValue: function resetInputValue() {
                  this.setInputValue(this.query);
              },
              getHint: function getHint() {
                  return this.$hint.val();
              },
              setHint: function setHint(value) {
                  this.$hint.val(value);
              },
              clearHint: function clearHint() {
                  this.setHint("");
              },
              clearHintIfInvalid: function clearHintIfInvalid() {
                  var val, hint, valIsPrefixOfHint, isValid;
                  val = this.getInputValue();
                  hint = this.getHint();
                  valIsPrefixOfHint = val !== hint && hint.indexOf(val) === 0;
                  isValid = val !== "" && valIsPrefixOfHint && !this.hasOverflow();
                  !isValid && this.clearHint();
              },
              hasFocus: function hasFocus() {
                  return this.$input.is(":focus");
              },
              hasOverflow: function hasOverflow() {
                  var constraint = this.$input.width() - 2;
                  this.$overflowHelper.text(this.getInputValue());
                  return this.$overflowHelper.width() >= constraint;
              },
              isCursorAtEnd: function() {
                  var valueLength, selectionStart, range;
                  valueLength = this.$input.val().length;
                  selectionStart = this.$input[0].selectionStart;
                  if (_.isNumber(selectionStart)) {
                      return selectionStart === valueLength;
                  } else if (document.selection) {
                      range = document.selection.createRange();
                      range.moveStart("character", -valueLength);
                      return valueLength === range.text.length;
                  }
                  return true;
              },
              destroy: function destroy() {
                  this.$hint.off(".tt");
                  this.$input.off(".tt");
                  this.$overflowHelper.remove();
                  this.$hint = this.$input = this.$overflowHelper = $("<div>");
              }
          });
          return Input;
          function buildOverflowHelper($input) {
              return $('<pre aria-hidden="true"></pre>').css({
                  position: "absolute",
                  visibility: "hidden",
                  whiteSpace: "pre",
                  fontFamily: $input.css("font-family"),
                  fontSize: $input.css("font-size"),
                  fontStyle: $input.css("font-style"),
                  fontVariant: $input.css("font-variant"),
                  fontWeight: $input.css("font-weight"),
                  wordSpacing: $input.css("word-spacing"),
                  letterSpacing: $input.css("letter-spacing"),
                  textIndent: $input.css("text-indent"),
                  textRendering: $input.css("text-rendering"),
                  textTransform: $input.css("text-transform")
              }).insertAfter($input);
          }
          function areQueriesEquivalent(a, b) {
              return Input.normalizeQuery(a) === Input.normalizeQuery(b);
          }
          function withModifier($e) {
              return $e.altKey || $e.ctrlKey || $e.metaKey || $e.shiftKey;
          }
      }();
      var Dataset = function() {
          "use strict";
          var keys, nameGenerator;
          keys = {
              val: "tt-selectable-display",
              obj: "tt-selectable-object"
          };
          nameGenerator = _.getIdGenerator();
          function Dataset(o, www) {
              o = o || {};
              o.templates = o.templates || {};
              o.templates.notFound = o.templates.notFound || o.templates.empty;
              if (!o.source) {
                  $.error("missing source");
              }
              if (!o.node) {
                  $.error("missing node");
              }
              if (o.name && !isValidName(o.name)) {
                  $.error("invalid dataset name: " + o.name);
              }
              www.mixin(this);
              this.highlight = !!o.highlight;
              this.name = o.name || nameGenerator();
              this.limit = o.limit || 5;
              this.displayFn = getDisplayFn(o.display || o.displayKey);
              this.templates = getTemplates(o.templates, this.displayFn);
              this.source = o.source.__ttAdapter ? o.source.__ttAdapter() : o.source;
              this.async = _.isUndefined(o.async) ? this.source.length > 2 : !!o.async;
              this._resetLastSuggestion();
              this.$el = $(o.node).addClass(this.classes.dataset).addClass(this.classes.dataset + "-" + this.name);
          }
          Dataset.extractData = function extractData(el) {
              var $el = $(el);
              if ($el.data(keys.obj)) {
                  return {
                      val: $el.data(keys.val) || "",
                      obj: $el.data(keys.obj) || null
                  };
              }
              return null;
          };
          _.mixin(Dataset.prototype, EventEmitter, {
              _overwrite: function overwrite(query, suggestions) {
                  suggestions = suggestions || [];
                  if (suggestions.length) {
                      this._renderSuggestions(query, suggestions);
                  } else if (this.async && this.templates.pending) {
                      this._renderPending(query);
                  } else if (!this.async && this.templates.notFound) {
                      this._renderNotFound(query);
                  } else {
                      this._empty();
                  }
                  this.trigger("rendered", this.name, suggestions, false);
              },
              _append: function append(query, suggestions) {
                  suggestions = suggestions || [];
                  if (suggestions.length && this.$lastSuggestion.length) {
                      this._appendSuggestions(query, suggestions);
                  } else if (suggestions.length) {
                      this._renderSuggestions(query, suggestions);
                  } else if (!this.$lastSuggestion.length && this.templates.notFound) {
                      this._renderNotFound(query);
                  }
                  this.trigger("rendered", this.name, suggestions, true);
              },
              _renderSuggestions: function renderSuggestions(query, suggestions) {
                  var $fragment;
                  $fragment = this._getSuggestionsFragment(query, suggestions);
                  this.$lastSuggestion = $fragment.children().last();
                  this.$el.html($fragment).prepend(this._getHeader(query, suggestions)).append(this._getFooter(query, suggestions));
              },
              _appendSuggestions: function appendSuggestions(query, suggestions) {
                  var $fragment, $lastSuggestion;
                  $fragment = this._getSuggestionsFragment(query, suggestions);
                  $lastSuggestion = $fragment.children().last();
                  this.$lastSuggestion.after($fragment);
                  this.$lastSuggestion = $lastSuggestion;
              },
              _renderPending: function renderPending(query) {
                  var template = this.templates.pending;
                  this._resetLastSuggestion();
                  template && this.$el.html(template({
                      query: query,
                      dataset: this.name
                  }));
              },
              _renderNotFound: function renderNotFound(query) {
                  var template = this.templates.notFound;
                  this._resetLastSuggestion();
                  template && this.$el.html(template({
                      query: query,
                      dataset: this.name
                  }));
              },
              _empty: function empty() {
                  this.$el.empty();
                  this._resetLastSuggestion();
              },
              _getSuggestionsFragment: function getSuggestionsFragment(query, suggestions) {
                  var that = this, fragment;
                  fragment = document.createDocumentFragment();
                  _.each(suggestions, function getSuggestionNode(suggestion) {
                      var $el, context;
                      context = that._injectQuery(query, suggestion);
                      $el = $(that.templates.suggestion(context)).data(keys.obj, suggestion).data(keys.val, that.displayFn(suggestion)).addClass(that.classes.suggestion + " " + that.classes.selectable);
                      fragment.appendChild($el[0]);
                  });
                  this.highlight && highlight({
                      className: this.classes.highlight,
                      node: fragment,
                      pattern: query
                  });
                  return $(fragment);
              },
              _getFooter: function getFooter(query, suggestions) {
                  return this.templates.footer ? this.templates.footer({
                      query: query,
                      suggestions: suggestions,
                      dataset: this.name
                  }) : null;
              },
              _getHeader: function getHeader(query, suggestions) {
                  return this.templates.header ? this.templates.header({
                      query: query,
                      suggestions: suggestions,
                      dataset: this.name
                  }) : null;
              },
              _resetLastSuggestion: function resetLastSuggestion() {
                  this.$lastSuggestion = $();
              },
              _injectQuery: function injectQuery(query, obj) {
                  return _.isObject(obj) ? _.mixin({
                      _query: query
                  }, obj) : obj;
              },
              update: function update(query) {
                  var that = this, canceled = false, syncCalled = false, rendered = 0;
                  this.cancel();
                  this.cancel = function cancel() {
                      canceled = true;
                      that.cancel = $.noop;
                      that.async && that.trigger("asyncCanceled", query);
                  };
                  this.source(query, sync, async);
                  !syncCalled && sync([]);
                  function sync(suggestions) {
                      if (syncCalled) {
                          return;
                      }
                      syncCalled = true;
                      suggestions = (suggestions || []).slice(0, that.limit);
                      rendered = suggestions.length;
                      that._overwrite(query, suggestions);
                      if (rendered < that.limit && that.async) {
                          that.trigger("asyncRequested", query);
                      }
                  }
                  function async(suggestions) {
                      suggestions = suggestions || [];
                      if (!canceled && rendered < that.limit) {
                          that.cancel = $.noop;
                          that._append(query, suggestions.slice(0, that.limit - rendered));
                          rendered += suggestions.length;
                          that.async && that.trigger("asyncReceived", query);
                      }
                  }
              },
              cancel: $.noop,
              clear: function clear() {
                  this._empty();
                  this.cancel();
                  this.trigger("cleared");
              },
              isEmpty: function isEmpty() {
                  return this.$el.is(":empty");
              },
              destroy: function destroy() {
                  this.$el = $("<div>");
              }
          });
          return Dataset;
          function getDisplayFn(display) {
              display = display || _.stringify;
              return _.isFunction(display) ? display : displayFn;
              function displayFn(obj) {
                  return obj[display];
              }
          }
          function getTemplates(templates, displayFn) {
              return {
                  notFound: templates.notFound && _.templatify(templates.notFound),
                  pending: templates.pending && _.templatify(templates.pending),
                  header: templates.header && _.templatify(templates.header),
                  footer: templates.footer && _.templatify(templates.footer),
                  suggestion: templates.suggestion || suggestionTemplate
              };
              function suggestionTemplate(context) {
                  return $("<div>").text(displayFn(context));
              }
          }
          function isValidName(str) {
              return /^[_a-zA-Z0-9-]+$/.test(str);
          }
      }();
      var Menu = function() {
          "use strict";
          function Menu(o, www) {
              var that = this;
              o = o || {};
              if (!o.node) {
                  $.error("node is required");
              }
              www.mixin(this);
              this.$node = $(o.node);
              this.query = null;
              this.datasets = _.map(o.datasets, initializeDataset);
              function initializeDataset(oDataset) {
                  var node = that.$node.find(oDataset.node).first();
                  oDataset.node = node.length ? node : $("<div>").appendTo(that.$node);
                  return new Dataset(oDataset, www);
              }
          }
          _.mixin(Menu.prototype, EventEmitter, {
              _onSelectableClick: function onSelectableClick($e) {
                  this.trigger("selectableClicked", $($e.currentTarget));
              },
              _onRendered: function onRendered(type, dataset, suggestions, async) {
                  this.$node.toggleClass(this.classes.empty, this._allDatasetsEmpty());
                  this.trigger("datasetRendered", dataset, suggestions, async);
              },
              _onCleared: function onCleared() {
                  this.$node.toggleClass(this.classes.empty, this._allDatasetsEmpty());
                  this.trigger("datasetCleared");
              },
              _propagate: function propagate() {
                  this.trigger.apply(this, arguments);
              },
              _allDatasetsEmpty: function allDatasetsEmpty() {
                  return _.every(this.datasets, isDatasetEmpty);
                  function isDatasetEmpty(dataset) {
                      return dataset.isEmpty();
                  }
              },
              _getSelectables: function getSelectables() {
                  return this.$node.find(this.selectors.selectable);
              },
              _removeCursor: function _removeCursor() {
                  var $selectable = this.getActiveSelectable();
                  $selectable && $selectable.removeClass(this.classes.cursor);
              },
              _ensureVisible: function ensureVisible($el) {
                  var elTop, elBottom, nodeScrollTop, nodeHeight;
                  elTop = $el.position().top;
                  elBottom = elTop + $el.outerHeight(true);
                  nodeScrollTop = this.$node.scrollTop();
                  nodeHeight = this.$node.height() + parseInt(this.$node.css("paddingTop"), 10) + parseInt(this.$node.css("paddingBottom"), 10);
                  if (elTop < 0) {
                      this.$node.scrollTop(nodeScrollTop + elTop);
                  } else if (nodeHeight < elBottom) {
                      this.$node.scrollTop(nodeScrollTop + (elBottom - nodeHeight));
                  }
              },
              bind: function() {
                  var that = this, onSelectableClick;
                  onSelectableClick = _.bind(this._onSelectableClick, this);
                  this.$node.on("click.tt", this.selectors.selectable, onSelectableClick);
                  _.each(this.datasets, function(dataset) {
                      dataset.onSync("asyncRequested", that._propagate, that).onSync("asyncCanceled", that._propagate, that).onSync("asyncReceived", that._propagate, that).onSync("rendered", that._onRendered, that).onSync("cleared", that._onCleared, that);
                  });
                  return this;
              },
              isOpen: function isOpen() {
                  return this.$node.hasClass(this.classes.open);
              },
              open: function open() {
                  this.$node.scrollTop(0);
                  this.$node.addClass(this.classes.open);
              },
              close: function close() {
                  this.$node.removeClass(this.classes.open);
                  this._removeCursor();
              },
              setLanguageDirection: function setLanguageDirection(dir) {
                  this.$node.attr("dir", dir);
              },
              selectableRelativeToCursor: function selectableRelativeToCursor(delta) {
                  var $selectables, $oldCursor, oldIndex, newIndex;
                  $oldCursor = this.getActiveSelectable();
                  $selectables = this._getSelectables();
                  oldIndex = $oldCursor ? $selectables.index($oldCursor) : -1;
                  newIndex = oldIndex + delta;
                  newIndex = (newIndex + 1) % ($selectables.length + 1) - 1;
                  newIndex = newIndex < -1 ? $selectables.length - 1 : newIndex;
                  return newIndex === -1 ? null : $selectables.eq(newIndex);
              },
              setCursor: function setCursor($selectable) {
                  this._removeCursor();
                  if ($selectable = $selectable && $selectable.first()) {
                      $selectable.addClass(this.classes.cursor);
                      this._ensureVisible($selectable);
                  }
              },
              getSelectableData: function getSelectableData($el) {
                  return $el && $el.length ? Dataset.extractData($el) : null;
              },
              getActiveSelectable: function getActiveSelectable() {
                  var $selectable = this._getSelectables().filter(this.selectors.cursor).first();
                  return $selectable.length ? $selectable : null;
              },
              getTopSelectable: function getTopSelectable() {
                  var $selectable = this._getSelectables().first();
                  return $selectable.length ? $selectable : null;
              },
              update: function update(query) {
                  var isValidUpdate = query !== this.query;
                  if (isValidUpdate) {
                      this.query = query;
                      _.each(this.datasets, updateDataset);
                  }
                  return isValidUpdate;
                  function updateDataset(dataset) {
                      dataset.update(query);
                  }
              },
              empty: function empty() {
                  _.each(this.datasets, clearDataset);
                  this.query = null;
                  this.$node.addClass(this.classes.empty);
                  function clearDataset(dataset) {
                      dataset.clear();
                  }
              },
              destroy: function destroy() {
                  this.$node.off(".tt");
                  this.$node = $("<div>");
                  _.each(this.datasets, destroyDataset);
                  function destroyDataset(dataset) {
                      dataset.destroy();
                  }
              }
          });
          return Menu;
      }();
      var DefaultMenu = function() {
          "use strict";
          var s = Menu.prototype;
          function DefaultMenu() {
              Menu.apply(this, [].slice.call(arguments, 0));
          }
          _.mixin(DefaultMenu.prototype, Menu.prototype, {
              open: function open() {
                  !this._allDatasetsEmpty() && this._show();
                  return s.open.apply(this, [].slice.call(arguments, 0));
              },
              close: function close() {
                  this._hide();
                  return s.close.apply(this, [].slice.call(arguments, 0));
              },
              _onRendered: function onRendered() {
                  if (this._allDatasetsEmpty()) {
                      this._hide();
                  } else {
                      this.isOpen() && this._show();
                  }
                  return s._onRendered.apply(this, [].slice.call(arguments, 0));
              },
              _onCleared: function onCleared() {
                  if (this._allDatasetsEmpty()) {
                      this._hide();
                  } else {
                      this.isOpen() && this._show();
                  }
                  return s._onCleared.apply(this, [].slice.call(arguments, 0));
              },
              setLanguageDirection: function setLanguageDirection(dir) {
                  this.$node.css(dir === "ltr" ? this.css.ltr : this.css.rtl);
                  return s.setLanguageDirection.apply(this, [].slice.call(arguments, 0));
              },
              _hide: function hide() {
                  this.$node.hide();
              },
              _show: function show() {
                  this.$node.css("display", "block");
              }
          });
          return DefaultMenu;
      }();
      var Typeahead = function() {
          "use strict";
          function Typeahead(o, www) {
              var onFocused, onBlurred, onEnterKeyed, onTabKeyed, onEscKeyed, onUpKeyed, onDownKeyed, onLeftKeyed, onRightKeyed, onQueryChanged, onWhitespaceChanged;
              o = o || {};
              if (!o.input) {
                  $.error("missing input");
              }
              if (!o.menu) {
                  $.error("missing menu");
              }
              if (!o.eventBus) {
                  $.error("missing event bus");
              }
              www.mixin(this);
              this.eventBus = o.eventBus;
              this.minLength = _.isNumber(o.minLength) ? o.minLength : 1;
              this.input = o.input;
              this.menu = o.menu;
              this.enabled = true;
              this.active = false;
              this.input.hasFocus() && this.activate();
              this.dir = this.input.getLangDir();
              this._hacks();
              this.menu.bind().onSync("selectableClicked", this._onSelectableClicked, this).onSync("asyncRequested", this._onAsyncRequested, this).onSync("asyncCanceled", this._onAsyncCanceled, this).onSync("asyncReceived", this._onAsyncReceived, this).onSync("datasetRendered", this._onDatasetRendered, this).onSync("datasetCleared", this._onDatasetCleared, this);
              onFocused = c(this, "activate", "open", "_onFocused");
              onBlurred = c(this, "deactivate", "_onBlurred");
              onEnterKeyed = c(this, "isActive", "isOpen", "_onEnterKeyed");
              onTabKeyed = c(this, "isActive", "isOpen", "_onTabKeyed");
              onEscKeyed = c(this, "isActive", "_onEscKeyed");
              onUpKeyed = c(this, "isActive", "open", "_onUpKeyed");
              onDownKeyed = c(this, "isActive", "open", "_onDownKeyed");
              onLeftKeyed = c(this, "isActive", "isOpen", "_onLeftKeyed");
              onRightKeyed = c(this, "isActive", "isOpen", "_onRightKeyed");
              onQueryChanged = c(this, "_openIfActive", "_onQueryChanged");
              onWhitespaceChanged = c(this, "_openIfActive", "_onWhitespaceChanged");
              this.input.bind().onSync("focused", onFocused, this).onSync("blurred", onBlurred, this).onSync("enterKeyed", onEnterKeyed, this).onSync("tabKeyed", onTabKeyed, this).onSync("escKeyed", onEscKeyed, this).onSync("upKeyed", onUpKeyed, this).onSync("downKeyed", onDownKeyed, this).onSync("leftKeyed", onLeftKeyed, this).onSync("rightKeyed", onRightKeyed, this).onSync("queryChanged", onQueryChanged, this).onSync("whitespaceChanged", onWhitespaceChanged, this).onSync("langDirChanged", this._onLangDirChanged, this);
          }
          _.mixin(Typeahead.prototype, {
              _hacks: function hacks() {
                  var $input, $menu;
                  $input = this.input.$input || $("<div>");
                  $menu = this.menu.$node || $("<div>");
                  $input.on("blur.tt", function($e) {
                      var active, isActive, hasActive;
                      active = document.activeElement;
                      isActive = $menu.is(active);
                      hasActive = $menu.has(active).length > 0;
                      if (_.isMsie() && (isActive || hasActive)) {
                          $e.preventDefault();
                          $e.stopImmediatePropagation();
                          _.defer(function() {
                              $input.focus();
                          });
                      }
                  });
                  $menu.on("mousedown.tt", function($e) {
                      $e.preventDefault();
                  });
              },
              _onSelectableClicked: function onSelectableClicked(type, $el) {
                  this.select($el);
              },
              _onDatasetCleared: function onDatasetCleared() {
                  this._updateHint();
              },
              _onDatasetRendered: function onDatasetRendered(type, dataset, suggestions, async) {
                  this._updateHint();
                  this.eventBus.trigger("render", suggestions, async, dataset);
              },
              _onAsyncRequested: function onAsyncRequested(type, dataset, query) {
                  this.eventBus.trigger("asyncrequest", query, dataset);
              },
              _onAsyncCanceled: function onAsyncCanceled(type, dataset, query) {
                  this.eventBus.trigger("asynccancel", query, dataset);
              },
              _onAsyncReceived: function onAsyncReceived(type, dataset, query) {
                  this.eventBus.trigger("asyncreceive", query, dataset);
              },
              _onFocused: function onFocused() {
                  this._minLengthMet() && this.menu.update(this.input.getQuery());
              },
              _onBlurred: function onBlurred() {
                  if (this.input.hasQueryChangedSinceLastFocus()) {
                      this.eventBus.trigger("change", this.input.getQuery());
                  }
              },
              _onEnterKeyed: function onEnterKeyed(type, $e) {
                  var $selectable;
                  if ($selectable = this.menu.getActiveSelectable()) {
                      this.select($selectable) && $e.preventDefault();
                  }
              },
              _onTabKeyed: function onTabKeyed(type, $e) {
                  var $selectable;
                  if ($selectable = this.menu.getActiveSelectable()) {
                      this.select($selectable) && $e.preventDefault();
                  } else if ($selectable = this.menu.getTopSelectable()) {
                      this.autocomplete($selectable) && $e.preventDefault();
                  }
              },
              _onEscKeyed: function onEscKeyed() {
                  this.close();
              },
              _onUpKeyed: function onUpKeyed() {
                  this.moveCursor(-1);
              },
              _onDownKeyed: function onDownKeyed() {
                  this.moveCursor(+1);
              },
              _onLeftKeyed: function onLeftKeyed() {
                  if (this.dir === "rtl" && this.input.isCursorAtEnd()) {
                      this.autocomplete(this.menu.getTopSelectable());
                  }
              },
              _onRightKeyed: function onRightKeyed() {
                  if (this.dir === "ltr" && this.input.isCursorAtEnd()) {
                      this.autocomplete(this.menu.getTopSelectable());
                  }
              },
              _onQueryChanged: function onQueryChanged(e, query) {
                  this._minLengthMet(query) ? this.menu.update(query) : this.menu.empty();
              },
              _onWhitespaceChanged: function onWhitespaceChanged() {
                  this._updateHint();
              },
              _onLangDirChanged: function onLangDirChanged(e, dir) {
                  if (this.dir !== dir) {
                      this.dir = dir;
                      this.menu.setLanguageDirection(dir);
                  }
              },
              _openIfActive: function openIfActive() {
                  this.isActive() && this.open();
              },
              _minLengthMet: function minLengthMet(query) {
                  query = _.isString(query) ? query : this.input.getQuery() || "";
                  return query.length >= this.minLength;
              },
              _updateHint: function updateHint() {
                  var $selectable, data, val, query, escapedQuery, frontMatchRegEx, match;
                  $selectable = this.menu.getTopSelectable();
                  data = this.menu.getSelectableData($selectable);
                  val = this.input.getInputValue();
                  if (data && !_.isBlankString(val) && !this.input.hasOverflow()) {
                      query = Input.normalizeQuery(val);
                      escapedQuery = _.escapeRegExChars(query);
                      frontMatchRegEx = new RegExp("^(?:" + escapedQuery + ")(.+$)", "i");
                      match = frontMatchRegEx.exec(data.val);
                      match && this.input.setHint(val + match[1]);
                  } else {
                      this.input.clearHint();
                  }
              },
              isEnabled: function isEnabled() {
                  return this.enabled;
              },
              enable: function enable() {
                  this.enabled = true;
              },
              disable: function disable() {
                  this.enabled = false;
              },
              isActive: function isActive() {
                  return this.active;
              },
              activate: function activate() {
                  if (this.isActive()) {
                      return true;
                  } else if (!this.isEnabled() || this.eventBus.before("active")) {
                      return false;
                  } else {
                      this.active = true;
                      this.eventBus.trigger("active");
                      return true;
                  }
              },
              deactivate: function deactivate() {
                  if (!this.isActive()) {
                      return true;
                  } else if (this.eventBus.before("idle")) {
                      return false;
                  } else {
                      this.active = false;
                      this.close();
                      this.eventBus.trigger("idle");
                      return true;
                  }
              },
              isOpen: function isOpen() {
                  return this.menu.isOpen();
              },
              open: function open() {
                  if (!this.isOpen() && !this.eventBus.before("open")) {
                      this.menu.open();
                      this._updateHint();
                      this.eventBus.trigger("open");
                  }
                  return this.isOpen();
              },
              close: function close() {
                  if (this.isOpen() && !this.eventBus.before("close")) {
                      this.menu.close();
                      this.input.clearHint();
                      this.input.resetInputValue();
                      this.eventBus.trigger("close");
                  }
                  return !this.isOpen();
              },
              setVal: function setVal(val) {
                  this.input.setQuery(_.toStr(val));
              },
              getVal: function getVal() {
                  return this.input.getQuery();
              },
              select: function select($selectable) {
                  var data = this.menu.getSelectableData($selectable);
                  if (data && !this.eventBus.before("select", data.obj)) {
                      this.input.setQuery(data.val, true);
                      this.eventBus.trigger("select", data.obj);
                      this.close();
                      return true;
                  }
                  return false;
              },
              autocomplete: function autocomplete($selectable) {
                  var query, data, isValid;
                  query = this.input.getQuery();
                  data = this.menu.getSelectableData($selectable);
                  isValid = data && query !== data.val;
                  if (isValid && !this.eventBus.before("autocomplete", data.obj)) {
                      this.input.setQuery(data.val);
                      this.eventBus.trigger("autocomplete", data.obj);
                      return true;
                  }
                  return false;
              },
              moveCursor: function moveCursor(delta) {
                  var query, $candidate, data, payload, cancelMove;
                  query = this.input.getQuery();
                  $candidate = this.menu.selectableRelativeToCursor(delta);
                  data = this.menu.getSelectableData($candidate);
                  payload = data ? data.obj : null;
                  cancelMove = this._minLengthMet() && this.menu.update(query);
                  if (!cancelMove && !this.eventBus.before("cursorchange", payload)) {
                      this.menu.setCursor($candidate);
                      if (data) {
                          this.input.setInputValue(data.val);
                      } else {
                          this.input.resetInputValue();
                          this._updateHint();
                      }
                      this.eventBus.trigger("cursorchange", payload);
                      return true;
                  }
                  return false;
              },
              destroy: function destroy() {
                  this.input.destroy();
                  this.menu.destroy();
              }
          });
          return Typeahead;
          function c(ctx) {
              var methods = [].slice.call(arguments, 1);
              return function() {
                  var args = [].slice.call(arguments);
                  _.each(methods, function(method) {
                      return ctx[method].apply(ctx, args);
                  });
              };
          }
      }();
      (function() {
          "use strict";
          var old, keys, methods;
          old = $.fn.typeahead;
          keys = {
              www: "tt-www",
              attrs: "tt-attrs",
              typeahead: "tt-typeahead"
          };
          methods = {
              initialize: function initialize(o, datasets) {
                  var www;
                  datasets = _.isArray(datasets) ? datasets : [].slice.call(arguments, 1);
                  o = o || {};
                  www = WWW(o.classNames);
                  return this.each(attach);
                  function attach() {
                      var $input, $wrapper, $hint, $menu, defaultHint, defaultMenu, eventBus, input, menu, typeahead, MenuConstructor;
                      _.each(datasets, function(d) {
                          d.highlight = !!o.highlight;
                      });
                      $input = $(this);
                      $wrapper = $(www.html.wrapper);
                      $hint = $elOrNull(o.hint);
                      $menu = $elOrNull(o.menu);
                      defaultHint = o.hint !== false && !$hint;
                      defaultMenu = o.menu !== false && !$menu;
                      defaultHint && ($hint = buildHintFromInput($input, www));
                      defaultMenu && ($menu = $(www.html.menu).css(www.css.menu));
                      $hint && $hint.val("");
                      $input = prepInput($input, www);
                      if (defaultHint || defaultMenu) {
                          $wrapper.css(www.css.wrapper);
                          $input.css(defaultHint ? www.css.input : www.css.inputWithNoHint);
                          $input.wrap($wrapper).parent().prepend(defaultHint ? $hint : null).append(defaultMenu ? $menu : null);
                      }
                      MenuConstructor = defaultMenu ? DefaultMenu : Menu;
                      eventBus = new EventBus({
                          el: $input
                      });
                      input = new Input({
                          hint: $hint,
                          input: $input
                      }, www);
                      menu = new MenuConstructor({
                          node: $menu,
                          datasets: datasets
                      }, www);
                      typeahead = new Typeahead({
                          input: input,
                          menu: menu,
                          eventBus: eventBus,
                          minLength: o.minLength
                      }, www);
                      $input.data(keys.www, www);
                      $input.data(keys.typeahead, typeahead);
                  }
              },
              isEnabled: function isEnabled() {
                  var enabled;
                  ttEach(this.first(), function(t) {
                      enabled = t.isEnabled();
                  });
                  return enabled;
              },
              enable: function enable() {
                  ttEach(this, function(t) {
                      t.enable();
                  });
                  return this;
              },
              disable: function disable() {
                  ttEach(this, function(t) {
                      t.disable();
                  });
                  return this;
              },
              isActive: function isActive() {
                  var active;
                  ttEach(this.first(), function(t) {
                      active = t.isActive();
                  });
                  return active;
              },
              activate: function activate() {
                  ttEach(this, function(t) {
                      t.activate();
                  });
                  return this;
              },
              deactivate: function deactivate() {
                  ttEach(this, function(t) {
                      t.deactivate();
                  });
                  return this;
              },
              isOpen: function isOpen() {
                  var open;
                  ttEach(this.first(), function(t) {
                      open = t.isOpen();
                  });
                  return open;
              },
              open: function open() {
                  ttEach(this, function(t) {
                      t.open();
                  });
                  return this;
              },
              close: function close() {
                  ttEach(this, function(t) {
                      t.close();
                  });
                  return this;
              },
              select: function select(el) {
                  var success = false, $el = $(el);
                  ttEach(this.first(), function(t) {
                      success = t.select($el);
                  });
                  return success;
              },
              autocomplete: function autocomplete(el) {
                  var success = false, $el = $(el);
                  ttEach(this.first(), function(t) {
                      success = t.autocomplete($el);
                  });
                  return success;
              },
              moveCursor: function moveCursoe(delta) {
                  var success = false;
                  ttEach(this.first(), function(t) {
                      success = t.moveCursor(delta);
                  });
                  return success;
              },
              val: function val(newVal) {
                  var query;
                  if (!arguments.length) {
                      ttEach(this.first(), function(t) {
                          query = t.getVal();
                      });
                      return query;
                  } else {
                      ttEach(this, function(t) {
                          t.setVal(_.toStr(newVal));
                      });
                      return this;
                  }
              },
              destroy: function destroy() {
                  ttEach(this, function(typeahead, $input) {
                      revert($input);
                      typeahead.destroy();
                  });
                  return this;
              }
          };
          $.fn.typeahead = function(method) {
              if (methods[method]) {
                  return methods[method].apply(this, [].slice.call(arguments, 1));
              } else {
                  return methods.initialize.apply(this, arguments);
              }
          };
          $.fn.typeahead.noConflict = function noConflict() {
              $.fn.typeahead = old;
              return this;
          };
          function ttEach($els, fn) {
              $els.each(function() {
                  var $input = $(this), typeahead;
                  (typeahead = $input.data(keys.typeahead)) && fn(typeahead, $input);
              });
          }
          function buildHintFromInput($input, www) {
              return $input.clone().addClass(www.classes.hint).removeData().css(www.css.hint).css(getBackgroundStyles($input)).prop("readonly", true).removeAttr("id name placeholder required").attr({
                  autocomplete: "off",
                  spellcheck: "false",
                  tabindex: -1
              });
          }
          function prepInput($input, www) {
              $input.data(keys.attrs, {
                  dir: $input.attr("dir"),
                  autocomplete: $input.attr("autocomplete"),
                  spellcheck: $input.attr("spellcheck"),
                  style: $input.attr("style")
              });
              $input.addClass(www.classes.input).attr({
                  autocomplete: "off",
                  spellcheck: false
              });
              try {
                  !$input.attr("dir") && $input.attr("dir", "auto");
              } catch (e) {}
              return $input;
          }
          function getBackgroundStyles($el) {
              return {
                  backgroundAttachment: $el.css("background-attachment"),
                  backgroundClip: $el.css("background-clip"),
                  backgroundColor: $el.css("background-color"),
                  backgroundImage: $el.css("background-image"),
                  backgroundOrigin: $el.css("background-origin"),
                  backgroundPosition: $el.css("background-position"),
                  backgroundRepeat: $el.css("background-repeat"),
                  backgroundSize: $el.css("background-size")
              };
          }
          function revert($input) {
              var www, $wrapper;
              www = $input.data(keys.www);
              $wrapper = $input.parent().filter(www.selectors.wrapper);
              _.each($input.data(keys.attrs), function(val, key) {
                  _.isUndefined(val) ? $input.removeAttr(key) : $input.attr(key, val);
              });
              $input.removeData(keys.typeahead).removeData(keys.www).removeData(keys.attr).removeClass(www.classes.input);
              if ($wrapper.length) {
                  $input.detach().insertAfter($wrapper);
                  $wrapper.remove();
              }
          }
          function $elOrNull(obj) {
              var isValid, $el;
              isValid = _.isJQuery(obj) || _.isElement(obj);
              $el = isValid ? $(obj).first() : [];
              return $el.length ? $el : null;
          }
      })();
  });
  
  // This file is generated by Blacklight. You probably don't want to edit
  //   this file directly, or you'll have to manually merge your changes if later
  //   versions of Blacklight change this file. Instead, use your own JS file
  //   which over-rides things in this JS file, as described below.
  //
  // These javascript files are compiled in via the Rails asset pipeline:
  
  
  
  
  
  
  
  
  //
  //Bootstrap JS for providing collapsable tablet/mobile menu/alert boxes
  
  
  
  
  
  
  // Twitter Typeahead for autocomplete
  
  
  /* Blacklight has a Javascript setup meant to support local disabling, 
    modification, and use of Blacklight behaviors. 
    
    There is a global Blacklight object, available to your local JS. 
    
    Individual logic to apply JS behaviors to particular elements is 
    stored in functions on that Blacklight object. 
    
    The actual behaviors themselves are implemented as JQuery plugins, 
    JQuery-UI widgets (a special kind of JQuery plugin), or in some cases
    just as logic in the Blacklight global object. 
    
    All of these things can be modified by your local JS code -- these functions
    are all set up on js load, and only called on document ready, so do your
    modifications just on js load, and they'll be made by the time document ready
    comes along. 
    
    Examples, in your application's own JS:
          
      Turn off adding of behavior to facet 'more' links, using a no-op function:
      
          Blacklight.do_more_facets_behavior = function() {};
          
      Change the implementation of facet 'more' link behavior to use entirely
      different JS. 
      
          Blacklight.do_more_facets_behavior = function() {
            $(Blacklight.do_more_facets_behavior.selector).each(function() {
              //my own thing!
            });
          };
  */
  
  
  $('.no-js').removeClass('no-js').addClass('js');
  //! openseadragon 2.4.2
  //! Built on 2020-03-05
  //! Git commit: v2.4.2-0-c450749
  //! http://openseadragon.github.io
  //! License: http://openseadragon.github.io/license/
  
  /*
   * OpenSeadragon
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  /*
   * Portions of this source file taken from jQuery:
   *
   * Copyright 2011 John Resig
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */
  
  /*
   * Portions of this source file taken from mattsnider.com:
   *
   * Copyright (c) 2006-2013 Matt Snider
   *
   * Permission is hereby granted, free of charge, to any person obtaining a
   * copy of this software and associated documentation files (the "Software"),
   * to deal in the Software without restriction, including without limitation
   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
   * and/or sell copies of the Software, and to permit persons to whom the
   * Software is furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included
   * in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
   * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
   * OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
   * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */
  
  
  /**
   * @namespace OpenSeadragon
   * @version openseadragon 2.4.2
   * @classdesc The root namespace for OpenSeadragon.  All utility methods
   * and classes are defined on or below this namespace.
   *
   */
  
  
  // Typedefs
  
   /**
    * All required and optional settings for instantiating a new instance of an OpenSeadragon image viewer.
    *
    * @typedef {Object} Options
    * @memberof OpenSeadragon
    *
    * @property {String} id
    *     Id of the element to append the viewer's container element to. If not provided, the 'element' property must be provided.
    *     If both the element and id properties are specified, the viewer is appended to the element provided in the element property.
    *
    * @property {Element} element
    *     The element to append the viewer's container element to. If not provided, the 'id' property must be provided.
    *     If both the element and id properties are specified, the viewer is appended to the element provided in the element property.
    *
    * @property {Array|String|Function|Object} [tileSources=null]
    *     Tile source(s) to open initially. This is a complex parameter; see
    *     {@link OpenSeadragon.Viewer#open} for details.
    *
    * @property {Number} [tabIndex=0]
    *     Tabbing order index to assign to the viewer element. Positive values are selected in increasing order. When tabIndex is 0
    *     source order is used. A negative value omits the viewer from the tabbing order.
    *
    * @property {Array} overlays Array of objects defining permanent overlays of
    *     the viewer. The overlays added via this option and later removed with
    *     {@link OpenSeadragon.Viewer#removeOverlay} will be added back when a new
    *     image is opened.
    *     To add overlays which can be definitively removed, one must use
    *     {@link OpenSeadragon.Viewer#addOverlay}
    *     If displaying a sequence of images, the overlays can be associated
    *     with a specific page by passing the overlays array to the page's
    *     tile source configuration.
    *     Expected properties:
    *     * x, y, (or px, py for pixel coordinates) to define the location.
    *     * width, height in point if using x,y or in pixels if using px,py. If width
    *       and height are specified, the overlay size is adjusted when zooming,
    *       otherwise the size stays the size of the content (or the size defined by CSS).
    *     * className to associate a class to the overlay
    *     * id to set the overlay element. If an element with this id already exists,
    *       it is reused, otherwise it is created. If not specified, a new element is
    *       created.
    *     * placement a string to define the relative position to the viewport.
    *       Only used if no width and height are specified. Default: 'TOP_LEFT'.
    *       See {@link OpenSeadragon.Placement} for possible values.
    *
    * @property {String} [xmlPath=null]
    *     <strong>DEPRECATED</strong>. A relative path to load a DZI file from the server.
    *     Prefer the newer Options.tileSources.
    *
    * @property {String} [prefixUrl='/images/']
    *     Prepends the prefixUrl to navImages paths, which is very useful
    *     since the default paths are rarely useful for production
    *     environments.
    *
    * @property {OpenSeadragon.NavImages} [navImages]
    *     An object with a property for each button or other built-in navigation
    *     control, eg the current 'zoomIn', 'zoomOut', 'home', and 'fullpage'.
    *     Each of those in turn provides an image path for each state of the button
    *     or navigation control, eg 'REST', 'GROUP', 'HOVER', 'PRESS'. Finally the
    *     image paths, by default assume there is a folder on the servers root path
    *     called '/images', eg '/images/zoomin_rest.png'.  If you need to adjust
    *     these paths, prefer setting the option.prefixUrl rather than overriding
    *     every image path directly through this setting.
    *
    * @property {Boolean} [debugMode=false]
    *     TODO: provide an in-screen panel providing event detail feedback.
    *
    * @property {String} [debugGridColor=['#437AB2', '#1B9E77', '#D95F02', '#7570B3', '#E7298A', '#66A61E', '#E6AB02', '#A6761D', '#666666']]
    *     The colors of grids in debug mode. Each tiled image's grid uses a consecutive color.
    *     If there are more tiled images than provided colors, the color vector is recycled.
    *
    * @property {Number} [blendTime=0]
    *     Specifies the duration of animation as higher or lower level tiles are
    *     replacing the existing tile.
    *
    * @property {Boolean} [alwaysBlend=false]
    *     Forces the tile to always blend.  By default the tiles skip blending
    *     when the blendTime is surpassed and the current animation frame would
    *     not complete the blend.
    *
    * @property {Boolean} [autoHideControls=true]
    *     If the user stops interacting with the viewport, fade the navigation
    *     controls.  Useful for presentation since the controls are by default
    *     floated on top of the image the user is viewing.
    *
    * @property {Boolean} [immediateRender=false]
    *     Render the best closest level first, ignoring the lowering levels which
    *     provide the effect of very blurry to sharp. It is recommended to change
    *     setting to true for mobile devices.
    *
    * @property {Number} [defaultZoomLevel=0]
    *     Zoom level to use when image is first opened or the home button is clicked.
    *     If 0, adjusts to fit viewer.
    *
    * @property {Number} [opacity=1]
    *     Default proportional opacity of the tiled images (1=opaque, 0=hidden)
    *     Hidden images do not draw and only load when preloading is allowed.
    *
    * @property {Boolean} [preload=false]
    *     Default switch for loading hidden images (true loads, false blocks)
    *
    * @property {String} [compositeOperation=null]
    *     Valid values are 'source-over', 'source-atop', 'source-in', 'source-out',
    *     'destination-over', 'destination-atop', 'destination-in',
    *     'destination-out', 'lighter', 'copy' or 'xor'
    *
    * @property {Boolean} [imageSmoothingEnabled=true]
    *     Image smoothing for canvas rendering (only if canvas is used). Note: Ignored
    *     by some (especially older) browsers which do not support this canvas property.
    *     This property can be changed in {@link Viewer.Drawer.setImageSmoothingEnabled}.
    *
    * @property {String|CanvasGradient|CanvasPattern|Function} [placeholderFillStyle=null]
    *     Draws a colored rectangle behind the tile if it is not loaded yet.
    *     You can pass a CSS color value like "#FF8800".
    *     When passing a function the tiledImage and canvas context are available as argument which is useful when you draw a gradient or pattern.
    *
    * @property {Number} [degrees=0]
    *     Initial rotation.
    *
    * @property {Boolean} [flipped=false]
    *     Initial flip state.
    *
    * @property {Number} [minZoomLevel=null]
    *
    * @property {Number} [maxZoomLevel=null]
    *
    * @property {Boolean} [homeFillsViewer=false]
    *     Make the 'home' button fill the viewer and clip the image, instead
    *     of fitting the image to the viewer and letterboxing.
    *
    * @property {Boolean} [panHorizontal=true]
    *     Allow horizontal pan.
    *
    * @property {Boolean} [panVertical=true]
    *     Allow vertical pan.
    *
    * @property {Boolean} [constrainDuringPan=false]
    *
    * @property {Boolean} [wrapHorizontal=false]
    *     Set to true to force the image to wrap horizontally within the viewport.
    *     Useful for maps or images representing the surface of a sphere or cylinder.
    *
    * @property {Boolean} [wrapVertical=false]
    *     Set to true to force the image to wrap vertically within the viewport.
    *     Useful for maps or images representing the surface of a sphere or cylinder.
    *
    * @property {Number} [minZoomImageRatio=0.9]
    *     The minimum percentage ( expressed as a number between 0 and 1 ) of
    *     the viewport height or width at which the zoom out will be constrained.
    *     Setting it to 0, for example will allow you to zoom out infinity.
    *
    * @property {Number} [maxZoomPixelRatio=1.1]
    *     The maximum ratio to allow a zoom-in to affect the highest level pixel
    *     ratio. This can be set to Infinity to allow 'infinite' zooming into the
    *     image though it is less effective visually if the HTML5 Canvas is not
    *     available on the viewing device.
    *
    * @property {Number} [smoothTileEdgesMinZoom=1.1]
    *     A zoom percentage ( where 1 is 100% ) of the highest resolution level.
    *     When zoomed in beyond this value alternative compositing will be used to
    *     smooth out the edges between tiles. This will have a performance impact.
    *     Can be set to Infinity to turn it off.
    *     Note: This setting is ignored on iOS devices due to a known bug (See {@link https://github.com/openseadragon/openseadragon/issues/952})
    *
    * @property {Boolean} [iOSDevice=?]
    *     True if running on an iOS device, false otherwise.
    *     Used to disable certain features that behave differently on iOS devices.
    *
    * @property {Boolean} [autoResize=true]
    *     Set to false to prevent polling for viewer size changes. Useful for providing custom resize behavior.
    *
    * @property {Boolean} [preserveImageSizeOnResize=false]
    *     Set to true to have the image size preserved when the viewer is resized. This requires autoResize=true (default).
    *
    * @property {Number} [minScrollDeltaTime=50]
    *     Number of milliseconds between canvas-scroll events. This value helps normalize the rate of canvas-scroll
    *     events between different devices, causing the faster devices to slow down enough to make the zoom control
    *     more manageable.
    *
    * @property {Number} [rotationIncrement=90]
    *     The number of degrees to rotate right or left when the rotate buttons or keyboard shortcuts are activated.
    *
    * @property {Number} [pixelsPerWheelLine=40]
    *     For pixel-resolution scrolling devices, the number of pixels equal to one scroll line.
    *
    * @property {Number} [pixelsPerArrowPress=40]
    *     The number of pixels viewport moves when an arrow key is pressed.
    *
    * @property {Number} [visibilityRatio=0.5]
    *     The percentage ( as a number from 0 to 1 ) of the source image which
    *     must be kept within the viewport.  If the image is dragged beyond that
    *     limit, it will 'bounce' back until the minimum visibility ratio is
    *     achieved.  Setting this to 0 and wrapHorizontal ( or wrapVertical ) to
    *     true will provide the effect of an infinitely scrolling viewport.
    *
    * @property {Object} [viewportMargins={}]
    *     Pushes the "home" region in from the sides by the specified amounts.
    *     Possible subproperties (Numbers, in screen coordinates): left, top, right, bottom.
    *
    * @property {Number} [imageLoaderLimit=0]
    *     The maximum number of image requests to make concurrently. By default
    *     it is set to 0 allowing the browser to make the maximum number of
    *     image requests in parallel as allowed by the browsers policy.
    *
    * @property {Number} [clickTimeThreshold=300]
    *      The number of milliseconds within which a pointer down-up event combination
    *      will be treated as a click gesture.
    *
    * @property {Number} [clickDistThreshold=5]
    *      The maximum distance allowed between a pointer down event and a pointer up event
    *      to be treated as a click gesture.
    *
    * @property {Number} [dblClickTimeThreshold=300]
    *      The number of milliseconds within which two pointer down-up event combinations
    *      will be treated as a double-click gesture.
    *
    * @property {Number} [dblClickDistThreshold=20]
    *      The maximum distance allowed between two pointer click events
    *      to be treated as a double-click gesture.
    *
    * @property {Number} [springStiffness=6.5]
    *
    * @property {Number} [animationTime=1.2]
    *     Specifies the animation duration per each {@link OpenSeadragon.Spring}
    *     which occur when the image is dragged or zoomed.
    *
    * @property {OpenSeadragon.GestureSettings} [gestureSettingsMouse]
    *     Settings for gestures generated by a mouse pointer device. (See {@link OpenSeadragon.GestureSettings})
    * @property {Boolean} [gestureSettingsMouse.scrollToZoom=true] - Zoom on scroll gesture
    * @property {Boolean} [gestureSettingsMouse.clickToZoom=true] - Zoom on click gesture
    * @property {Boolean} [gestureSettingsMouse.dblClickToZoom=false] - Zoom on double-click gesture. Note: If set to true
    *     then clickToZoom should be set to false to prevent multiple zooms.
    * @property {Boolean} [gestureSettingsMouse.pinchToZoom=false] - Zoom on pinch gesture
    * @property {Boolean} [gestureSettingsMouse.zoomToRefPoint=true] - If zoomToRefPoint is true, the zoom is centered at the pointer position. Otherwise,
    *     the zoom is centered at the canvas center.
    * @property {Boolean} [gestureSettingsMouse.flickEnabled=false] - Enable flick gesture
    * @property {Number} [gestureSettingsMouse.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)
    * @property {Number} [gestureSettingsMouse.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture
    * @property {Boolean} [gestureSettingsMouse.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.
    *
    * @property {OpenSeadragon.GestureSettings} [gestureSettingsTouch]
    *     Settings for gestures generated by a touch pointer device. (See {@link OpenSeadragon.GestureSettings})
    * @property {Boolean} [gestureSettingsTouch.scrollToZoom=false] - Zoom on scroll gesture
    * @property {Boolean} [gestureSettingsTouch.clickToZoom=false] - Zoom on click gesture
    * @property {Boolean} [gestureSettingsTouch.dblClickToZoom=true] - Zoom on double-click gesture. Note: If set to true
    *     then clickToZoom should be set to false to prevent multiple zooms.
    * @property {Boolean} [gestureSettingsTouch.pinchToZoom=true] - Zoom on pinch gesture
    * @property {Boolean} [gestureSettingsTouch.zoomToRefPoint=true] - If zoomToRefPoint is true, the zoom is centered at the pointer position. Otherwise,
    *     the zoom is centered at the canvas center.
    * @property {Boolean} [gestureSettingsTouch.flickEnabled=true] - Enable flick gesture
    * @property {Number} [gestureSettingsTouch.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)
    * @property {Number} [gestureSettingsTouch.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture
    * @property {Boolean} [gestureSettingsTouch.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.
    *
    * @property {OpenSeadragon.GestureSettings} [gestureSettingsPen]
    *     Settings for gestures generated by a pen pointer device. (See {@link OpenSeadragon.GestureSettings})
    * @property {Boolean} [gestureSettingsPen.scrollToZoom=false] - Zoom on scroll gesture
    * @property {Boolean} [gestureSettingsPen.clickToZoom=true] - Zoom on click gesture
    * @property {Boolean} [gestureSettingsPen.dblClickToZoom=false] - Zoom on double-click gesture. Note: If set to true
    *     then clickToZoom should be set to false to prevent multiple zooms.
    * @property {Boolean} [gestureSettingsPen.pinchToZoom=false] - Zoom on pinch gesture
    * @property {Boolean} [gestureSettingsPen.zoomToRefPoint=true] - If zoomToRefPoint is true, the zoom is centered at the pointer position. Otherwise,
    *     the zoom is centered at the canvas center.
    * @property {Boolean} [gestureSettingsPen.flickEnabled=false] - Enable flick gesture
    * @property {Number} [gestureSettingsPen.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)
    * @property {Number} [gestureSettingsPen.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture
    * @property {Boolean} [gestureSettingsPen.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.
    *
    * @property {OpenSeadragon.GestureSettings} [gestureSettingsUnknown]
    *     Settings for gestures generated by unknown pointer devices. (See {@link OpenSeadragon.GestureSettings})
    * @property {Boolean} [gestureSettingsUnknown.scrollToZoom=true] - Zoom on scroll gesture
    * @property {Boolean} [gestureSettingsUnknown.clickToZoom=false] - Zoom on click gesture
    * @property {Boolean} [gestureSettingsUnknown.dblClickToZoom=true] - Zoom on double-click gesture. Note: If set to true
    *     then clickToZoom should be set to false to prevent multiple zooms.
    * @property {Boolean} [gestureSettingsUnknown.pinchToZoom=true] - Zoom on pinch gesture
    * @property {Boolean} [gestureSettingsUnknown.zoomToRefPoint=true] - If zoomToRefPoint is true, the zoom is centered at the pointer position. Otherwise,
    *     the zoom is centered at the canvas center.
    * @property {Boolean} [gestureSettingsUnknown.flickEnabled=true] - Enable flick gesture
    * @property {Number} [gestureSettingsUnknown.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)
    * @property {Number} [gestureSettingsUnknown.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture
    * @property {Boolean} [gestureSettingsUnknown.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.
    *
    * @property {Number} [zoomPerClick=2.0]
    *     The "zoom distance" per mouse click or touch tap. <em><strong>Note:</strong> Setting this to 1.0 effectively disables the click-to-zoom feature (also see gestureSettings[Mouse|Touch|Pen].clickToZoom/dblClickToZoom).</em>
    *
    * @property {Number} [zoomPerScroll=1.2]
    *     The "zoom distance" per mouse scroll or touch pinch. <em><strong>Note:</strong> Setting this to 1.0 effectively disables the mouse-wheel zoom feature (also see gestureSettings[Mouse|Touch|Pen].scrollToZoom}).</em>
    *
    * @property {Number} [zoomPerSecond=1.0]
    *     The number of seconds to animate a single zoom event over.
    *
    * @property {Boolean} [showNavigator=false]
    *     Set to true to make the navigator minimap appear.
    *
    * @property {String} [navigatorId=navigator-GENERATED DATE]
    *     The ID of a div to hold the navigator minimap.
    *     If an ID is specified, the navigatorPosition, navigatorSizeRatio, navigatorMaintainSizeRatio, navigator[Top|Left|Height|Width] and navigatorAutoFade options will be ignored.
    *     If an ID is not specified, a div element will be generated and placed on top of the main image.
    *
    * @property {String} [navigatorPosition='TOP_RIGHT']
    *     Valid values are 'TOP_LEFT', 'TOP_RIGHT', 'BOTTOM_LEFT', 'BOTTOM_RIGHT', or 'ABSOLUTE'.<br>
    *     If 'ABSOLUTE' is specified, then navigator[Top|Left|Height|Width] determines the size and position of the navigator minimap in the viewer, and navigatorSizeRatio and navigatorMaintainSizeRatio are ignored.<br>
    *     For 'TOP_LEFT', 'TOP_RIGHT', 'BOTTOM_LEFT', and 'BOTTOM_RIGHT', the navigatorSizeRatio or navigator[Height|Width] values determine the size of the navigator minimap.
    *
    * @property {Number} [navigatorSizeRatio=0.2]
    *     Ratio of navigator size to viewer size. Ignored if navigator[Height|Width] are specified.
    *
    * @property {Boolean} [navigatorMaintainSizeRatio=false]
    *     If true, the navigator minimap is resized (using navigatorSizeRatio) when the viewer size changes.
    *
    * @property {Number|String} [navigatorTop=null]
    *     Specifies the location of the navigator minimap (see navigatorPosition).
    *
    * @property {Number|String} [navigatorLeft=null]
    *     Specifies the location of the navigator minimap (see navigatorPosition).
    *
    * @property {Number|String} [navigatorHeight=null]
    *     Specifies the size of the navigator minimap (see navigatorPosition).
    *     If specified, navigatorSizeRatio and navigatorMaintainSizeRatio are ignored.
    *
    * @property {Number|String} [navigatorWidth=null]
    *     Specifies the size of the navigator minimap (see navigatorPosition).
    *     If specified, navigatorSizeRatio and navigatorMaintainSizeRatio are ignored.
    *
    * @property {Boolean} [navigatorAutoResize=true]
    *     Set to false to prevent polling for navigator size changes. Useful for providing custom resize behavior.
    *     Setting to false can also improve performance when the navigator is configured to a fixed size.
    *
    * @property {Boolean} [navigatorAutoFade=true]
    *     If the user stops interacting with the viewport, fade the navigator minimap.
    *     Setting to false will make the navigator minimap always visible.
    *
    * @property {Boolean} [navigatorRotate=true]
    *     If true, the navigator will be rotated together with the viewer.
    *
    * @property {String} [navigatorBackground='#000']
    *     Specifies the background color of the navigator minimap
    *
    * @property {Number} [navigatorOpacity=0.8]
    *     Specifies the opacity of the navigator minimap.
    *
    * @property {String} [navigatorBorderColor='#555']
    *     Specifies the border color of the navigator minimap
    *
    * @property {String} [navigatorDisplayRegionColor='#900']
    *     Specifies the border color of the display region rectangle of the navigator minimap
    *
    * @property {Number} [controlsFadeDelay=2000]
    *     The number of milliseconds to wait once the user has stopped interacting
    *     with the interface before beginning to fade the controls. Assumes
    *     showNavigationControl and autoHideControls are both true.
    *
    * @property {Number} [controlsFadeLength=1500]
    *     The number of milliseconds to animate the controls fading out.
    *
    * @property {Number} [maxImageCacheCount=200]
    *     The max number of images we should keep in memory (per drawer).
    *
    * @property {Number} [timeout=30000]
    *     The max number of milliseconds that an image job may take to complete.
    *
    * @property {Boolean} [useCanvas=true]
    *     Set to false to not use an HTML canvas element for image rendering even if canvas is supported.
    *
    * @property {Number} [minPixelRatio=0.5]
    *     The higher the minPixelRatio, the lower the quality of the image that
    *     is considered sufficient to stop rendering a given zoom level.  For
    *     example, if you are targeting mobile devices with less bandwidth you may
    *     try setting this to 1.5 or higher.
    *
    * @property {Boolean} [mouseNavEnabled=true]
    *     Is the user able to interact with the image via mouse or touch. Default
    *     interactions include draging the image in a plane, and zooming in toward
    *     and away from the image.
    *
    * @property {Boolean} [showNavigationControl=true]
    *     Set to false to prevent the appearance of the default navigation controls.<br>
    *     Note that if set to false, the customs buttons set by the options
    *     zoomInButton, zoomOutButton etc, are rendered inactive.
    *
    * @property {OpenSeadragon.ControlAnchor} [navigationControlAnchor=TOP_LEFT]
    *     Placement of the default navigation controls.
    *     To set the placement of the sequence controls, see the
    *     sequenceControlAnchor option.
    *
    * @property {Boolean} [showZoomControl=true]
    *     If true then + and - buttons to zoom in and out are displayed.<br>
    *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding
    *     this setting when set to false.
    *
    * @property {Boolean} [showHomeControl=true]
    *     If true then the 'Go home' button is displayed to go back to the original
    *     zoom and pan.<br>
    *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding
    *     this setting when set to false.
    *
    * @property {Boolean} [showFullPageControl=true]
    *     If true then the 'Toggle full page' button is displayed to switch
    *     between full page and normal mode.<br>
    *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding
    *     this setting when set to false.
    *
    * @property {Boolean} [showRotationControl=false]
    *     If true then the rotate left/right controls will be displayed as part of the
    *     standard controls. This is also subject to the browser support for rotate
    *     (e.g. viewer.drawer.canRotate()).<br>
    *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding
    *     this setting when set to false.
    *
    * @property {Boolean} [showFlipControl=false]
    *     If true then the flip controls will be displayed as part of the
    *     standard controls.
    *
    * @property {Boolean} [showSequenceControl=true]
    *     If sequenceMode is true, then provide buttons for navigating forward and
    *     backward through the images.
    *
    * @property {OpenSeadragon.ControlAnchor} [sequenceControlAnchor=TOP_LEFT]
    *     Placement of the default sequence controls.
    *
    * @property {Boolean} [navPrevNextWrap=false]
    *     If true then the 'previous' button will wrap to the last image when
    *     viewing the first image and the 'next' button will wrap to the first
    *     image when viewing the last image.
    *
    * @property {String} zoomInButton
    *     Set the id of the custom 'Zoom in' button to use.
    *     This is useful to have a custom button anywhere in the web page.<br>
    *     To only change the button images, consider using
    *     {@link OpenSeadragon.Options.navImages}
    *
    * @property {String} zoomOutButton
    *     Set the id of the custom 'Zoom out' button to use.
    *     This is useful to have a custom button anywhere in the web page.<br>
    *     To only change the button images, consider using
    *     {@link OpenSeadragon.Options.navImages}
    *
    * @property {String} homeButton
    *     Set the id of the custom 'Go home' button to use.
    *     This is useful to have a custom button anywhere in the web page.<br>
    *     To only change the button images, consider using
    *     {@link OpenSeadragon.Options.navImages}
    *
    * @property {String} fullPageButton
    *     Set the id of the custom 'Toggle full page' button to use.
    *     This is useful to have a custom button anywhere in the web page.<br>
    *     To only change the button images, consider using
    *     {@link OpenSeadragon.Options.navImages}
    *
    * @property {String} rotateLeftButton
    *     Set the id of the custom 'Rotate left' button to use.
    *     This is useful to have a custom button anywhere in the web page.<br>
    *     To only change the button images, consider using
    *     {@link OpenSeadragon.Options.navImages}
    *
    * @property {String} rotateRightButton
    *     Set the id of the custom 'Rotate right' button to use.
    *     This is useful to have a custom button anywhere in the web page.<br>
    *     To only change the button images, consider using
    *     {@link OpenSeadragon.Options.navImages}
    *
    * @property {String} previousButton
    *     Set the id of the custom 'Previous page' button to use.
    *     This is useful to have a custom button anywhere in the web page.<br>
    *     To only change the button images, consider using
    *     {@link OpenSeadragon.Options.navImages}
    *
    * @property {String} nextButton
    *     Set the id of the custom 'Next page' button to use.
    *     This is useful to have a custom button anywhere in the web page.<br>
    *     To only change the button images, consider using
    *     {@link OpenSeadragon.Options.navImages}
    *
    * @property {Boolean} [sequenceMode=false]
    *     Set to true to have the viewer treat your tilesources as a sequence of images to
    *     be opened one at a time rather than all at once.
    *
    * @property {Number} [initialPage=0]
    *     If sequenceMode is true, display this page initially.
    *
    * @property {Boolean} [preserveViewport=false]
    *     If sequenceMode is true, then normally navigating through each image resets the
    *     viewport to 'home' position.  If preserveViewport is set to true, then the viewport
    *     position is preserved when navigating between images in the sequence.
    *
    * @property {Boolean} [preserveOverlays=false]
    *     If sequenceMode is true, then normally navigating through each image
    *     resets the overlays.
    *     If preserveOverlays is set to true, then the overlays added with {@link OpenSeadragon.Viewer#addOverlay}
    *     are preserved when navigating between images in the sequence.
    *     Note: setting preserveOverlays overrides any overlays specified in the global
    *     "overlays" option for the Viewer. It's also not compatible with specifying
    *     per-tileSource overlays via the options, as those overlays will persist
    *     even after the tileSource is closed.
    *
    * @property {Boolean} [showReferenceStrip=false]
    *     If sequenceMode is true, then display a scrolling strip of image thumbnails for
    *     navigating through the images.
    *
    * @property {String} [referenceStripScroll='horizontal']
    *
    * @property {Element} [referenceStripElement=null]
    *
    * @property {Number} [referenceStripHeight=null]
    *
    * @property {Number} [referenceStripWidth=null]
    *
    * @property {String} [referenceStripPosition='BOTTOM_LEFT']
    *
    * @property {Number} [referenceStripSizeRatio=0.2]
    *
    * @property {Boolean} [collectionMode=false]
    *     Set to true to have the viewer arrange your TiledImages in a grid or line.
    *
    * @property {Number} [collectionRows=3]
    *     If collectionMode is true, specifies how many rows the grid should have. Use 1 to make a line.
    *     If collectionLayout is 'vertical', specifies how many columns instead.
    *
    * @property {Number} [collectionColumns=0]
    *     If collectionMode is true, specifies how many columns the grid should have. Use 1 to make a line.
    *     If collectionLayout is 'vertical', specifies how many rows instead. Ignored if collectionRows is not set to a falsy value.
    *
    * @property {String} [collectionLayout='horizontal']
    *     If collectionMode is true, specifies whether to arrange vertically or horizontally.
    *
    * @property {Number} [collectionTileSize=800]
    *     If collectionMode is true, specifies the size, in viewport coordinates, for each TiledImage to fit into.
    *     The TiledImage will be centered within a square of the specified size.
    *
    * @property {Number} [collectionTileMargin=80]
    *     If collectionMode is true, specifies the margin, in viewport coordinates, between each TiledImage.
    *
    * @property {String|Boolean} [crossOriginPolicy=false]
    *     Valid values are 'Anonymous', 'use-credentials', and false. If false, canvas requests will
    *     not use CORS, and the canvas will be tainted.
    *
    * @property {Boolean} [ajaxWithCredentials=false]
    *     Whether to set the withCredentials XHR flag for AJAX requests.
    *     Note that this can be overridden at the {@link OpenSeadragon.TileSource} level.
    *
    * @property {Boolean} [loadTilesWithAjax=false]
    *     Whether to load tile data using AJAX requests.
    *     Note that this can be overridden at the {@link OpenSeadragon.TileSource} level.
    *
    * @property {Object} [ajaxHeaders={}]
    *     A set of headers to include when making AJAX requests for tile sources or tiles.
    *
    */
  
   /**
    * Settings for gestures generated by a pointer device.
    *
    * @typedef {Object} GestureSettings
    * @memberof OpenSeadragon
    *
    * @property {Boolean} scrollToZoom
    *     Set to false to disable zooming on scroll gestures.
    *
    * @property {Boolean} clickToZoom
    *     Set to false to disable zooming on click gestures.
    *
    * @property {Boolean} dblClickToZoom
    *     Set to false to disable zooming on double-click gestures. Note: If set to true
    *     then clickToZoom should be set to false to prevent multiple zooms.
    *
    * @property {Boolean} pinchToZoom
    *     Set to false to disable zooming on pinch gestures.
    *
    * @property {Boolean} flickEnabled
    *     Set to false to disable the kinetic panning effect (flick) at the end of a drag gesture.
    *
    * @property {Number} flickMinSpeed
    *     If flickEnabled is true, the minimum speed (in pixels-per-second) required to cause the kinetic panning effect (flick) at the end of a drag gesture.
    *
    * @property {Number} flickMomentum
    *     If flickEnabled is true, a constant multiplied by the velocity to determine the distance of the kinetic panning effect (flick) at the end of a drag gesture.
    *     A larger value will make the flick feel "lighter", while a smaller value will make the flick feel "heavier".
    *     Note: springStiffness and animationTime also affect the "spring" used to stop the flick animation.
    *
    */
  
  /**
    * The names for the image resources used for the image navigation buttons.
    *
    * @typedef {Object} NavImages
    * @memberof OpenSeadragon
    *
    * @property {Object} zoomIn - Images for the zoom-in button.
    * @property {String} zoomIn.REST
    * @property {String} zoomIn.GROUP
    * @property {String} zoomIn.HOVER
    * @property {String} zoomIn.DOWN
    *
    * @property {Object} zoomOut - Images for the zoom-out button.
    * @property {String} zoomOut.REST
    * @property {String} zoomOut.GROUP
    * @property {String} zoomOut.HOVER
    * @property {String} zoomOut.DOWN
    *
    * @property {Object} home - Images for the home button.
    * @property {String} home.REST
    * @property {String} home.GROUP
    * @property {String} home.HOVER
    * @property {String} home.DOWN
    *
    * @property {Object} fullpage - Images for the full-page button.
    * @property {String} fullpage.REST
    * @property {String} fullpage.GROUP
    * @property {String} fullpage.HOVER
    * @property {String} fullpage.DOWN
    *
    * @property {Object} rotateleft - Images for the rotate left button.
    * @property {String} rotateleft.REST
    * @property {String} rotateleft.GROUP
    * @property {String} rotateleft.HOVER
    * @property {String} rotateleft.DOWN
    *
    * @property {Object} rotateright - Images for the rotate right button.
    * @property {String} rotateright.REST
    * @property {String} rotateright.GROUP
    * @property {String} rotateright.HOVER
    * @property {String} rotateright.DOWN
    *
    * @property {Object} flip - Images for the flip button.
    * @property {String} flip.REST
    * @property {String} flip.GROUP
    * @property {String} flip.HOVER
    * @property {String} flip.DOWN
    *
    * @property {Object} previous - Images for the previous button.
    * @property {String} previous.REST
    * @property {String} previous.GROUP
    * @property {String} previous.HOVER
    * @property {String} previous.DOWN
    *
    * @property {Object} next - Images for the next button.
    * @property {String} next.REST
    * @property {String} next.GROUP
    * @property {String} next.HOVER
    * @property {String} next.DOWN
    *
    */
  
  /* eslint-disable no-redeclare */
  
  function OpenSeadragon( options ){
      return new OpenSeadragon.Viewer( options );
  }
  
  (function( $ ){
  
  
      /**
       * The OpenSeadragon version.
       *
       * @member {Object} OpenSeadragon.version
       * @property {String} versionStr - The version number as a string ('major.minor.revision').
       * @property {Number} major - The major version number.
       * @property {Number} minor - The minor version number.
       * @property {Number} revision - The revision number.
       * @since 1.0.0
       */
      $.version = {
          versionStr: '2.4.2',
          major: parseInt('2', 10),
          minor: parseInt('4', 10),
          revision: parseInt('2', 10)
      };
  
  
      /**
       * Taken from jquery 1.6.1
       * [[Class]] -> type pairs
       * @private
       */
      var class2type = {
              '[object Boolean]':     'boolean',
              '[object Number]':      'number',
              '[object String]':      'string',
              '[object Function]':    'function',
              '[object Array]':       'array',
              '[object Date]':        'date',
              '[object RegExp]':      'regexp',
              '[object Object]':      'object'
          },
          // Save a reference to some core methods
          toString    = Object.prototype.toString,
          hasOwn      = Object.prototype.hasOwnProperty;
  
      /**
       * Taken from jQuery 1.6.1
       * @function isFunction
       * @memberof OpenSeadragon
       * @see {@link http://www.jquery.com/ jQuery}
       */
      $.isFunction = function( obj ) {
          return $.type(obj) === "function";
      };
  
  
      /**
       * Taken from jQuery 1.6.1
       * @function isArray
       * @memberof OpenSeadragon
       * @see {@link http://www.jquery.com/ jQuery}
       */
      $.isArray = Array.isArray || function( obj ) {
          return $.type(obj) === "array";
      };
  
  
      /**
       * A crude way of determining if an object is a window.
       * Taken from jQuery 1.6.1
       * @function isWindow
       * @memberof OpenSeadragon
       * @see {@link http://www.jquery.com/ jQuery}
       */
      $.isWindow = function( obj ) {
          return obj && typeof obj === "object" && "setInterval" in obj;
      };
  
  
      /**
       * Taken from jQuery 1.6.1
       * @function type
       * @memberof OpenSeadragon
       * @see {@link http://www.jquery.com/ jQuery}
       */
      $.type = function( obj ) {
          return ( obj === null ) || ( obj === undefined ) ?
              String( obj ) :
              class2type[ toString.call(obj) ] || "object";
      };
  
  
      /**
       * Taken from jQuery 1.6.1
       * @function isPlainObject
       * @memberof OpenSeadragon
       * @see {@link http://www.jquery.com/ jQuery}
       */
      $.isPlainObject = function( obj ) {
          // Must be an Object.
          // Because of IE, we also have to check the presence of the constructor property.
          // Make sure that DOM nodes and window objects don't pass through, as well
          if ( !obj || OpenSeadragon.type(obj) !== "object" || obj.nodeType || $.isWindow( obj ) ) {
              return false;
          }
  
          // Not own constructor property must be Object
          if ( obj.constructor &&
              !hasOwn.call(obj, "constructor") &&
              !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
              return false;
          }
  
          // Own properties are enumerated firstly, so to speed up,
          // if last one is own, then all properties are own.
  
          var lastKey;
          for (var key in obj ) {
              lastKey = key;
          }
  
          return lastKey === undefined || hasOwn.call( obj, lastKey );
      };
  
  
      /**
       * Taken from jQuery 1.6.1
       * @function isEmptyObject
       * @memberof OpenSeadragon
       * @see {@link http://www.jquery.com/ jQuery}
       */
      $.isEmptyObject = function( obj ) {
          for ( var name in obj ) {
              return false;
          }
          return true;
      };
  
      /**
       * Shim around Object.freeze. Does nothing if Object.freeze is not supported.
       * @param {Object} obj The object to freeze.
       * @return {Object} obj The frozen object.
       */
      $.freezeObject = function(obj) {
          if (Object.freeze) {
              $.freezeObject = Object.freeze;
          } else {
              $.freezeObject = function(obj) {
                  return obj;
              };
          }
          return $.freezeObject(obj);
      };
  
      /**
       * True if the browser supports the HTML5 canvas element
       * @member {Boolean} supportsCanvas
       * @memberof OpenSeadragon
       */
      $.supportsCanvas = (function () {
          var canvasElement = document.createElement( 'canvas' );
          return !!( $.isFunction( canvasElement.getContext ) &&
                      canvasElement.getContext( '2d' ) );
      }());
  
      /**
       * Test whether the submitted canvas is tainted or not.
       * @argument {Canvas} canvas The canvas to test.
       * @returns {Boolean} True if the canvas is tainted.
       */
      $.isCanvasTainted = function(canvas) {
          var isTainted = false;
          try {
              // We test if the canvas is tainted by retrieving data from it.
              // An exception will be raised if the canvas is tainted.
              canvas.getContext('2d').getImageData(0, 0, 1, 1);
          } catch (e) {
              isTainted = true;
          }
          return isTainted;
      };
  
      /**
       * A ratio comparing the device screen's pixel density to the canvas's backing store pixel density,
       * clamped to a minimum of 1. Defaults to 1 if canvas isn't supported by the browser.
       * @member {Number} pixelDensityRatio
       * @memberof OpenSeadragon
       */
      $.pixelDensityRatio = (function () {
          if ( $.supportsCanvas ) {
              var context = document.createElement('canvas').getContext('2d');
              var devicePixelRatio = window.devicePixelRatio || 1;
              var backingStoreRatio = context.webkitBackingStorePixelRatio ||
                                      context.mozBackingStorePixelRatio ||
                                      context.msBackingStorePixelRatio ||
                                      context.oBackingStorePixelRatio ||
                                      context.backingStorePixelRatio || 1;
              return Math.max(devicePixelRatio, 1) / backingStoreRatio;
          } else {
              return 1;
          }
      }());
  
  }( OpenSeadragon ));
  
  /**
   *  This closure defines all static methods available to the OpenSeadragon
   *  namespace.  Many, if not most, are taked directly from jQuery for use
   *  to simplify and reduce common programming patterns.  More static methods
   *  from jQuery may eventually make their way into this though we are
   *  attempting to avoid an explicit dependency on jQuery only because
   *  OpenSeadragon is a broadly useful code base and would be made less broad
   *  by requiring jQuery fully.
   *
   *  Some static methods have also been refactored from the original OpenSeadragon
   *  project.
   */
  (function( $ ){
  
      /**
       * Taken from jQuery 1.6.1
       * @function extend
       * @memberof OpenSeadragon
       * @see {@link http://www.jquery.com/ jQuery}
       */
      $.extend = function() {
          var options,
              name,
              src,
              copy,
              copyIsArray,
              clone,
              target  = arguments[ 0 ] || {},
              length  = arguments.length,
              deep    = false,
              i       = 1;
  
          // Handle a deep copy situation
          if ( typeof target === "boolean" ) {
              deep    = target;
              target  = arguments[ 1 ] || {};
              // skip the boolean and the target
              i = 2;
          }
  
          // Handle case when target is a string or something (possible in deep copy)
          if ( typeof target !== "object" && !OpenSeadragon.isFunction( target ) ) {
              target = {};
          }
  
          // extend jQuery itself if only one argument is passed
          if ( length === i ) {
              target = this;
              --i;
          }
  
          for ( ; i < length; i++ ) {
              // Only deal with non-null/undefined values
              options = arguments[ i ];
              if ( options !== null || options !== undefined ) {
                  // Extend the base object
                  for ( name in options ) {
                      src = target[ name ];
                      copy = options[ name ];
  
                      // Prevent never-ending loop
                      if ( target === copy ) {
                          continue;
                      }
  
                      // Recurse if we're merging plain objects or arrays
                      if ( deep && copy && ( OpenSeadragon.isPlainObject( copy ) || ( copyIsArray = OpenSeadragon.isArray( copy ) ) ) ) {
                          if ( copyIsArray ) {
                              copyIsArray = false;
                              clone = src && OpenSeadragon.isArray( src ) ? src : [];
  
                          } else {
                              clone = src && OpenSeadragon.isPlainObject( src ) ? src : {};
                          }
  
                          // Never move original objects, clone them
                          target[ name ] = OpenSeadragon.extend( deep, clone, copy );
  
                      // Don't bring in undefined values
                      } else if ( copy !== undefined ) {
                          target[ name ] = copy;
                      }
                  }
              }
          }
  
          // Return the modified object
          return target;
      };
  
      var isIOSDevice = function () {
          if (typeof navigator !== 'object') {
              return false;
          }
          var userAgent = navigator.userAgent;
          if (typeof userAgent !== 'string') {
              return false;
          }
          return userAgent.indexOf('iPhone') !== -1 ||
                 userAgent.indexOf('iPad') !== -1 ||
                 userAgent.indexOf('iPod') !== -1;
      };
  
      $.extend( $, /** @lends OpenSeadragon */{
          /**
           * The default values for the optional settings documented at {@link OpenSeadragon.Options}.
           * @static
           * @type {Object}
           */
          DEFAULT_SETTINGS: {
              //DATA SOURCE DETAILS
              xmlPath:                null,
              tileSources:            null,
              tileHost:               null,
              initialPage:            0,
              crossOriginPolicy:      false,
              ajaxWithCredentials:    false,
              loadTilesWithAjax:      false,
              ajaxHeaders:            {},
  
              //PAN AND ZOOM SETTINGS AND CONSTRAINTS
              panHorizontal:          true,
              panVertical:            true,
              constrainDuringPan:     false,
              wrapHorizontal:         false,
              wrapVertical:           false,
              visibilityRatio:        0.5, //-> how much of the viewer can be negative space
              minPixelRatio:          0.5, //->closer to 0 draws tiles meant for a higher zoom at this zoom
              defaultZoomLevel:       0,
              minZoomLevel:           null,
              maxZoomLevel:           null,
              homeFillsViewer:        false,
  
              //UI RESPONSIVENESS AND FEEL
              clickTimeThreshold:     300,
              clickDistThreshold:     5,
              dblClickTimeThreshold:  300,
              dblClickDistThreshold:  20,
              springStiffness:        6.5,
              animationTime:          1.2,
              gestureSettingsMouse:   {
                  scrollToZoom: true,
                  clickToZoom: true,
                  dblClickToZoom: false,
                  pinchToZoom: false,
                  zoomToRefPoint: true,
                  flickEnabled: false,
                  flickMinSpeed: 120,
                  flickMomentum: 0.25,
                  pinchRotate: false
              },
              gestureSettingsTouch:   {
                  scrollToZoom: false,
                  clickToZoom: false,
                  dblClickToZoom: true,
                  pinchToZoom: true,
                  zoomToRefPoint: true,
                  flickEnabled: true,
                  flickMinSpeed: 120,
                  flickMomentum: 0.25,
                  pinchRotate: false
              },
              gestureSettingsPen:     {
                  scrollToZoom: false,
                  clickToZoom: true,
                  dblClickToZoom: false,
                  pinchToZoom: false,
                  zoomToRefPoint: true,
                  flickEnabled: false,
                  flickMinSpeed: 120,
                  flickMomentum: 0.25,
                  pinchRotate: false
              },
              gestureSettingsUnknown: {
                  scrollToZoom: false,
                  clickToZoom: false,
                  dblClickToZoom: true,
                  pinchToZoom: true,
                  zoomToRefPoint: true,
                  flickEnabled: true,
                  flickMinSpeed: 120,
                  flickMomentum: 0.25,
                  pinchRotate: false
              },
              zoomPerClick:           2,
              zoomPerScroll:          1.2,
              zoomPerSecond:          1.0,
              blendTime:              0,
              alwaysBlend:            false,
              autoHideControls:       true,
              immediateRender:        false,
              minZoomImageRatio:      0.9, //-> closer to 0 allows zoom out to infinity
              maxZoomPixelRatio:      1.1, //-> higher allows 'over zoom' into pixels
              smoothTileEdgesMinZoom: 1.1, //-> higher than maxZoomPixelRatio disables it
              iOSDevice:              isIOSDevice(),
              pixelsPerWheelLine:     40,
              pixelsPerArrowPress:    40,
              autoResize:             true,
              preserveImageSizeOnResize: false, // requires autoResize=true
              minScrollDeltaTime:     50,
              rotationIncrement:      90,
  
              //DEFAULT CONTROL SETTINGS
              showSequenceControl:     true,  //SEQUENCE
              sequenceControlAnchor:   null,  //SEQUENCE
              preserveViewport:        false, //SEQUENCE
              preserveOverlays:        false, //SEQUENCE
              navPrevNextWrap:         false, //SEQUENCE
              showNavigationControl:   true,  //ZOOM/HOME/FULL/ROTATION
              navigationControlAnchor: null,  //ZOOM/HOME/FULL/ROTATION
              showZoomControl:         true,  //ZOOM
              showHomeControl:         true,  //HOME
              showFullPageControl:     true,  //FULL
              showRotationControl:     false, //ROTATION
              showFlipControl:         false,  //FLIP
              controlsFadeDelay:       2000,  //ZOOM/HOME/FULL/SEQUENCE
              controlsFadeLength:      1500,  //ZOOM/HOME/FULL/SEQUENCE
              mouseNavEnabled:         true,  //GENERAL MOUSE INTERACTIVITY
  
              //VIEWPORT NAVIGATOR SETTINGS
              showNavigator:              false,
              navigatorId:                null,
              navigatorPosition:          null,
              navigatorSizeRatio:         0.2,
              navigatorMaintainSizeRatio: false,
              navigatorTop:               null,
              navigatorLeft:              null,
              navigatorHeight:            null,
              navigatorWidth:             null,
              navigatorAutoResize:        true,
              navigatorAutoFade:          true,
              navigatorRotate:            true,
              navigatorBackground:        '#000',
              navigatorOpacity:           0.8,
              navigatorBorderColor:       '#555',
              navigatorDisplayRegionColor: '#900',
  
              // INITIAL ROTATION
              degrees:                    0,
  
              // INITIAL FLIP STATE
              flipped:                    false,
  
              // APPEARANCE
              opacity:                    1,
              preload:                    false,
              compositeOperation:         null,
              imageSmoothingEnabled:      true,
              placeholderFillStyle:       null,
  
              //REFERENCE STRIP SETTINGS
              showReferenceStrip:          false,
              referenceStripScroll:       'horizontal',
              referenceStripElement:       null,
              referenceStripHeight:        null,
              referenceStripWidth:         null,
              referenceStripPosition:      'BOTTOM_LEFT',
              referenceStripSizeRatio:     0.2,
  
              //COLLECTION VISUALIZATION SETTINGS
              collectionRows:         3, //or columns depending on layout
              collectionColumns:      0, //columns in horizontal layout, rows in vertical layout
              collectionLayout:       'horizontal', //vertical
              collectionMode:         false,
              collectionTileSize:     800,
              collectionTileMargin:   80,
  
              //PERFORMANCE SETTINGS
              imageLoaderLimit:       0,
              maxImageCacheCount:     200,
              timeout:                30000,
              useCanvas:              true,  // Use canvas element for drawing if available
  
              //INTERFACE RESOURCE SETTINGS
              prefixUrl:              "/images/",
              navImages: {
                  zoomIn: {
                      REST:   'zoomin_rest.png',
                      GROUP:  'zoomin_grouphover.png',
                      HOVER:  'zoomin_hover.png',
                      DOWN:   'zoomin_pressed.png'
                  },
                  zoomOut: {
                      REST:   'zoomout_rest.png',
                      GROUP:  'zoomout_grouphover.png',
                      HOVER:  'zoomout_hover.png',
                      DOWN:   'zoomout_pressed.png'
                  },
                  home: {
                      REST:   'home_rest.png',
                      GROUP:  'home_grouphover.png',
                      HOVER:  'home_hover.png',
                      DOWN:   'home_pressed.png'
                  },
                  fullpage: {
                      REST:   'fullpage_rest.png',
                      GROUP:  'fullpage_grouphover.png',
                      HOVER:  'fullpage_hover.png',
                      DOWN:   'fullpage_pressed.png'
                  },
                  rotateleft: {
                      REST:   'rotateleft_rest.png',
                      GROUP:  'rotateleft_grouphover.png',
                      HOVER:  'rotateleft_hover.png',
                      DOWN:   'rotateleft_pressed.png'
                  },
                  rotateright: {
                      REST:   'rotateright_rest.png',
                      GROUP:  'rotateright_grouphover.png',
                      HOVER:  'rotateright_hover.png',
                      DOWN:   'rotateright_pressed.png'
                  },
                  flip: { // Flip icon designed by Yaroslav Samoylov from the Noun Project and modified by Nelson Campos ncampos@criteriamarathon.com, https://thenounproject.com/term/flip/136289/
                      REST:   'flip_rest.png',
                      GROUP:  'flip_grouphover.png',
                      HOVER:  'flip_hover.png',
                      DOWN:   'flip_pressed.png'
                  },
                  previous: {
                      REST:   'previous_rest.png',
                      GROUP:  'previous_grouphover.png',
                      HOVER:  'previous_hover.png',
                      DOWN:   'previous_pressed.png'
                  },
                  next: {
                      REST:   'next_rest.png',
                      GROUP:  'next_grouphover.png',
                      HOVER:  'next_hover.png',
                      DOWN:   'next_pressed.png'
                  }
              },
  
              //DEVELOPER SETTINGS
              debugMode:              false,
              debugGridColor:         ['#437AB2', '#1B9E77', '#D95F02', '#7570B3', '#E7298A', '#66A61E', '#E6AB02', '#A6761D', '#666666']
          },
  
  
          /**
           * TODO: get rid of this.  I can't see how it's required at all.  Looks
           *       like an early legacy code artifact.
           * @static
           * @ignore
           */
          SIGNAL: "----seadragon----",
  
  
          /**
           * Returns a function which invokes the method as if it were a method belonging to the object.
           * @function
           * @param {Object} object
           * @param {Function} method
           * @returns {Function}
           */
          delegate: function( object, method ) {
              return function(){
                  var args = arguments;
                  if ( args === undefined ){
                      args = [];
                  }
                  return method.apply( object, args );
              };
          },
  
  
          /**
           * An enumeration of Browser vendors.
           * @static
           * @type {Object}
           * @property {Number} UNKNOWN
           * @property {Number} IE
           * @property {Number} FIREFOX
           * @property {Number} SAFARI
           * @property {Number} CHROME
           * @property {Number} OPERA
           */
          BROWSERS: {
              UNKNOWN:    0,
              IE:         1,
              FIREFOX:    2,
              SAFARI:     3,
              CHROME:     4,
              OPERA:      5
          },
  
  
          /**
           * Returns a DOM Element for the given id or element.
           * @function
           * @param {String|Element} element Accepts an id or element.
           * @returns {Element} The element with the given id, null, or the element itself.
           */
          getElement: function( element ) {
              if ( typeof ( element ) == "string" ) {
                  element = document.getElementById( element );
              }
              return element;
          },
  
  
          /**
           * Determines the position of the upper-left corner of the element.
           * @function
           * @param {Element|String} element - the element we want the position for.
           * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element.
           */
          getElementPosition: function( element ) {
              var result = new $.Point(),
                  isFixed,
                  offsetParent;
  
              element      = $.getElement( element );
              isFixed      = $.getElementStyle( element ).position == "fixed";
              offsetParent = getOffsetParent( element, isFixed );
  
              while ( offsetParent ) {
  
                  result.x += element.offsetLeft;
                  result.y += element.offsetTop;
  
                  if ( isFixed ) {
                      result = result.plus( $.getPageScroll() );
                  }
  
                  element = offsetParent;
                  isFixed = $.getElementStyle( element ).position == "fixed";
                  offsetParent = getOffsetParent( element, isFixed );
              }
  
              return result;
          },
  
  
          /**
           * Determines the position of the upper-left corner of the element adjusted for current page and/or element scroll.
           * @function
           * @param {Element|String} element - the element we want the position for.
           * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element adjusted for current page and/or element scroll.
           */
          getElementOffset: function( element ) {
              element = $.getElement( element );
  
              var doc = element && element.ownerDocument,
                  docElement,
                  win,
                  boundingRect = { top: 0, left: 0 };
  
              if ( !doc ) {
                  return new $.Point();
              }
  
              docElement = doc.documentElement;
  
              if ( typeof element.getBoundingClientRect !== typeof undefined ) {
                  boundingRect = element.getBoundingClientRect();
              }
  
              win = ( doc == doc.window ) ?
                  doc :
                  ( doc.nodeType === 9 ) ?
                      doc.defaultView || doc.parentWindow :
                      false;
  
              return new $.Point(
                  boundingRect.left + ( win.pageXOffset || docElement.scrollLeft ) - ( docElement.clientLeft || 0 ),
                  boundingRect.top + ( win.pageYOffset || docElement.scrollTop ) - ( docElement.clientTop || 0 )
              );
          },
  
  
          /**
           * Determines the height and width of the given element.
           * @function
           * @param {Element|String} element
           * @returns {OpenSeadragon.Point}
           */
          getElementSize: function( element ) {
              element = $.getElement( element );
  
              return new $.Point(
                  element.clientWidth,
                  element.clientHeight
              );
          },
  
  
          /**
           * Returns the CSSStyle object for the given element.
           * @function
           * @param {Element|String} element
           * @returns {CSSStyle}
           */
          getElementStyle:
              document.documentElement.currentStyle ?
              function( element ) {
                  element = $.getElement( element );
                  return element.currentStyle;
              } :
              function( element ) {
                  element = $.getElement( element );
                  return window.getComputedStyle( element, "" );
              },
  
          /**
           * Returns the property with the correct vendor prefix appended.
           * @param {String} property the property name
           * @returns {String} the property with the correct prefix or null if not
           * supported.
           */
          getCssPropertyWithVendorPrefix: function(property) {
              var memo = {};
  
              $.getCssPropertyWithVendorPrefix = function(property) {
                  if (memo[property] !== undefined) {
                      return memo[property];
                  }
                  var style = document.createElement('div').style;
                  var result = null;
                  if (style[property] !== undefined) {
                      result = property;
                  } else {
                      var prefixes = ['Webkit', 'Moz', 'MS', 'O',
                          'webkit', 'moz', 'ms', 'o'];
                      var suffix = $.capitalizeFirstLetter(property);
                      for (var i = 0; i < prefixes.length; i++) {
                          var prop = prefixes[i] + suffix;
                          if (style[prop] !== undefined) {
                              result = prop;
                              break;
                          }
                      }
                  }
                  memo[property] = result;
                  return result;
              };
              return $.getCssPropertyWithVendorPrefix(property);
          },
  
          /**
           * Capitalizes the first letter of a string
           * @param {String} string
           * @returns {String} The string with the first letter capitalized
           */
          capitalizeFirstLetter: function(string) {
              return string.charAt(0).toUpperCase() + string.slice(1);
          },
  
          /**
           * Compute the modulo of a number but makes sure to always return
           * a positive value.
           * @param {Number} number the number to computes the modulo of
           * @param {Number} modulo the modulo
           * @returns {Number} the result of the modulo of number
           */
          positiveModulo: function(number, modulo) {
              var result = number % modulo;
              if (result < 0) {
                  result += modulo;
              }
              return result;
          },
  
          /**
           * Determines if a point is within the bounding rectangle of the given element (hit-test).
           * @function
           * @param {Element|String} element
           * @param {OpenSeadragon.Point} point
           * @returns {Boolean}
           */
          pointInElement: function( element, point ) {
              element = $.getElement( element );
              var offset = $.getElementOffset( element ),
                  size = $.getElementSize( element );
              return point.x >= offset.x && point.x < offset.x + size.x && point.y < offset.y + size.y && point.y >= offset.y;
          },
  
  
          /**
           * Gets the latest event, really only useful internally since its
           * specific to IE behavior.
           * @function
           * @param {Event} [event]
           * @returns {Event}
           * @deprecated For internal use only
           * @private
           */
          getEvent: function( event ) {
              if( event ){
                  $.getEvent = function( event ) {
                      return event;
                  };
              } else {
                  $.getEvent = function() {
                      return window.event;
                  };
              }
              return $.getEvent( event );
          },
  
  
          /**
           * Gets the position of the mouse on the screen for a given event.
           * @function
           * @param {Event} [event]
           * @returns {OpenSeadragon.Point}
           */
          getMousePosition: function( event ) {
  
              if ( typeof ( event.pageX ) == "number" ) {
                  $.getMousePosition = function( event ){
                      var result = new $.Point();
  
                      event = $.getEvent( event );
                      result.x = event.pageX;
                      result.y = event.pageY;
  
                      return result;
                  };
              } else if ( typeof ( event.clientX ) == "number" ) {
                  $.getMousePosition = function( event ){
                      var result = new $.Point();
  
                      event = $.getEvent( event );
                      result.x =
                          event.clientX +
                          document.body.scrollLeft +
                          document.documentElement.scrollLeft;
                      result.y =
                          event.clientY +
                          document.body.scrollTop +
                          document.documentElement.scrollTop;
  
                      return result;
                  };
              } else {
                  throw new Error(
                      "Unknown event mouse position, no known technique."
                  );
              }
  
              return $.getMousePosition( event );
          },
  
  
          /**
           * Determines the page's current scroll position.
           * @function
           * @returns {OpenSeadragon.Point}
           */
          getPageScroll: function() {
              var docElement  = document.documentElement || {},
                  body        = document.body || {};
  
              if ( typeof ( window.pageXOffset ) == "number" ) {
                  $.getPageScroll = function(){
                      return new $.Point(
                          window.pageXOffset,
                          window.pageYOffset
                      );
                  };
              } else if ( body.scrollLeft || body.scrollTop ) {
                  $.getPageScroll = function(){
                      return new $.Point(
                          document.body.scrollLeft,
                          document.body.scrollTop
                      );
                  };
              } else if ( docElement.scrollLeft || docElement.scrollTop ) {
                  $.getPageScroll = function(){
                      return new $.Point(
                          document.documentElement.scrollLeft,
                          document.documentElement.scrollTop
                      );
                  };
              } else {
                  // We can't reassign the function yet, as there was no scroll.
                  return new $.Point(0, 0);
              }
  
              return $.getPageScroll();
          },
  
          /**
           * Set the page scroll position.
           * @function
           * @returns {OpenSeadragon.Point}
           */
          setPageScroll: function( scroll ) {
              if ( typeof ( window.scrollTo ) !== "undefined" ) {
                  $.setPageScroll = function( scroll ) {
                      window.scrollTo( scroll.x, scroll.y );
                  };
              } else {
                  var originalScroll = $.getPageScroll();
                  if ( originalScroll.x === scroll.x &&
                      originalScroll.y === scroll.y ) {
                      // We are already correctly positioned and there
                      // is no way to detect the correct method.
                      return;
                  }
  
                  document.body.scrollLeft = scroll.x;
                  document.body.scrollTop = scroll.y;
                  var currentScroll = $.getPageScroll();
                  if ( currentScroll.x !== originalScroll.x &&
                      currentScroll.y !== originalScroll.y ) {
                      $.setPageScroll = function( scroll ) {
                          document.body.scrollLeft = scroll.x;
                          document.body.scrollTop = scroll.y;
                      };
                      return;
                  }
  
                  document.documentElement.scrollLeft = scroll.x;
                  document.documentElement.scrollTop = scroll.y;
                  currentScroll = $.getPageScroll();
                  if ( currentScroll.x !== originalScroll.x &&
                      currentScroll.y !== originalScroll.y ) {
                      $.setPageScroll = function( scroll ) {
                          document.documentElement.scrollLeft = scroll.x;
                          document.documentElement.scrollTop = scroll.y;
                      };
                      return;
                  }
  
                  // We can't find anything working, so we do nothing.
                  $.setPageScroll = function( scroll ) {
                  };
              }
  
              return $.setPageScroll( scroll );
          },
  
          /**
           * Determines the size of the browsers window.
           * @function
           * @returns {OpenSeadragon.Point}
           */
          getWindowSize: function() {
              var docElement = document.documentElement || {},
                  body    = document.body || {};
  
              if ( typeof ( window.innerWidth ) == 'number' ) {
                  $.getWindowSize = function(){
                      return new $.Point(
                          window.innerWidth,
                          window.innerHeight
                      );
                  };
              } else if ( docElement.clientWidth || docElement.clientHeight ) {
                  $.getWindowSize = function(){
                      return new $.Point(
                          document.documentElement.clientWidth,
                          document.documentElement.clientHeight
                      );
                  };
              } else if ( body.clientWidth || body.clientHeight ) {
                  $.getWindowSize = function(){
                      return new $.Point(
                          document.body.clientWidth,
                          document.body.clientHeight
                      );
                  };
              } else {
                  throw new Error("Unknown window size, no known technique.");
              }
  
              return $.getWindowSize();
          },
  
  
          /**
           * Wraps the given element in a nest of divs so that the element can
           * be easily centered using CSS tables
           * @function
           * @param {Element|String} element
           * @returns {Element} outermost wrapper element
           */
          makeCenteredNode: function( element ) {
              // Convert a possible ID to an actual HTMLElement
              element = $.getElement( element );
  
              /*
                  CSS tables require you to have a display:table/row/cell hierarchy so we need to create
                  three nested wrapper divs:
               */
  
              var wrappers = [
                  $.makeNeutralElement( 'div' ),
                  $.makeNeutralElement( 'div' ),
                  $.makeNeutralElement( 'div' )
              ];
  
              // It feels like we should be able to pass style dicts to makeNeutralElement:
              $.extend(wrappers[0].style, {
                  display: "table",
                  height: "100%",
                  width: "100%"
              });
  
              $.extend(wrappers[1].style, {
                  display: "table-row"
              });
  
              $.extend(wrappers[2].style, {
                  display: "table-cell",
                  verticalAlign: "middle",
                  textAlign: "center"
              });
  
              wrappers[0].appendChild(wrappers[1]);
              wrappers[1].appendChild(wrappers[2]);
              wrappers[2].appendChild(element);
  
              return wrappers[0];
          },
  
  
          /**
           * Creates an easily positionable element of the given type that therefor
           * serves as an excellent container element.
           * @function
           * @param {String} tagName
           * @returns {Element}
           */
          makeNeutralElement: function( tagName ) {
              var element = document.createElement( tagName ),
                  style   = element.style;
  
              style.background = "transparent none";
              style.border     = "none";
              style.margin     = "0px";
              style.padding    = "0px";
              style.position   = "static";
  
              return element;
          },
  
  
          /**
           * Returns the current milliseconds, using Date.now() if available
           * @function
           */
          now: function( ) {
              if (Date.now) {
                  $.now = Date.now;
              } else {
                  $.now = function() {
                      return new Date().getTime();
                  };
              }
  
              return $.now();
          },
  
  
          /**
           * Ensures an image is loaded correctly to support alpha transparency.
           * Generally only IE has issues doing this correctly for formats like
           * png.
           * @function
           * @param {String} src
           * @returns {Element}
           */
          makeTransparentImage: function( src ) {
  
              $.makeTransparentImage = function( src ){
                  var img = $.makeNeutralElement( "img" );
  
                  img.src = src;
  
                  return img;
              };
  
              if ( $.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 7 ) {
  
                  $.makeTransparentImage = function( src ){
                      var img     = $.makeNeutralElement( "img" ),
                          element = null;
  
                      element = $.makeNeutralElement("span");
                      element.style.display = "inline-block";
  
                      img.onload = function() {
                          element.style.width  = element.style.width || img.width + "px";
                          element.style.height = element.style.height || img.height + "px";
  
                          img.onload = null;
                          img = null;     // to prevent memory leaks in IE
                      };
  
                      img.src = src;
                      element.style.filter =
                          "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" +
                          src +
                          "', sizingMethod='scale')";
  
                      return element;
                  };
  
              }
  
              return $.makeTransparentImage( src );
          },
  
  
          /**
           * Sets the opacity of the specified element.
           * @function
           * @param {Element|String} element
           * @param {Number} opacity
           * @param {Boolean} [usesAlpha]
           */
          setElementOpacity: function( element, opacity, usesAlpha ) {
  
              var ieOpacity,
                  ieFilter;
  
              element = $.getElement( element );
  
              if ( usesAlpha && !$.Browser.alpha ) {
                  opacity = Math.round( opacity );
              }
  
              if ( $.Browser.opacity ) {
                  element.style.opacity = opacity < 1 ? opacity : "";
              } else {
                  if ( opacity < 1 ) {
                      ieOpacity = Math.round( 100 * opacity );
                      ieFilter  = "alpha(opacity=" + ieOpacity + ")";
                      element.style.filter = ieFilter;
                  } else {
                      element.style.filter = "";
                  }
              }
          },
  
  
          /**
           * Sets the specified element's touch-action style attribute to 'none'.
           * @function
           * @param {Element|String} element
           */
          setElementTouchActionNone: function( element ) {
              element = $.getElement( element );
              if ( typeof element.style.touchAction !== 'undefined' ) {
                  element.style.touchAction = 'none';
              } else if ( typeof element.style.msTouchAction !== 'undefined' ) {
                  element.style.msTouchAction = 'none';
              }
          },
  
  
          /**
           * Add the specified CSS class to the element if not present.
           * @function
           * @param {Element|String} element
           * @param {String} className
           */
          addClass: function( element, className ) {
              element = $.getElement( element );
  
              if (!element.className) {
                  element.className = className;
              } else if ( ( ' ' + element.className + ' ' ).
                  indexOf( ' ' + className + ' ' ) === -1 ) {
                  element.className += ' ' + className;
              }
          },
  
          /**
           * Find the first index at which an element is found in an array or -1
           * if not present.
           *
           * Code taken and adapted from
           * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Compatibility
           *
           * @function
           * @param {Array} array The array from which to find the element
           * @param {Object} searchElement The element to find
           * @param {Number} [fromIndex=0] Index to start research.
           * @returns {Number} The index of the element in the array.
           */
          indexOf: function( array, searchElement, fromIndex ) {
              if ( Array.prototype.indexOf ) {
                  this.indexOf = function( array, searchElement, fromIndex ) {
                      return array.indexOf( searchElement, fromIndex );
                  };
              } else {
                  this.indexOf = function( array, searchElement, fromIndex ) {
                      var i,
                          pivot = ( fromIndex ) ? fromIndex : 0,
                          length;
                      if ( !array ) {
                          throw new TypeError( );
                      }
  
                      length = array.length;
                      if ( length === 0 || pivot >= length ) {
                          return -1;
                      }
  
                      if ( pivot < 0 ) {
                          pivot = length - Math.abs( pivot );
                      }
  
                      for ( i = pivot; i < length; i++ ) {
                          if ( array[i] === searchElement ) {
                              return i;
                          }
                      }
                      return -1;
                  };
              }
              return this.indexOf( array, searchElement, fromIndex );
          },
  
          /**
           * Remove the specified CSS class from the element.
           * @function
           * @param {Element|String} element
           * @param {String} className
           */
          removeClass: function( element, className ) {
              var oldClasses,
                  newClasses = [],
                  i;
  
              element = $.getElement( element );
              oldClasses = element.className.split( /\s+/ );
              for ( i = 0; i < oldClasses.length; i++ ) {
                  if ( oldClasses[ i ] && oldClasses[ i ] !== className ) {
                      newClasses.push( oldClasses[ i ] );
                  }
              }
              element.className = newClasses.join(' ');
          },
  
  
          /**
           * Adds an event listener for the given element, eventName and handler.
           * @function
           * @param {Element|String} element
           * @param {String} eventName
           * @param {Function} handler
           * @param {Boolean} [useCapture]
           */
          addEvent: (function () {
              if ( window.addEventListener ) {
                  return function ( element, eventName, handler, useCapture ) {
                      element = $.getElement( element );
                      element.addEventListener( eventName, handler, useCapture );
                  };
              } else if ( window.attachEvent ) {
                  return function ( element, eventName, handler, useCapture ) {
                      element = $.getElement( element );
                      element.attachEvent( 'on' + eventName, handler );
                  };
              } else {
                  throw new Error( "No known event model." );
              }
          }()),
  
  
          /**
           * Remove a given event listener for the given element, event type and
           * handler.
           * @function
           * @param {Element|String} element
           * @param {String} eventName
           * @param {Function} handler
           * @param {Boolean} [useCapture]
           */
          removeEvent: (function () {
              if ( window.removeEventListener ) {
                  return function ( element, eventName, handler, useCapture ) {
                      element = $.getElement( element );
                      element.removeEventListener( eventName, handler, useCapture );
                  };
              } else if ( window.detachEvent ) {
                  return function( element, eventName, handler, useCapture ) {
                      element = $.getElement( element );
                      element.detachEvent( 'on' + eventName, handler );
                  };
              } else {
                  throw new Error( "No known event model." );
              }
          }()),
  
  
          /**
           * Cancels the default browser behavior had the event propagated all
           * the way up the DOM to the window object.
           * @function
           * @param {Event} [event]
           */
          cancelEvent: function( event ) {
              event = $.getEvent( event );
  
              if ( event.preventDefault ) {
                  $.cancelEvent = function( event ){
                      // W3C for preventing default
                      event.preventDefault();
                  };
              } else {
                  $.cancelEvent = function( event ){
                      event = $.getEvent( event );
                      // legacy for preventing default
                      event.cancel = true;
                      // IE for preventing default
                      event.returnValue = false;
                  };
              }
              $.cancelEvent( event );
          },
  
  
          /**
           * Stops the propagation of the event up the DOM.
           * @function
           * @param {Event} [event]
           */
          stopEvent: function( event ) {
              event = $.getEvent( event );
  
              if ( event.stopPropagation ) {
                  // W3C for stopping propagation
                  $.stopEvent = function( event ){
                      event.stopPropagation();
                  };
              } else {
                  // IE for stopping propagation
                  $.stopEvent = function( event ){
                      event = $.getEvent( event );
                      event.cancelBubble = true;
                  };
  
              }
  
              $.stopEvent( event );
          },
  
  
          /**
           * Similar to OpenSeadragon.delegate, but it does not immediately call
           * the method on the object, returning a function which can be called
           * repeatedly to delegate the method. It also allows additional arguments
           * to be passed during construction which will be added during each
           * invocation, and each invocation can add additional arguments as well.
           *
           * @function
           * @param {Object} object
           * @param {Function} method
           * @param [args] any additional arguments are passed as arguments to the
           *  created callback
           * @returns {Function}
           */
          createCallback: function( object, method ) {
              //TODO: This pattern is painful to use and debug.  It's much cleaner
              //      to use pinning plus anonymous functions.  Get rid of this
              //      pattern!
              var initialArgs = [],
                  i;
              for ( i = 2; i < arguments.length; i++ ) {
                  initialArgs.push( arguments[ i ] );
              }
  
              return function() {
                  var args = initialArgs.concat( [] ),
                      i;
                  for ( i = 0; i < arguments.length; i++ ) {
                      args.push( arguments[ i ] );
                  }
  
                  return method.apply( object, args );
              };
          },
  
  
          /**
           * Retrieves the value of a url parameter from the window.location string.
           * @function
           * @param {String} key
           * @returns {String} The value of the url parameter or null if no param matches.
           */
          getUrlParameter: function( key ) {
              // eslint-disable-next-line no-use-before-define
              var value = URLPARAMS[ key ];
              return value ? value : null;
          },
  
          /**
           * Retrieves the protocol used by the url. The url can either be absolute
           * or relative.
           * @function
           * @private
           * @param {String} url The url to retrieve the protocol from.
           * @return {String} The protocol (http:, https:, file:, ftp: ...)
           */
          getUrlProtocol: function( url ) {
              var match = url.match(/^([a-z]+:)\/\//i);
              if ( match === null ) {
                  // Relative URL, retrive the protocol from window.location
                  return window.location.protocol;
              }
              return match[1].toLowerCase();
          },
  
          /**
           * Create an XHR object
           * @private
           * @param {type} [local] If set to true, the XHR will be file: protocol
           * compatible if possible (but may raise a warning in the browser).
           * @returns {XMLHttpRequest}
           */
          createAjaxRequest: function( local ) {
              // IE11 does not support window.ActiveXObject so we just try to
              // create one to see if it is supported.
              // See: http://msdn.microsoft.com/en-us/library/ie/dn423948%28v=vs.85%29.aspx
              var supportActiveX;
              try {
                  /* global ActiveXObject:true */
                  supportActiveX = !!new ActiveXObject( "Microsoft.XMLHTTP" );
              } catch( e ) {
                  supportActiveX = false;
              }
  
              if ( supportActiveX ) {
                  if ( window.XMLHttpRequest ) {
                      $.createAjaxRequest = function( local ) {
                          if ( local ) {
                              return new ActiveXObject( "Microsoft.XMLHTTP" );
                          }
                          return new XMLHttpRequest();
                      };
                  } else {
                      $.createAjaxRequest = function() {
                          return new ActiveXObject( "Microsoft.XMLHTTP" );
                      };
                  }
              } else if ( window.XMLHttpRequest ) {
                  $.createAjaxRequest = function() {
                      return new XMLHttpRequest();
                  };
              } else {
                  throw new Error( "Browser doesn't support XMLHttpRequest." );
              }
              return $.createAjaxRequest( local );
          },
  
          /**
           * Makes an AJAX request.
           * @param {Object} options
           * @param {String} options.url - the url to request
           * @param {Function} options.success - a function to call on a successful response
           * @param {Function} options.error - a function to call on when an error occurs
           * @param {Object} options.headers - headers to add to the AJAX request
           * @param {String} options.responseType - the response type of the the AJAX request
           * @param {Boolean} [options.withCredentials=false] - whether to set the XHR's withCredentials
           * @throws {Error}
           * @returns {XMLHttpRequest}
           */
          makeAjaxRequest: function( url, onSuccess, onError ) {
              var withCredentials;
              var headers;
              var responseType;
  
              // Note that our preferred API is that you pass in a single object; the named
              // arguments are for legacy support.
              if( $.isPlainObject( url ) ){
                  onSuccess = url.success;
                  onError = url.error;
                  withCredentials = url.withCredentials;
                  headers = url.headers;
                  responseType = url.responseType || null;
                  url = url.url;
              }
  
              var protocol = $.getUrlProtocol( url );
              var request = $.createAjaxRequest( protocol === "file:" );
  
              if ( !$.isFunction( onSuccess ) ) {
                  throw new Error( "makeAjaxRequest requires a success callback" );
              }
  
              request.onreadystatechange = function() {
                  // 4 = DONE (https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#Properties)
                  if ( request.readyState == 4 ) {
                      request.onreadystatechange = function(){};
  
                      // With protocols other than http/https, a successful request status is in
                      // the 200's on Firefox and 0 on other browsers
                      if ( (request.status >= 200 && request.status < 300) ||
                          ( request.status === 0 &&
                            protocol !== "http:" &&
                            protocol !== "https:" )) {
                          onSuccess( request );
                      } else {
                          $.console.log( "AJAX request returned %d: %s", request.status, url );
  
                          if ( $.isFunction( onError ) ) {
                              onError( request );
                          }
                      }
                  }
              };
  
              try {
                  request.open( "GET", url, true );
  
                  if (responseType) {
                      request.responseType = responseType;
                  }
  
                  if (headers) {
                      for (var headerName in headers) {
                          if (Object.prototype.hasOwnProperty.call(headers, headerName) && headers[headerName]) {
                              request.setRequestHeader(headerName, headers[headerName]);
                          }
                      }
                  }
  
                  if (withCredentials) {
                      request.withCredentials = true;
                  }
  
                  request.send(null);
              } catch (e) {
                  var msg = e.message;
  
                  /*
                      IE < 10 does not support CORS and an XHR request to a different origin will fail as soon
                      as send() is called. This is particularly easy to miss during development and appear in
                      production if you use a CDN or domain sharding and the security policy is likely to break
                      exception handlers since any attempt to access a property of the request object will
                      raise an access denied TypeError inside the catch block.
  
                      To be friendlier, we'll check for this specific error and add a documentation pointer
                      to point developers in the right direction. We test the exception number because IE's
                      error messages are localized.
                  */
                  var oldIE = $.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 10;
                  if ( oldIE && typeof ( e.number ) != "undefined" && e.number == -2147024891 ) {
                      msg += "\nSee http://msdn.microsoft.com/en-us/library/ms537505(v=vs.85).aspx#xdomain";
                  }
  
                  $.console.log( "%s while making AJAX request: %s", e.name, msg );
  
                  request.onreadystatechange = function(){};
  
                  if (window.XDomainRequest) { // IE9 or IE8 might as well try to use XDomainRequest
                      var xdr = new window.XDomainRequest();
                      if (xdr) {
                          xdr.onload = function (e) {
                              if ( $.isFunction( onSuccess ) ) {
                                  onSuccess({ // Faking an xhr object
                                      responseText: xdr.responseText,
                                      status: 200, // XDomainRequest doesn't support status codes, so we just fake one! :/
                                      statusText: 'OK'
                                  });
                              }
                          };
                          xdr.onerror = function (e) {
                              if ($.isFunction(onError)) {
                                  onError({ // Faking an xhr object
                                      responseText: xdr.responseText,
                                      status: 444, // 444 No Response
                                      statusText: 'An error happened. Due to an XDomainRequest deficiency we can not extract any information about this error. Upgrade your browser.'
                                  });
                              }
                          };
                          try {
                              xdr.open('GET', url);
                              xdr.send();
                          } catch (e2) {
                              if ( $.isFunction( onError ) ) {
                                  onError( request, e );
                              }
                          }
                      }
                  } else {
                      if ( $.isFunction( onError ) ) {
                          onError( request, e );
                      }
                  }
              }
  
              return request;
          },
  
          /**
           * Taken from jQuery 1.6.1
           * @function
           * @param {Object} options
           * @param {String} options.url
           * @param {Function} options.callback
           * @param {String} [options.param='callback'] The name of the url parameter
           *      to request the jsonp provider with.
           * @param {String} [options.callbackName=] The name of the callback to
           *      request the jsonp provider with.
           */
          jsonp: function( options ){
              var script,
                  url     = options.url,
                  head    = document.head ||
                      document.getElementsByTagName( "head" )[ 0 ] ||
                      document.documentElement,
                  jsonpCallback = options.callbackName || 'openseadragon' + $.now(),
                  previous      = window[ jsonpCallback ],
                  replace       = "$1" + jsonpCallback + "$2",
                  callbackParam = options.param || 'callback',
                  callback      = options.callback;
  
              url = url.replace( /(\=)\?(&|$)|\?\?/i, replace );
              // Add callback manually
              url += (/\?/.test( url ) ? "&" : "?") + callbackParam + "=" + jsonpCallback;
  
              // Install callback
              window[ jsonpCallback ] = function( response ) {
                  if ( !previous ){
                      try{
                          delete window[ jsonpCallback ];
                      }catch(e){
                          //swallow
                      }
                  } else {
                      window[ jsonpCallback ] = previous;
                  }
                  if( callback && $.isFunction( callback ) ){
                      callback( response );
                  }
              };
  
              script = document.createElement( "script" );
  
              //TODO: having an issue with async info requests
              if( undefined !== options.async || false !== options.async ){
                  script.async = "async";
              }
  
              if ( options.scriptCharset ) {
                  script.charset = options.scriptCharset;
              }
  
              script.src = url;
  
              // Attach handlers for all browsers
              script.onload = script.onreadystatechange = function( _, isAbort ) {
  
                  if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {
  
                      // Handle memory leak in IE
                      script.onload = script.onreadystatechange = null;
  
                      // Remove the script
                      if ( head && script.parentNode ) {
                          head.removeChild( script );
                      }
  
                      // Dereference the script
                      script = undefined;
                  }
              };
              // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
              // This arises when a base node is used (#2709 and #4378).
              head.insertBefore( script, head.firstChild );
  
          },
  
  
          /**
           * Fully deprecated. Will throw an error.
           * @function
           * @deprecated use {@link OpenSeadragon.Viewer#open}
           */
          createFromDZI: function() {
              throw "OpenSeadragon.createFromDZI is deprecated, use Viewer.open.";
          },
  
          /**
           * Parses an XML string into a DOM Document.
           * @function
           * @param {String} string
           * @returns {Document}
           */
          parseXml: function( string ) {
              if ( window.DOMParser ) {
  
                  $.parseXml = function( string ) {
                      var xmlDoc = null,
                          parser;
  
                      parser = new DOMParser();
                      xmlDoc = parser.parseFromString( string, "text/xml" );
                      return xmlDoc;
                  };
  
              } else if ( window.ActiveXObject ) {
  
                  $.parseXml = function( string ) {
                      var xmlDoc = null;
  
                      xmlDoc = new ActiveXObject( "Microsoft.XMLDOM" );
                      xmlDoc.async = false;
                      xmlDoc.loadXML( string );
                      return xmlDoc;
                  };
  
              } else {
                  throw new Error( "Browser doesn't support XML DOM." );
              }
  
              return $.parseXml( string );
          },
  
          /**
           * Parses a JSON string into a Javascript object.
           * @function
           * @param {String} string
           * @returns {Object}
           */
          parseJSON: function(string) {
              if (window.JSON && window.JSON.parse) {
                  $.parseJSON = window.JSON.parse;
              } else {
                  // Should only be used by IE8 in non standards mode
                  $.parseJSON = function(string) {
                      /*jshint evil:true*/
                      //eslint-disable-next-line no-eval
                      return eval('(' + string + ')');
                  };
              }
              return $.parseJSON(string);
          },
  
          /**
           * Reports whether the image format is supported for tiling in this
           * version.
           * @function
           * @param {String} [extension]
           * @returns {Boolean}
           */
          imageFormatSupported: function( extension ) {
              extension = extension ? extension : "";
              // eslint-disable-next-line no-use-before-define
              return !!FILEFORMATS[ extension.toLowerCase() ];
          }
  
      });
  
  
      //TODO: $.console is often used inside a try/catch block which generally
      //      prevents allowings errors to occur with detection until a debugger
      //      is attached.  Although I've been guilty of the same anti-pattern
      //      I eventually was convinced that errors should naturally propagate in
      //      all but the most special cases.
      /**
       * A convenient alias for console when available, and a simple null
       * function when console is unavailable.
       * @static
       * @private
       */
      var nullfunction = function( msg ){
          //document.location.hash = msg;
      };
  
      $.console = window.console || {
          log:    nullfunction,
          debug:  nullfunction,
          info:   nullfunction,
          warn:   nullfunction,
          error:  nullfunction,
          assert: nullfunction
      };
  
  
      /**
       * The current browser vendor, version, and related information regarding detected features.
       * @member {Object} Browser
       * @memberof OpenSeadragon
       * @static
       * @type {Object}
       * @property {OpenSeadragon.BROWSERS} vendor - One of the {@link OpenSeadragon.BROWSERS} enumeration values.
       * @property {Number} version
       * @property {Boolean} alpha - Does the browser support image alpha transparency.
       */
      $.Browser = {
          vendor:     $.BROWSERS.UNKNOWN,
          version:    0,
          alpha:      true
      };
  
  
      var FILEFORMATS = {
              "bmp":  false,
              "jpeg": true,
              "jpg":  true,
              "png":  true,
              "tif":  false,
              "wdp":  false
          },
          URLPARAMS = {};
  
      (function() {
          //A small auto-executing routine to determine the browser vendor,
          //version and supporting feature sets.
          var ver = navigator.appVersion,
              ua  = navigator.userAgent,
              regex;
  
          //console.error( 'appName: ' + navigator.appName );
          //console.error( 'appVersion: ' + navigator.appVersion );
          //console.error( 'userAgent: ' + navigator.userAgent );
  
          switch( navigator.appName ){
              case "Microsoft Internet Explorer":
                  if( !!window.attachEvent &&
                      !!window.ActiveXObject ) {
  
                      $.Browser.vendor = $.BROWSERS.IE;
                      $.Browser.version = parseFloat(
                          ua.substring(
                              ua.indexOf( "MSIE" ) + 5,
                              ua.indexOf( ";", ua.indexOf( "MSIE" ) ) )
                          );
                  }
                  break;
              case "Netscape":
                  if (window.addEventListener) {
                      if ( ua.indexOf( "Firefox" ) >= 0 ) {
                          $.Browser.vendor = $.BROWSERS.FIREFOX;
                          $.Browser.version = parseFloat(
                              ua.substring( ua.indexOf( "Firefox" ) + 8 )
                          );
                      } else if ( ua.indexOf( "Safari" ) >= 0 ) {
                          $.Browser.vendor = ua.indexOf( "Chrome" ) >= 0 ?
                              $.BROWSERS.CHROME :
                              $.BROWSERS.SAFARI;
                          $.Browser.version = parseFloat(
                              ua.substring(
                                  ua.substring( 0, ua.indexOf( "Safari" ) ).lastIndexOf( "/" ) + 1,
                                  ua.indexOf( "Safari" )
                              )
                          );
                      } else {
                          regex = new RegExp( "Trident/.*rv:([0-9]{1,}[.0-9]{0,})");
                          if ( regex.exec( ua ) !== null ) {
                              $.Browser.vendor = $.BROWSERS.IE;
                              $.Browser.version = parseFloat( RegExp.$1 );
                          }
                      }
                  }
                  break;
              case "Opera":
                  $.Browser.vendor = $.BROWSERS.OPERA;
                  $.Browser.version = parseFloat( ver );
                  break;
          }
  
              // ignore '?' portion of query string
          var query = window.location.search.substring( 1 ),
              parts = query.split('&'),
              part,
              sep,
              i;
  
          for ( i = 0; i < parts.length; i++ ) {
              part = parts[ i ];
              sep  = part.indexOf( '=' );
  
              if ( sep > 0 ) {
                  var key = part.substring( 0, sep ),
                      value = part.substring( sep + 1 );
                  try {
                      URLPARAMS[ key ] = decodeURIComponent( value );
                  } catch (e) {
                      $.console.error( "Ignoring malformed URL parameter: %s=%s", key, value );
                  }
              }
          }
  
          //determine if this browser supports image alpha transparency
          $.Browser.alpha = !(
              (
                  $.Browser.vendor == $.BROWSERS.IE &&
                  $.Browser.version < 9
              ) || (
                  $.Browser.vendor == $.BROWSERS.CHROME &&
                  $.Browser.version < 2
              )
          );
  
          //determine if this browser supports element.style.opacity
          $.Browser.opacity = !(
              $.Browser.vendor == $.BROWSERS.IE &&
              $.Browser.version < 9
          );
  
      })();
  
  
      // Adding support for HTML5's requestAnimationFrame as suggested by acdha.
      // Implementation taken from matt synder's post here:
      // http://mattsnider.com/cross-browser-and-legacy-supported-requestframeanimation/
      (function( w ) {
  
          // most browsers have an implementation
          var requestAnimationFrame = w.requestAnimationFrame ||
              w.mozRequestAnimationFrame ||
              w.webkitRequestAnimationFrame ||
              w.msRequestAnimationFrame;
  
          var cancelAnimationFrame = w.cancelAnimationFrame ||
              w.mozCancelAnimationFrame ||
              w.webkitCancelAnimationFrame ||
              w.msCancelAnimationFrame;
  
          // polyfill, when necessary
          if ( requestAnimationFrame && cancelAnimationFrame ) {
              // We can't assign these window methods directly to $ because they
              // expect their "this" to be "window", so we call them in wrappers.
              $.requestAnimationFrame = function(){
                  return requestAnimationFrame.apply( w, arguments );
              };
              $.cancelAnimationFrame = function(){
                  return cancelAnimationFrame.apply( w, arguments );
              };
          } else {
              var aAnimQueue = [],
                  processing = [],
                  iRequestId = 0,
                  iIntervalId;
  
              // create a mock requestAnimationFrame function
              $.requestAnimationFrame = function( callback ) {
                  aAnimQueue.push( [ ++iRequestId, callback ] );
  
                  if ( !iIntervalId ) {
                      iIntervalId = setInterval( function() {
                          if ( aAnimQueue.length ) {
                              var time = $.now();
                              // Process all of the currently outstanding frame
                              // requests, but none that get added during the
                              // processing.
                              // Swap the arrays so we don't have to create a new
                              // array every frame.
                              var temp = processing;
                              processing = aAnimQueue;
                              aAnimQueue = temp;
                              while ( processing.length ) {
                                  processing.shift()[ 1 ]( time );
                              }
                          } else {
                              // don't continue the interval, if unnecessary
                              clearInterval( iIntervalId );
                              iIntervalId = undefined;
                          }
                      }, 1000 / 50);  // estimating support for 50 frames per second
                  }
  
                  return iRequestId;
              };
  
              // create a mock cancelAnimationFrame function
              $.cancelAnimationFrame = function( requestId ) {
                  // find the request ID and remove it
                  var i, j;
                  for ( i = 0, j = aAnimQueue.length; i < j; i += 1 ) {
                      if ( aAnimQueue[ i ][ 0 ] === requestId ) {
                          aAnimQueue.splice( i, 1 );
                          return;
                      }
                  }
  
                  // If it's not in the queue, it may be in the set we're currently
                  // processing (if cancelAnimationFrame is called from within a
                  // requestAnimationFrame callback).
                  for ( i = 0, j = processing.length; i < j; i += 1 ) {
                      if ( processing[ i ][ 0 ] === requestId ) {
                          processing.splice( i, 1 );
                          return;
                      }
                  }
              };
          }
      })( window );
  
      /**
       * @private
       * @inner
       * @function
       * @param {Element} element
       * @param {Boolean} [isFixed]
       * @returns {Element}
       */
      function getOffsetParent( element, isFixed ) {
          if ( isFixed && element != document.body ) {
              return document.body;
          } else {
              return element.offsetParent;
          }
      }
  
  }(OpenSeadragon));
  
  
  // Universal Module Definition, supports CommonJS, AMD and simple script tag
  (function (root, factory) {
      if (typeof define === 'function' && define.amd) {
          // expose as amd module
          define([], factory);
      } else if (typeof module === 'object' && module.exports) {
          // expose as commonjs module
          module.exports = factory();
      } else {
          // expose as window.OpenSeadragon
          root.OpenSeadragon = factory();
      }
  }(this, function () {
      return OpenSeadragon;
  }));
  
  /*
   * OpenSeadragon - full-screen support functions
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ) {
      /**
       * Determine native full screen support we can get from the browser.
       * @member fullScreenApi
       * @memberof OpenSeadragon
       * @type {object}
       * @property {Boolean} supportsFullScreen Return true if full screen API is supported.
       * @property {Function} isFullScreen Return true if currently in full screen mode.
       * @property {Function} getFullScreenElement Return the element currently in full screen mode.
       * @property {Function} requestFullScreen Make a request to go in full screen mode.
       * @property {Function} exitFullScreen Make a request to exit full screen mode.
       * @property {Function} cancelFullScreen Deprecated, use exitFullScreen instead.
       * @property {String} fullScreenEventName Event fired when the full screen mode change.
       * @property {String} fullScreenErrorEventName Event fired when a request to go
       * in full screen mode failed.
       */
      var fullScreenApi = {
          supportsFullScreen: false,
          isFullScreen: function() { return false; },
          getFullScreenElement: function() { return null; },
          requestFullScreen: function() {},
          exitFullScreen: function() {},
          cancelFullScreen: function() {},
          fullScreenEventName: '',
          fullScreenErrorEventName: ''
      };
  
      // check for native support
      if ( document.exitFullscreen ) {
          // W3C standard
          fullScreenApi.supportsFullScreen = true;
          fullScreenApi.getFullScreenElement = function() {
              return document.fullscreenElement;
          };
          fullScreenApi.requestFullScreen = function( element ) {
              return element.requestFullscreen();
          };
          fullScreenApi.exitFullScreen = function() {
              document.exitFullscreen();
          };
          fullScreenApi.fullScreenEventName = "fullscreenchange";
          fullScreenApi.fullScreenErrorEventName = "fullscreenerror";
      } else if ( document.msExitFullscreen ) {
          // IE 11
          fullScreenApi.supportsFullScreen = true;
          fullScreenApi.getFullScreenElement = function() {
              return document.msFullscreenElement;
          };
          fullScreenApi.requestFullScreen = function( element ) {
              return element.msRequestFullscreen();
          };
          fullScreenApi.exitFullScreen = function() {
              document.msExitFullscreen();
          };
          fullScreenApi.fullScreenEventName = "MSFullscreenChange";
          fullScreenApi.fullScreenErrorEventName = "MSFullscreenError";
      } else if ( document.webkitExitFullscreen ) {
          // Recent webkit
          fullScreenApi.supportsFullScreen = true;
          fullScreenApi.getFullScreenElement = function() {
              return document.webkitFullscreenElement;
          };
          fullScreenApi.requestFullScreen = function( element ) {
              return element.webkitRequestFullscreen();
          };
          fullScreenApi.exitFullScreen = function() {
              document.webkitExitFullscreen();
          };
          fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
          fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";
      } else if ( document.webkitCancelFullScreen ) {
          // Old webkit
          fullScreenApi.supportsFullScreen = true;
          fullScreenApi.getFullScreenElement = function() {
              return document.webkitCurrentFullScreenElement;
          };
          fullScreenApi.requestFullScreen = function( element ) {
              return element.webkitRequestFullScreen();
          };
          fullScreenApi.exitFullScreen = function() {
              document.webkitCancelFullScreen();
          };
          fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
          fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";
      } else if ( document.mozCancelFullScreen ) {
          // Firefox
          fullScreenApi.supportsFullScreen = true;
          fullScreenApi.getFullScreenElement = function() {
              return document.mozFullScreenElement;
          };
          fullScreenApi.requestFullScreen = function( element ) {
              return element.mozRequestFullScreen();
          };
          fullScreenApi.exitFullScreen = function() {
              document.mozCancelFullScreen();
          };
          fullScreenApi.fullScreenEventName = "mozfullscreenchange";
          fullScreenApi.fullScreenErrorEventName = "mozfullscreenerror";
      }
      fullScreenApi.isFullScreen = function() {
          return fullScreenApi.getFullScreenElement() !== null;
      };
      fullScreenApi.cancelFullScreen = function() {
          $.console.error("cancelFullScreen is deprecated. Use exitFullScreen instead.");
          fullScreenApi.exitFullScreen();
      };
  
      // export api
      $.extend( $, fullScreenApi );
  
  })( OpenSeadragon );
  
  /*
   * OpenSeadragon - EventSource
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function($){
  
  /**
   * Event handler method signature used by all OpenSeadragon events.
   *
   * @callback EventHandler
   * @memberof OpenSeadragon
   * @param {Object} event - See individual events for event-specific properties.
   */
  
  
  /**
   * @class EventSource
   * @classdesc For use by classes which want to support custom, non-browser events.
   *
   * @memberof OpenSeadragon
   */
  $.EventSource = function() {
      this.events = {};
  };
  
  /** @lends OpenSeadragon.EventSource.prototype */
  $.EventSource.prototype = {
  
      /**
       * Add an event handler to be triggered only once (or a given number of times)
       * for a given event.
       * @function
       * @param {String} eventName - Name of event to register.
       * @param {OpenSeadragon.EventHandler} handler - Function to call when event
       * is triggered.
       * @param {Object} [userData=null] - Arbitrary object to be passed unchanged
       * to the handler.
       * @param {Number} [times=1] - The number of times to handle the event
       * before removing it.
       */
      addOnceHandler: function(eventName, handler, userData, times) {
          var self = this;
          times = times || 1;
          var count = 0;
          var onceHandler = function(event) {
              count++;
              if (count === times) {
                  self.removeHandler(eventName, onceHandler);
              }
              handler(event);
          };
          this.addHandler(eventName, onceHandler, userData);
      },
  
      /**
       * Add an event handler for a given event.
       * @function
       * @param {String} eventName - Name of event to register.
       * @param {OpenSeadragon.EventHandler} handler - Function to call when event is triggered.
       * @param {Object} [userData=null] - Arbitrary object to be passed unchanged to the handler.
       */
      addHandler: function ( eventName, handler, userData ) {
          var events = this.events[ eventName ];
          if ( !events ) {
              this.events[ eventName ] = events = [];
          }
          if ( handler && $.isFunction( handler ) ) {
              events[ events.length ] = { handler: handler, userData: userData || null };
          }
      },
  
      /**
       * Remove a specific event handler for a given event.
       * @function
       * @param {String} eventName - Name of event for which the handler is to be removed.
       * @param {OpenSeadragon.EventHandler} handler - Function to be removed.
       */
      removeHandler: function ( eventName, handler ) {
          var events = this.events[ eventName ],
              handlers = [],
              i;
          if ( !events ) {
              return;
          }
          if ( $.isArray( events ) ) {
              for ( i = 0; i < events.length; i++ ) {
                  if ( events[i].handler !== handler ) {
                      handlers.push( events[ i ] );
                  }
              }
              this.events[ eventName ] = handlers;
          }
      },
  
  
      /**
       * Remove all event handlers for a given event type. If no type is given all
       * event handlers for every event type are removed.
       * @function
       * @param {String} eventName - Name of event for which all handlers are to be removed.
       */
      removeAllHandlers: function( eventName ) {
          if ( eventName ){
              this.events[ eventName ] = [];
          } else{
              for ( var eventType in this.events ) {
                  this.events[ eventType ] = [];
              }
          }
      },
  
      /**
       * Get a function which iterates the list of all handlers registered for a given event, calling the handler for each.
       * @function
       * @param {String} eventName - Name of event to get handlers for.
       */
      getHandler: function ( eventName ) {
          var events = this.events[ eventName ];
          if ( !events || !events.length ) {
              return null;
          }
          events = events.length === 1 ?
              [ events[ 0 ] ] :
              Array.apply( null, events );
          return function ( source, args ) {
              var i,
                  length = events.length;
              for ( i = 0; i < length; i++ ) {
                  if ( events[ i ] ) {
                      args.eventSource = source;
                      args.userData = events[ i ].userData;
                      events[ i ].handler( args );
                  }
              }
          };
      },
  
      /**
       * Trigger an event, optionally passing additional information.
       * @function
       * @param {String} eventName - Name of event to register.
       * @param {Object} eventArgs - Event-specific data.
       */
      raiseEvent: function( eventName, eventArgs ) {
          //uncomment if you want to get a log of all events
          //$.console.log( eventName );
          var handler = this.getHandler( eventName );
  
          if ( handler ) {
              if ( !eventArgs ) {
                  eventArgs = {};
              }
  
              handler( this, eventArgs );
          }
      }
  };
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - MouseTracker
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function ( $ ) {
  
      // All MouseTracker instances
      var MOUSETRACKERS  = [];
  
      // dictionary from hash to private properties
      var THIS           = {};
  
  
      /**
       * @class MouseTracker
       * @classdesc Provides simplified handling of common pointer device (mouse, touch, pen, etc.) gestures
       *            and keyboard events on a specified element.
       * @memberof OpenSeadragon
       * @param {Object} options
       *      Allows configurable properties to be entirely specified by passing
       *      an options object to the constructor.  The constructor also supports
       *      the original positional arguments 'element', 'clickTimeThreshold',
       *      and 'clickDistThreshold' in that order.
       * @param {Element|String} options.element
       *      A reference to an element or an element id for which the pointer/key
       *      events will be monitored.
       * @param {Boolean} [options.startDisabled=false]
       *      If true, event tracking on the element will not start until
       *      {@link OpenSeadragon.MouseTracker.setTracking|setTracking} is called.
       * @param {Number} options.clickTimeThreshold
       *      The number of milliseconds within which a pointer down-up event combination
       *      will be treated as a click gesture.
       * @param {Number} options.clickDistThreshold
       *      The maximum distance allowed between a pointer down event and a pointer up event
       *      to be treated as a click gesture.
       * @param {Number} options.dblClickTimeThreshold
       *      The number of milliseconds within which two pointer down-up event combinations
       *      will be treated as a double-click gesture.
       * @param {Number} options.dblClickDistThreshold
       *      The maximum distance allowed between two pointer click events
       *      to be treated as a click gesture.
       * @param {Number} [options.stopDelay=50]
       *      The number of milliseconds without pointer move before the stop
       *      event is fired.
       * @param {OpenSeadragon.EventHandler} [options.enterHandler=null]
       *      An optional handler for pointer enter.
       * @param {OpenSeadragon.EventHandler} [options.exitHandler=null]
       *      An optional handler for pointer exit.
       * @param {OpenSeadragon.EventHandler} [options.pressHandler=null]
       *      An optional handler for pointer press.
       * @param {OpenSeadragon.EventHandler} [options.nonPrimaryPressHandler=null]
       *      An optional handler for pointer non-primary button press.
       * @param {OpenSeadragon.EventHandler} [options.releaseHandler=null]
       *      An optional handler for pointer release.
       * @param {OpenSeadragon.EventHandler} [options.nonPrimaryReleaseHandler=null]
       *      An optional handler for pointer non-primary button release.
       * @param {OpenSeadragon.EventHandler} [options.moveHandler=null]
       *      An optional handler for pointer move.
       * @param {OpenSeadragon.EventHandler} [options.scrollHandler=null]
       *      An optional handler for mouse wheel scroll.
       * @param {OpenSeadragon.EventHandler} [options.clickHandler=null]
       *      An optional handler for pointer click.
       * @param {OpenSeadragon.EventHandler} [options.dblClickHandler=null]
       *      An optional handler for pointer double-click.
       * @param {OpenSeadragon.EventHandler} [options.dragHandler=null]
       *      An optional handler for the drag gesture.
       * @param {OpenSeadragon.EventHandler} [options.dragEndHandler=null]
       *      An optional handler for after a drag gesture.
       * @param {OpenSeadragon.EventHandler} [options.pinchHandler=null]
       *      An optional handler for the pinch gesture.
       * @param {OpenSeadragon.EventHandler} [options.keyDownHandler=null]
       *      An optional handler for keydown.
       * @param {OpenSeadragon.EventHandler} [options.keyUpHandler=null]
       *      An optional handler for keyup.
       * @param {OpenSeadragon.EventHandler} [options.keyHandler=null]
       *      An optional handler for keypress.
       * @param {OpenSeadragon.EventHandler} [options.focusHandler=null]
       *      An optional handler for focus.
       * @param {OpenSeadragon.EventHandler} [options.blurHandler=null]
       *      An optional handler for blur.
       * @param {Object} [options.userData=null]
       *      Arbitrary object to be passed unchanged to any attached handler methods.
       */
      $.MouseTracker = function ( options ) {
  
          MOUSETRACKERS.push( this );
  
          var args = arguments;
  
          if ( !$.isPlainObject( options ) ) {
              options = {
                  element:            args[ 0 ],
                  clickTimeThreshold: args[ 1 ],
                  clickDistThreshold: args[ 2 ]
              };
          }
  
          this.hash               = Math.random(); // An unique hash for this tracker.
          /**
           * The element for which pointer events are being monitored.
           * @member {Element} element
           * @memberof OpenSeadragon.MouseTracker#
           */
          this.element            = $.getElement( options.element );
          /**
           * The number of milliseconds within which a pointer down-up event combination
           * will be treated as a click gesture.
           * @member {Number} clickTimeThreshold
           * @memberof OpenSeadragon.MouseTracker#
           */
          this.clickTimeThreshold = options.clickTimeThreshold || $.DEFAULT_SETTINGS.clickTimeThreshold;
          /**
           * The maximum distance allowed between a pointer down event and a pointer up event
           * to be treated as a click gesture.
           * @member {Number} clickDistThreshold
           * @memberof OpenSeadragon.MouseTracker#
           */
          this.clickDistThreshold = options.clickDistThreshold || $.DEFAULT_SETTINGS.clickDistThreshold;
          /**
           * The number of milliseconds within which two pointer down-up event combinations
           * will be treated as a double-click gesture.
           * @member {Number} dblClickTimeThreshold
           * @memberof OpenSeadragon.MouseTracker#
           */
          this.dblClickTimeThreshold = options.dblClickTimeThreshold || $.DEFAULT_SETTINGS.dblClickTimeThreshold;
          /**
           * The maximum distance allowed between two pointer click events
           * to be treated as a click gesture.
           * @member {Number} clickDistThreshold
           * @memberof OpenSeadragon.MouseTracker#
           */
          this.dblClickDistThreshold = options.dblClickDistThreshold || $.DEFAULT_SETTINGS.dblClickDistThreshold;
          /*eslint-disable no-multi-spaces*/
          this.userData              = options.userData          || null;
          this.stopDelay             = options.stopDelay         || 50;
  
          this.enterHandler             = options.enterHandler             || null;
          this.exitHandler              = options.exitHandler              || null;
          this.pressHandler             = options.pressHandler             || null;
          this.nonPrimaryPressHandler   = options.nonPrimaryPressHandler   || null;
          this.releaseHandler           = options.releaseHandler           || null;
          this.nonPrimaryReleaseHandler = options.nonPrimaryReleaseHandler || null;
          this.moveHandler              = options.moveHandler              || null;
          this.scrollHandler            = options.scrollHandler            || null;
          this.clickHandler             = options.clickHandler             || null;
          this.dblClickHandler          = options.dblClickHandler          || null;
          this.dragHandler              = options.dragHandler              || null;
          this.dragEndHandler           = options.dragEndHandler           || null;
          this.pinchHandler             = options.pinchHandler             || null;
          this.stopHandler              = options.stopHandler              || null;
          this.keyDownHandler           = options.keyDownHandler           || null;
          this.keyUpHandler             = options.keyUpHandler             || null;
          this.keyHandler               = options.keyHandler               || null;
          this.focusHandler             = options.focusHandler             || null;
          this.blurHandler              = options.blurHandler              || null;
          /*eslint-enable no-multi-spaces*/
  
          //Store private properties in a scope sealed hash map
          var _this = this;
  
          /**
           * @private
           * @property {Boolean} tracking
           *      Are we currently tracking pointer events for this element.
           */
          THIS[ this.hash ] = {
              click:                 function ( event ) { onClick( _this, event ); },
              dblclick:              function ( event ) { onDblClick( _this, event ); },
              keydown:               function ( event ) { onKeyDown( _this, event ); },
              keyup:                 function ( event ) { onKeyUp( _this, event ); },
              keypress:              function ( event ) { onKeyPress( _this, event ); },
              focus:                 function ( event ) { onFocus( _this, event ); },
              blur:                  function ( event ) { onBlur( _this, event ); },
  
              wheel:                 function ( event ) { onWheel( _this, event ); },
              mousewheel:            function ( event ) { onMouseWheel( _this, event ); },
              DOMMouseScroll:        function ( event ) { onMouseWheel( _this, event ); },
              MozMousePixelScroll:   function ( event ) { onMouseWheel( _this, event ); },
  
              mouseenter:            function ( event ) { onMouseEnter( _this, event ); }, // Used on IE8 only
              mouseleave:            function ( event ) { onMouseLeave( _this, event ); }, // Used on IE8 only
              mouseover:             function ( event ) { onMouseOver( _this, event ); },
              mouseout:              function ( event ) { onMouseOut( _this, event ); },
              mousedown:             function ( event ) { onMouseDown( _this, event ); },
              mouseup:               function ( event ) { onMouseUp( _this, event ); },
              mouseupcaptured:       function ( event ) { onMouseUpCaptured( _this, event ); },
              mousemove:             function ( event ) { onMouseMove( _this, event ); },
              mousemovecaptured:     function ( event ) { onMouseMoveCaptured( _this, event ); },
  
              touchstart:            function ( event ) { onTouchStart( _this, event ); },
              touchend:              function ( event ) { onTouchEnd( _this, event ); },
              touchendcaptured:      function ( event ) { onTouchEndCaptured( _this, event ); },
              touchmove:             function ( event ) { onTouchMove( _this, event ); },
              touchmovecaptured:     function ( event ) { onTouchMoveCaptured( _this, event ); },
              touchcancel:           function ( event ) { onTouchCancel( _this, event ); },
  
              gesturestart:          function ( event ) { onGestureStart( _this, event ); },
              gesturechange:         function ( event ) { onGestureChange( _this, event ); },
  
              pointerover:           function ( event ) { onPointerOver( _this, event ); },
              MSPointerOver:         function ( event ) { onPointerOver( _this, event ); },
              pointerout:            function ( event ) { onPointerOut( _this, event ); },
              MSPointerOut:          function ( event ) { onPointerOut( _this, event ); },
              pointerdown:           function ( event ) { onPointerDown( _this, event ); },
              MSPointerDown:         function ( event ) { onPointerDown( _this, event ); },
              pointerup:             function ( event ) { onPointerUp( _this, event ); },
              MSPointerUp:           function ( event ) { onPointerUp( _this, event ); },
              pointermove:           function ( event ) { onPointerMove( _this, event ); },
              MSPointerMove:         function ( event ) { onPointerMove( _this, event ); },
              pointercancel:         function ( event ) { onPointerCancel( _this, event ); },
              MSPointerCancel:       function ( event ) { onPointerCancel( _this, event ); },
              pointerupcaptured:     function ( event ) { onPointerUpCaptured( _this, event ); },
              pointermovecaptured:   function ( event ) { onPointerMoveCaptured( _this, event ); },
  
              tracking:              false,
  
              // Active pointers lists. Array of GesturePointList objects, one for each pointer device type.
              // GesturePointList objects are added each time a pointer is tracked by a new pointer device type (see getActivePointersListByType()).
              // Active pointers are any pointer being tracked for this element which are in the hit-test area
              //     of the element (for hover-capable devices) and/or have contact or a button press initiated in the element.
              activePointersLists:   [],
  
              // Tracking for double-click gesture
              lastClickPos:          null,
              dblClickTimeOut:       null,
  
              // Tracking for pinch gesture
              pinchGPoints:          [],
              lastPinchDist:         0,
              currentPinchDist:      0,
              lastPinchCenter:       null,
              currentPinchCenter:    null
          };
  
          if ( !options.startDisabled ) {
              this.setTracking( true );
          }
      };
  
      /** @lends OpenSeadragon.MouseTracker.prototype */
      $.MouseTracker.prototype = {
  
          /**
           * Clean up any events or objects created by the tracker.
           * @function
           */
          destroy: function () {
              var i;
  
              stopTracking( this );
              this.element = null;
  
              for ( i = 0; i < MOUSETRACKERS.length; i++ ) {
                  if ( MOUSETRACKERS[ i ] === this ) {
                      MOUSETRACKERS.splice( i, 1 );
                      break;
                  }
              }
  
              THIS[ this.hash ] = null;
              delete THIS[ this.hash ];
          },
  
          /**
           * Are we currently tracking events on this element.
           * @deprecated Just use this.tracking
           * @function
           * @returns {Boolean} Are we currently tracking events on this element.
           */
          isTracking: function () {
              return THIS[ this.hash ].tracking;
          },
  
          /**
           * Enable or disable whether or not we are tracking events on this element.
           * @function
           * @param {Boolean} track True to start tracking, false to stop tracking.
           * @returns {OpenSeadragon.MouseTracker} Chainable.
           */
          setTracking: function ( track ) {
              if ( track ) {
                  startTracking( this );
              } else {
                  stopTracking( this );
              }
              //chain
              return this;
          },
  
          /**
           * Returns the {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} for all but the given pointer device type.
           * @function
           * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.
           * @returns {Array.<OpenSeadragon.MouseTracker.GesturePointList>}
           */
          getActivePointersListsExceptType: function ( type ) {
              var delegate = THIS[ this.hash ];
              var listArray = [];
  
              for (var i = 0; i < delegate.activePointersLists.length; ++i) {
                  if (delegate.activePointersLists[i].type !== type) {
                      listArray.push(delegate.activePointersLists[i]);
                  }
              }
  
              return listArray;
          },
  
          /**
           * Returns the {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} for the given pointer device type,
           * creating and caching a new {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} if one doesn't already exist for the type.
           * @function
           * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.
           * @returns {OpenSeadragon.MouseTracker.GesturePointList}
           */
          getActivePointersListByType: function ( type ) {
              var delegate = THIS[ this.hash ],
                  i,
                  len = delegate.activePointersLists.length,
                  list;
  
              for ( i = 0; i < len; i++ ) {
                  if ( delegate.activePointersLists[ i ].type === type ) {
                      return delegate.activePointersLists[ i ];
                  }
              }
  
              list = new $.MouseTracker.GesturePointList( type );
              delegate.activePointersLists.push( list );
              return list;
          },
  
          /**
           * Returns the total number of pointers currently active on the tracked element.
           * @function
           * @returns {Number}
           */
          getActivePointerCount: function () {
              var delegate = THIS[ this.hash ],
                  i,
                  len = delegate.activePointersLists.length,
                  count = 0;
  
              for ( i = 0; i < len; i++ ) {
                  count += delegate.activePointersLists[ i ].getLength();
              }
  
              return count;
          },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {String} event.pointerType
           *     "mouse", "touch", "pen", etc.
           * @param {OpenSeadragon.Point} event.position
           *      The position of the event relative to the tracked element.
           * @param {Number} event.buttons
           *      Current buttons pressed.
           *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
           * @param {Number} event.pointers
           *      Number of pointers (all types) active in the tracked element.
           * @param {Boolean} event.insideElementPressed
           *      True if the left mouse button is currently being pressed and was
           *      initiated inside the tracked element, otherwise false.
           * @param {Boolean} event.buttonDownAny
           *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
           * @param {Boolean} event.isTouchEvent
           *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          enterHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {String} event.pointerType
           *     "mouse", "touch", "pen", etc.
           * @param {OpenSeadragon.Point} event.position
           *      The position of the event relative to the tracked element.
           * @param {Number} event.buttons
           *      Current buttons pressed.
           *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
           * @param {Number} event.pointers
           *      Number of pointers (all types) active in the tracked element.
           * @param {Boolean} event.insideElementPressed
           *      True if the left mouse button is currently being pressed and was
           *      initiated inside the tracked element, otherwise false.
           * @param {Boolean} event.buttonDownAny
           *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
           * @param {Boolean} event.isTouchEvent
           *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          exitHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {String} event.pointerType
           *     "mouse", "touch", "pen", etc.
           * @param {OpenSeadragon.Point} event.position
           *      The position of the event relative to the tracked element.
           * @param {Number} event.buttons
           *      Current buttons pressed.
           *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
           * @param {Boolean} event.isTouchEvent
           *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          pressHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {String} event.pointerType
           *     "mouse", "touch", "pen", etc.
           * @param {OpenSeadragon.Point} event.position
           *      The position of the event relative to the tracked element.
           * @param {Number} event.button
           *      Button which caused the event.
           *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
           * @param {Number} event.buttons
           *      Current buttons pressed.
           *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
           * @param {Boolean} event.isTouchEvent
           *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          nonPrimaryPressHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {String} event.pointerType
           *     "mouse", "touch", "pen", etc.
           * @param {OpenSeadragon.Point} event.position
           *      The position of the event relative to the tracked element.
           * @param {Number} event.buttons
           *      Current buttons pressed.
           *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
           * @param {Boolean} event.insideElementPressed
           *      True if the left mouse button is currently being pressed and was
           *      initiated inside the tracked element, otherwise false.
           * @param {Boolean} event.insideElementReleased
           *      True if the cursor inside the tracked element when the button was released.
           * @param {Boolean} event.isTouchEvent
           *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          releaseHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {String} event.pointerType
           *     "mouse", "touch", "pen", etc.
           * @param {OpenSeadragon.Point} event.position
           *      The position of the event relative to the tracked element.
           * @param {Number} event.button
           *      Button which caused the event.
           *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
           * @param {Number} event.buttons
           *      Current buttons pressed.
           *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
           * @param {Boolean} event.isTouchEvent
           *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          nonPrimaryReleaseHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {String} event.pointerType
           *     "mouse", "touch", "pen", etc.
           * @param {OpenSeadragon.Point} event.position
           *      The position of the event relative to the tracked element.
           * @param {Number} event.buttons
           *      Current buttons pressed.
           *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
           * @param {Boolean} event.isTouchEvent
           *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          moveHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {String} event.pointerType
           *     "mouse", "touch", "pen", etc.
           * @param {OpenSeadragon.Point} event.position
           *      The position of the event relative to the tracked element.
           * @param {Number} event.scroll
           *      The scroll delta for the event.
           * @param {Boolean} event.shift
           *      True if the shift key was pressed during this event.
           * @param {Boolean} event.isTouchEvent
           *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead. Touch devices no longer generate scroll event.</span>
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          scrollHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {String} event.pointerType
           *     "mouse", "touch", "pen", etc.
           * @param {OpenSeadragon.Point} event.position
           *      The position of the event relative to the tracked element.
           * @param {Boolean} event.quick
           *      True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for ignoring drag events.
           * @param {Boolean} event.shift
           *      True if the shift key was pressed during this event.
           * @param {Boolean} event.isTouchEvent
           *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          clickHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {String} event.pointerType
           *     "mouse", "touch", "pen", etc.
           * @param {OpenSeadragon.Point} event.position
           *      The position of the event relative to the tracked element.
           * @param {Boolean} event.shift
           *      True if the shift key was pressed during this event.
           * @param {Boolean} event.isTouchEvent
           *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          dblClickHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {String} event.pointerType
           *     "mouse", "touch", "pen", etc.
           * @param {OpenSeadragon.Point} event.position
           *      The position of the event relative to the tracked element.
           * @param {Number} event.buttons
           *      Current buttons pressed.
           *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
           * @param {OpenSeadragon.Point} event.delta
           *      The x,y components of the difference between the current position and the last drag event position.  Useful for ignoring or weighting the events.
           * @param {Number} event.speed
           *     Current computed speed, in pixels per second.
           * @param {Number} event.direction
           *     Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
           * @param {Boolean} event.shift
           *      True if the shift key was pressed during this event.
           * @param {Boolean} event.isTouchEvent
           *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          dragHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {String} event.pointerType
           *     "mouse", "touch", "pen", etc.
           * @param {OpenSeadragon.Point} event.position
           *      The position of the event relative to the tracked element.
           * @param {Number} event.speed
           *     Speed at the end of a drag gesture, in pixels per second.
           * @param {Number} event.direction
           *     Direction at the end of a drag gesture, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
           * @param {Boolean} event.shift
           *      True if the shift key was pressed during this event.
           * @param {Boolean} event.isTouchEvent
           *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          dragEndHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {String} event.pointerType
           *     "mouse", "touch", "pen", etc.
           * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} event.gesturePoints
           *      Gesture points associated with the gesture. Velocity data can be found here.
           * @param {OpenSeadragon.Point} event.lastCenter
           *      The previous center point of the two pinch contact points relative to the tracked element.
           * @param {OpenSeadragon.Point} event.center
           *      The center point of the two pinch contact points relative to the tracked element.
           * @param {Number} event.lastDistance
           *      The previous distance between the two pinch contact points in CSS pixels.
           * @param {Number} event.distance
           *      The distance between the two pinch contact points in CSS pixels.
           * @param {Boolean} event.shift
           *      True if the shift key was pressed during this event.
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          pinchHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {String} event.pointerType
           *     "mouse", "touch", "pen", etc.
           * @param {OpenSeadragon.Point} event.position
           *      The position of the event relative to the tracked element.
           * @param {Number} event.buttons
           *      Current buttons pressed.
           *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
           * @param {Boolean} event.isTouchEvent
           *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          stopHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {Number} event.keyCode
           *      The key code that was pressed.
           * @param {Boolean} event.ctrl
           *      True if the ctrl key was pressed during this event.
           * @param {Boolean} event.shift
           *      True if the shift key was pressed during this event.
           * @param {Boolean} event.alt
           *      True if the alt key was pressed during this event.
           * @param {Boolean} event.meta
           *      True if the meta key was pressed during this event.
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          keyDownHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {Number} event.keyCode
           *      The key code that was pressed.
           * @param {Boolean} event.ctrl
           *      True if the ctrl key was pressed during this event.
           * @param {Boolean} event.shift
           *      True if the shift key was pressed during this event.
           * @param {Boolean} event.alt
           *      True if the alt key was pressed during this event.
           * @param {Boolean} event.meta
           *      True if the meta key was pressed during this event.
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          keyUpHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {Number} event.keyCode
           *      The key code that was pressed.
           * @param {Boolean} event.ctrl
           *      True if the ctrl key was pressed during this event.
           * @param {Boolean} event.shift
           *      True if the shift key was pressed during this event.
           * @param {Boolean} event.alt
           *      True if the alt key was pressed during this event.
           * @param {Boolean} event.meta
           *      True if the meta key was pressed during this event.
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          keyHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          focusHandler: function () { },
  
          /**
           * Implement or assign implementation to these handlers during or after
           * calling the constructor.
           * @function
           * @param {Object} event
           * @param {OpenSeadragon.MouseTracker} event.eventSource
           *      A reference to the tracker instance.
           * @param {Object} event.originalEvent
           *      The original event object.
           * @param {Boolean} event.preventDefaultAction
           *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.
           * @param {Object} event.userData
           *      Arbitrary user-defined object.
           */
          blurHandler: function () { }
      };
  
      /**
       * Resets all active mousetrakers. (Added to patch issue #697 "Mouse up outside map will cause "canvas-drag" event to stick")
       *
       * @private
       * @member resetAllMouseTrackers
       * @memberof OpenSeadragon.MouseTracker
       */
      $.MouseTracker.resetAllMouseTrackers = function(){
          for(var i = 0; i < MOUSETRACKERS.length; i++){
              if (MOUSETRACKERS[i].isTracking()){
                  MOUSETRACKERS[i].setTracking(false);
                  MOUSETRACKERS[i].setTracking(true);
              }
          }
      };
  
      /**
       * Provides continuous computation of velocity (speed and direction) of active pointers.
       * This is a singleton, used by all MouseTracker instances, as it is unlikely there will ever be more than
       * two active gesture pointers at a time.
       *
       * @private
       * @member gesturePointVelocityTracker
       * @memberof OpenSeadragon.MouseTracker
       */
      $.MouseTracker.gesturePointVelocityTracker = (function () {
          var trackerPoints = [],
              intervalId = 0,
              lastTime = 0;
  
          // Generates a unique identifier for a tracked gesture point
          var _generateGuid = function ( tracker, gPoint ) {
              return tracker.hash.toString() + gPoint.type + gPoint.id.toString();
          };
  
          // Interval timer callback. Computes velocity for all tracked gesture points.
          var _doTracking = function () {
              var i,
                  len = trackerPoints.length,
                  trackPoint,
                  gPoint,
                  now = $.now(),
                  elapsedTime,
                  distance,
                  speed;
  
              elapsedTime = now - lastTime;
              lastTime = now;
  
              for ( i = 0; i < len; i++ ) {
                  trackPoint = trackerPoints[ i ];
                  gPoint = trackPoint.gPoint;
                  // Math.atan2 gives us just what we need for a velocity vector, as we can simply
                  //   use cos()/sin() to extract the x/y velocity components.
                  gPoint.direction = Math.atan2( gPoint.currentPos.y - trackPoint.lastPos.y, gPoint.currentPos.x - trackPoint.lastPos.x );
                  // speed = distance / elapsed time
                  distance = trackPoint.lastPos.distanceTo( gPoint.currentPos );
                  trackPoint.lastPos = gPoint.currentPos;
                  speed = 1000 * distance / ( elapsedTime + 1 );
                  // Simple biased average, favors the most recent speed computation. Smooths out erratic gestures a bit.
                  gPoint.speed = 0.75 * speed + 0.25 * gPoint.speed;
              }
          };
  
          // Public. Add a gesture point to be tracked
          var addPoint = function ( tracker, gPoint ) {
              var guid = _generateGuid( tracker, gPoint );
  
              trackerPoints.push(
                  {
                      guid: guid,
                      gPoint: gPoint,
                      lastPos: gPoint.currentPos
                  } );
  
              // Only fire up the interval timer when there's gesture pointers to track
              if ( trackerPoints.length === 1 ) {
                  lastTime = $.now();
                  intervalId = window.setInterval( _doTracking, 50 );
              }
          };
  
          // Public. Stop tracking a gesture point
          var removePoint = function ( tracker, gPoint ) {
              var guid = _generateGuid( tracker, gPoint ),
                  i,
                  len = trackerPoints.length;
              for ( i = 0; i < len; i++ ) {
                  if ( trackerPoints[ i ].guid === guid ) {
                      trackerPoints.splice( i, 1 );
                      // Only run the interval timer if theres gesture pointers to track
                      len--;
                      if ( len === 0 ) {
                          window.clearInterval( intervalId );
                      }
                      break;
                  }
              }
          };
  
          return {
              addPoint:    addPoint,
              removePoint: removePoint
          };
      } )();
  
  
  ///////////////////////////////////////////////////////////////////////////////
  // Pointer event model and feature detection
  ///////////////////////////////////////////////////////////////////////////////
  
      $.MouseTracker.captureElement = document;
  
      /**
       * Detect available mouse wheel event name.
       */
      $.MouseTracker.wheelEventName = ( $.Browser.vendor == $.BROWSERS.IE && $.Browser.version > 8 ) ||
                                                  ( 'onwheel' in document.createElement( 'div' ) ) ? 'wheel' : // Modern browsers support 'wheel'
                                      document.onmousewheel !== undefined ? 'mousewheel' :                     // Webkit and IE support at least 'mousewheel'
                                      'DOMMouseScroll';                                                        // Assume old Firefox
  
      /**
       * Detect legacy mouse capture support.
       */
      $.MouseTracker.supportsMouseCapture = (function () {
          var divElement = document.createElement( 'div' );
          return $.isFunction( divElement.setCapture ) && $.isFunction( divElement.releaseCapture );
      }());
  
      /**
       * Detect browser pointer device event model(s) and build appropriate list of events to subscribe to.
       */
      $.MouseTracker.subscribeEvents = [ "click", "dblclick", "keydown", "keyup", "keypress", "focus", "blur", $.MouseTracker.wheelEventName ];
  
      if( $.MouseTracker.wheelEventName == "DOMMouseScroll" ) {
          // Older Firefox
          $.MouseTracker.subscribeEvents.push( "MozMousePixelScroll" );
      }
  
      // Note: window.navigator.pointerEnable is deprecated on IE 11 and not part of W3C spec.
      if ( window.PointerEvent && ( window.navigator.pointerEnabled || $.Browser.vendor !== $.BROWSERS.IE ) ) {
          // IE11 and other W3C Pointer Event implementations (see http://www.w3.org/TR/pointerevents)
          $.MouseTracker.havePointerEvents = true;
          $.MouseTracker.subscribeEvents.push( "pointerover", "pointerout", "pointerdown", "pointerup", "pointermove", "pointercancel" );
          $.MouseTracker.unprefixedPointerEvents = true;
          if( navigator.maxTouchPoints ) {
              $.MouseTracker.maxTouchPoints = navigator.maxTouchPoints;
          } else {
              $.MouseTracker.maxTouchPoints = 0;
          }
          $.MouseTracker.haveMouseEnter = false;
      } else if ( window.MSPointerEvent && window.navigator.msPointerEnabled ) {
          // IE10
          $.MouseTracker.havePointerEvents = true;
          $.MouseTracker.subscribeEvents.push( "MSPointerOver", "MSPointerOut", "MSPointerDown", "MSPointerUp", "MSPointerMove", "MSPointerCancel" );
          $.MouseTracker.unprefixedPointerEvents = false;
          if( navigator.msMaxTouchPoints ) {
              $.MouseTracker.maxTouchPoints = navigator.msMaxTouchPoints;
          } else {
              $.MouseTracker.maxTouchPoints = 0;
          }
          $.MouseTracker.haveMouseEnter = false;
      } else {
          // Legacy W3C mouse events
          $.MouseTracker.havePointerEvents = false;
          if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {
              $.MouseTracker.subscribeEvents.push( "mouseenter", "mouseleave" );
              $.MouseTracker.haveMouseEnter = true;
          } else {
              $.MouseTracker.subscribeEvents.push( "mouseover", "mouseout" );
              $.MouseTracker.haveMouseEnter = false;
          }
          $.MouseTracker.subscribeEvents.push( "mousedown", "mouseup", "mousemove" );
          if ( 'ontouchstart' in window ) {
              // iOS, Android, and other W3c Touch Event implementations
              //    (see http://www.w3.org/TR/touch-events/)
              //    (see https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)
              //    (see https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)
              $.MouseTracker.subscribeEvents.push( "touchstart", "touchend", "touchmove", "touchcancel" );
          }
          if ( 'ongesturestart' in window ) {
              // iOS (see https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)
              //   Subscribe to these to prevent default gesture handling
              $.MouseTracker.subscribeEvents.push( "gesturestart", "gesturechange" );
          }
          $.MouseTracker.mousePointerId = "legacy-mouse";
          $.MouseTracker.maxTouchPoints = 10;
      }
  
  
  ///////////////////////////////////////////////////////////////////////////////
  // Classes and typedefs
  ///////////////////////////////////////////////////////////////////////////////
  
      /**
       * Represents a point of contact on the screen made by a mouse cursor, pen, touch, or other pointer device.
       *
       * @typedef {Object} GesturePoint
       * @memberof OpenSeadragon.MouseTracker
       *
       * @property {Number} id
       *     Identifier unique from all other active GesturePoints for a given pointer device.
       * @property {String} type
       *     The pointer device type: "mouse", "touch", "pen", etc.
       * @property {Boolean} captured
       *     True if events for the gesture point are captured to the tracked element.
       * @property {Boolean} isPrimary
       *     True if the gesture point is a master pointer amongst the set of active pointers for each pointer type. True for mouse and primary (first) touch/pen pointers.
       * @property {Boolean} insideElementPressed
       *     True if button pressed or contact point initiated inside the screen area of the tracked element.
       * @property {Boolean} insideElement
       *     True if pointer or contact point is currently inside the bounds of the tracked element.
       * @property {Number} speed
       *     Current computed speed, in pixels per second.
       * @property {Number} direction
       *     Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
       * @property {OpenSeadragon.Point} contactPos
       *     The initial pointer contact position, relative to the page including any scrolling. Only valid if the pointer has contact (pressed, touch contact, pen contact).
       * @property {Number} contactTime
       *     The initial pointer contact time, in milliseconds. Only valid if the pointer has contact (pressed, touch contact, pen contact).
       * @property {OpenSeadragon.Point} lastPos
       *     The last pointer position, relative to the page including any scrolling.
       * @property {Number} lastTime
       *     The last pointer contact time, in milliseconds.
       * @property {OpenSeadragon.Point} currentPos
       *     The current pointer position, relative to the page including any scrolling.
       * @property {Number} currentTime
       *     The current pointer contact time, in milliseconds.
       */
  
  
      /**
       * @class GesturePointList
       * @classdesc Provides an abstraction for a set of active {@link OpenSeadragon.MouseTracker.GesturePoint|GesturePoint} objects for a given pointer device type.
       *            Active pointers are any pointer being tracked for this element which are in the hit-test area
       *            of the element (for hover-capable devices) and/or have contact or a button press initiated in the element.
       * @memberof OpenSeadragon.MouseTracker
       * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.
       */
      $.MouseTracker.GesturePointList = function ( type ) {
          this._gPoints = [];
          /**
           * The pointer device type: "mouse", "touch", "pen", etc.
           * @member {String} type
           * @memberof OpenSeadragon.MouseTracker.GesturePointList#
           */
          this.type = type;
          /**
           * Current buttons pressed for the device.
           * Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
           * @member {Number} buttons
           * @memberof OpenSeadragon.MouseTracker.GesturePointList#
           */
          this.buttons = 0;
          /**
           * Current number of contact points (touch points, mouse down, etc.) for the device.
           * @member {Number} contacts
           * @memberof OpenSeadragon.MouseTracker.GesturePointList#
           */
          this.contacts = 0;
          /**
           * Current number of clicks for the device. Used for multiple click gesture tracking.
           * @member {Number} clicks
           * @memberof OpenSeadragon.MouseTracker.GesturePointList#
           */
          this.clicks = 0;
          /**
           * Current number of captured pointers for the device.
           * @member {Number} captureCount
           * @memberof OpenSeadragon.MouseTracker.GesturePointList#
           */
          this.captureCount = 0;
      };
  
      /** @lends OpenSeadragon.MouseTracker.GesturePointList.prototype */
      $.MouseTracker.GesturePointList.prototype = {
          /**
           * @function
           * @returns {Number} Number of gesture points in the list.
           */
          getLength: function () {
              return this._gPoints.length;
          },
          /**
           * @function
           * @returns {Array.<OpenSeadragon.MouseTracker.GesturePoint>} The list of gesture points in the list as an array (read-only).
           */
          asArray: function () {
              return this._gPoints;
          },
          /**
           * @function
           * @param {OpenSeadragon.MouseTracker.GesturePoint} gesturePoint - A gesture point to add to the list.
           * @returns {Number} Number of gesture points in the list.
           */
          add: function ( gp ) {
              return this._gPoints.push( gp );
          },
          /**
           * @function
           * @param {Number} id - The id of the gesture point to remove from the list.
           * @returns {Number} Number of gesture points in the list.
           */
          removeById: function ( id ) {
              var i,
                  len = this._gPoints.length;
              for ( i = 0; i < len; i++ ) {
                  if ( this._gPoints[ i ].id === id ) {
                      this._gPoints.splice( i, 1 );
                      break;
                  }
              }
              return this._gPoints.length;
          },
          /**
           * @function
           * @param {Number} index - The index of the gesture point to retrieve from the list.
           * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point at the given index, or null if not found.
           */
          getByIndex: function ( index ) {
              if ( index < this._gPoints.length) {
                  return this._gPoints[ index ];
              }
  
              return null;
          },
          /**
           * @function
           * @param {Number} id - The id of the gesture point to retrieve from the list.
           * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point with the given id, or null if not found.
           */
          getById: function ( id ) {
              var i,
                  len = this._gPoints.length;
              for ( i = 0; i < len; i++ ) {
                  if ( this._gPoints[ i ].id === id ) {
                      return this._gPoints[ i ];
                  }
              }
              return null;
          },
          /**
           * @function
           * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The primary gesture point in the list, or null if not found.
           */
          getPrimary: function ( id ) {
              var i,
                  len = this._gPoints.length;
              for ( i = 0; i < len; i++ ) {
                  if ( this._gPoints[ i ].isPrimary ) {
                      return this._gPoints[ i ];
                  }
              }
              return null;
          },
  
          /**
           * Increment this pointer's contact count.
           * It will evaluate whether this pointer type is allowed to have multiple contacts.
           * @function
           */
          addContact: function() {
              ++this.contacts;
  
              if (this.contacts > 1 && (this.type === "mouse" || this.type === "pen")) {
                  this.contacts = 1;
              }
          },
  
          /**
           * Decrement this pointer's contact count.
           * It will make sure the count does not go below 0.
           * @function
           */
          removeContact: function() {
              --this.contacts;
  
              if (this.contacts < 0) {
                  this.contacts = 0;
              }
          }
      };
  
  
  ///////////////////////////////////////////////////////////////////////////////
  // Utility functions
  ///////////////////////////////////////////////////////////////////////////////
  
      /**
       * Removes all tracked pointers.
       * @private
       * @inner
       */
      function clearTrackedPointers( tracker ) {
          var delegate = THIS[ tracker.hash ],
              i,
              pointerListCount = delegate.activePointersLists.length;
  
          for ( i = 0; i < pointerListCount; i++ ) {
              if ( delegate.activePointersLists[ i ].captureCount > 0 ) {
                  $.removeEvent(
                      $.MouseTracker.captureElement,
                      'mousemove',
                      delegate.mousemovecaptured,
                      true
                  );
                  $.removeEvent(
                      $.MouseTracker.captureElement,
                      'mouseup',
                      delegate.mouseupcaptured,
                      true
                  );
                  $.removeEvent(
                      $.MouseTracker.captureElement,
                      $.MouseTracker.unprefixedPointerEvents ? 'pointermove' : 'MSPointerMove',
                      delegate.pointermovecaptured,
                      true
                  );
                  $.removeEvent(
                      $.MouseTracker.captureElement,
                      $.MouseTracker.unprefixedPointerEvents ? 'pointerup' : 'MSPointerUp',
                      delegate.pointerupcaptured,
                      true
                  );
                  $.removeEvent(
                      $.MouseTracker.captureElement,
                      'touchmove',
                      delegate.touchmovecaptured,
                      true
                  );
                  $.removeEvent(
                      $.MouseTracker.captureElement,
                      'touchend',
                      delegate.touchendcaptured,
                      true
                  );
  
                  delegate.activePointersLists[ i ].captureCount = 0;
              }
          }
  
          for ( i = 0; i < pointerListCount; i++ ) {
              delegate.activePointersLists.pop();
          }
      }
  
      /**
       * Starts tracking pointer events on the tracked element.
       * @private
       * @inner
       */
      function startTracking( tracker ) {
          var delegate = THIS[ tracker.hash ],
              event,
              i;
  
          if ( !delegate.tracking ) {
              for ( i = 0; i < $.MouseTracker.subscribeEvents.length; i++ ) {
                  event = $.MouseTracker.subscribeEvents[ i ];
                  $.addEvent(
                      tracker.element,
                      event,
                      delegate[ event ],
                      false
                  );
              }
  
              clearTrackedPointers( tracker );
  
              delegate.tracking = true;
          }
      }
  
      /**
       * Stops tracking pointer events on the tracked element.
       * @private
       * @inner
       */
      function stopTracking( tracker ) {
          var delegate = THIS[ tracker.hash ],
              event,
              i;
  
          if ( delegate.tracking ) {
              for ( i = 0; i < $.MouseTracker.subscribeEvents.length; i++ ) {
                  event = $.MouseTracker.subscribeEvents[ i ];
                  $.removeEvent(
                      tracker.element,
                      event,
                      delegate[ event ],
                      false
                  );
              }
  
              clearTrackedPointers( tracker );
  
              delegate.tracking = false;
          }
      }
  
      /**
       * @private
       * @inner
       */
      function getCaptureEventParams( tracker, pointerType ) {
          var delegate = THIS[ tracker.hash ];
  
          if ( pointerType === 'pointerevent' ) {
              return {
                  upName: $.MouseTracker.unprefixedPointerEvents ? 'pointerup' : 'MSPointerUp',
                  upHandler: delegate.pointerupcaptured,
                  moveName: $.MouseTracker.unprefixedPointerEvents ? 'pointermove' : 'MSPointerMove',
                  moveHandler: delegate.pointermovecaptured
              };
          } else if ( pointerType === 'mouse' ) {
              return {
                  upName: 'mouseup',
                  upHandler: delegate.mouseupcaptured,
                  moveName: 'mousemove',
                  moveHandler: delegate.mousemovecaptured
              };
          } else if ( pointerType === 'touch' ) {
              return {
                  upName: 'touchend',
                  upHandler: delegate.touchendcaptured,
                  moveName: 'touchmove',
                  moveHandler: delegate.touchmovecaptured
              };
          } else {
              throw new Error( "MouseTracker.getCaptureEventParams: Unknown pointer type." );
          }
      }
  
      /**
       * Begin capturing pointer events to the tracked element.
       * @private
       * @inner
       */
      function capturePointer( tracker, pointerType, pointerCount ) {
          var pointsList = tracker.getActivePointersListByType( pointerType ),
              eventParams;
  
          pointsList.captureCount += (pointerCount || 1);
  
          if ( pointsList.captureCount === 1 ) {
              if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {
                  tracker.element.setCapture( true );
              } else {
                  eventParams = getCaptureEventParams( tracker, $.MouseTracker.havePointerEvents ? 'pointerevent' : pointerType );
                  // We emulate mouse capture by hanging listeners on the document object.
                  //    (Note we listen on the capture phase so the captured handlers will get called first)
                  // eslint-disable-next-line no-use-before-define
                  if (isInIframe && canAccessEvents(window.top)) {
                      $.addEvent(
                          window.top,
                          eventParams.upName,
                          eventParams.upHandler,
                          true
                      );
                  }
                  $.addEvent(
                      $.MouseTracker.captureElement,
                      eventParams.upName,
                      eventParams.upHandler,
                      true
                  );
                  $.addEvent(
                      $.MouseTracker.captureElement,
                      eventParams.moveName,
                      eventParams.moveHandler,
                      true
                  );
              }
          }
      }
  
  
      /**
       * Stop capturing pointer events to the tracked element.
       * @private
       * @inner
       */
      function releasePointer( tracker, pointerType, pointerCount ) {
          var pointsList = tracker.getActivePointersListByType( pointerType ),
              eventParams;
  
          pointsList.captureCount -= (pointerCount || 1);
  
          if ( pointsList.captureCount === 0 ) {
              if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {
                  tracker.element.releaseCapture();
              } else {
                  eventParams = getCaptureEventParams( tracker, $.MouseTracker.havePointerEvents ? 'pointerevent' : pointerType );
                  // We emulate mouse capture by hanging listeners on the document object.
                  //    (Note we listen on the capture phase so the captured handlers will get called first)
                  // eslint-disable-next-line no-use-before-define
                  if (isInIframe && canAccessEvents(window.top)) {
                      $.removeEvent(
                          window.top,
                          eventParams.upName,
                          eventParams.upHandler,
                          true
                      );
                  }
                  $.removeEvent(
                      $.MouseTracker.captureElement,
                      eventParams.moveName,
                      eventParams.moveHandler,
                      true
                  );
                  $.removeEvent(
                      $.MouseTracker.captureElement,
                      eventParams.upName,
                      eventParams.upHandler,
                      true
                  );
              }
          }
      }
  
  
      /**
       * Gets a W3C Pointer Events model compatible pointer type string from a DOM pointer event.
       * IE10 used a long integer value, but the W3C specification (and IE11+) use a string "mouse", "touch", "pen", etc.
       * @private
       * @inner
       */
      function getPointerType( event ) {
          var pointerTypeStr;
          if ( $.MouseTracker.unprefixedPointerEvents ) {
              pointerTypeStr = event.pointerType;
          } else {
              // IE10
              //  MSPOINTER_TYPE_TOUCH: 0x00000002
              //  MSPOINTER_TYPE_PEN:   0x00000003
              //  MSPOINTER_TYPE_MOUSE: 0x00000004
              switch( event.pointerType )
              {
                  case 0x00000002:
                      pointerTypeStr = 'touch';
                      break;
                  case 0x00000003:
                      pointerTypeStr = 'pen';
                      break;
                  case 0x00000004:
                      pointerTypeStr = 'mouse';
                      break;
                  default:
                      pointerTypeStr = '';
              }
          }
          return pointerTypeStr;
      }
  
  
      /**
       * @private
       * @inner
       */
      function getMouseAbsolute( event ) {
          return $.getMousePosition( event );
      }
  
      /**
       * @private
       * @inner
       */
      function getMouseRelative( event, element ) {
          return getPointRelativeToAbsolute( getMouseAbsolute( event ), element );
      }
  
      /**
       * @private
       * @inner
       */
      function getPointRelativeToAbsolute( point, element ) {
          var offset = $.getElementOffset( element );
          return point.minus( offset );
      }
  
      /**
       * @private
       * @inner
       */
      function getCenterPoint( point1, point2 ) {
          return new $.Point( ( point1.x + point2.x ) / 2, ( point1.y + point2.y ) / 2 );
      }
  
  
  ///////////////////////////////////////////////////////////////////////////////
  // Device-specific DOM event handlers
  ///////////////////////////////////////////////////////////////////////////////
  
      /**
       * @private
       * @inner
       */
      function onClick( tracker, event ) {
          if ( tracker.clickHandler ) {
              $.cancelEvent( event );
          }
      }
  
  
      /**
       * @private
       * @inner
       */
      function onDblClick( tracker, event ) {
          if ( tracker.dblClickHandler ) {
              $.cancelEvent( event );
          }
      }
  
  
      /**
       * @private
       * @inner
       */
      function onKeyDown( tracker, event ) {
          //$.console.log( "keydown %s %s %s %s %s", event.keyCode, event.charCode, event.ctrlKey, event.shiftKey, event.altKey );
          var propagate;
          if ( tracker.keyDownHandler ) {
              event = $.getEvent( event );
              propagate = tracker.keyDownHandler(
                  {
                      eventSource:          tracker,
                      keyCode:              event.keyCode ? event.keyCode : event.charCode,
                      ctrl:                 event.ctrlKey,
                      shift:                event.shiftKey,
                      alt:                  event.altKey,
                      meta:                 event.metaKey,
                      originalEvent:        event,
                      preventDefaultAction: false,
                      userData:             tracker.userData
                  }
              );
              if ( !propagate ) {
                  $.cancelEvent( event );
              }
          }
      }
  
  
      /**
       * @private
       * @inner
       */
      function onKeyUp( tracker, event ) {
          //$.console.log( "keyup %s %s %s %s %s", event.keyCode, event.charCode, event.ctrlKey, event.shiftKey, event.altKey );
          var propagate;
          if ( tracker.keyUpHandler ) {
              event = $.getEvent( event );
              propagate = tracker.keyUpHandler(
                  {
                      eventSource:          tracker,
                      keyCode:              event.keyCode ? event.keyCode : event.charCode,
                      ctrl:                 event.ctrlKey,
                      shift:                event.shiftKey,
                      alt:                  event.altKey,
                      meta:                 event.metaKey,
                      originalEvent:        event,
                      preventDefaultAction: false,
                      userData:             tracker.userData
                  }
              );
              if ( !propagate ) {
                  $.cancelEvent( event );
              }
          }
      }
  
  
      /**
       * @private
       * @inner
       */
      function onKeyPress( tracker, event ) {
          //$.console.log( "keypress %s %s %s %s %s", event.keyCode, event.charCode, event.ctrlKey, event.shiftKey, event.altKey );
          var propagate;
          if ( tracker.keyHandler ) {
              event = $.getEvent( event );
              propagate = tracker.keyHandler(
                  {
                      eventSource:          tracker,
                      keyCode:              event.keyCode ? event.keyCode : event.charCode,
                      ctrl:                 event.ctrlKey,
                      shift:                event.shiftKey,
                      alt:                  event.altKey,
                      meta:                 event.metaKey,
                      originalEvent:        event,
                      preventDefaultAction: false,
                      userData:             tracker.userData
                  }
              );
              if ( !propagate ) {
                  $.cancelEvent( event );
              }
          }
      }
  
  
      /**
       * @private
       * @inner
       */
      function onFocus( tracker, event ) {
          //console.log( "focus %s", event );
          var propagate;
          if ( tracker.focusHandler ) {
              event = $.getEvent( event );
              propagate = tracker.focusHandler(
                  {
                      eventSource:          tracker,
                      originalEvent:        event,
                      preventDefaultAction: false,
                      userData:             tracker.userData
                  }
              );
              if ( propagate === false ) {
                  $.cancelEvent( event );
              }
          }
      }
  
  
      /**
       * @private
       * @inner
       */
      function onBlur( tracker, event ) {
          //console.log( "blur %s", event );
          var propagate;
          if ( tracker.blurHandler ) {
              event = $.getEvent( event );
              propagate = tracker.blurHandler(
                  {
                      eventSource:          tracker,
                      originalEvent:        event,
                      preventDefaultAction: false,
                      userData:             tracker.userData
                  }
              );
              if ( propagate === false ) {
                  $.cancelEvent( event );
              }
          }
      }
  
  
      /**
       * Handler for 'wheel' events
       *
       * @private
       * @inner
       */
      function onWheel( tracker, event ) {
          handleWheelEvent( tracker, event, event );
      }
  
  
      /**
       * Handler for 'mousewheel', 'DOMMouseScroll', and 'MozMousePixelScroll' events
       *
       * @private
       * @inner
       */
      function onMouseWheel( tracker, event ) {
          event = $.getEvent( event );
  
          // Simulate a 'wheel' event
          var simulatedEvent = {
              target:     event.target || event.srcElement,
              type:       "wheel",
              shiftKey:   event.shiftKey || false,
              clientX:    event.clientX,
              clientY:    event.clientY,
              pageX:      event.pageX ? event.pageX : event.clientX,
              pageY:      event.pageY ? event.pageY : event.clientY,
              deltaMode:  event.type == "MozMousePixelScroll" ? 0 : 1, // 0=pixel, 1=line, 2=page
              deltaX:     0,
              deltaZ:     0
          };
  
          // Calculate deltaY
          if ( $.MouseTracker.wheelEventName == "mousewheel" ) {
              simulatedEvent.deltaY = -event.wheelDelta / $.DEFAULT_SETTINGS.pixelsPerWheelLine;
          } else {
              simulatedEvent.deltaY = event.detail;
          }
  
          handleWheelEvent( tracker, simulatedEvent, event );
      }
  
  
      /**
       * Handles 'wheel' events.
       * The event may be simulated by the legacy mouse wheel event handler (onMouseWheel()).
       *
       * @private
       * @inner
       */
      function handleWheelEvent( tracker, event, originalEvent ) {
          var nDelta = 0,
              propagate;
  
          // The nDelta variable is gated to provide smooth z-index scrolling
          //   since the mouse wheel allows for substantial deltas meant for rapid
          //   y-index scrolling.
          // event.deltaMode: 0=pixel, 1=line, 2=page
          // TODO: Deltas in pixel mode should be accumulated then a scroll value computed after $.DEFAULT_SETTINGS.pixelsPerWheelLine threshold reached
          nDelta = event.deltaY < 0 ? 1 : -1;
  
          if ( tracker.scrollHandler ) {
              propagate = tracker.scrollHandler(
                  {
                      eventSource:          tracker,
                      pointerType:          'mouse',
                      position:             getMouseRelative( event, tracker.element ),
                      scroll:               nDelta,
                      shift:                event.shiftKey,
                      isTouchEvent:         false,
                      originalEvent:        originalEvent,
                      preventDefaultAction: false,
                      userData:             tracker.userData
                  }
              );
              if ( propagate === false ) {
                  $.cancelEvent( originalEvent );
              }
          }
      }
  
  
      /**
       * @private
       * @inner
       */
      function isParentChild( parent, child )
      {
         if ( parent === child ) {
             return false;
         }
         while ( child && child !== parent ) {
             child = child.parentNode;
         }
         return child === parent;
      }
  
  
      /**
       * Only used on IE 8
       *
       * @private
       * @inner
       */
      function onMouseEnter( tracker, event ) {
          event = $.getEvent( event );
  
          handleMouseEnter( tracker, event );
      }
  
  
      /**
       * @private
       * @inner
       */
      function onMouseOver( tracker, event ) {
          event = $.getEvent( event );
  
          if ( event.currentTarget === event.relatedTarget || isParentChild( event.currentTarget, event.relatedTarget ) ) {
              return;
          }
  
          handleMouseEnter( tracker, event );
      }
  
  
      /**
       * @private
       * @inner
       */
      function handleMouseEnter( tracker, event ) {
          var gPoint = {
              id: $.MouseTracker.mousePointerId,
              type: 'mouse',
              isPrimary: true,
              currentPos: getMouseAbsolute( event ),
              currentTime: $.now()
          };
  
          updatePointersEnter( tracker, event, [ gPoint ] );
      }
  
  
      /**
       * Only used on IE 8
       *
       * @private
       * @inner
       */
      function onMouseLeave( tracker, event ) {
          event = $.getEvent( event );
  
          handleMouseExit( tracker, event );
      }
  
  
      /**
       * @private
       * @inner
       */
      function onMouseOut( tracker, event ) {
          event = $.getEvent( event );
  
          if ( event.currentTarget === event.relatedTarget || isParentChild( event.currentTarget, event.relatedTarget ) ) {
              return;
          }
  
          handleMouseExit( tracker, event );
      }
  
  
      /**
       * @private
       * @inner
       */
      function handleMouseExit( tracker, event ) {
          var gPoint = {
              id: $.MouseTracker.mousePointerId,
              type: 'mouse',
              isPrimary: true,
              currentPos: getMouseAbsolute( event ),
              currentTime: $.now()
          };
  
          updatePointersExit( tracker, event, [ gPoint ] );
      }
  
  
      /**
       * Returns a W3C DOM level 3 standard button value given an event.button property:
       *   -1 == none, 0 == primary/left, 1 == middle, 2 == secondary/right, 3 == X1/back, 4 == X2/forward, 5 == eraser (pen)
       * @private
       * @inner
       */
      function getStandardizedButton( button ) {
          if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {
              // On IE 8, 0 == none, 1 == left, 2 == right, 3 == left and right, 4 == middle, 5 == left and middle, 6 == right and middle, 7 == all three
              // TODO: Support chorded (multiple) button presses on IE 8?
              if ( button === 1 ) {
                  return 0;
              } else if ( button === 2 ) {
                  return 2;
              } else if ( button === 4 ) {
                  return 1;
              } else {
                  return -1;
              }
          } else {
              return button;
          }
      }
  
  
      /**
       * @private
       * @inner
       */
      function onMouseDown( tracker, event ) {
          var gPoint;
  
          event = $.getEvent( event );
  
          gPoint = {
              id: $.MouseTracker.mousePointerId,
              type: 'mouse',
              isPrimary: true,
              currentPos: getMouseAbsolute( event ),
              currentTime: $.now()
          };
  
          if ( updatePointersDown( tracker, event, [ gPoint ], getStandardizedButton( event.button ) ) ) {
              $.stopEvent( event );
              capturePointer( tracker, 'mouse' );
          }
  
          if ( tracker.clickHandler || tracker.dblClickHandler || tracker.pressHandler || tracker.dragHandler || tracker.dragEndHandler ) {
              $.cancelEvent( event );
          }
      }
  
  
      /**
       * @private
       * @inner
       */
      function onMouseUp( tracker, event ) {
          handleMouseUp( tracker, event );
      }
  
      /**
       * This handler is attached to the window object (on the capture phase) to emulate mouse capture.
       * onMouseUp is still attached to the tracked element, so stop propagation to avoid processing twice.
       *
       * @private
       * @inner
       */
      function onMouseUpCaptured( tracker, event ) {
          handleMouseUp( tracker, event );
          $.stopEvent( event );
      }
  
  
      /**
       * @private
       * @inner
       */
      function handleMouseUp( tracker, event ) {
          var gPoint;
  
          event = $.getEvent( event );
  
          gPoint = {
              id: $.MouseTracker.mousePointerId,
              type: 'mouse',
              isPrimary: true,
              currentPos: getMouseAbsolute( event ),
              currentTime: $.now()
          };
  
          if ( updatePointersUp( tracker, event, [ gPoint ], getStandardizedButton( event.button ) ) ) {
              releasePointer( tracker, 'mouse' );
          }
      }
  
  
      /**
       * @private
       * @inner
       */
      function onMouseMove( tracker, event ) {
          handleMouseMove( tracker, event );
     }
  
  
      /**
       * This handler is attached to the window object (on the capture phase) to emulate mouse capture.
       * onMouseMove is still attached to the tracked element, so stop propagation to avoid processing twice.
       *
       * @private
       * @inner
       */
      function onMouseMoveCaptured( tracker, event ) {
          handleMouseMove( tracker, event );
          $.stopEvent( event );
      }
  
  
      /**
       * @private
       * @inner
       */
      function handleMouseMove( tracker, event ) {
          var gPoint;
  
          event = $.getEvent( event );
  
          gPoint = {
              id: $.MouseTracker.mousePointerId,
              type: 'mouse',
              isPrimary: true,
              currentPos: getMouseAbsolute( event ),
              currentTime: $.now()
          };
  
          updatePointersMove( tracker, event, [ gPoint ] );
      }
  
  
      /**
       * @private
       * @inner
       */
      function abortContacts( tracker, event, pointsList ) {
          var i,
              gPointCount = pointsList.getLength(),
              abortGPoints = [];
  
          // Check contact count for hoverable pointer types before aborting
          if (pointsList.type === 'touch' || pointsList.contacts > 0) {
              for ( i = 0; i < gPointCount; i++ ) {
                  abortGPoints.push( pointsList.getByIndex( i ) );
              }
  
              if ( abortGPoints.length > 0 ) {
                  // simulate touchend/mouseup
                  updatePointersUp( tracker, event, abortGPoints, 0 ); // 0 means primary button press/release or touch contact
                  // release pointer capture
                  pointsList.captureCount = 1;
                  releasePointer( tracker, pointsList.type );
                  // simulate touchleave/mouseout
                  updatePointersExit( tracker, event, abortGPoints );
              }
          }
      }
  
  
      /**
       * @private
       * @inner
       */
      function onTouchStart( tracker, event ) {
          var time,
              i,
              j,
              touchCount = event.changedTouches.length,
              gPoints = [],
              parentGPoints,
              pointsList = tracker.getActivePointersListByType( 'touch' );
  
          time = $.now();
  
          if ( pointsList.getLength() > event.touches.length - touchCount ) {
              $.console.warn('Tracked touch contact count doesn\'t match event.touches.length. Removing all tracked touch pointers.');
              abortContacts( tracker, event, pointsList );
          }
  
          for ( i = 0; i < touchCount; i++ ) {
              gPoints.push( {
                  id: event.changedTouches[ i ].identifier,
                  type: 'touch',
                  // isPrimary not set - let the updatePointers functions determine it
                  currentPos: getMouseAbsolute( event.changedTouches[ i ] ),
                  currentTime: time
              } );
          }
  
          // simulate touchenter on our tracked element
          updatePointersEnter( tracker, event, gPoints );
  
          // simulate touchenter on our tracked element's tracked ancestor elements
          for ( i = 0; i < MOUSETRACKERS.length; i++ ) {
              if ( MOUSETRACKERS[ i ] !== tracker && MOUSETRACKERS[ i ].isTracking() && isParentChild( MOUSETRACKERS[ i ].element, tracker.element ) ) {
                  parentGPoints = [];
                  for ( j = 0; j < touchCount; j++ ) {
                      parentGPoints.push( {
                          id: event.changedTouches[ j ].identifier,
                          type: 'touch',
                          // isPrimary not set - let the updatePointers functions determine it
                          currentPos: getMouseAbsolute( event.changedTouches[ j ] ),
                          currentTime: time
                      } );
                  }
                  updatePointersEnter( MOUSETRACKERS[ i ], event, parentGPoints );
              }
          }
  
          if ( updatePointersDown( tracker, event, gPoints, 0 ) ) { // 0 means primary button press/release or touch contact
              $.stopEvent( event );
              capturePointer( tracker, 'touch', touchCount );
          }
  
          $.cancelEvent( event );
      }
  
  
      /**
       * @private
       * @inner
       */
      function onTouchEnd( tracker, event ) {
          handleTouchEnd( tracker, event );
      }
  
  
      /**
       * This handler is attached to the window object (on the capture phase) to emulate pointer capture.
       * onTouchEnd is still attached to the tracked element, so stop propagation to avoid processing twice.
       *
       * @private
       * @inner
       */
      function onTouchEndCaptured( tracker, event ) {
          handleTouchEnd( tracker, event );
          $.stopEvent( event );
      }
  
  
      /**
       * @private
       * @inner
       */
      function handleTouchEnd( tracker, event ) {
          var time,
              i,
              j,
              touchCount = event.changedTouches.length,
              gPoints = [],
              parentGPoints;
  
          time = $.now();
  
          for ( i = 0; i < touchCount; i++ ) {
              gPoints.push( {
                  id: event.changedTouches[ i ].identifier,
                  type: 'touch',
                  // isPrimary not set - let the updatePointers functions determine it
                  currentPos: getMouseAbsolute( event.changedTouches[ i ] ),
                  currentTime: time
              } );
          }
  
          if ( updatePointersUp( tracker, event, gPoints, 0 ) ) {
              releasePointer( tracker, 'touch', touchCount );
          }
  
          // simulate touchleave on our tracked element
          updatePointersExit( tracker, event, gPoints );
  
          // simulate touchleave on our tracked element's tracked ancestor elements
          for ( i = 0; i < MOUSETRACKERS.length; i++ ) {
              if ( MOUSETRACKERS[ i ] !== tracker && MOUSETRACKERS[ i ].isTracking() && isParentChild( MOUSETRACKERS[ i ].element, tracker.element ) ) {
                  parentGPoints = [];
                  for ( j = 0; j < touchCount; j++ ) {
                      parentGPoints.push( {
                          id: event.changedTouches[ j ].identifier,
                          type: 'touch',
                          // isPrimary not set - let the updatePointers functions determine it
                          currentPos: getMouseAbsolute( event.changedTouches[ j ] ),
                          currentTime: time
                      } );
                  }
                  updatePointersExit( MOUSETRACKERS[ i ], event, parentGPoints );
              }
          }
  
          $.cancelEvent( event );
      }
  
  
      /**
       * @private
       * @inner
       */
      function onTouchMove( tracker, event ) {
          handleTouchMove( tracker, event );
      }
  
  
      /**
       * This handler is attached to the window object (on the capture phase) to emulate pointer capture.
       * onTouchMove is still attached to the tracked element, so stop propagation to avoid processing twice.
       *
       * @private
       * @inner
       */
      function onTouchMoveCaptured( tracker, event ) {
          handleTouchMove( tracker, event );
          $.stopEvent( event );
      }
  
  
      /**
       * @private
       * @inner
       */
      function handleTouchMove( tracker, event ) {
          var i,
              touchCount = event.changedTouches.length,
              gPoints = [];
  
          for ( i = 0; i < touchCount; i++ ) {
              gPoints.push( {
                  id: event.changedTouches[ i ].identifier,
                  type: 'touch',
                  // isPrimary not set - let the updatePointers functions determine it
                  currentPos: getMouseAbsolute( event.changedTouches[ i ] ),
                  currentTime: $.now()
              } );
          }
  
          updatePointersMove( tracker, event, gPoints );
  
          $.cancelEvent( event );
      }
  
  
      /**
       * @private
       * @inner
       */
      function onTouchCancel( tracker, event ) {
          var pointsList = tracker.getActivePointersListByType('touch');
  
          abortContacts( tracker, event, pointsList );
      }
  
  
      /**
       * @private
       * @inner
       */
      function onGestureStart( tracker, event ) {
          event.stopPropagation();
          event.preventDefault();
          return false;
      }
  
  
      /**
       * @private
       * @inner
       */
      function onGestureChange( tracker, event ) {
          event.stopPropagation();
          event.preventDefault();
          return false;
      }
  
  
      /**
       * @private
       * @inner
       */
      function onPointerOver( tracker, event ) {
          var gPoint;
  
          if ( event.currentTarget === event.relatedTarget || isParentChild( event.currentTarget, event.relatedTarget ) ) {
              return;
          }
  
          gPoint = {
              id: event.pointerId,
              type: getPointerType( event ),
              isPrimary: event.isPrimary,
              currentPos: getMouseAbsolute( event ),
              currentTime: $.now()
          };
  
          updatePointersEnter( tracker, event, [ gPoint ] );
      }
  
  
      /**
       * @private
       * @inner
       */
      function onPointerOut( tracker, event ) {
          var gPoint;
  
          if ( event.currentTarget === event.relatedTarget || isParentChild( event.currentTarget, event.relatedTarget ) ) {
              return;
          }
  
          gPoint = {
              id: event.pointerId,
              type: getPointerType( event ),
              isPrimary: event.isPrimary,
              currentPos: getMouseAbsolute( event ),
              currentTime: $.now()
          };
  
          updatePointersExit( tracker, event, [ gPoint ] );
      }
  
  
      /**
       * @private
       * @inner
       */
      function onPointerDown( tracker, event ) {
          var gPoint;
  
          gPoint = {
              id: event.pointerId,
              type: getPointerType( event ),
              isPrimary: event.isPrimary,
              currentPos: getMouseAbsolute( event ),
              currentTime: $.now()
          };
  
          if ( updatePointersDown( tracker, event, [ gPoint ], event.button ) ) {
              $.stopEvent( event );
              capturePointer( tracker, gPoint.type );
          }
  
          if ( tracker.clickHandler || tracker.dblClickHandler || tracker.pressHandler || tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler ) {
              $.cancelEvent( event );
          }
      }
  
  
      /**
       * @private
       * @inner
       */
      function onPointerUp( tracker, event ) {
          handlePointerUp( tracker, event );
      }
  
  
      /**
       * This handler is attached to the window object (on the capture phase) to emulate mouse capture.
       * onPointerUp is still attached to the tracked element, so stop propagation to avoid processing twice.
       *
       * @private
       * @inner
       */
      function onPointerUpCaptured( tracker, event ) {
          var pointsList = tracker.getActivePointersListByType( getPointerType( event ) );
          if ( pointsList.getById( event.pointerId ) ) {
              handlePointerUp( tracker, event );
          }
          $.stopEvent( event );
      }
  
  
      /**
       * @private
       * @inner
       */
      function handlePointerUp( tracker, event ) {
          var gPoint;
  
          gPoint = {
              id: event.pointerId,
              type: getPointerType( event ),
              isPrimary: event.isPrimary,
              currentPos: getMouseAbsolute( event ),
              currentTime: $.now()
          };
  
          if ( updatePointersUp( tracker, event, [ gPoint ], event.button ) ) {
              releasePointer( tracker, gPoint.type );
          }
      }
  
  
      /**
       * @private
       * @inner
       */
      function onPointerMove( tracker, event ) {
          handlePointerMove( tracker, event );
      }
  
  
      /**
       * This handler is attached to the window object (on the capture phase) to emulate mouse capture.
       * onPointerMove is still attached to the tracked element, so stop propagation to avoid processing twice.
       *
       * @private
       * @inner
       */
      function onPointerMoveCaptured( tracker, event ) {
          var pointsList = tracker.getActivePointersListByType( getPointerType( event ) );
          if ( pointsList.getById( event.pointerId ) ) {
              handlePointerMove( tracker, event );
          }
          $.stopEvent( event );
      }
  
  
      /**
       * @private
       * @inner
       */
      function handlePointerMove( tracker, event ) {
          // Pointer changed coordinates, button state, pressure, tilt, or contact geometry (e.g. width and height)
          var gPoint;
  
          gPoint = {
              id: event.pointerId,
              type: getPointerType( event ),
              isPrimary: event.isPrimary,
              currentPos: getMouseAbsolute( event ),
              currentTime: $.now()
          };
  
          updatePointersMove( tracker, event, [ gPoint ] );
      }
  
  
      /**
       * @private
       * @inner
       */
      function onPointerCancel( tracker, event ) {
          var gPoint;
  
          gPoint = {
              id: event.pointerId,
              type: getPointerType( event )
          };
  
          updatePointersCancel( tracker, event, [ gPoint ] );
      }
  
  
  ///////////////////////////////////////////////////////////////////////////////
  // Device-agnostic DOM event handlers
  ///////////////////////////////////////////////////////////////////////////////
  
      /**
       * @function
       * @private
       * @inner
       * @param {OpenSeadragon.MouseTracker.GesturePointList} pointsList
       *     The GesturePointList to track the pointer in.
       * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
       *      Gesture point to track.
       * @returns {Number} Number of gesture points in pointsList.
       */
      function startTrackingPointer( pointsList, gPoint ) {
  
          // If isPrimary is not known for the pointer then set it according to our rules:
          //    true if the first pointer in the gesture, otherwise false
          if ( !Object.prototype.hasOwnProperty.call( gPoint, 'isPrimary' ) ) {
              if ( pointsList.getLength() === 0 ) {
                  gPoint.isPrimary = true;
              } else {
                  gPoint.isPrimary = false;
              }
          }
          gPoint.speed = 0;
          gPoint.direction = 0;
          gPoint.contactPos = gPoint.currentPos;
          gPoint.contactTime = gPoint.currentTime;
          gPoint.lastPos = gPoint.currentPos;
          gPoint.lastTime = gPoint.currentTime;
  
          return pointsList.add( gPoint );
      }
  
  
      /**
       * @function
       * @private
       * @inner
       * @param {OpenSeadragon.MouseTracker.GesturePointList} pointsList
       *     The GesturePointList to stop tracking the pointer on.
       * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
       *      Gesture point to stop tracking.
       * @returns {Number} Number of gesture points in pointsList.
       */
      function stopTrackingPointer( pointsList, gPoint ) {
          var listLength,
              primaryPoint;
  
          if ( pointsList.getById( gPoint.id ) ) {
              listLength = pointsList.removeById( gPoint.id );
  
              // If isPrimary is not known for the pointer and we just removed the primary pointer from the list then we need to set another pointer as primary
              if ( !Object.prototype.hasOwnProperty.call( gPoint, 'isPrimary' ) ) {
                  primaryPoint = pointsList.getPrimary();
                  if ( !primaryPoint ) {
                      primaryPoint = pointsList.getByIndex( 0 );
                      if ( primaryPoint ) {
                          primaryPoint.isPrimary = true;
                      }
                  }
              }
          } else {
              listLength = pointsList.getLength();
          }
  
          return listLength;
      }
  
  
      /**
       * @function
       * @private
       * @inner
       * @param {OpenSeadragon.MouseTracker} tracker
       *     A reference to the MouseTracker instance.
       * @param {Object} event
       *     A reference to the originating DOM event.
       * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints
       *      Gesture points associated with the event.
       */
      function updatePointersEnter( tracker, event, gPoints ) {
          var pointsList = tracker.getActivePointersListByType( gPoints[ 0 ].type ),
              i,
              gPointCount = gPoints.length,
              curGPoint,
              updateGPoint,
              propagate;
  
          for ( i = 0; i < gPointCount; i++ ) {
              curGPoint = gPoints[ i ];
              updateGPoint = pointsList.getById( curGPoint.id );
  
              if ( updateGPoint ) {
                  // Already tracking the pointer...update it
                  updateGPoint.insideElement = true;
                  updateGPoint.lastPos = updateGPoint.currentPos;
                  updateGPoint.lastTime = updateGPoint.currentTime;
                  updateGPoint.currentPos = curGPoint.currentPos;
                  updateGPoint.currentTime = curGPoint.currentTime;
  
                  curGPoint = updateGPoint;
              } else {
                  // Initialize for tracking and add to the tracking list
                  curGPoint.captured = false;
                  curGPoint.insideElementPressed = false;
                  curGPoint.insideElement = true;
                  startTrackingPointer( pointsList, curGPoint );
              }
  
              // Enter
              if ( tracker.enterHandler ) {
                  propagate = tracker.enterHandler(
                      {
                          eventSource:          tracker,
                          pointerType:          curGPoint.type,
                          position:             getPointRelativeToAbsolute( curGPoint.currentPos, tracker.element ),
                          buttons:              pointsList.buttons,
                          pointers:             tracker.getActivePointerCount(),
                          insideElementPressed: curGPoint.insideElementPressed,
                          buttonDownAny:        pointsList.buttons !== 0,
                          isTouchEvent:         curGPoint.type === 'touch',
                          originalEvent:        event,
                          preventDefaultAction: false,
                          userData:             tracker.userData
                      }
                  );
                  if ( propagate === false ) {
                      $.cancelEvent( event );
                  }
              }
          }
      }
  
  
      /**
       * @function
       * @private
       * @inner
       * @param {OpenSeadragon.MouseTracker} tracker
       *     A reference to the MouseTracker instance.
       * @param {Object} event
       *     A reference to the originating DOM event.
       * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints
       *      Gesture points associated with the event.
       */
      function updatePointersExit( tracker, event, gPoints ) {
          var pointsList = tracker.getActivePointersListByType(gPoints[0].type),
              i,
              gPointCount = gPoints.length,
              curGPoint,
              updateGPoint,
              propagate;
  
          for ( i = 0; i < gPointCount; i++ ) {
              curGPoint = gPoints[ i ];
              updateGPoint = pointsList.getById( curGPoint.id );
  
              if ( updateGPoint ) {
                  // Already tracking the pointer. If captured then update it, else stop tracking it
                  if ( updateGPoint.captured ) {
                      updateGPoint.insideElement = false;
                      updateGPoint.lastPos = updateGPoint.currentPos;
                      updateGPoint.lastTime = updateGPoint.currentTime;
                      updateGPoint.currentPos = curGPoint.currentPos;
                      updateGPoint.currentTime = curGPoint.currentTime;
                  } else {
                      stopTrackingPointer( pointsList, updateGPoint );
                  }
  
                  curGPoint = updateGPoint;
              }
  
              // Exit
              if ( tracker.exitHandler ) {
                  propagate = tracker.exitHandler(
                      {
                          eventSource:          tracker,
                          pointerType:          curGPoint.type,
                          position:             curGPoint.currentPos && getPointRelativeToAbsolute( curGPoint.currentPos, tracker.element ),
                          buttons:              pointsList.buttons,
                          pointers:             tracker.getActivePointerCount(),
                          insideElementPressed: updateGPoint ? updateGPoint.insideElementPressed : false,
                          buttonDownAny:        pointsList.buttons !== 0,
                          isTouchEvent:         curGPoint.type === 'touch',
                          originalEvent:        event,
                          preventDefaultAction: false,
                          userData:             tracker.userData
                      }
                  );
  
                  if ( propagate === false ) {
                      $.cancelEvent( event );
                  }
              }
          }
      }
  
  
      /**
       * @function
       * @private
       * @inner
       * @param {OpenSeadragon.MouseTracker} tracker
       *     A reference to the MouseTracker instance.
       * @param {Object} event
       *     A reference to the originating DOM event.
       * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints
       *      Gesture points associated with the event.
       * @param {Number} buttonChanged
       *      The button involved in the event: -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
       *      Note on chorded button presses (a button pressed when another button is already pressed): In the W3C Pointer Events model,
       *      only one pointerdown/pointerup event combo is fired. Chorded button state changes instead fire pointermove events.
       *
       * @returns {Boolean} True if pointers should be captured to the tracked element, otherwise false.
       */
      function updatePointersDown( tracker, event, gPoints, buttonChanged ) {
          var delegate = THIS[ tracker.hash ],
              propagate,
              pointsList = tracker.getActivePointersListByType( gPoints[ 0 ].type ),
              i,
              gPointCount = gPoints.length,
              curGPoint,
              updateGPoint;
  
          if ( typeof event.buttons !== 'undefined' ) {
              pointsList.buttons = event.buttons;
          } else {
              if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {
                  if ( buttonChanged === 0 ) {
                      // Primary
                      pointsList.buttons += 1;
                  } else if ( buttonChanged === 1 ) {
                      // Aux
                      pointsList.buttons += 4;
                  } else if ( buttonChanged === 2 ) {
                      // Secondary
                      pointsList.buttons += 2;
                  } else if ( buttonChanged === 3 ) {
                      // X1 (Back)
                      pointsList.buttons += 8;
                  } else if ( buttonChanged === 4 ) {
                      // X2 (Forward)
                      pointsList.buttons += 16;
                  } else if ( buttonChanged === 5 ) {
                      // Pen Eraser
                      pointsList.buttons += 32;
                  }
              } else {
                  if ( buttonChanged === 0 ) {
                      // Primary
                      pointsList.buttons |= 1;
                  } else if ( buttonChanged === 1 ) {
                      // Aux
                      pointsList.buttons |= 4;
                  } else if ( buttonChanged === 2 ) {
                      // Secondary
                      pointsList.buttons |= 2;
                  } else if ( buttonChanged === 3 ) {
                      // X1 (Back)
                      pointsList.buttons |= 8;
                  } else if ( buttonChanged === 4 ) {
                      // X2 (Forward)
                      pointsList.buttons |= 16;
                  } else if ( buttonChanged === 5 ) {
                      // Pen Eraser
                      pointsList.buttons |= 32;
                  }
              }
          }
  
          // Some pointers may steal control from another pointer without firing the appropriate release events
          // e.g. Touching a screen while click-dragging with certain mice.
          var otherPointsLists = tracker.getActivePointersListsExceptType(gPoints[ 0 ].type);
          for (i = 0; i < otherPointsLists.length; i++) {
              //If another pointer has contact, simulate the release
              abortContacts(tracker, event, otherPointsLists[i]); // No-op if no active pointer
          }
  
          // Only capture and track primary button, pen, and touch contacts
          if ( buttonChanged !== 0 ) {
              // Aux Press
              if ( tracker.nonPrimaryPressHandler ) {
                  propagate = tracker.nonPrimaryPressHandler(
                      {
                          eventSource:          tracker,
                          pointerType:          gPoints[ 0 ].type,
                          position:             getPointRelativeToAbsolute( gPoints[ 0 ].currentPos, tracker.element ),
                          button:               buttonChanged,
                          buttons:              pointsList.buttons,
                          isTouchEvent:         gPoints[ 0 ].type === 'touch',
                          originalEvent:        event,
                          preventDefaultAction: false,
                          userData:             tracker.userData
                      }
                  );
                  if ( propagate === false ) {
                      $.cancelEvent( event );
                  }
              }
  
              return false;
          }
  
          for ( i = 0; i < gPointCount; i++ ) {
              curGPoint = gPoints[ i ];
              updateGPoint = pointsList.getById( curGPoint.id );
  
              if ( updateGPoint ) {
                  // Already tracking the pointer...update it
                  updateGPoint.captured = true;
                  updateGPoint.insideElementPressed = true;
                  updateGPoint.insideElement = true;
                  updateGPoint.contactPos = curGPoint.currentPos;
                  updateGPoint.contactTime = curGPoint.currentTime;
                  updateGPoint.lastPos = updateGPoint.currentPos;
                  updateGPoint.lastTime = updateGPoint.currentTime;
                  updateGPoint.currentPos = curGPoint.currentPos;
                  updateGPoint.currentTime = curGPoint.currentTime;
  
                  curGPoint = updateGPoint;
              } else {
                  // Initialize for tracking and add to the tracking list (no pointerover or pointermove event occurred before this)
                  curGPoint.captured = true;
                  curGPoint.insideElementPressed = true;
                  curGPoint.insideElement = true;
                  startTrackingPointer( pointsList, curGPoint );
              }
  
              pointsList.addContact();
              //$.console.log('contacts++ ', pointsList.contacts);
  
              if ( tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler ) {
                  $.MouseTracker.gesturePointVelocityTracker.addPoint( tracker, curGPoint );
              }
  
              if ( pointsList.contacts === 1 ) {
                  // Press
                  if ( tracker.pressHandler ) {
                      propagate = tracker.pressHandler(
                          {
                              eventSource:          tracker,
                              pointerType:          curGPoint.type,
                              position:             getPointRelativeToAbsolute( curGPoint.contactPos, tracker.element ),
                              buttons:              pointsList.buttons,
                              isTouchEvent:         curGPoint.type === 'touch',
                              originalEvent:        event,
                              preventDefaultAction: false,
                              userData:             tracker.userData
                          }
                      );
                      if ( propagate === false ) {
                          $.cancelEvent( event );
                      }
                  }
              } else if ( pointsList.contacts === 2 ) {
                  if ( tracker.pinchHandler && curGPoint.type === 'touch' ) {
                      // Initialize for pinch
                      delegate.pinchGPoints = pointsList.asArray();
                      delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[ 0 ].currentPos.distanceTo( delegate.pinchGPoints[ 1 ].currentPos );
                      delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint( delegate.pinchGPoints[ 0 ].currentPos, delegate.pinchGPoints[ 1 ].currentPos );
                  }
              }
          }
  
          return true;
      }
  
  
      /**
       * @function
       * @private
       * @inner
       * @param {OpenSeadragon.MouseTracker} tracker
       *     A reference to the MouseTracker instance.
       * @param {Object} event
       *     A reference to the originating DOM event.
       * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints
       *      Gesture points associated with the event.
       * @param {Number} buttonChanged
       *      The button involved in the event: -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
       *      Note on chorded button presses (a button pressed when another button is already pressed): In the W3C Pointer Events model,
       *      only one pointerdown/pointerup event combo is fired. Chorded button state changes instead fire pointermove events.
       *
       * @returns {Boolean} True if pointer capture should be released from the tracked element, otherwise false.
       */
      function updatePointersUp( tracker, event, gPoints, buttonChanged ) {
          var delegate = THIS[ tracker.hash ],
              pointsList = tracker.getActivePointersListByType( gPoints[ 0 ].type ),
              propagate,
              releasePoint,
              releaseTime,
              i,
              gPointCount = gPoints.length,
              curGPoint,
              updateGPoint,
              releaseCapture = false,
              wasCaptured = false,
              quick;
  
          if ( typeof event.buttons !== 'undefined' ) {
              pointsList.buttons = event.buttons;
          } else {
              if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {
                  if ( buttonChanged === 0 ) {
                      // Primary
                      pointsList.buttons -= 1;
                  } else if ( buttonChanged === 1 ) {
                      // Aux
                      pointsList.buttons -= 4;
                  } else if ( buttonChanged === 2 ) {
                      // Secondary
                      pointsList.buttons -= 2;
                  } else if ( buttonChanged === 3 ) {
                      // X1 (Back)
                      pointsList.buttons -= 8;
                  } else if ( buttonChanged === 4 ) {
                      // X2 (Forward)
                      pointsList.buttons -= 16;
                  } else if ( buttonChanged === 5 ) {
                      // Pen Eraser
                      pointsList.buttons -= 32;
                  }
              } else {
                  if ( buttonChanged === 0 ) {
                      // Primary
                      pointsList.buttons ^= ~1;
                  } else if ( buttonChanged === 1 ) {
                      // Aux
                      pointsList.buttons ^= ~4;
                  } else if ( buttonChanged === 2 ) {
                      // Secondary
                      pointsList.buttons ^= ~2;
                  } else if ( buttonChanged === 3 ) {
                      // X1 (Back)
                      pointsList.buttons ^= ~8;
                  } else if ( buttonChanged === 4 ) {
                      // X2 (Forward)
                      pointsList.buttons ^= ~16;
                  } else if ( buttonChanged === 5 ) {
                      // Pen Eraser
                      pointsList.buttons ^= ~32;
                  }
              }
          }
  
          // Only capture and track primary button, pen, and touch contacts
          if ( buttonChanged !== 0 ) {
              // Aux Release
              if ( tracker.nonPrimaryReleaseHandler ) {
                  propagate = tracker.nonPrimaryReleaseHandler(
                      {
                          eventSource:           tracker,
                          pointerType:           gPoints[ 0 ].type,
                          position:              getPointRelativeToAbsolute(gPoints[0].currentPos, tracker.element),
                          button:                buttonChanged,
                          buttons:               pointsList.buttons,
                          isTouchEvent:          gPoints[ 0 ].type === 'touch',
                          originalEvent:         event,
                          preventDefaultAction:  false,
                          userData:              tracker.userData
                      }
                  );
                  if ( propagate === false ) {
                      $.cancelEvent( event );
                  }
              }
  
              // A primary mouse button may have been released while the non-primary button was down
              var otherPointsList = tracker.getActivePointersListByType("mouse");
              // Stop tracking the mouse; see https://github.com/openseadragon/openseadragon/pull/1223
              abortContacts(tracker, event, otherPointsList); // No-op if no active pointer
  
              return false;
          }
  
          // OS-specific gestures (e.g. swipe up with four fingers in iPadOS 13)
          if (typeof gPoints[ 0 ].currentPos === "undefined") {
              abortContacts(tracker, event, pointsList);
  
              return false;
          }
  
          for ( i = 0; i < gPointCount; i++ ) {
              curGPoint = gPoints[ i ];
              updateGPoint = pointsList.getById( curGPoint.id );
              if ( updateGPoint ) {
                  // Update the pointer, stop tracking it if not still in this element
                  if ( updateGPoint.captured ) {
                      updateGPoint.captured = false;
                      releaseCapture = true;
                      wasCaptured = true;
                  }
                  updateGPoint.lastPos = updateGPoint.currentPos;
                  updateGPoint.lastTime = updateGPoint.currentTime;
                  updateGPoint.currentPos = curGPoint.currentPos;
                  updateGPoint.currentTime = curGPoint.currentTime;
                  if ( !updateGPoint.insideElement ) {
                      stopTrackingPointer( pointsList, updateGPoint );
                  }
  
                  releasePoint = updateGPoint.currentPos;
                  releaseTime = updateGPoint.currentTime;
  
                  if ( wasCaptured ) {
                      // Pointer was activated in our element but could have been removed in any element since events are captured to our element
  
                      pointsList.removeContact();
                      //$.console.log('contacts-- ', pointsList.contacts);
  
                      if ( tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler ) {
                          $.MouseTracker.gesturePointVelocityTracker.removePoint( tracker, updateGPoint );
                      }
  
                      if ( pointsList.contacts === 0 ) {
  
                          // Release (pressed in our element)
                          if ( tracker.releaseHandler ) {
                              propagate = tracker.releaseHandler(
                                  {
                                      eventSource:           tracker,
                                      pointerType:           updateGPoint.type,
                                      position:              getPointRelativeToAbsolute( releasePoint, tracker.element ),
                                      buttons:               pointsList.buttons,
                                      insideElementPressed:  updateGPoint.insideElementPressed,
                                      insideElementReleased: updateGPoint.insideElement,
                                      isTouchEvent:          updateGPoint.type === 'touch',
                                      originalEvent:         event,
                                      preventDefaultAction:  false,
                                      userData:              tracker.userData
                                  }
                              );
                              if ( propagate === false ) {
                                  $.cancelEvent( event );
                              }
                          }
  
                          // Drag End
                          if ( tracker.dragEndHandler && !updateGPoint.currentPos.equals( updateGPoint.contactPos ) ) {
                              propagate = tracker.dragEndHandler(
                                  {
                                      eventSource:          tracker,
                                      pointerType:          updateGPoint.type,
                                      position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),
                                      speed:                updateGPoint.speed,
                                      direction:            updateGPoint.direction,
                                      shift:                event.shiftKey,
                                      isTouchEvent:         updateGPoint.type === 'touch',
                                      originalEvent:        event,
                                      preventDefaultAction: false,
                                      userData:             tracker.userData
                                  }
                              );
                              if ( propagate === false ) {
                                  $.cancelEvent( event );
                              }
                          }
  
                          // Click / Double-Click
                          if ( ( tracker.clickHandler || tracker.dblClickHandler ) && updateGPoint.insideElement ) {
                              quick = releaseTime - updateGPoint.contactTime <= tracker.clickTimeThreshold &&
                                              updateGPoint.contactPos.distanceTo( releasePoint ) <= tracker.clickDistThreshold;
  
                              // Click
                              if ( tracker.clickHandler ) {
                                  propagate = tracker.clickHandler(
                                      {
                                          eventSource:          tracker,
                                          pointerType:          updateGPoint.type,
                                          position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),
                                          quick:                quick,
                                          shift:                event.shiftKey,
                                          isTouchEvent:         updateGPoint.type === 'touch',
                                          originalEvent:        event,
                                          preventDefaultAction: false,
                                          userData:             tracker.userData
                                      }
                                  );
                                  if ( propagate === false ) {
                                      $.cancelEvent( event );
                                  }
                              }
  
                              // Double-Click
                              if ( tracker.dblClickHandler && quick ) {
                                  pointsList.clicks++;
                                  if ( pointsList.clicks === 1 ) {
                                      delegate.lastClickPos = releasePoint;
                                      /*jshint loopfunc:true*/
                                      delegate.dblClickTimeOut = setTimeout( function() {
                                          pointsList.clicks = 0;
                                      }, tracker.dblClickTimeThreshold );
                                      /*jshint loopfunc:false*/
                                  } else if ( pointsList.clicks === 2 ) {
                                      clearTimeout( delegate.dblClickTimeOut );
                                      pointsList.clicks = 0;
                                      if ( delegate.lastClickPos.distanceTo( releasePoint ) <= tracker.dblClickDistThreshold ) {
                                          propagate = tracker.dblClickHandler(
                                              {
                                                  eventSource:          tracker,
                                                  pointerType:          updateGPoint.type,
                                                  position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),
                                                  shift:                event.shiftKey,
                                                  isTouchEvent:         updateGPoint.type === 'touch',
                                                  originalEvent:        event,
                                                  preventDefaultAction: false,
                                                  userData:             tracker.userData
                                              }
                                          );
                                          if ( propagate === false ) {
                                              $.cancelEvent( event );
                                          }
                                      }
                                      delegate.lastClickPos = null;
                                  }
                              }
                          }
                      } else if ( pointsList.contacts === 2 ) {
                          if ( tracker.pinchHandler && updateGPoint.type === 'touch' ) {
                              // Reset for pinch
                              delegate.pinchGPoints = pointsList.asArray();
                              delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[ 0 ].currentPos.distanceTo( delegate.pinchGPoints[ 1 ].currentPos );
                              delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint( delegate.pinchGPoints[ 0 ].currentPos, delegate.pinchGPoints[ 1 ].currentPos );
                          }
                      }
                  } else {
                      // Pointer was activated in another element but removed in our element
  
                      // Release (pressed in another element)
                      if ( tracker.releaseHandler ) {
                          propagate = tracker.releaseHandler(
                              {
                                  eventSource:           tracker,
                                  pointerType:           updateGPoint.type,
                                  position:              getPointRelativeToAbsolute( releasePoint, tracker.element ),
                                  buttons:               pointsList.buttons,
                                  insideElementPressed:  updateGPoint.insideElementPressed,
                                  insideElementReleased: updateGPoint.insideElement,
                                  isTouchEvent:          updateGPoint.type === 'touch',
                                  originalEvent:         event,
                                  preventDefaultAction:  false,
                                  userData:              tracker.userData
                              }
                          );
                          if ( propagate === false ) {
                              $.cancelEvent( event );
                          }
                      }
                  }
              }
          }
  
          return releaseCapture;
      }
  
  
      /**
       * Call when pointer(s) change coordinates, button state, pressure, tilt, or contact geometry (e.g. width and height)
       *
       * @function
       * @private
       * @inner
       * @param {OpenSeadragon.MouseTracker} tracker
       *     A reference to the MouseTracker instance.
       * @param {Object} event
       *     A reference to the originating DOM event.
       * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints
       *      Gesture points associated with the event.
       */
      function updatePointersMove( tracker, event, gPoints ) {
          var delegate = THIS[ tracker.hash ],
              pointsList = tracker.getActivePointersListByType( gPoints[ 0 ].type ),
              i,
              gPointCount = gPoints.length,
              curGPoint,
              updateGPoint,
              gPointArray,
              delta,
              propagate;
  
          if ( typeof event.buttons !== 'undefined' ) {
              pointsList.buttons = event.buttons;
          }
  
          for ( i = 0; i < gPointCount; i++ ) {
              curGPoint = gPoints[ i ];
              updateGPoint = pointsList.getById( curGPoint.id );
  
              if ( updateGPoint ) {
                  // Already tracking the pointer...update it
                  if ( Object.prototype.hasOwnProperty.call( curGPoint, 'isPrimary' ) ) {
                      updateGPoint.isPrimary = curGPoint.isPrimary;
                  }
                  updateGPoint.lastPos = updateGPoint.currentPos;
                  updateGPoint.lastTime = updateGPoint.currentTime;
                  updateGPoint.currentPos = curGPoint.currentPos;
                  updateGPoint.currentTime = curGPoint.currentTime;
              } else {
                  // Initialize for tracking and add to the tracking list (no pointerover or pointerdown event occurred before this)
                  curGPoint.captured = false;
                  curGPoint.insideElementPressed = false;
                  curGPoint.insideElement = true;
                  startTrackingPointer( pointsList, curGPoint );
              }
          }
  
          // Stop (mouse only)
          if ( tracker.stopHandler && gPoints[ 0 ].type === 'mouse' ) {
              clearTimeout( tracker.stopTimeOut );
              tracker.stopTimeOut = setTimeout( function() {
                  handlePointerStop( tracker, event, gPoints[ 0 ].type );
              }, tracker.stopDelay );
          }
  
          if ( pointsList.contacts === 0 ) {
              // Move (no contacts: hovering mouse or other hover-capable device)
              if ( tracker.moveHandler ) {
                  propagate = tracker.moveHandler(
                      {
                          eventSource:          tracker,
                          pointerType:          gPoints[ 0 ].type,
                          position:             getPointRelativeToAbsolute( gPoints[ 0 ].currentPos, tracker.element ),
                          buttons:              pointsList.buttons,
                          isTouchEvent:         gPoints[ 0 ].type === 'touch',
                          originalEvent:        event,
                          preventDefaultAction: false,
                          userData:             tracker.userData
                      }
                  );
                  if ( propagate === false ) {
                      $.cancelEvent( event );
                  }
              }
          } else if ( pointsList.contacts === 1 ) {
              // Move (1 contact)
              if ( tracker.moveHandler ) {
                  updateGPoint = pointsList.asArray()[ 0 ];
                  propagate = tracker.moveHandler(
                      {
                          eventSource:          tracker,
                          pointerType:          updateGPoint.type,
                          position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),
                          buttons:              pointsList.buttons,
                          isTouchEvent:         updateGPoint.type === 'touch',
                          originalEvent:        event,
                          preventDefaultAction: false,
                          userData:             tracker.userData
                      }
                  );
                  if ( propagate === false ) {
                      $.cancelEvent( event );
                  }
              }
  
              // Drag
              if ( tracker.dragHandler ) {
                  updateGPoint = pointsList.asArray()[ 0 ];
                  delta = updateGPoint.currentPos.minus( updateGPoint.lastPos );
                  propagate = tracker.dragHandler(
                      {
                          eventSource:          tracker,
                          pointerType:          updateGPoint.type,
                          position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),
                          buttons:              pointsList.buttons,
                          delta:                delta,
                          speed:                updateGPoint.speed,
                          direction:            updateGPoint.direction,
                          shift:                event.shiftKey,
                          isTouchEvent:         updateGPoint.type === 'touch',
                          originalEvent:        event,
                          preventDefaultAction: false,
                          userData:             tracker.userData
                      }
                  );
                  if ( propagate === false ) {
                      $.cancelEvent( event );
                  }
              }
          } else if ( pointsList.contacts === 2 ) {
              // Move (2 contacts, use center)
              if ( tracker.moveHandler ) {
                  gPointArray = pointsList.asArray();
                  propagate = tracker.moveHandler(
                      {
                          eventSource:          tracker,
                          pointerType:          gPointArray[ 0 ].type,
                          position:             getPointRelativeToAbsolute( getCenterPoint( gPointArray[ 0 ].currentPos, gPointArray[ 1 ].currentPos ), tracker.element ),
                          buttons:              pointsList.buttons,
                          isTouchEvent:         gPointArray[ 0 ].type === 'touch',
                          originalEvent:        event,
                          preventDefaultAction: false,
                          userData:             tracker.userData
                      }
                  );
                  if ( propagate === false ) {
                      $.cancelEvent( event );
                  }
              }
  
              // Pinch
              if ( tracker.pinchHandler && gPoints[ 0 ].type === 'touch' ) {
                  delta = delegate.pinchGPoints[ 0 ].currentPos.distanceTo( delegate.pinchGPoints[ 1 ].currentPos );
                  if ( delta != delegate.currentPinchDist ) {
                      delegate.lastPinchDist = delegate.currentPinchDist;
                      delegate.currentPinchDist = delta;
                      delegate.lastPinchCenter = delegate.currentPinchCenter;
                      delegate.currentPinchCenter = getCenterPoint( delegate.pinchGPoints[ 0 ].currentPos, delegate.pinchGPoints[ 1 ].currentPos );
                      propagate = tracker.pinchHandler(
                          {
                              eventSource:          tracker,
                              pointerType:          'touch',
                              gesturePoints:        delegate.pinchGPoints,
                              lastCenter:           getPointRelativeToAbsolute( delegate.lastPinchCenter, tracker.element ),
                              center:               getPointRelativeToAbsolute( delegate.currentPinchCenter, tracker.element ),
                              lastDistance:         delegate.lastPinchDist,
                              distance:             delegate.currentPinchDist,
                              shift:                event.shiftKey,
                              originalEvent:        event,
                              preventDefaultAction: false,
                              userData:             tracker.userData
                          }
                      );
                      if ( propagate === false ) {
                          $.cancelEvent( event );
                      }
                  }
              }
          }
      }
  
  
      /**
       * @function
       * @private
       * @inner
       * @param {OpenSeadragon.MouseTracker} tracker
       *     A reference to the MouseTracker instance.
       * @param {Object} event
       *     A reference to the originating DOM event.
       * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints
       *      Gesture points associated with the event.
       */
      function updatePointersCancel( tracker, event, gPoints ) {
          updatePointersUp( tracker, event, gPoints, 0 );
          updatePointersExit( tracker, event, gPoints );
      }
  
  
      /**
       * @private
       * @inner
       */
      function handlePointerStop( tracker, originalMoveEvent, pointerType ) {
          if ( tracker.stopHandler ) {
              tracker.stopHandler( {
                  eventSource:          tracker,
                  pointerType:          pointerType,
                  position:             getMouseRelative( originalMoveEvent, tracker.element ),
                  buttons:              tracker.getActivePointersListByType( pointerType ).buttons,
                  isTouchEvent:         pointerType === 'touch',
                  originalEvent:        originalMoveEvent,
                  preventDefaultAction: false,
                  userData:             tracker.userData
              } );
          }
      }
  
      /**
       * True if inside an iframe, otherwise false.
       * @member {Boolean} isInIframe
       * @private
       * @inner
       */
      var isInIframe = (function() {
          try {
              return window.self !== window.top;
          } catch (e) {
              return true;
          }
      })();
  
      /**
       * @function
       * @private
       * @inner
       * @returns {Boolean} True if the target has access rights to events, otherwise false.
       */
      function canAccessEvents (target) {
          try {
              return target.addEventListener && target.removeEventListener;
          } catch (e) {
              return false;
          }
      }
  
  }(OpenSeadragon));
  
  /*
   * OpenSeadragon - Control
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  /**
   * An enumeration of supported locations where controls can be anchored.
   * The anchoring is always relative to the container.
   * @member ControlAnchor
   * @memberof OpenSeadragon
   * @static
   * @type {Object}
   * @property {Number} NONE
   * @property {Number} TOP_LEFT
   * @property {Number} TOP_RIGHT
   * @property {Number} BOTTOM_LEFT
   * @property {Number} BOTTOM_RIGHT
   * @property {Number} ABSOLUTE
   */
  $.ControlAnchor = {
      NONE: 0,
      TOP_LEFT: 1,
      TOP_RIGHT: 2,
      BOTTOM_RIGHT: 3,
      BOTTOM_LEFT: 4,
      ABSOLUTE: 5
  };
  
  /**
   * @class Control
   * @classdesc A Control represents any interface element which is meant to allow the user
   * to interact with the zoomable interface. Any control can be anchored to any
   * element.
   *
   * @memberof OpenSeadragon
   * @param {Element} element - the control element to be anchored in the container.
   * @param {Object } options - All required and optional settings for configuring a control element.
   * @param {OpenSeadragon.ControlAnchor} [options.anchor=OpenSeadragon.ControlAnchor.NONE] - the position of the control
   *  relative to the container.
   * @param {Boolean} [options.attachToViewer=true] - Whether the control should be added directly to the viewer, or
   *  directly to the container
   * @param {Boolean} [options.autoFade=true] - Whether the control should have the autofade behavior
   * @param {Element} container - the element to control will be anchored too.
   */
  $.Control = function ( element, options, container ) {
      var parent = element.parentNode;
      if (typeof options === 'number')
      {
          $.console.error("Passing an anchor directly into the OpenSeadragon.Control constructor is deprecated; " +
                          "please use an options object instead.  " +
                          "Support for this deprecated variant is scheduled for removal in December 2013");
           options = {anchor: options};
      }
      options.attachToViewer = (typeof options.attachToViewer === 'undefined') ? true : options.attachToViewer;
      /**
       * True if the control should have autofade behavior.
       * @member {Boolean} autoFade
       * @memberof OpenSeadragon.Control#
       */
      this.autoFade = (typeof options.autoFade === 'undefined') ? true : options.autoFade;
      /**
       * The element providing the user interface with some type of control (e.g. a zoom-in button).
       * @member {Element} element
       * @memberof OpenSeadragon.Control#
       */
      this.element    = element;
      /**
       * The position of the Control relative to its container.
       * @member {OpenSeadragon.ControlAnchor} anchor
       * @memberof OpenSeadragon.Control#
       */
      this.anchor     = options.anchor;
      /**
       * The Control's containing element.
       * @member {Element} container
       * @memberof OpenSeadragon.Control#
       */
      this.container  = container;
      /**
       * A neutral element surrounding the control element.
       * @member {Element} wrapper
       * @memberof OpenSeadragon.Control#
       */
      if ( this.anchor == $.ControlAnchor.ABSOLUTE ) {
          this.wrapper    = $.makeNeutralElement( "div" );
          this.wrapper.style.position = "absolute";
          this.wrapper.style.top = typeof (options.top) == "number" ? (options.top + 'px') : options.top;
          this.wrapper.style.left  = typeof (options.left) == "number" ? (options.left + 'px') : options.left;
          this.wrapper.style.height = typeof (options.height) == "number" ? (options.height + 'px') : options.height;
          this.wrapper.style.width  = typeof (options.width) == "number" ? (options.width + 'px') : options.width;
          this.wrapper.style.margin = "0px";
          this.wrapper.style.padding = "0px";
  
          this.element.style.position = "relative";
          this.element.style.top = "0px";
          this.element.style.left = "0px";
          this.element.style.height = "100%";
          this.element.style.width = "100%";
      } else {
          this.wrapper    = $.makeNeutralElement( "div" );
          this.wrapper.style.display = "inline-block";
          if ( this.anchor == $.ControlAnchor.NONE ) {
              // IE6 fix
              this.wrapper.style.width = this.wrapper.style.height = "100%";
          }
      }
      this.wrapper.appendChild( this.element );
  
      if (options.attachToViewer ) {
          if ( this.anchor == $.ControlAnchor.TOP_RIGHT ||
               this.anchor == $.ControlAnchor.BOTTOM_RIGHT ) {
              this.container.insertBefore(
                  this.wrapper,
                  this.container.firstChild
              );
          } else {
              this.container.appendChild( this.wrapper );
          }
      } else {
          parent.appendChild( this.wrapper );
      }
  };
  
  /** @lends OpenSeadragon.Control.prototype */
  $.Control.prototype = {
  
      /**
       * Removes the control from the container.
       * @function
       */
      destroy: function() {
          this.wrapper.removeChild( this.element );
          this.container.removeChild( this.wrapper );
      },
  
      /**
       * Determines if the control is currently visible.
       * @function
       * @return {Boolean} true if currently visible, false otherwise.
       */
      isVisible: function() {
          return this.wrapper.style.display != "none";
      },
  
      /**
       * Toggles the visibility of the control.
       * @function
       * @param {Boolean} visible - true to make visible, false to hide.
       */
      setVisible: function( visible ) {
          this.wrapper.style.display = visible ?
              ( this.anchor == $.ControlAnchor.ABSOLUTE ? 'block' : 'inline-block' ) :
              "none";
      },
  
      /**
       * Sets the opacity level for the control.
       * @function
       * @param {Number} opactiy - a value between 1 and 0 inclusively.
       */
      setOpacity: function( opacity ) {
          if ( this.element[ $.SIGNAL ] && $.Browser.vendor == $.BROWSERS.IE ) {
              $.setElementOpacity( this.element, opacity, true );
          } else {
              $.setElementOpacity( this.wrapper, opacity, true );
          }
      }
  };
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - ControlDock
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
      /**
       * @class ControlDock
       * @classdesc Provides a container element (a &lt;form&gt; element) with support for the layout of control elements.
       *
       * @memberof OpenSeadragon
       */
      $.ControlDock = function( options ){
          var layouts = [ 'topleft', 'topright', 'bottomright', 'bottomleft'],
              layout,
              i;
  
          $.extend( true, this, {
              id: 'controldock-' + $.now() + '-' + Math.floor(Math.random() * 1000000),
              container: $.makeNeutralElement( 'div' ),
              controls: []
          }, options );
  
          // Disable the form's submit; otherwise button clicks and return keys
          // can trigger it.
          this.container.onsubmit = function() {
              return false;
          };
  
          if( this.element ){
              this.element = $.getElement( this.element );
              this.element.appendChild( this.container );
              this.element.style.position = 'relative';
              this.container.style.width = '100%';
              this.container.style.height = '100%';
          }
  
          for( i = 0; i < layouts.length; i++ ){
              layout = layouts[ i ];
              this.controls[ layout ] = $.makeNeutralElement( "div" );
              this.controls[ layout ].style.position = 'absolute';
              if ( layout.match( 'left' ) ){
                  this.controls[ layout ].style.left = '0px';
              }
              if ( layout.match( 'right' ) ){
                  this.controls[ layout ].style.right = '0px';
              }
              if ( layout.match( 'top' ) ){
                  this.controls[ layout ].style.top = '0px';
              }
              if ( layout.match( 'bottom' ) ){
                  this.controls[ layout ].style.bottom = '0px';
              }
          }
  
          this.container.appendChild( this.controls.topleft );
          this.container.appendChild( this.controls.topright );
          this.container.appendChild( this.controls.bottomright );
          this.container.appendChild( this.controls.bottomleft );
      };
  
      /** @lends OpenSeadragon.ControlDock.prototype */
      $.ControlDock.prototype = {
  
          /**
           * @function
           */
          addControl: function ( element, controlOptions ) {
              element = $.getElement( element );
              var div = null;
  
              if ( getControlIndex( this, element ) >= 0 ) {
                  return;     // they're trying to add a duplicate control
              }
  
              switch ( controlOptions.anchor ) {
                  case $.ControlAnchor.TOP_RIGHT:
                      div = this.controls.topright;
                      element.style.position = "relative";
                      element.style.paddingRight = "0px";
                      element.style.paddingTop = "0px";
                      break;
                  case $.ControlAnchor.BOTTOM_RIGHT:
                      div = this.controls.bottomright;
                      element.style.position = "relative";
                      element.style.paddingRight = "0px";
                      element.style.paddingBottom = "0px";
                      break;
                  case $.ControlAnchor.BOTTOM_LEFT:
                      div = this.controls.bottomleft;
                      element.style.position = "relative";
                      element.style.paddingLeft = "0px";
                      element.style.paddingBottom = "0px";
                      break;
                  case $.ControlAnchor.TOP_LEFT:
                      div = this.controls.topleft;
                      element.style.position = "relative";
                      element.style.paddingLeft = "0px";
                      element.style.paddingTop = "0px";
                      break;
                  case $.ControlAnchor.ABSOLUTE:
                      div = this.container;
                      element.style.margin = "0px";
                      element.style.padding = "0px";
                      break;
                  default:
                  case $.ControlAnchor.NONE:
                      div = this.container;
                      element.style.margin = "0px";
                      element.style.padding = "0px";
                      break;
              }
  
              this.controls.push(
                  new $.Control( element, controlOptions, div )
              );
              element.style.display = "inline-block";
          },
  
  
          /**
           * @function
           * @return {OpenSeadragon.ControlDock} Chainable.
           */
          removeControl: function ( element ) {
              element = $.getElement( element );
              var i = getControlIndex( this, element );
  
              if ( i >= 0 ) {
                  this.controls[ i ].destroy();
                  this.controls.splice( i, 1 );
              }
  
              return this;
          },
  
          /**
           * @function
           * @return {OpenSeadragon.ControlDock} Chainable.
           */
          clearControls: function () {
              while ( this.controls.length > 0 ) {
                  this.controls.pop().destroy();
              }
  
              return this;
          },
  
  
          /**
           * @function
           * @return {Boolean}
           */
          areControlsEnabled: function () {
              var i;
  
              for ( i = this.controls.length - 1; i >= 0; i-- ) {
                  if ( this.controls[ i ].isVisible() ) {
                      return true;
                  }
              }
  
              return false;
          },
  
  
          /**
           * @function
           * @return {OpenSeadragon.ControlDock} Chainable.
           */
          setControlsEnabled: function( enabled ) {
              var i;
  
              for ( i = this.controls.length - 1; i >= 0; i-- ) {
                  this.controls[ i ].setVisible( enabled );
              }
  
              return this;
          }
  
      };
  
  
      ///////////////////////////////////////////////////////////////////////////////
      // Utility methods
      ///////////////////////////////////////////////////////////////////////////////
      function getControlIndex( dock, element ) {
          var controls = dock.controls,
              i;
  
          for ( i = controls.length - 1; i >= 0; i-- ) {
              if ( controls[ i ].element == element ) {
                  return i;
              }
          }
  
          return -1;
      }
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - Placement
   *
   * Copyright (C) 2010-2016 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function($) {
  
      /**
       * An enumeration of positions to anchor an element.
       * @member Placement
       * @memberOf OpenSeadragon
       * @static
       * @readonly
       * @property {OpenSeadragon.Placement} CENTER
       * @property {OpenSeadragon.Placement} TOP_LEFT
       * @property {OpenSeadragon.Placement} TOP
       * @property {OpenSeadragon.Placement} TOP_RIGHT
       * @property {OpenSeadragon.Placement} RIGHT
       * @property {OpenSeadragon.Placement} BOTTOM_RIGHT
       * @property {OpenSeadragon.Placement} BOTTOM
       * @property {OpenSeadragon.Placement} BOTTOM_LEFT
       * @property {OpenSeadragon.Placement} LEFT
       */
      $.Placement = $.freezeObject({
          CENTER:       0,
          TOP_LEFT:     1,
          TOP:          2,
          TOP_RIGHT:    3,
          RIGHT:        4,
          BOTTOM_RIGHT: 5,
          BOTTOM:       6,
          BOTTOM_LEFT:  7,
          LEFT:         8,
          properties: {
              0: {
                  isLeft: false,
                  isHorizontallyCentered: true,
                  isRight: false,
                  isTop: false,
                  isVerticallyCentered: true,
                  isBottom: false
              },
              1: {
                  isLeft: true,
                  isHorizontallyCentered: false,
                  isRight: false,
                  isTop: true,
                  isVerticallyCentered: false,
                  isBottom: false
              },
              2: {
                  isLeft: false,
                  isHorizontallyCentered: true,
                  isRight: false,
                  isTop: true,
                  isVerticallyCentered: false,
                  isBottom: false
              },
              3: {
                  isLeft: false,
                  isHorizontallyCentered: false,
                  isRight: true,
                  isTop: true,
                  isVerticallyCentered: false,
                  isBottom: false
              },
              4: {
                  isLeft: false,
                  isHorizontallyCentered: false,
                  isRight: true,
                  isTop: false,
                  isVerticallyCentered: true,
                  isBottom: false
              },
              5: {
                  isLeft: false,
                  isHorizontallyCentered: false,
                  isRight: true,
                  isTop: false,
                  isVerticallyCentered: false,
                  isBottom: true
              },
              6: {
                  isLeft: false,
                  isHorizontallyCentered: true,
                  isRight: false,
                  isTop: false,
                  isVerticallyCentered: false,
                  isBottom: true
              },
              7: {
                  isLeft: true,
                  isHorizontallyCentered: false,
                  isRight: false,
                  isTop: false,
                  isVerticallyCentered: false,
                  isBottom: true
              },
              8: {
                  isLeft: true,
                  isHorizontallyCentered: false,
                  isRight: false,
                  isTop: false,
                  isVerticallyCentered: true,
                  isBottom: false
              }
          }
      });
  
  }(OpenSeadragon));
  
  /*
   * OpenSeadragon - Viewer
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  // dictionary from hash to private properties
  var THIS = {};
  var nextHash = 1;
  
  /**
   *
   * The main point of entry into creating a zoomable image on the page.<br>
   * <br>
   * We have provided an idiomatic javascript constructor which takes
   * a single object, but still support the legacy positional arguments.<br>
   * <br>
   * The options below are given in order that they appeared in the constructor
   * as arguments and we translate a positional call into an idiomatic call.<br>
   * <br>
   * To create a viewer, you can use either of this methods:<br>
   * <ul>
   * <li><code>var viewer = new OpenSeadragon.Viewer(options);</code></li>
   * <li><code>var viewer = OpenSeadragon(options);</code></li>
   * </ul>
   * @class Viewer
   * @classdesc The main OpenSeadragon viewer class.
   *
   * @memberof OpenSeadragon
   * @extends OpenSeadragon.EventSource
   * @extends OpenSeadragon.ControlDock
   * @param {OpenSeadragon.Options} options - Viewer options.
   *
   **/
  $.Viewer = function( options ) {
  
      var args  = arguments,
          _this = this,
          i;
  
  
      //backward compatibility for positional args while preferring more
      //idiomatic javascript options object as the only argument
      if( !$.isPlainObject( options ) ){
          options = {
              id:                 args[ 0 ],
              xmlPath:            args.length > 1 ? args[ 1 ] : undefined,
              prefixUrl:          args.length > 2 ? args[ 2 ] : undefined,
              controls:           args.length > 3 ? args[ 3 ] : undefined,
              overlays:           args.length > 4 ? args[ 4 ] : undefined
          };
      }
  
      //options.config and the general config argument are deprecated
      //in favor of the more direct specification of optional settings
      //being pass directly on the options object
      if ( options.config ){
          $.extend( true, options, options.config );
          delete options.config;
      }
  
      //Public properties
      //Allow the options object to override global defaults
      $.extend( true, this, {
  
          //internal state and dom identifiers
          id:             options.id,
          hash:           options.hash || nextHash++,
          /**
           * Index for page to be shown first next time open() is called (only used in sequenceMode).
           * @member {Number} initialPage
           * @memberof OpenSeadragon.Viewer#
           */
          initialPage:    0,
  
          //dom nodes
          /**
           * The parent element of this Viewer instance, passed in when the Viewer was created.
           * @member {Element} element
           * @memberof OpenSeadragon.Viewer#
           */
          element:        null,
          /**
           * A &lt;div&gt; element (provided by {@link OpenSeadragon.ControlDock}), the base element of this Viewer instance.<br><br>
           * Child element of {@link OpenSeadragon.Viewer#element}.
           * @member {Element} container
           * @memberof OpenSeadragon.Viewer#
           */
          container:      null,
          /**
           * A &lt;div&gt; element, the element where user-input events are handled for panning and zooming.<br><br>
           * Child element of {@link OpenSeadragon.Viewer#container},
           * positioned on top of {@link OpenSeadragon.Viewer#keyboardCommandArea}.<br><br>
           * The parent of {@link OpenSeadragon.Drawer#canvas} instances.
           * @member {Element} canvas
           * @memberof OpenSeadragon.Viewer#
           */
          canvas:         null,
  
          // Overlays list. An overlay allows to add html on top of the viewer.
          overlays:           [],
          // Container inside the canvas where overlays are drawn.
          overlaysContainer:  null,
  
          //private state properties
          previousBody:   [],
  
          //This was originally initialized in the constructor and so could never
          //have anything in it.  now it can because we allow it to be specified
          //in the options and is only empty by default if not specified. Also
          //this array was returned from get_controls which I find confusing
          //since this object has a controls property which is treated in other
          //functions like clearControls.  I'm removing the accessors.
          customControls: [],
  
          //These are originally not part options but declared as members
          //in initialize.  It's still considered idiomatic to put them here
          //source is here for backwards compatibility. It is not an official
          //part of the API and should not be relied upon.
          source:         null,
          /**
           * Handles rendering of tiles in the viewer. Created for each TileSource opened.
           * @member {OpenSeadragon.Drawer} drawer
           * @memberof OpenSeadragon.Viewer#
           */
          drawer:             null,
          /**
           * Keeps track of all of the tiled images in the scene.
           * @member {OpenSeadragon.World} world
           * @memberof OpenSeadragon.Viewer#
           */
          world:              null,
          /**
           * Handles coordinate-related functionality - zoom, pan, rotation, etc. Created for each TileSource opened.
           * @member {OpenSeadragon.Viewport} viewport
           * @memberof OpenSeadragon.Viewer#
           */
          viewport:       null,
          /**
           * @member {OpenSeadragon.Navigator} navigator
           * @memberof OpenSeadragon.Viewer#
           */
          navigator:      null,
  
          //A collection viewport is a separate viewport used to provide
          //simultaneous rendering of sets of tiles
          collectionViewport:     null,
          collectionDrawer:       null,
  
          //UI image resources
          //TODO: rename navImages to uiImages
          navImages:      null,
  
          //interface button controls
          buttons:        null,
  
          //TODO: this is defunct so safely remove it
          profiler:       null
  
      }, $.DEFAULT_SETTINGS, options );
  
      if ( typeof ( this.hash) === "undefined" ) {
          throw new Error("A hash must be defined, either by specifying options.id or options.hash.");
      }
      if ( typeof ( THIS[ this.hash ] ) !== "undefined" ) {
          // We don't want to throw an error here, as the user might have discarded
          // the previous viewer with the same hash and now want to recreate it.
          $.console.warn("Hash " + this.hash + " has already been used.");
      }
  
      //Private state properties
      THIS[ this.hash ] = {
          "fsBoundsDelta":     new $.Point( 1, 1 ),
          "prevContainerSize": null,
          "animating":         false,
          "forceRedraw":       false,
          "mouseInside":       false,
          "group":             null,
          // whether we should be continuously zooming
          "zooming":           false,
          // how much we should be continuously zooming by
          "zoomFactor":        null,
          "lastZoomTime":      null,
          "fullPage":          false,
          "onfullscreenchange": null
      };
  
      this._sequenceIndex = 0;
      this._firstOpen = true;
      this._updateRequestId = null;
      this._loadQueue = [];
      this.currentOverlays = [];
  
      this._lastScrollTime = $.now(); // variable used to help normalize the scroll event speed of different devices
  
      //Inherit some behaviors and properties
      $.EventSource.call( this );
  
      this.addHandler( 'open-failed', function ( event ) {
          var msg = $.getString( "Errors.OpenFailed", event.eventSource, event.message);
          _this._showMessage( msg );
      });
  
      $.ControlDock.call( this, options );
  
      //Deal with tile sources
      if (this.xmlPath) {
          //Deprecated option.  Now it is preferred to use the tileSources option
          this.tileSources = [ this.xmlPath ];
      }
  
      this.element              = this.element || document.getElementById( this.id );
      this.canvas               = $.makeNeutralElement( "div" );
  
      this.canvas.className = "openseadragon-canvas";
      (function( style ){
          style.width    = "100%";
          style.height   = "100%";
          style.overflow = "hidden";
          style.position = "absolute";
          style.top      = "0px";
          style.left     = "0px";
      }(this.canvas.style));
      $.setElementTouchActionNone( this.canvas );
      if (options.tabIndex !== "") {
          this.canvas.tabIndex = (options.tabIndex === undefined ? 0 : options.tabIndex);
      }
  
      //the container is created through applying the ControlDock constructor above
      this.container.className = "openseadragon-container";
      (function( style ){
          style.width     = "100%";
          style.height    = "100%";
          style.position  = "relative";
          style.overflow  = "hidden";
          style.left      = "0px";
          style.top       = "0px";
          style.textAlign = "left";  // needed to protect against
      }( this.container.style ));
  
      this.container.insertBefore( this.canvas, this.container.firstChild );
      this.element.appendChild( this.container );
  
      //Used for toggling between fullscreen and default container size
      //TODO: these can be closure private and shared across Viewer
      //      instances.
      this.bodyWidth      = document.body.style.width;
      this.bodyHeight     = document.body.style.height;
      this.bodyOverflow   = document.body.style.overflow;
      this.docOverflow    = document.documentElement.style.overflow;
  
      this.innerTracker = new $.MouseTracker({
          element:                  this.canvas,
          startDisabled:            !this.mouseNavEnabled,
          clickTimeThreshold:       this.clickTimeThreshold,
          clickDistThreshold:       this.clickDistThreshold,
          dblClickTimeThreshold:    this.dblClickTimeThreshold,
          dblClickDistThreshold:    this.dblClickDistThreshold,
          keyDownHandler:           $.delegate( this, onCanvasKeyDown ),
          keyHandler:               $.delegate( this, onCanvasKeyPress ),
          clickHandler:             $.delegate( this, onCanvasClick ),
          dblClickHandler:          $.delegate( this, onCanvasDblClick ),
          dragHandler:              $.delegate( this, onCanvasDrag ),
          dragEndHandler:           $.delegate( this, onCanvasDragEnd ),
          enterHandler:             $.delegate( this, onCanvasEnter ),
          exitHandler:              $.delegate( this, onCanvasExit ),
          pressHandler:             $.delegate( this, onCanvasPress ),
          releaseHandler:           $.delegate( this, onCanvasRelease ),
          nonPrimaryPressHandler:   $.delegate( this, onCanvasNonPrimaryPress ),
          nonPrimaryReleaseHandler: $.delegate( this, onCanvasNonPrimaryRelease ),
          scrollHandler:            $.delegate( this, onCanvasScroll ),
          pinchHandler:             $.delegate( this, onCanvasPinch )
      });
  
      this.outerTracker = new $.MouseTracker({
          element:               this.container,
          startDisabled:         !this.mouseNavEnabled,
          clickTimeThreshold:    this.clickTimeThreshold,
          clickDistThreshold:    this.clickDistThreshold,
          dblClickTimeThreshold: this.dblClickTimeThreshold,
          dblClickDistThreshold: this.dblClickDistThreshold,
          enterHandler:          $.delegate( this, onContainerEnter ),
          exitHandler:           $.delegate( this, onContainerExit )
      });
  
      if( this.toolbar ){
          this.toolbar = new $.ControlDock({ element: this.toolbar });
      }
  
      this.bindStandardControls();
  
      THIS[ this.hash ].prevContainerSize = _getSafeElemSize( this.container );
  
      // Create the world
      this.world = new $.World({
          viewer: this
      });
  
      this.world.addHandler('add-item', function(event) {
          // For backwards compatibility, we maintain the source property
          _this.source = _this.world.getItemAt(0).source;
  
          THIS[ _this.hash ].forceRedraw = true;
  
          if (!_this._updateRequestId) {
              _this._updateRequestId = scheduleUpdate( _this, updateMulti );
          }
      });
  
      this.world.addHandler('remove-item', function(event) {
          // For backwards compatibility, we maintain the source property
          if (_this.world.getItemCount()) {
              _this.source = _this.world.getItemAt(0).source;
          } else {
              _this.source = null;
          }
  
          THIS[ _this.hash ].forceRedraw = true;
      });
  
      this.world.addHandler('metrics-change', function(event) {
          if (_this.viewport) {
              _this.viewport._setContentBounds(_this.world.getHomeBounds(), _this.world.getContentFactor());
          }
      });
  
      this.world.addHandler('item-index-change', function(event) {
          // For backwards compatibility, we maintain the source property
          _this.source = _this.world.getItemAt(0).source;
      });
  
      // Create the viewport
      this.viewport = new $.Viewport({
          containerSize:      THIS[ this.hash ].prevContainerSize,
          springStiffness:    this.springStiffness,
          animationTime:      this.animationTime,
          minZoomImageRatio:  this.minZoomImageRatio,
          maxZoomPixelRatio:  this.maxZoomPixelRatio,
          visibilityRatio:    this.visibilityRatio,
          wrapHorizontal:     this.wrapHorizontal,
          wrapVertical:       this.wrapVertical,
          defaultZoomLevel:   this.defaultZoomLevel,
          minZoomLevel:       this.minZoomLevel,
          maxZoomLevel:       this.maxZoomLevel,
          viewer:             this,
          degrees:            this.degrees,
          flipped:            this.flipped,
          navigatorRotate:    this.navigatorRotate,
          homeFillsViewer:    this.homeFillsViewer,
          margins:            this.viewportMargins
      });
  
      this.viewport._setContentBounds(this.world.getHomeBounds(), this.world.getContentFactor());
  
      // Create the image loader
      this.imageLoader = new $.ImageLoader({
          jobLimit: this.imageLoaderLimit,
          timeout: options.timeout
      });
  
      // Create the tile cache
      this.tileCache = new $.TileCache({
          maxImageCacheCount: this.maxImageCacheCount
      });
  
      // Create the drawer
      this.drawer = new $.Drawer({
          viewer:             this,
          viewport:           this.viewport,
          element:            this.canvas,
          debugGridColor:     this.debugGridColor
      });
  
      // Overlay container
      this.overlaysContainer    = $.makeNeutralElement( "div" );
      this.canvas.appendChild( this.overlaysContainer );
  
      // Now that we have a drawer, see if it supports rotate. If not we need to remove the rotate buttons
      if (!this.drawer.canRotate()) {
          // Disable/remove the rotate left/right buttons since they aren't supported
          if (this.rotateLeft) {
              i = this.buttons.buttons.indexOf(this.rotateLeft);
              this.buttons.buttons.splice(i, 1);
              this.buttons.element.removeChild(this.rotateLeft.element);
          }
          if (this.rotateRight) {
              i = this.buttons.buttons.indexOf(this.rotateRight);
              this.buttons.buttons.splice(i, 1);
              this.buttons.element.removeChild(this.rotateRight.element);
          }
      }
  
      //Instantiate a navigator if configured
      if ( this.showNavigator){
          this.navigator = new $.Navigator({
              id:                this.navigatorId,
              position:          this.navigatorPosition,
              sizeRatio:         this.navigatorSizeRatio,
              maintainSizeRatio: this.navigatorMaintainSizeRatio,
              top:               this.navigatorTop,
              left:              this.navigatorLeft,
              width:             this.navigatorWidth,
              height:            this.navigatorHeight,
              autoResize:        this.navigatorAutoResize,
              autoFade:          this.navigatorAutoFade,
              prefixUrl:         this.prefixUrl,
              viewer:            this,
              navigatorRotate:   this.navigatorRotate,
              background:        this.navigatorBackground,
              opacity:           this.navigatorOpacity,
              borderColor:       this.navigatorBorderColor,
              displayRegionColor: this.navigatorDisplayRegionColor,
              crossOriginPolicy: this.crossOriginPolicy
          });
      }
  
      // Sequence mode
      if (this.sequenceMode) {
          this.bindSequenceControls();
      }
  
      // Open initial tilesources
      if (this.tileSources) {
          this.open( this.tileSources );
      }
  
      // Add custom controls
      for ( i = 0; i < this.customControls.length; i++ ) {
          this.addControl(
              this.customControls[ i ].id,
              {anchor: this.customControls[ i ].anchor}
          );
      }
  
      // Initial fade out
      $.requestAnimationFrame( function(){
          beginControlsAutoHide( _this );
      } );
  
      // Initial canvas options
      if ( this.imageSmoothingEnabled !== undefined && !this.imageSmoothingEnabled){
          this.drawer.setImageSmoothingEnabled(this.imageSmoothingEnabled);
      }
  
  };
  
  $.extend( $.Viewer.prototype, $.EventSource.prototype, $.ControlDock.prototype, /** @lends OpenSeadragon.Viewer.prototype */{
  
  
      /**
       * @function
       * @return {Boolean}
       */
      isOpen: function () {
          return !!this.world.getItemCount();
      },
  
      // deprecated
      openDzi: function ( dzi ) {
          $.console.error( "[Viewer.openDzi] this function is deprecated; use Viewer.open() instead." );
          return this.open( dzi );
      },
  
      // deprecated
      openTileSource: function ( tileSource ) {
          $.console.error( "[Viewer.openTileSource] this function is deprecated; use Viewer.open() instead." );
          return this.open( tileSource );
      },
  
      /**
       * Open tiled images into the viewer, closing any others.
       * To get the TiledImage instance created by open, add an event listener for
       * {@link OpenSeadragon.Viewer.html#.event:open}, which when fired can be used to get access
       * to the instance, i.e., viewer.world.getItemAt(0).
       * @function
       * @param {Array|String|Object|Function} tileSources - This can be a TiledImage
       * specifier, a TileSource specifier, or an array of either. A TiledImage specifier
       * is the same as the options parameter for {@link OpenSeadragon.Viewer#addTiledImage},
       * except for the index property; images are added in sequence.
       * A TileSource specifier is anything you could pass as the tileSource property
       * of the options parameter for {@link OpenSeadragon.Viewer#addTiledImage}.
       * @param {Number} initialPage - If sequenceMode is true, display this page initially
       * for the given tileSources. If specified, will overwrite the Viewer's existing initialPage property.
       * @return {OpenSeadragon.Viewer} Chainable.
       * @fires OpenSeadragon.Viewer.event:open
       * @fires OpenSeadragon.Viewer.event:open-failed
       */
      open: function (tileSources, initialPage) {
          var _this = this;
  
          this.close();
  
          if (!tileSources) {
              return;
          }
  
          if (this.sequenceMode && $.isArray(tileSources)) {
              if (this.referenceStrip) {
                  this.referenceStrip.destroy();
                  this.referenceStrip = null;
              }
  
              if (typeof initialPage != 'undefined' && !isNaN(initialPage)) {
                this.initialPage = initialPage;
              }
  
              this.tileSources = tileSources;
              this._sequenceIndex = Math.max(0, Math.min(this.tileSources.length - 1, this.initialPage));
              if (this.tileSources.length) {
                  this.open(this.tileSources[this._sequenceIndex]);
  
                  if ( this.showReferenceStrip ){
                      this.addReferenceStrip();
                  }
              }
  
              this._updateSequenceButtons( this._sequenceIndex );
              return;
          }
  
          if (!$.isArray(tileSources)) {
              tileSources = [tileSources];
          }
  
          if (!tileSources.length) {
              return;
          }
  
          this._opening = true;
  
          var expected = tileSources.length;
          var successes = 0;
          var failures = 0;
          var failEvent;
  
          var checkCompletion = function() {
              if (successes + failures === expected) {
                  if (successes) {
                      if (_this._firstOpen || !_this.preserveViewport) {
                          _this.viewport.goHome( true );
                          _this.viewport.update();
                      }
  
                      _this._firstOpen = false;
  
                      var source = tileSources[0];
                      if (source.tileSource) {
                          source = source.tileSource;
                      }
  
                      // Global overlays
                      if( _this.overlays && !_this.preserveOverlays ){
                          for ( var i = 0; i < _this.overlays.length; i++ ) {
                              _this.currentOverlays[ i ] = getOverlayObject( _this, _this.overlays[ i ] );
                          }
                      }
  
                      _this._drawOverlays();
                      _this._opening = false;
  
                      /**
                       * Raised when the viewer has opened and loaded one or more TileSources.
                       *
                       * @event open
                       * @memberof OpenSeadragon.Viewer
                       * @type {object}
                       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
                       * @property {OpenSeadragon.TileSource} source - The tile source that was opened.
                       * @property {?Object} userData - Arbitrary subscriber-defined object.
                       */
                      // TODO: what if there are multiple sources?
                      _this.raiseEvent( 'open', { source: source } );
                  } else {
                      _this._opening = false;
  
                      /**
                       * Raised when an error occurs loading a TileSource.
                       *
                       * @event open-failed
                       * @memberof OpenSeadragon.Viewer
                       * @type {object}
                       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
                       * @property {String} message - Information about what failed.
                       * @property {String} source - The tile source that failed.
                       * @property {?Object} userData - Arbitrary subscriber-defined object.
                       */
                      _this.raiseEvent( 'open-failed', failEvent );
                  }
              }
          };
  
          var doOne = function(options) {
              if (!$.isPlainObject(options) || !options.tileSource) {
                  options = {
                      tileSource: options
                  };
              }
  
              if (options.index !== undefined) {
                  $.console.error('[Viewer.open] setting indexes here is not supported; use addTiledImage instead');
                  delete options.index;
              }
  
              if (options.collectionImmediately === undefined) {
                  options.collectionImmediately = true;
              }
  
              var originalSuccess = options.success;
              options.success = function(event) {
                  successes++;
  
                  // TODO: now that options has other things besides tileSource, the overlays
                  // should probably be at the options level, not the tileSource level.
                  if (options.tileSource.overlays) {
                      for (var i = 0; i < options.tileSource.overlays.length; i++) {
                          _this.addOverlay(options.tileSource.overlays[i]);
                      }
                  }
  
                  if (originalSuccess) {
                      originalSuccess(event);
                  }
  
                  checkCompletion();
              };
  
              var originalError = options.error;
              options.error = function(event) {
                  failures++;
  
                  if (!failEvent) {
                      failEvent = event;
                  }
  
                  if (originalError) {
                      originalError(event);
                  }
  
                  checkCompletion();
              };
  
              _this.addTiledImage(options);
          };
  
          // TileSources
          for (var i = 0; i < tileSources.length; i++) {
              doOne(tileSources[i]);
          }
  
          return this;
      },
  
  
      /**
       * @function
       * @return {OpenSeadragon.Viewer} Chainable.
       * @fires OpenSeadragon.Viewer.event:close
       */
      close: function ( ) {
          if ( !THIS[ this.hash ] ) {
              //this viewer has already been destroyed: returning immediately
              return this;
          }
  
          this._opening = false;
  
          if ( this.navigator ) {
              this.navigator.close();
          }
  
          if (!this.preserveOverlays) {
              this.clearOverlays();
              this.overlaysContainer.innerHTML = "";
          }
  
          THIS[ this.hash ].animating = false;
          this.world.removeAll();
          this.imageLoader.clear();
  
          /**
           * Raised when the viewer is closed (see {@link OpenSeadragon.Viewer#close}).
           *
           * @event close
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent( 'close' );
  
          return this;
      },
  
  
      /**
       * Function to destroy the viewer and clean up everything created by OpenSeadragon.
       *
       * Example:
       * var viewer = OpenSeadragon({
       *   [...]
       * });
       *
       * //when you are done with the viewer:
       * viewer.destroy();
       * viewer = null; //important
       *
       * @function
       */
      destroy: function( ) {
          if ( !THIS[ this.hash ] ) {
              //this viewer has already been destroyed: returning immediately
              return;
          }
  
          this.close();
  
          this.clearOverlays();
          this.overlaysContainer.innerHTML = "";
  
          //TODO: implement this...
          //this.unbindSequenceControls()
          //this.unbindStandardControls()
  
          if (this.referenceStrip) {
              this.referenceStrip.destroy();
              this.referenceStrip = null;
          }
  
          if ( this._updateRequestId !== null ) {
              $.cancelAnimationFrame( this._updateRequestId );
              this._updateRequestId = null;
          }
  
          if ( this.drawer ) {
              this.drawer.destroy();
          }
  
          this.removeAllHandlers();
  
          // Go through top element (passed to us) and remove all children
          // Use removeChild to make sure it handles SVG or any non-html
          // also it performs better - http://jsperf.com/innerhtml-vs-removechild/15
          if (this.element){
              while (this.element.firstChild) {
                  this.element.removeChild(this.element.firstChild);
              }
          }
  
          // destroy the mouse trackers
          if (this.innerTracker){
              this.innerTracker.destroy();
          }
          if (this.outerTracker){
              this.outerTracker.destroy();
          }
  
          THIS[ this.hash ] = null;
          delete THIS[ this.hash ];
  
          // clear all our references to dom objects
          this.canvas = null;
          this.container = null;
  
          // clear our reference to the main element - they will need to pass it in again, creating a new viewer
          this.element = null;
      },
  
      /**
       * @function
       * @return {Boolean}
       */
      isMouseNavEnabled: function () {
          return this.innerTracker.isTracking();
      },
  
      /**
       * @function
       * @param {Boolean} enabled - true to enable, false to disable
       * @return {OpenSeadragon.Viewer} Chainable.
       * @fires OpenSeadragon.Viewer.event:mouse-enabled
       */
      setMouseNavEnabled: function( enabled ){
          this.innerTracker.setTracking( enabled );
          this.outerTracker.setTracking( enabled );
          /**
           * Raised when mouse/touch navigation is enabled or disabled (see {@link OpenSeadragon.Viewer#setMouseNavEnabled}).
           *
           * @event mouse-enabled
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
           * @property {Boolean} enabled
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent( 'mouse-enabled', { enabled: enabled } );
          return this;
      },
  
  
      /**
       * @function
       * @return {Boolean}
       */
      areControlsEnabled: function () {
          var enabled = this.controls.length,
              i;
          for( i = 0; i < this.controls.length; i++ ){
              enabled = enabled && this.controls[ i ].isVisible();
          }
          return enabled;
      },
  
  
      /**
       * Shows or hides the controls (e.g. the default navigation buttons).
       *
       * @function
       * @param {Boolean} true to show, false to hide.
       * @return {OpenSeadragon.Viewer} Chainable.
       * @fires OpenSeadragon.Viewer.event:controls-enabled
       */
      setControlsEnabled: function( enabled ) {
          if( enabled ){
              abortControlsAutoHide( this );
          } else {
              beginControlsAutoHide( this );
          }
          /**
           * Raised when the navigation controls are shown or hidden (see {@link OpenSeadragon.Viewer#setControlsEnabled}).
           *
           * @event controls-enabled
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
           * @property {Boolean} enabled
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent( 'controls-enabled', { enabled: enabled } );
          return this;
      },
  
      /**
       * Turns debugging mode on or off for this viewer.
       *
       * @function
       * @param {Boolean} true to turn debug on, false to turn debug off.
       */
      setDebugMode: function(debugMode){
  
          for (var i = 0; i < this.world.getItemCount(); i++) {
              this.world.getItemAt(i).debugMode = debugMode;
          }
  
          this.debugMode = debugMode;
          this.forceRedraw();
      },
  
      /**
       * @function
       * @return {Boolean}
       */
      isFullPage: function () {
          return THIS[ this.hash ].fullPage;
      },
  
  
      /**
       * Toggle full page mode.
       * @function
       * @param {Boolean} fullPage
       *      If true, enter full page mode.  If false, exit full page mode.
       * @return {OpenSeadragon.Viewer} Chainable.
       * @fires OpenSeadragon.Viewer.event:pre-full-page
       * @fires OpenSeadragon.Viewer.event:full-page
       */
      setFullPage: function( fullPage ) {
  
          var body = document.body,
              bodyStyle = body.style,
              docStyle = document.documentElement.style,
              _this = this,
              nodes,
              i;
  
          //don't bother modifying the DOM if we are already in full page mode.
          if ( fullPage == this.isFullPage() ) {
              return this;
          }
  
          var fullPageEventArgs = {
              fullPage: fullPage,
              preventDefaultAction: false
          };
          /**
           * Raised when the viewer is about to change to/from full-page mode (see {@link OpenSeadragon.Viewer#setFullPage}).
           *
           * @event pre-full-page
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
           * @property {Boolean} fullPage - True if entering full-page mode, false if exiting full-page mode.
           * @property {Boolean} preventDefaultAction - Set to true to prevent full-page mode change. Default: false.
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent( 'pre-full-page', fullPageEventArgs );
          if ( fullPageEventArgs.preventDefaultAction ) {
              return this;
          }
  
          if ( fullPage ) {
  
              this.elementSize = $.getElementSize( this.element );
              this.pageScroll = $.getPageScroll();
  
              this.elementMargin = this.element.style.margin;
              this.element.style.margin = "0";
              this.elementPadding = this.element.style.padding;
              this.element.style.padding = "0";
  
              this.bodyMargin = bodyStyle.margin;
              this.docMargin = docStyle.margin;
              bodyStyle.margin = "0";
              docStyle.margin = "0";
  
              this.bodyPadding = bodyStyle.padding;
              this.docPadding = docStyle.padding;
              bodyStyle.padding = "0";
              docStyle.padding = "0";
  
              this.bodyWidth = bodyStyle.width;
              this.docWidth = docStyle.width;
              bodyStyle.width = "100%";
              docStyle.width = "100%";
  
              this.bodyHeight = bodyStyle.height;
              this.docHeight = docStyle.height;
              bodyStyle.height = "100%";
              docStyle.height = "100%";
  
              //when entering full screen on the ipad it wasn't sufficient to leave
              //the body intact as only only the top half of the screen would
              //respond to touch events on the canvas, while the bottom half treated
              //them as touch events on the document body.  Thus we remove and store
              //the bodies elements and replace them when we leave full screen.
              this.previousBody = [];
              THIS[ this.hash ].prevElementParent = this.element.parentNode;
              THIS[ this.hash ].prevNextSibling = this.element.nextSibling;
              THIS[ this.hash ].prevElementWidth = this.element.style.width;
              THIS[ this.hash ].prevElementHeight = this.element.style.height;
              nodes = body.childNodes.length;
              for ( i = 0; i < nodes; i++ ) {
                  this.previousBody.push( body.childNodes[ 0 ] );
                  body.removeChild( body.childNodes[ 0 ] );
              }
  
              //If we've got a toolbar, we need to enable the user to use css to
              //preserve it in fullpage mode
              if ( this.toolbar && this.toolbar.element ) {
                  //save a reference to the parent so we can put it back
                  //in the long run we need a better strategy
                  this.toolbar.parentNode = this.toolbar.element.parentNode;
                  this.toolbar.nextSibling = this.toolbar.element.nextSibling;
                  body.appendChild( this.toolbar.element );
  
                  //Make sure the user has some ability to style the toolbar based
                  //on the mode
                  $.addClass( this.toolbar.element, 'fullpage' );
              }
  
              $.addClass( this.element, 'fullpage' );
              body.appendChild( this.element );
  
              this.element.style.height = $.getWindowSize().y + 'px';
              this.element.style.width = $.getWindowSize().x + 'px';
  
              if ( this.toolbar && this.toolbar.element ) {
                  this.element.style.height = (
                      $.getElementSize( this.element ).y - $.getElementSize( this.toolbar.element ).y
                  ) + 'px';
              }
  
              THIS[ this.hash ].fullPage = true;
  
              // mouse will be inside container now
              $.delegate( this, onContainerEnter )( {} );
  
          } else {
  
              this.element.style.margin = this.elementMargin;
              this.element.style.padding = this.elementPadding;
  
              bodyStyle.margin = this.bodyMargin;
              docStyle.margin = this.docMargin;
  
              bodyStyle.padding = this.bodyPadding;
              docStyle.padding = this.docPadding;
  
              bodyStyle.width = this.bodyWidth;
              docStyle.width = this.docWidth;
  
              bodyStyle.height = this.bodyHeight;
              docStyle.height = this.docHeight;
  
              body.removeChild( this.element );
              nodes = this.previousBody.length;
              for ( i = 0; i < nodes; i++ ) {
                  body.appendChild( this.previousBody.shift() );
              }
  
              $.removeClass( this.element, 'fullpage' );
              THIS[ this.hash ].prevElementParent.insertBefore(
                  this.element,
                  THIS[ this.hash ].prevNextSibling
              );
  
              //If we've got a toolbar, we need to enable the user to use css to
              //reset it to its original state
              if ( this.toolbar && this.toolbar.element ) {
                  body.removeChild( this.toolbar.element );
  
                  //Make sure the user has some ability to style the toolbar based
                  //on the mode
                  $.removeClass( this.toolbar.element, 'fullpage' );
  
                  this.toolbar.parentNode.insertBefore(
                      this.toolbar.element,
                      this.toolbar.nextSibling
                  );
                  delete this.toolbar.parentNode;
                  delete this.toolbar.nextSibling;
              }
  
              this.element.style.width = THIS[ this.hash ].prevElementWidth;
              this.element.style.height = THIS[ this.hash ].prevElementHeight;
  
              // After exiting fullPage or fullScreen, it can take some time
              // before the browser can actually set the scroll.
              var restoreScrollCounter = 0;
              var restoreScroll = function() {
                  $.setPageScroll( _this.pageScroll );
                  var pageScroll = $.getPageScroll();
                  restoreScrollCounter++;
                  if (restoreScrollCounter < 10 &&
                      (pageScroll.x !== _this.pageScroll.x ||
                      pageScroll.y !== _this.pageScroll.y)) {
                      $.requestAnimationFrame( restoreScroll );
                  }
              };
              $.requestAnimationFrame( restoreScroll );
  
              THIS[ this.hash ].fullPage = false;
  
              // mouse will likely be outside now
              $.delegate( this, onContainerExit )( { } );
  
          }
  
          if ( this.navigator && this.viewport ) {
              this.navigator.update( this.viewport );
          }
  
          /**
           * Raised when the viewer has changed to/from full-page mode (see {@link OpenSeadragon.Viewer#setFullPage}).
           *
           * @event full-page
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
           * @property {Boolean} fullPage - True if changed to full-page mode, false if exited full-page mode.
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent( 'full-page', { fullPage: fullPage } );
  
          return this;
      },
  
      /**
       * Toggle full screen mode if supported. Toggle full page mode otherwise.
       * @function
       * @param {Boolean} fullScreen
       *      If true, enter full screen mode.  If false, exit full screen mode.
       * @return {OpenSeadragon.Viewer} Chainable.
       * @fires OpenSeadragon.Viewer.event:pre-full-screen
       * @fires OpenSeadragon.Viewer.event:full-screen
       */
      setFullScreen: function( fullScreen ) {
          var _this = this;
  
          if ( !$.supportsFullScreen ) {
              return this.setFullPage( fullScreen );
          }
  
          if ( $.isFullScreen() === fullScreen ) {
              return this;
          }
  
          var fullScreeEventArgs = {
              fullScreen: fullScreen,
              preventDefaultAction: false
          };
          /**
           * Raised when the viewer is about to change to/from full-screen mode (see {@link OpenSeadragon.Viewer#setFullScreen}).
           * Note: the pre-full-screen event is not raised when the user is exiting
           * full-screen mode by pressing the Esc key. In that case, consider using
           * the full-screen, pre-full-page or full-page events.
           *
           * @event pre-full-screen
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
           * @property {Boolean} fullScreen - True if entering full-screen mode, false if exiting full-screen mode.
           * @property {Boolean} preventDefaultAction - Set to true to prevent full-screen mode change. Default: false.
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent( 'pre-full-screen', fullScreeEventArgs );
          if ( fullScreeEventArgs.preventDefaultAction ) {
              return this;
          }
  
          if ( fullScreen ) {
  
              this.setFullPage( true );
              // If the full page mode is not actually entered, we need to prevent
              // the full screen mode.
              if ( !this.isFullPage() ) {
                  return this;
              }
  
              this.fullPageStyleWidth = this.element.style.width;
              this.fullPageStyleHeight = this.element.style.height;
              this.element.style.width = '100%';
              this.element.style.height = '100%';
  
              var onFullScreenChange = function() {
                  var isFullScreen = $.isFullScreen();
                  if ( !isFullScreen ) {
                      $.removeEvent( document, $.fullScreenEventName, onFullScreenChange );
                      $.removeEvent( document, $.fullScreenErrorEventName, onFullScreenChange );
  
                      _this.setFullPage( false );
                      if ( _this.isFullPage() ) {
                          _this.element.style.width = _this.fullPageStyleWidth;
                          _this.element.style.height = _this.fullPageStyleHeight;
                      }
                  }
                  if ( _this.navigator && _this.viewport ) {
                      //09/08/2018 - Fabroh : Fix issue #1504 : Ensure to get the navigator updated on fullscreen out with custom location with a timeout
                      setTimeout(function(){
                          _this.navigator.update( _this.viewport );
                      });
                  }
                  /**
                   * Raised when the viewer has changed to/from full-screen mode (see {@link OpenSeadragon.Viewer#setFullScreen}).
                   *
                   * @event full-screen
                   * @memberof OpenSeadragon.Viewer
                   * @type {object}
                   * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
                   * @property {Boolean} fullScreen - True if changed to full-screen mode, false if exited full-screen mode.
                   * @property {?Object} userData - Arbitrary subscriber-defined object.
                   */
                  _this.raiseEvent( 'full-screen', { fullScreen: isFullScreen } );
              };
              $.addEvent( document, $.fullScreenEventName, onFullScreenChange );
              $.addEvent( document, $.fullScreenErrorEventName, onFullScreenChange );
  
              $.requestFullScreen( document.body );
  
          } else {
              $.exitFullScreen();
          }
          return this;
      },
  
      /**
       * @function
       * @return {Boolean}
       */
      isVisible: function () {
          return this.container.style.visibility != "hidden";
      },
  
  
      /**
       * @function
       * @param {Boolean} visible
       * @return {OpenSeadragon.Viewer} Chainable.
       * @fires OpenSeadragon.Viewer.event:visible
       */
      setVisible: function( visible ){
          this.container.style.visibility = visible ? "" : "hidden";
          /**
           * Raised when the viewer is shown or hidden (see {@link OpenSeadragon.Viewer#setVisible}).
           *
           * @event visible
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
           * @property {Boolean} visible
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent( 'visible', { visible: visible } );
          return this;
      },
  
      /**
       * Add a tiled image to the viewer.
       * options.tileSource can be anything that {@link OpenSeadragon.Viewer#open}
       *  supports except arrays of images.
       * Note that you can specify options.width or options.height, but not both.
       * The other dimension will be calculated according to the item's aspect ratio.
       * If collectionMode is on (see {@link OpenSeadragon.Options}), the new image is
       * automatically arranged with the others.
       * @function
       * @param {Object} options
       * @param {String|Object|Function} options.tileSource - The TileSource specifier.
       * A String implies a url used to determine the tileSource implementation
       *      based on the file extension of url. JSONP is implied by *.js,
       *      otherwise the url is retrieved as text and the resulting text is
       *      introspected to determine if its json, xml, or text and parsed.
       * An Object implies an inline configuration which has a single
       *      property sufficient for being able to determine tileSource
       *      implementation. If the object has a property which is a function
       *      named 'getTileUrl', it is treated as a custom TileSource.
       * @param {Number} [options.index] The index of the item. Added on top of
       * all other items if not specified.
       * @param {Boolean} [options.replace=false] If true, the item at options.index will be
       * removed and the new item is added in its place. options.tileSource will be
       * interpreted and fetched if necessary before the old item is removed to avoid leaving
       * a gap in the world.
       * @param {Number} [options.x=0] The X position for the image in viewport coordinates.
       * @param {Number} [options.y=0] The Y position for the image in viewport coordinates.
       * @param {Number} [options.width=1] The width for the image in viewport coordinates.
       * @param {Number} [options.height] The height for the image in viewport coordinates.
       * @param {OpenSeadragon.Rect} [options.fitBounds] The bounds in viewport coordinates
       * to fit the image into. If specified, x, y, width and height get ignored.
       * @param {OpenSeadragon.Placement} [options.fitBoundsPlacement=OpenSeadragon.Placement.CENTER]
       * How to anchor the image in the bounds if options.fitBounds is set.
       * @param {OpenSeadragon.Rect} [options.clip] - An area, in image pixels, to clip to
       * (portions of the image outside of this area will not be visible). Only works on
       * browsers that support the HTML5 canvas.
       * @param {Number} [options.opacity=1] Proportional opacity of the tiled images (1=opaque, 0=hidden)
       * @param {Boolean} [options.preload=false]  Default switch for loading hidden images (true loads, false blocks)
       * @param {Number} [options.degrees=0] Initial rotation of the tiled image around
       * its top left corner in degrees.
       * @param {String} [options.compositeOperation] How the image is composited onto other images.
       * @param {String} [options.crossOriginPolicy] The crossOriginPolicy for this specific image,
       * overriding viewer.crossOriginPolicy.
       * @param {Boolean} [options.ajaxWithCredentials] Whether to set withCredentials on tile AJAX
       * @param {Boolean} [options.loadTilesWithAjax]
       *      Whether to load tile data using AJAX requests.
       *      Defaults to the setting in {@link OpenSeadragon.Options}.
       * @param {Object} [options.ajaxHeaders]
       *      A set of headers to include when making tile AJAX requests.
       *      Note that these headers will be merged over any headers specified in {@link OpenSeadragon.Options}.
       *      Specifying a falsy value for a header will clear its existing value set at the Viewer level (if any).
       * requests.
       * @param {Function} [options.success] A function that gets called when the image is
       * successfully added. It's passed the event object which contains a single property:
       * "item", which is the resulting instance of TiledImage.
       * @param {Function} [options.error] A function that gets called if the image is
       * unable to be added. It's passed the error event object, which contains "message"
       * and "source" properties.
       * @param {Boolean} [options.collectionImmediately=false] If collectionMode is on,
       * specifies whether to snap to the new arrangement immediately or to animate to it.
       * @param {String|CanvasGradient|CanvasPattern|Function} [options.placeholderFillStyle] - See {@link OpenSeadragon.Options}.
       * @fires OpenSeadragon.World.event:add-item
       * @fires OpenSeadragon.Viewer.event:add-item-failed
       */
      addTiledImage: function( options ) {
          $.console.assert(options, "[Viewer.addTiledImage] options is required");
          $.console.assert(options.tileSource, "[Viewer.addTiledImage] options.tileSource is required");
          $.console.assert(!options.replace || (options.index > -1 && options.index < this.world.getItemCount()),
              "[Viewer.addTiledImage] if options.replace is used, options.index must be a valid index in Viewer.world");
  
          var _this = this;
  
          if (options.replace) {
              options.replaceItem = _this.world.getItemAt(options.index);
          }
  
          this._hideMessage();
  
          if (options.placeholderFillStyle === undefined) {
              options.placeholderFillStyle = this.placeholderFillStyle;
          }
          if (options.opacity === undefined) {
              options.opacity = this.opacity;
          }
          if (options.preload === undefined) {
              options.preload = this.preload;
          }
          if (options.compositeOperation === undefined) {
              options.compositeOperation = this.compositeOperation;
          }
          if (options.crossOriginPolicy === undefined) {
              options.crossOriginPolicy = options.tileSource.crossOriginPolicy !== undefined ? options.tileSource.crossOriginPolicy : this.crossOriginPolicy;
          }
          if (options.ajaxWithCredentials === undefined) {
              options.ajaxWithCredentials = this.ajaxWithCredentials;
          }
          if (options.loadTilesWithAjax === undefined) {
              options.loadTilesWithAjax = this.loadTilesWithAjax;
          }
          if (options.ajaxHeaders === undefined || options.ajaxHeaders === null) {
              options.ajaxHeaders = this.ajaxHeaders;
          } else if ($.isPlainObject(options.ajaxHeaders) && $.isPlainObject(this.ajaxHeaders)) {
              options.ajaxHeaders = $.extend({}, this.ajaxHeaders, options.ajaxHeaders);
          }
  
          var myQueueItem = {
              options: options
          };
  
          function raiseAddItemFailed( event ) {
              for (var i = 0; i < _this._loadQueue.length; i++) {
                  if (_this._loadQueue[i] === myQueueItem) {
                      _this._loadQueue.splice(i, 1);
                      break;
                  }
              }
  
              if (_this._loadQueue.length === 0) {
                  refreshWorld(myQueueItem);
              }
  
               /**
               * Raised when an error occurs while adding a item.
               * @event add-item-failed
               * @memberOf OpenSeadragon.Viewer
               * @type {object}
               * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
               * @property {String} message
               * @property {String} source
               * @property {Object} options The options passed to the addTiledImage method.
               * @property {?Object} userData - Arbitrary subscriber-defined object.
               */
              _this.raiseEvent( 'add-item-failed', event );
  
              if (options.error) {
                  options.error(event);
              }
          }
  
          function refreshWorld(theItem) {
              if (_this.collectionMode) {
                  _this.world.arrange({
                      immediately: theItem.options.collectionImmediately,
                      rows: _this.collectionRows,
                      columns: _this.collectionColumns,
                      layout: _this.collectionLayout,
                      tileSize: _this.collectionTileSize,
                      tileMargin: _this.collectionTileMargin
                  });
                  _this.world.setAutoRefigureSizes(true);
              }
          }
  
          if ($.isArray(options.tileSource)) {
              setTimeout(function() {
                  raiseAddItemFailed({
                      message: "[Viewer.addTiledImage] Sequences can not be added; add them one at a time instead.",
                      source: options.tileSource,
                      options: options
                  });
              });
              return;
          }
  
          this._loadQueue.push(myQueueItem);
  
          function processReadyItems() {
              var queueItem, tiledImage, optionsClone;
              while (_this._loadQueue.length) {
                  queueItem = _this._loadQueue[0];
                  if (!queueItem.tileSource) {
                      break;
                  }
  
                  _this._loadQueue.splice(0, 1);
  
                  if (queueItem.options.replace) {
                      var newIndex = _this.world.getIndexOfItem(queueItem.options.replaceItem);
                      if (newIndex != -1) {
                          queueItem.options.index = newIndex;
                      }
                      _this.world.removeItem(queueItem.options.replaceItem);
                  }
  
                  tiledImage = new $.TiledImage({
                      viewer: _this,
                      source: queueItem.tileSource,
                      viewport: _this.viewport,
                      drawer: _this.drawer,
                      tileCache: _this.tileCache,
                      imageLoader: _this.imageLoader,
                      x: queueItem.options.x,
                      y: queueItem.options.y,
                      width: queueItem.options.width,
                      height: queueItem.options.height,
                      fitBounds: queueItem.options.fitBounds,
                      fitBoundsPlacement: queueItem.options.fitBoundsPlacement,
                      clip: queueItem.options.clip,
                      placeholderFillStyle: queueItem.options.placeholderFillStyle,
                      opacity: queueItem.options.opacity,
                      preload: queueItem.options.preload,
                      degrees: queueItem.options.degrees,
                      compositeOperation: queueItem.options.compositeOperation,
                      springStiffness: _this.springStiffness,
                      animationTime: _this.animationTime,
                      minZoomImageRatio: _this.minZoomImageRatio,
                      wrapHorizontal: _this.wrapHorizontal,
                      wrapVertical: _this.wrapVertical,
                      immediateRender: _this.immediateRender,
                      blendTime: _this.blendTime,
                      alwaysBlend: _this.alwaysBlend,
                      minPixelRatio: _this.minPixelRatio,
                      smoothTileEdgesMinZoom: _this.smoothTileEdgesMinZoom,
                      iOSDevice: _this.iOSDevice,
                      crossOriginPolicy: queueItem.options.crossOriginPolicy,
                      ajaxWithCredentials: queueItem.options.ajaxWithCredentials,
                      loadTilesWithAjax: queueItem.options.loadTilesWithAjax,
                      ajaxHeaders: queueItem.options.ajaxHeaders,
                      debugMode: _this.debugMode
                  });
  
                  if (_this.collectionMode) {
                      _this.world.setAutoRefigureSizes(false);
                  }
                  _this.world.addItem( tiledImage, {
                      index: queueItem.options.index
                  });
  
                  if (_this._loadQueue.length === 0) {
                      //this restores the autoRefigureSizes flag to true.
                      refreshWorld(queueItem);
                  }
  
                  if (_this.world.getItemCount() === 1 && !_this.preserveViewport) {
                      _this.viewport.goHome(true);
                  }
  
                  if (_this.navigator) {
                      optionsClone = $.extend({}, queueItem.options, {
                          replace: false, // navigator already removed the layer, nothing to replace
                          originalTiledImage: tiledImage,
                          tileSource: queueItem.tileSource
                      });
  
                      _this.navigator.addTiledImage(optionsClone);
                  }
  
                  if (queueItem.options.success) {
                      queueItem.options.success({
                          item: tiledImage
                      });
                  }
              }
          }
  
          getTileSourceImplementation( this, options.tileSource, options, function( tileSource ) {
  
              myQueueItem.tileSource = tileSource;
  
              // add everybody at the front of the queue that's ready to go
              processReadyItems();
          }, function( event ) {
              event.options = options;
              raiseAddItemFailed(event);
  
              // add everybody at the front of the queue that's ready to go
              processReadyItems();
          } );
      },
  
      /**
       * Add a simple image to the viewer.
       * The options are the same as the ones in {@link OpenSeadragon.Viewer#addTiledImage}
       * except for options.tileSource which is replaced by options.url.
       * @function
       * @param {Object} options - See {@link OpenSeadragon.Viewer#addTiledImage}
       * for all the options
       * @param {String} options.url - The URL of the image to add.
       * @fires OpenSeadragon.World.event:add-item
       * @fires OpenSeadragon.Viewer.event:add-item-failed
       */
      addSimpleImage: function(options) {
          $.console.assert(options, "[Viewer.addSimpleImage] options is required");
          $.console.assert(options.url, "[Viewer.addSimpleImage] options.url is required");
  
          var opts = $.extend({}, options, {
              tileSource: {
                  type: 'image',
                  url:  options.url
              }
          });
          delete opts.url;
          this.addTiledImage(opts);
      },
  
      // deprecated
      addLayer: function( options ) {
          var _this = this;
  
          $.console.error( "[Viewer.addLayer] this function is deprecated; use Viewer.addTiledImage() instead." );
  
          var optionsClone = $.extend({}, options, {
              success: function(event) {
                  _this.raiseEvent("add-layer", {
                      options: options,
                      drawer: event.item
                  });
              },
              error: function(event) {
                  _this.raiseEvent("add-layer-failed", event);
              }
          });
  
          this.addTiledImage(optionsClone);
          return this;
      },
  
      // deprecated
      getLayerAtLevel: function( level ) {
          $.console.error( "[Viewer.getLayerAtLevel] this function is deprecated; use World.getItemAt() instead." );
          return this.world.getItemAt(level);
      },
  
      // deprecated
      getLevelOfLayer: function( drawer ) {
          $.console.error( "[Viewer.getLevelOfLayer] this function is deprecated; use World.getIndexOfItem() instead." );
          return this.world.getIndexOfItem(drawer);
      },
  
      // deprecated
      getLayersCount: function() {
          $.console.error( "[Viewer.getLayersCount] this function is deprecated; use World.getItemCount() instead." );
          return this.world.getItemCount();
      },
  
      // deprecated
      setLayerLevel: function( drawer, level ) {
          $.console.error( "[Viewer.setLayerLevel] this function is deprecated; use World.setItemIndex() instead." );
          return this.world.setItemIndex(drawer, level);
      },
  
      // deprecated
      removeLayer: function( drawer ) {
          $.console.error( "[Viewer.removeLayer] this function is deprecated; use World.removeItem() instead." );
          return this.world.removeItem(drawer);
      },
  
      /**
       * Force the viewer to redraw its contents.
       * @returns {OpenSeadragon.Viewer} Chainable.
       */
      forceRedraw: function() {
          THIS[ this.hash ].forceRedraw = true;
          return this;
      },
  
      /**
       * @function
       * @return {OpenSeadragon.Viewer} Chainable.
       */
      bindSequenceControls: function(){
  
          //////////////////////////////////////////////////////////////////////////
          // Image Sequence Controls
          //////////////////////////////////////////////////////////////////////////
          var onFocusHandler          = $.delegate( this, onFocus ),
              onBlurHandler           = $.delegate( this, onBlur ),
              onNextHandler           = $.delegate( this, onNext ),
              onPreviousHandler       = $.delegate( this, onPrevious ),
              navImages               = this.navImages,
              useGroup                = true;
  
          if( this.showSequenceControl ){
  
              if( this.previousButton || this.nextButton ){
                  //if we are binding to custom buttons then layout and
                  //grouping is the responsibility of the page author
                  useGroup = false;
              }
  
              this.previousButton = new $.Button({
                  element:    this.previousButton ? $.getElement( this.previousButton ) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip:    $.getString( "Tooltips.PreviousPage" ),
                  srcRest:    resolveUrl( this.prefixUrl, navImages.previous.REST ),
                  srcGroup:   resolveUrl( this.prefixUrl, navImages.previous.GROUP ),
                  srcHover:   resolveUrl( this.prefixUrl, navImages.previous.HOVER ),
                  srcDown:    resolveUrl( this.prefixUrl, navImages.previous.DOWN ),
                  onRelease:  onPreviousHandler,
                  onFocus:    onFocusHandler,
                  onBlur:     onBlurHandler
              });
  
              this.nextButton = new $.Button({
                  element:    this.nextButton ? $.getElement( this.nextButton ) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip:    $.getString( "Tooltips.NextPage" ),
                  srcRest:    resolveUrl( this.prefixUrl, navImages.next.REST ),
                  srcGroup:   resolveUrl( this.prefixUrl, navImages.next.GROUP ),
                  srcHover:   resolveUrl( this.prefixUrl, navImages.next.HOVER ),
                  srcDown:    resolveUrl( this.prefixUrl, navImages.next.DOWN ),
                  onRelease:  onNextHandler,
                  onFocus:    onFocusHandler,
                  onBlur:     onBlurHandler
              });
  
              if( !this.navPrevNextWrap ){
                  this.previousButton.disable();
              }
  
              if (!this.tileSources || !this.tileSources.length) {
                  this.nextButton.disable();
              }
  
              if( useGroup ){
                  this.paging = new $.ButtonGroup({
                      buttons: [
                          this.previousButton,
                          this.nextButton
                      ],
                      clickTimeThreshold: this.clickTimeThreshold,
                      clickDistThreshold: this.clickDistThreshold
                  });
  
                  this.pagingControl = this.paging.element;
  
                  if( this.toolbar ){
                      this.toolbar.addControl(
                          this.pagingControl,
                          {anchor: $.ControlAnchor.BOTTOM_RIGHT}
                      );
                  }else{
                      this.addControl(
                          this.pagingControl,
                          {anchor: this.sequenceControlAnchor || $.ControlAnchor.TOP_LEFT}
                      );
                  }
              }
          }
          return this;
      },
  
  
      /**
       * @function
       * @return {OpenSeadragon.Viewer} Chainable.
       */
      bindStandardControls: function(){
          //////////////////////////////////////////////////////////////////////////
          // Navigation Controls
          //////////////////////////////////////////////////////////////////////////
          var beginZoomingInHandler   = $.delegate( this, beginZoomingIn ),
              endZoomingHandler       = $.delegate( this, endZooming ),
              doSingleZoomInHandler   = $.delegate( this, doSingleZoomIn ),
              beginZoomingOutHandler  = $.delegate( this, beginZoomingOut ),
              doSingleZoomOutHandler  = $.delegate( this, doSingleZoomOut ),
              onHomeHandler           = $.delegate( this, onHome ),
              onFullScreenHandler     = $.delegate( this, onFullScreen ),
              onRotateLeftHandler     = $.delegate( this, onRotateLeft ),
              onRotateRightHandler    = $.delegate( this, onRotateRight ),
              onFlipHandler           = $.delegate( this, onFlip),
              onFocusHandler          = $.delegate( this, onFocus ),
              onBlurHandler           = $.delegate( this, onBlur ),
              navImages               = this.navImages,
              buttons                 = [],
              useGroup                = true;
  
  
          if ( this.showNavigationControl ) {
  
              if( this.zoomInButton || this.zoomOutButton ||
                  this.homeButton || this.fullPageButton ||
                  this.rotateLeftButton || this.rotateRightButton ||
                  this.flipButton ) {
                  //if we are binding to custom buttons then layout and
                  //grouping is the responsibility of the page author
                  useGroup = false;
              }
  
              if ( this.showZoomControl ) {
                  buttons.push( this.zoomInButton = new $.Button({
                      element:    this.zoomInButton ? $.getElement( this.zoomInButton ) : null,
                      clickTimeThreshold: this.clickTimeThreshold,
                      clickDistThreshold: this.clickDistThreshold,
                      tooltip:    $.getString( "Tooltips.ZoomIn" ),
                      srcRest:    resolveUrl( this.prefixUrl, navImages.zoomIn.REST ),
                      srcGroup:   resolveUrl( this.prefixUrl, navImages.zoomIn.GROUP ),
                      srcHover:   resolveUrl( this.prefixUrl, navImages.zoomIn.HOVER ),
                      srcDown:    resolveUrl( this.prefixUrl, navImages.zoomIn.DOWN ),
                      onPress:    beginZoomingInHandler,
                      onRelease:  endZoomingHandler,
                      onClick:    doSingleZoomInHandler,
                      onEnter:    beginZoomingInHandler,
                      onExit:     endZoomingHandler,
                      onFocus:    onFocusHandler,
                      onBlur:     onBlurHandler
                  }));
  
                  buttons.push( this.zoomOutButton = new $.Button({
                      element:    this.zoomOutButton ? $.getElement( this.zoomOutButton ) : null,
                      clickTimeThreshold: this.clickTimeThreshold,
                      clickDistThreshold: this.clickDistThreshold,
                      tooltip:    $.getString( "Tooltips.ZoomOut" ),
                      srcRest:    resolveUrl( this.prefixUrl, navImages.zoomOut.REST ),
                      srcGroup:   resolveUrl( this.prefixUrl, navImages.zoomOut.GROUP ),
                      srcHover:   resolveUrl( this.prefixUrl, navImages.zoomOut.HOVER ),
                      srcDown:    resolveUrl( this.prefixUrl, navImages.zoomOut.DOWN ),
                      onPress:    beginZoomingOutHandler,
                      onRelease:  endZoomingHandler,
                      onClick:    doSingleZoomOutHandler,
                      onEnter:    beginZoomingOutHandler,
                      onExit:     endZoomingHandler,
                      onFocus:    onFocusHandler,
                      onBlur:     onBlurHandler
                  }));
              }
  
              if ( this.showHomeControl ) {
                  buttons.push( this.homeButton = new $.Button({
                      element:    this.homeButton ? $.getElement( this.homeButton ) : null,
                      clickTimeThreshold: this.clickTimeThreshold,
                      clickDistThreshold: this.clickDistThreshold,
                      tooltip:    $.getString( "Tooltips.Home" ),
                      srcRest:    resolveUrl( this.prefixUrl, navImages.home.REST ),
                      srcGroup:   resolveUrl( this.prefixUrl, navImages.home.GROUP ),
                      srcHover:   resolveUrl( this.prefixUrl, navImages.home.HOVER ),
                      srcDown:    resolveUrl( this.prefixUrl, navImages.home.DOWN ),
                      onRelease:  onHomeHandler,
                      onFocus:    onFocusHandler,
                      onBlur:     onBlurHandler
                  }));
              }
  
              if ( this.showFullPageControl ) {
                  buttons.push( this.fullPageButton = new $.Button({
                      element:    this.fullPageButton ? $.getElement( this.fullPageButton ) : null,
                      clickTimeThreshold: this.clickTimeThreshold,
                      clickDistThreshold: this.clickDistThreshold,
                      tooltip:    $.getString( "Tooltips.FullPage" ),
                      srcRest:    resolveUrl( this.prefixUrl, navImages.fullpage.REST ),
                      srcGroup:   resolveUrl( this.prefixUrl, navImages.fullpage.GROUP ),
                      srcHover:   resolveUrl( this.prefixUrl, navImages.fullpage.HOVER ),
                      srcDown:    resolveUrl( this.prefixUrl, navImages.fullpage.DOWN ),
                      onRelease:  onFullScreenHandler,
                      onFocus:    onFocusHandler,
                      onBlur:     onBlurHandler
                  }));
              }
  
              if ( this.showRotationControl ) {
                  buttons.push( this.rotateLeftButton = new $.Button({
                      element:    this.rotateLeftButton ? $.getElement( this.rotateLeftButton ) : null,
                      clickTimeThreshold: this.clickTimeThreshold,
                      clickDistThreshold: this.clickDistThreshold,
                      tooltip:    $.getString( "Tooltips.RotateLeft" ),
                      srcRest:    resolveUrl( this.prefixUrl, navImages.rotateleft.REST ),
                      srcGroup:   resolveUrl( this.prefixUrl, navImages.rotateleft.GROUP ),
                      srcHover:   resolveUrl( this.prefixUrl, navImages.rotateleft.HOVER ),
                      srcDown:    resolveUrl( this.prefixUrl, navImages.rotateleft.DOWN ),
                      onRelease:  onRotateLeftHandler,
                      onFocus:    onFocusHandler,
                      onBlur:     onBlurHandler
                  }));
  
                  buttons.push( this.rotateRightButton = new $.Button({
                      element:    this.rotateRightButton ? $.getElement( this.rotateRightButton ) : null,
                      clickTimeThreshold: this.clickTimeThreshold,
                      clickDistThreshold: this.clickDistThreshold,
                      tooltip:    $.getString( "Tooltips.RotateRight" ),
                      srcRest:    resolveUrl( this.prefixUrl, navImages.rotateright.REST ),
                      srcGroup:   resolveUrl( this.prefixUrl, navImages.rotateright.GROUP ),
                      srcHover:   resolveUrl( this.prefixUrl, navImages.rotateright.HOVER ),
                      srcDown:    resolveUrl( this.prefixUrl, navImages.rotateright.DOWN ),
                      onRelease:  onRotateRightHandler,
                      onFocus:    onFocusHandler,
                      onBlur:     onBlurHandler
                  }));
              }
  
              if ( this.showFlipControl ) {
                  buttons.push( this.flipButton = new $.Button({
                      element:    this.flipButton ? $.getElement( this.flipButton ) : null,
                      clickTimeThreshold: this.clickTimeThreshold,
                      clickDistThreshold: this.clickDistThreshold,
                      tooltip:    $.getString( "Tooltips.Flip" ),
                      srcRest:    resolveUrl( this.prefixUrl, navImages.flip.REST ),
                      srcGroup:   resolveUrl( this.prefixUrl, navImages.flip.GROUP ),
                      srcHover:   resolveUrl( this.prefixUrl, navImages.flip.HOVER ),
                      srcDown:    resolveUrl( this.prefixUrl, navImages.flip.DOWN ),
                      onRelease:  onFlipHandler,
                      onFocus:    onFocusHandler,
                      onBlur:     onBlurHandler
                  }));
              }
  
              if ( useGroup ) {
                  this.buttons = new $.ButtonGroup({
                      buttons:            buttons,
                      clickTimeThreshold: this.clickTimeThreshold,
                      clickDistThreshold: this.clickDistThreshold
                  });
  
                  this.navControl  = this.buttons.element;
                  this.addHandler( 'open', $.delegate( this, lightUp ) );
  
                  if( this.toolbar ){
                      this.toolbar.addControl(
                          this.navControl,
                          {anchor: this.navigationControlAnchor || $.ControlAnchor.TOP_LEFT}
                      );
                  } else {
                      this.addControl(
                          this.navControl,
                          {anchor: this.navigationControlAnchor || $.ControlAnchor.TOP_LEFT}
                      );
                  }
              }
  
          }
          return this;
      },
  
      /**
       * Gets the active page of a sequence
       * @function
       * @return {Number}
       */
      currentPage: function() {
          return this._sequenceIndex;
      },
  
      /**
       * @function
       * @return {OpenSeadragon.Viewer} Chainable.
       * @fires OpenSeadragon.Viewer.event:page
       */
      goToPage: function( page ){
          if( this.tileSources && page >= 0 && page < this.tileSources.length ){
              this._sequenceIndex = page;
  
              this._updateSequenceButtons( page );
  
              this.open( this.tileSources[ page ] );
  
              if( this.referenceStrip ){
                  this.referenceStrip.setFocus( page );
              }
  
              /**
               * Raised when the page is changed on a viewer configured with multiple image sources (see {@link OpenSeadragon.Viewer#goToPage}).
               *
               * @event page
               * @memberof OpenSeadragon.Viewer
               * @type {Object}
               * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
               * @property {Number} page - The page index.
               * @property {?Object} userData - Arbitrary subscriber-defined object.
               */
              this.raiseEvent( 'page', { page: page } );
          }
  
          return this;
      },
  
     /**
       * Adds an html element as an overlay to the current viewport.  Useful for
       * highlighting words or areas of interest on an image or other zoomable
       * interface. The overlays added via this method are removed when the viewport
       * is closed which include when changing page.
       * @method
       * @param {Element|String|Object} element - A reference to an element or an id for
       *      the element which will be overlaid. Or an Object specifying the configuration for the overlay.
       *      If using an object, see {@link OpenSeadragon.Overlay} for a list of
       *      all available options.
       * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
       *      rectangle which will be overlaid. This is a viewport relative location.
       * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
       *      viewport which the location coordinates will be treated as relative
       *      to.
       * @param {function} [onDraw] - If supplied the callback is called when the overlay
       *      needs to be drawn. It it the responsibility of the callback to do any drawing/positioning.
       *      It is passed position, size and element.
       * @return {OpenSeadragon.Viewer} Chainable.
       * @fires OpenSeadragon.Viewer.event:add-overlay
       */
      addOverlay: function( element, location, placement, onDraw ) {
          var options;
          if( $.isPlainObject( element ) ){
              options = element;
          } else {
              options = {
                  element: element,
                  location: location,
                  placement: placement,
                  onDraw: onDraw
              };
          }
  
          element = $.getElement( options.element );
  
          if ( getOverlayIndex( this.currentOverlays, element ) >= 0 ) {
              // they're trying to add a duplicate overlay
              return this;
          }
  
          var overlay = getOverlayObject( this, options);
          this.currentOverlays.push(overlay);
          overlay.drawHTML( this.overlaysContainer, this.viewport );
  
          /**
           * Raised when an overlay is added to the viewer (see {@link OpenSeadragon.Viewer#addOverlay}).
           *
           * @event add-overlay
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
           * @property {Element} element - The overlay element.
           * @property {OpenSeadragon.Point|OpenSeadragon.Rect} location
           * @property {OpenSeadragon.Placement} placement
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent( 'add-overlay', {
              element: element,
              location: options.location,
              placement: options.placement
          });
          return this;
      },
  
      /**
       * Updates the overlay represented by the reference to the element or
       * element id moving it to the new location, relative to the new placement.
       * @method
       * @param {Element|String} element - A reference to an element or an id for
       *      the element which is overlaid.
       * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
       *      rectangle which will be overlaid. This is a viewport relative location.
       * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
       *      viewport which the location coordinates will be treated as relative
       *      to.
       * @return {OpenSeadragon.Viewer} Chainable.
       * @fires OpenSeadragon.Viewer.event:update-overlay
       */
      updateOverlay: function( element, location, placement ) {
          var i;
  
          element = $.getElement( element );
          i = getOverlayIndex( this.currentOverlays, element );
  
          if ( i >= 0 ) {
              this.currentOverlays[ i ].update( location, placement );
              THIS[ this.hash ].forceRedraw = true;
              /**
               * Raised when an overlay's location or placement changes
               * (see {@link OpenSeadragon.Viewer#updateOverlay}).
               *
               * @event update-overlay
               * @memberof OpenSeadragon.Viewer
               * @type {object}
               * @property {OpenSeadragon.Viewer} eventSource - A reference to the
               * Viewer which raised the event.
               * @property {Element} element
               * @property {OpenSeadragon.Point|OpenSeadragon.Rect} location
               * @property {OpenSeadragon.Placement} placement
               * @property {?Object} userData - Arbitrary subscriber-defined object.
               */
              this.raiseEvent( 'update-overlay', {
                  element: element,
                  location: location,
                  placement: placement
              });
          }
          return this;
      },
  
      /**
       * Removes an overlay identified by the reference element or element id
       * and schedules an update.
       * @method
       * @param {Element|String} element - A reference to the element or an
       *      element id which represent the ovelay content to be removed.
       * @return {OpenSeadragon.Viewer} Chainable.
       * @fires OpenSeadragon.Viewer.event:remove-overlay
       */
      removeOverlay: function( element ) {
          var i;
  
          element = $.getElement( element );
          i = getOverlayIndex( this.currentOverlays, element );
  
          if ( i >= 0 ) {
              this.currentOverlays[ i ].destroy();
              this.currentOverlays.splice( i, 1 );
              THIS[ this.hash ].forceRedraw = true;
              /**
               * Raised when an overlay is removed from the viewer
               * (see {@link OpenSeadragon.Viewer#removeOverlay}).
               *
               * @event remove-overlay
               * @memberof OpenSeadragon.Viewer
               * @type {object}
               * @property {OpenSeadragon.Viewer} eventSource - A reference to the
               * Viewer which raised the event.
               * @property {Element} element - The overlay element.
               * @property {?Object} userData - Arbitrary subscriber-defined object.
               */
              this.raiseEvent( 'remove-overlay', {
                  element: element
              });
          }
          return this;
      },
  
      /**
       * Removes all currently configured Overlays from this Viewer and schedules
       * an update.
       * @method
       * @return {OpenSeadragon.Viewer} Chainable.
       * @fires OpenSeadragon.Viewer.event:clear-overlay
       */
      clearOverlays: function() {
          while ( this.currentOverlays.length > 0 ) {
              this.currentOverlays.pop().destroy();
          }
          THIS[ this.hash ].forceRedraw = true;
          /**
           * Raised when all overlays are removed from the viewer (see {@link OpenSeadragon.Drawer#clearOverlays}).
           *
           * @event clear-overlay
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent( 'clear-overlay', {} );
          return this;
      },
  
       /**
       * Finds an overlay identified by the reference element or element id
       * and returns it as an object, return null if not found.
       * @method
       * @param {Element|String} element - A reference to the element or an
       *      element id which represents the overlay content.
       * @return {OpenSeadragon.Overlay} the matching overlay or null if none found.
       */
      getOverlayById: function( element ) {
          var i;
  
          element = $.getElement( element );
          i = getOverlayIndex( this.currentOverlays, element );
  
          if (i >= 0) {
              return this.currentOverlays[i];
          } else {
              return null;
          }
      },
  
      /**
       * Updates the sequence buttons.
       * @function OpenSeadragon.Viewer.prototype._updateSequenceButtons
       * @private
       * @param {Number} Sequence Value
       */
      _updateSequenceButtons: function( page ) {
  
              if ( this.nextButton ) {
                  if(!this.tileSources || this.tileSources.length - 1 === page) {
                      //Disable next button
                      if ( !this.navPrevNextWrap ) {
                          this.nextButton.disable();
                      }
                  } else {
                      this.nextButton.enable();
                  }
              }
              if ( this.previousButton ) {
                  if ( page > 0 ) {
                      //Enable previous button
                      this.previousButton.enable();
                  } else {
                      if ( !this.navPrevNextWrap ) {
                          this.previousButton.disable();
                      }
                  }
              }
        },
  
      /**
       * Display a message in the viewport
       * @function OpenSeadragon.Viewer.prototype._showMessage
       * @private
       * @param {String} text message
       */
      _showMessage: function ( message ) {
          this._hideMessage();
  
          var div = $.makeNeutralElement( "div" );
          div.appendChild( document.createTextNode( message ) );
  
          this.messageDiv = $.makeCenteredNode( div );
  
          $.addClass(this.messageDiv, "openseadragon-message");
  
          this.container.appendChild( this.messageDiv );
      },
  
      /**
       * Hide any currently displayed viewport message
       * @function OpenSeadragon.Viewer.prototype._hideMessage
       * @private
       */
      _hideMessage: function () {
          var div = this.messageDiv;
          if (div) {
              div.parentNode.removeChild(div);
              delete this.messageDiv;
          }
      },
  
      /**
       * Gets this viewer's gesture settings for the given pointer device type.
       * @method
       * @param {String} type - The pointer device type to get the gesture settings for ("mouse", "touch", "pen", etc.).
       * @return {OpenSeadragon.GestureSettings}
       */
      gestureSettingsByDeviceType: function ( type ) {
          switch ( type ) {
              case 'mouse':
                  return this.gestureSettingsMouse;
              case 'touch':
                  return this.gestureSettingsTouch;
              case 'pen':
                  return this.gestureSettingsPen;
              default:
                  return this.gestureSettingsUnknown;
          }
      },
  
      // private
      _drawOverlays: function() {
          var i,
              length = this.currentOverlays.length;
          for ( i = 0; i < length; i++ ) {
              this.currentOverlays[ i ].drawHTML( this.overlaysContainer, this.viewport );
          }
      },
  
      /**
       * Cancel the "in flight" images.
       */
      _cancelPendingImages: function() {
          this._loadQueue = [];
      },
  
      /**
       * Removes the reference strip and disables displaying it.
       * @function
       */
      removeReferenceStrip: function() {
          this.showReferenceStrip = false;
  
          if (this.referenceStrip) {
              this.referenceStrip.destroy();
              this.referenceStrip = null;
          }
      },
  
      /**
       * Enables and displays the reference strip based on the currently set tileSources.
       * Works only when the Viewer has sequenceMode set to true.
       * @function
       */
      addReferenceStrip: function() {
          this.showReferenceStrip = true;
  
          if (this.sequenceMode) {
              if (this.referenceStrip) {
                  return;
              }
  
              if (this.tileSources.length && this.tileSources.length > 1) {
                  this.referenceStrip = new $.ReferenceStrip({
                      id:          this.referenceStripElement,
                      position:    this.referenceStripPosition,
                      sizeRatio:   this.referenceStripSizeRatio,
                      scroll:      this.referenceStripScroll,
                      height:      this.referenceStripHeight,
                      width:       this.referenceStripWidth,
                      tileSources: this.tileSources,
                      prefixUrl:   this.prefixUrl,
                      useCanvas:   this.useCanvas,
                      viewer:      this
                  });
  
                  this.referenceStrip.setFocus( this._sequenceIndex );
              }
          } else {
              $.console.warn('Attempting to display a reference strip while "sequenceMode" is off.');
          }
      }
  });
  
  
  /**
   * _getSafeElemSize is like getElementSize(), but refuses to return 0 for x or y,
   * which was causing some calling operations to return NaN.
   * @returns {Point}
   * @private
   */
  function _getSafeElemSize (oElement) {
      oElement = $.getElement( oElement );
  
      return new $.Point(
          (oElement.clientWidth === 0 ? 1 : oElement.clientWidth),
          (oElement.clientHeight === 0 ? 1 : oElement.clientHeight)
      );
  }
  
  
  /**
   * @function
   * @private
   */
  function getTileSourceImplementation( viewer, tileSource, imgOptions, successCallback,
      failCallback ) {
      var _this = viewer;
  
      //allow plain xml strings or json strings to be parsed here
      if ( $.type( tileSource ) == 'string' ) {
          //xml should start with "<" and end with ">"
          if ( tileSource.match( /^\s*<.*>\s*$/ ) ) {
              tileSource = $.parseXml( tileSource );
          //json should start with "{" or "[" and end with "}" or "]"
          } else if ( tileSource.match(/^\s*[\{\[].*[\}\]]\s*$/ ) ) {
              try {
                var tileSourceJ = $.parseJSON(tileSource);
                tileSource = tileSourceJ;
              } catch (e) {
                //tileSource = tileSource;
              }
          }
      }
  
      function waitUntilReady(tileSource, originalTileSource) {
          if (tileSource.ready) {
              successCallback(tileSource);
          } else {
              tileSource.addHandler('ready', function () {
                  successCallback(tileSource);
              });
              tileSource.addHandler('open-failed', function (event) {
                  failCallback({
                      message: event.message,
                      source: originalTileSource
                  });
              });
          }
      }
  
      setTimeout( function() {
          if ( $.type( tileSource ) == 'string' ) {
              //If its still a string it means it must be a url at this point
              tileSource = new $.TileSource({
                  url: tileSource,
                  crossOriginPolicy: imgOptions.crossOriginPolicy !== undefined ?
                      imgOptions.crossOriginPolicy : viewer.crossOriginPolicy,
                  ajaxWithCredentials: viewer.ajaxWithCredentials,
                  ajaxHeaders: viewer.ajaxHeaders,
                  useCanvas: viewer.useCanvas,
                  success: function( event ) {
                      successCallback( event.tileSource );
                  }
              });
              tileSource.addHandler( 'open-failed', function( event ) {
                  failCallback( event );
              } );
  
          } else if ($.isPlainObject(tileSource) || tileSource.nodeType) {
              if (tileSource.crossOriginPolicy === undefined &&
                  (imgOptions.crossOriginPolicy !== undefined || viewer.crossOriginPolicy !== undefined)) {
                  tileSource.crossOriginPolicy = imgOptions.crossOriginPolicy !== undefined ?
                      imgOptions.crossOriginPolicy : viewer.crossOriginPolicy;
              }
              if (tileSource.ajaxWithCredentials === undefined) {
                  tileSource.ajaxWithCredentials = viewer.ajaxWithCredentials;
              }
              if (tileSource.useCanvas === undefined) {
                  tileSource.useCanvas = viewer.useCanvas;
              }
  
              if ( $.isFunction( tileSource.getTileUrl ) ) {
                  //Custom tile source
                  var customTileSource = new $.TileSource( tileSource );
                  customTileSource.getTileUrl = tileSource.getTileUrl;
                  successCallback( customTileSource );
              } else {
                  //inline configuration
                  var $TileSource = $.TileSource.determineType( _this, tileSource );
                  if ( !$TileSource ) {
                      failCallback( {
                          message: "Unable to load TileSource",
                          source: tileSource
                      });
                      return;
                  }
                  var options = $TileSource.prototype.configure.apply( _this, [ tileSource ] );
                  waitUntilReady(new $TileSource(options), tileSource);
              }
          } else {
              //can assume it's already a tile source implementation
              waitUntilReady(tileSource, tileSource);
          }
      });
  }
  
  function getOverlayObject( viewer, overlay ) {
      if ( overlay instanceof $.Overlay ) {
          return overlay;
      }
  
      var element = null;
      if ( overlay.element ) {
          element = $.getElement( overlay.element );
      } else {
          var id = overlay.id ?
              overlay.id :
              "openseadragon-overlay-" + Math.floor( Math.random() * 10000000 );
  
          element = $.getElement( overlay.id );
          if ( !element ) {
              element         = document.createElement( "a" );
              element.href    = "#/overlay/" + id;
          }
          element.id = id;
          $.addClass( element, overlay.className ?
              overlay.className :
              "openseadragon-overlay"
          );
      }
  
      var location = overlay.location;
      var width = overlay.width;
      var height = overlay.height;
      if (!location) {
          var x = overlay.x;
          var y = overlay.y;
          if (overlay.px !== undefined) {
              var rect = viewer.viewport.imageToViewportRectangle(new $.Rect(
                  overlay.px,
                  overlay.py,
                  width || 0,
                  height || 0));
              x = rect.x;
              y = rect.y;
              width = width !== undefined ? rect.width : undefined;
              height = height !== undefined ? rect.height : undefined;
          }
          location = new $.Point(x, y);
      }
  
      var placement = overlay.placement;
      if (placement && $.type(placement) === "string") {
          placement = $.Placement[overlay.placement.toUpperCase()];
      }
  
      return new $.Overlay({
          element: element,
          location: location,
          placement: placement,
          onDraw: overlay.onDraw,
          checkResize: overlay.checkResize,
          width: width,
          height: height,
          rotationMode: overlay.rotationMode
      });
  }
  
  /**
   * @private
   * @inner
   * Determines the index of the given overlay in the given overlays array.
   */
  function getOverlayIndex( overlays, element ) {
      var i;
      for ( i = overlays.length - 1; i >= 0; i-- ) {
          if ( overlays[ i ].element === element ) {
              return i;
          }
      }
  
      return -1;
  }
  
  ///////////////////////////////////////////////////////////////////////////////
  // Schedulers provide the general engine for animation
  ///////////////////////////////////////////////////////////////////////////////
  function scheduleUpdate( viewer, updateFunc ){
      return $.requestAnimationFrame( function(){
          updateFunc( viewer );
      } );
  }
  
  
  //provides a sequence in the fade animation
  function scheduleControlsFade( viewer ) {
      $.requestAnimationFrame( function(){
          updateControlsFade( viewer );
      });
  }
  
  
  //initiates an animation to hide the controls
  function beginControlsAutoHide( viewer ) {
      if ( !viewer.autoHideControls ) {
          return;
      }
      viewer.controlsShouldFade = true;
      viewer.controlsFadeBeginTime =
          $.now() +
          viewer.controlsFadeDelay;
  
      window.setTimeout( function(){
          scheduleControlsFade( viewer );
      }, viewer.controlsFadeDelay );
  }
  
  
  //determines if fade animation is done or continues the animation
  function updateControlsFade( viewer ) {
      var currentTime,
          deltaTime,
          opacity,
          i;
      if ( viewer.controlsShouldFade ) {
          currentTime = $.now();
          deltaTime = currentTime - viewer.controlsFadeBeginTime;
          opacity = 1.0 - deltaTime / viewer.controlsFadeLength;
  
          opacity = Math.min( 1.0, opacity );
          opacity = Math.max( 0.0, opacity );
  
          for ( i = viewer.controls.length - 1; i >= 0; i--) {
              if (viewer.controls[ i ].autoFade) {
                  viewer.controls[ i ].setOpacity( opacity );
              }
          }
  
          if ( opacity > 0 ) {
              // fade again
              scheduleControlsFade( viewer );
          }
      }
  }
  
  
  //stop the fade animation on the controls and show them
  function abortControlsAutoHide( viewer ) {
      var i;
      viewer.controlsShouldFade = false;
      for ( i = viewer.controls.length - 1; i >= 0; i-- ) {
          viewer.controls[ i ].setOpacity( 1.0 );
      }
  }
  
  
  
  ///////////////////////////////////////////////////////////////////////////////
  // Default view event handlers.
  ///////////////////////////////////////////////////////////////////////////////
  function onFocus(){
      abortControlsAutoHide( this );
  }
  
  function onBlur(){
      beginControlsAutoHide( this );
  
  }
  
  function onCanvasKeyDown( event ) {
      var canvasKeyDownEventArgs = {
        originalEvent: event.originalEvent,
        preventDefaultAction: event.preventDefaultAction,
        preventVerticalPan: event.preventVerticalPan,
        preventHorizontalPan: event.preventHorizontalPan
      };
  
      /**
       * Raised when a keyboard key is pressed and the focus is on the {@link OpenSeadragon.Viewer#canvas} element.
       *
       * @event canvas-key
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
       * @property {Object} originalEvent - The original DOM event.
       * @property {Boolean} preventDefaultAction - Set to true to prevent default keyboard behaviour. Default: false.
       * @property {Boolean} preventVerticalPan - Set to true to prevent keyboard vertical panning. Default: false.
       * @property {Boolean} preventHorizontalPan - Set to true to prevent keyboard horizontal panning. Default: false.
       * @property {?Object} userData - Arbitrary subscriber-defined object.
       */
  
      this.raiseEvent('canvas-key', canvasKeyDownEventArgs);
  
      if ( !canvasKeyDownEventArgs.preventDefaultAction && !event.ctrl && !event.alt && !event.meta ) {
          switch( event.keyCode ){
              case 38://up arrow
                  if (!canvasKeyDownEventArgs.preventVerticalPan) {
                    if ( event.shift ) {
                      this.viewport.zoomBy(1.1);
                    } else {
                      this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, -this.pixelsPerArrowPress)));
                    }
                    this.viewport.applyConstraints();
                  }
                  return false;
              case 40://down arrow
                  if (!canvasKeyDownEventArgs.preventVerticalPan) {
                    if ( event.shift ) {
                      this.viewport.zoomBy(0.9);
                    } else {
                      this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, this.pixelsPerArrowPress)));
                    }
                    this.viewport.applyConstraints();
                  }
                  return false;
              case 37://left arrow
                  if (!canvasKeyDownEventArgs.preventHorizontalPan) {
                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(-this.pixelsPerArrowPress, 0)));
                    this.viewport.applyConstraints();
                  }
                  return false;
              case 39://right arrow
                  if (!canvasKeyDownEventArgs.preventHorizontalPan) {
                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(this.pixelsPerArrowPress, 0)));
                    this.viewport.applyConstraints();
                  }
                  return false;
              default:
                  //console.log( 'navigator keycode %s', event.keyCode );
                  return true;
          }
      } else {
          return true;
      }
  }
  function onCanvasKeyPress( event ) {
      var canvasKeyPressEventArgs = {
        originalEvent: event.originalEvent,
        preventDefaultAction: event.preventDefaultAction,
        preventVerticalPan: event.preventVerticalPan,
        preventHorizontalPan: event.preventHorizontalPan
      };
  
      // This event is documented in onCanvasKeyDown
      this.raiseEvent('canvas-key', canvasKeyPressEventArgs);
  
      if ( !canvasKeyPressEventArgs.preventDefaultAction && !event.ctrl && !event.alt && !event.meta ) {
          switch( event.keyCode ){
              case 43://=|+
              case 61://=|+
                  this.viewport.zoomBy(1.1);
                  this.viewport.applyConstraints();
                  return false;
              case 45://-|_
                  this.viewport.zoomBy(0.9);
                  this.viewport.applyConstraints();
                  return false;
              case 48://0|)
                  this.viewport.goHome();
                  this.viewport.applyConstraints();
                  return false;
              case 119://w
              case 87://W
                  if (!canvasKeyPressEventArgs.preventVerticalPan) {
                      if ( event.shift ) {
                          this.viewport.zoomBy(1.1);
                      } else {
                          this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, -40)));
                      }
                      this.viewport.applyConstraints();
                    }
                    return false;
              case 115://s
              case 83://S
                  if (!canvasKeyPressEventArgs.preventVerticalPan) {
                    if ( event.shift ) {
                      this.viewport.zoomBy(0.9);
                    } else {
                      this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, 40)));
                    }
                    this.viewport.applyConstraints();
                  }
                  return false;
              case 97://a
                  if (!canvasKeyPressEventArgs.preventHorizontalPan) {
                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(-40, 0)));
                    this.viewport.applyConstraints();
                  }
                  return false;
              case 100://d
                  if (!canvasKeyPressEventArgs.preventHorizontalPan) {
                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(40, 0)));
                    this.viewport.applyConstraints();
                  }
                  return false;
              case 114: //r - clockwise rotation
                if(this.viewport.flipped){
                  this.viewport.setRotation($.positiveModulo(this.viewport.degrees - this.rotationIncrement, 360));
                } else{
                  this.viewport.setRotation($.positiveModulo(this.viewport.degrees + this.rotationIncrement, 360));
                }
                this.viewport.applyConstraints();
                return false;
              case 82: //R - counterclockwise  rotation
                if(this.viewport.flipped){
                  this.viewport.setRotation($.positiveModulo(this.viewport.degrees + this.rotationIncrement, 360));
                } else{
                  this.viewport.setRotation($.positiveModulo(this.viewport.degrees - this.rotationIncrement, 360));
                }
                this.viewport.applyConstraints();
                return false;
              case 102: //f
                this.viewport.toggleFlip();
                return false;
              default:
                  // console.log( 'navigator keycode %s', event.keyCode );
                  return true;
          }
      } else {
          return true;
      }
  }
  
  function onCanvasClick( event ) {
      var gestureSettings;
  
      var haveKeyboardFocus = document.activeElement == this.canvas;
  
      // If we don't have keyboard focus, request it.
      if ( !haveKeyboardFocus ) {
          this.canvas.focus();
      }
      if(this.viewport.flipped){
          event.position.x = this.viewport.getContainerSize().x - event.position.x;
      }
  
      var canvasClickEventArgs = {
          tracker: event.eventSource,
          position: event.position,
          quick: event.quick,
          shift: event.shift,
          originalEvent: event.originalEvent,
          preventDefaultAction: event.preventDefaultAction
      };
  
      /**
       * Raised when a mouse press/release or touch/remove occurs on the {@link OpenSeadragon.Viewer#canvas} element.
       *
       * @event canvas-click
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
       * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
       * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
       * @property {Boolean} quick - True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for differentiating between clicks and drags.
       * @property {Boolean} shift - True if the shift key was pressed during this event.
       * @property {Object} originalEvent - The original DOM event.
       * @property {Boolean} preventDefaultAction - Set to true to prevent default click to zoom behaviour. Default: false.
       * @property {?Object} userData - Arbitrary subscriber-defined object.
       */
      this.raiseEvent( 'canvas-click', canvasClickEventArgs);
  
      if ( !canvasClickEventArgs.preventDefaultAction && this.viewport && event.quick ) {
          gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );
          if ( gestureSettings.clickToZoom ) {
              this.viewport.zoomBy(
                  event.shift ? 1.0 / this.zoomPerClick : this.zoomPerClick,
                  gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel( event.position, true ) : null
              );
              this.viewport.applyConstraints();
          }
      }
  }
  
  function onCanvasDblClick( event ) {
      var gestureSettings;
  
      var canvasDblClickEventArgs = {
          tracker: event.eventSource,
          position: event.position,
          shift: event.shift,
          originalEvent: event.originalEvent,
          preventDefaultAction: event.preventDefaultAction
      };
  
      /**
       * Raised when a double mouse press/release or touch/remove occurs on the {@link OpenSeadragon.Viewer#canvas} element.
       *
       * @event canvas-double-click
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
       * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
       * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
       * @property {Boolean} shift - True if the shift key was pressed during this event.
       * @property {Object} originalEvent - The original DOM event.
       * @property {Boolean} preventDefaultAction - Set to true to prevent default double tap to zoom behaviour. Default: false.
       * @property {?Object} userData - Arbitrary subscriber-defined object.
       */
      this.raiseEvent( 'canvas-double-click', canvasDblClickEventArgs);
  
      if ( !canvasDblClickEventArgs.preventDefaultAction && this.viewport ) {
          gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );
          if ( gestureSettings.dblClickToZoom ) {
              this.viewport.zoomBy(
                  event.shift ? 1.0 / this.zoomPerClick : this.zoomPerClick,
                  gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel( event.position, true ) : null
              );
              this.viewport.applyConstraints();
          }
      }
  }
  
  function onCanvasDrag( event ) {
      var gestureSettings;
  
      var canvasDragEventArgs = {
          tracker: event.eventSource,
          position: event.position,
          delta: event.delta,
          speed: event.speed,
          direction: event.direction,
          shift: event.shift,
          originalEvent: event.originalEvent,
          preventDefaultAction: event.preventDefaultAction
      };
  
      /**
       * Raised when a mouse or touch drag operation occurs on the {@link OpenSeadragon.Viewer#canvas} element.
       *
       * @event canvas-drag
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
       * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
       * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
       * @property {OpenSeadragon.Point} delta - The x,y components of the difference between start drag and end drag.
       * @property {Number} speed - Current computed speed, in pixels per second.
       * @property {Number} direction - Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
       * @property {Boolean} shift - True if the shift key was pressed during this event.
       * @property {Object} originalEvent - The original DOM event.
       * @property {Boolean} preventDefaultAction - Set to true to prevent default drag behaviour. Default: false.
       * @property {?Object} userData - Arbitrary subscriber-defined object.
       */
      this.raiseEvent( 'canvas-drag', canvasDragEventArgs);
  
      if ( !canvasDragEventArgs.preventDefaultAction && this.viewport ) {
          gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );
          if( !this.panHorizontal ){
              event.delta.x = 0;
          }
          if( !this.panVertical ){
              event.delta.y = 0;
          }
          if(this.viewport.flipped){
              event.delta.x = -event.delta.x;
          }
  
          if( this.constrainDuringPan ){
              var delta = this.viewport.deltaPointsFromPixels( event.delta.negate() );
  
              this.viewport.centerSpringX.target.value += delta.x;
              this.viewport.centerSpringY.target.value += delta.y;
  
              var bounds = this.viewport.getBounds();
              var constrainedBounds = this.viewport.getConstrainedBounds();
  
              this.viewport.centerSpringX.target.value -= delta.x;
              this.viewport.centerSpringY.target.value -= delta.y;
  
              if (bounds.x != constrainedBounds.x) {
                  event.delta.x = 0;
              }
  
              if (bounds.y != constrainedBounds.y) {
                  event.delta.y = 0;
              }
          }
  
          this.viewport.panBy( this.viewport.deltaPointsFromPixels( event.delta.negate() ), gestureSettings.flickEnabled && !this.constrainDuringPan);
      }
  }
  
  function onCanvasDragEnd( event ) {
      if (!event.preventDefaultAction && this.viewport) {
          var gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
          if (gestureSettings.flickEnabled &&
              event.speed >= gestureSettings.flickMinSpeed) {
              var amplitudeX = 0;
              if (this.panHorizontal) {
                  amplitudeX = gestureSettings.flickMomentum * event.speed *
                      Math.cos(event.direction);
              }
              var amplitudeY = 0;
              if (this.panVertical) {
                  amplitudeY = gestureSettings.flickMomentum * event.speed *
                      Math.sin(event.direction);
              }
              var center = this.viewport.pixelFromPoint(
                  this.viewport.getCenter(true));
              var target = this.viewport.pointFromPixel(
                  new $.Point(center.x - amplitudeX, center.y - amplitudeY));
              this.viewport.panTo(target, false);
          }
          this.viewport.applyConstraints();
      }
      /**
       * Raised when a mouse or touch drag operation ends on the {@link OpenSeadragon.Viewer#canvas} element.
       *
       * @event canvas-drag-end
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
       * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
       * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
       * @property {Number} speed - Speed at the end of a drag gesture, in pixels per second.
       * @property {Number} direction - Direction at the end of a drag gesture, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
       * @property {Boolean} shift - True if the shift key was pressed during this event.
       * @property {Object} originalEvent - The original DOM event.
       * @property {?Object} userData - Arbitrary subscriber-defined object.
       */
      this.raiseEvent('canvas-drag-end', {
          tracker: event.eventSource,
          position: event.position,
          speed: event.speed,
          direction: event.direction,
          shift: event.shift,
          originalEvent: event.originalEvent
      });
  }
  
  function onCanvasEnter( event ) {
      /**
       * Raised when a pointer enters the {@link OpenSeadragon.Viewer#canvas} element.
       *
       * @event canvas-enter
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
       * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
       * @property {String} pointerType - "mouse", "touch", "pen", etc.
       * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
       * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @property {Number} pointers - Number of pointers (all types) active in the tracked element.
       * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
       * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
       * @property {Object} originalEvent - The original DOM event.
       * @property {?Object} userData - Arbitrary subscriber-defined object.
       */
      this.raiseEvent( 'canvas-enter', {
          tracker: event.eventSource,
          pointerType: event.pointerType,
          position: event.position,
          buttons: event.buttons,
          pointers: event.pointers,
          insideElementPressed: event.insideElementPressed,
          buttonDownAny: event.buttonDownAny,
          originalEvent: event.originalEvent
      });
  }
  
  function onCanvasExit( event ) {
  
      if (window.location != window.parent.location){
          $.MouseTracker.resetAllMouseTrackers();
      }
  
      /**
       * Raised when a pointer leaves the {@link OpenSeadragon.Viewer#canvas} element.
       *
       * @event canvas-exit
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
       * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
       * @property {String} pointerType - "mouse", "touch", "pen", etc.
       * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
       * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @property {Number} pointers - Number of pointers (all types) active in the tracked element.
       * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
       * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
       * @property {Object} originalEvent - The original DOM event.
       * @property {?Object} userData - Arbitrary subscriber-defined object.
       */
      this.raiseEvent( 'canvas-exit', {
          tracker: event.eventSource,
          pointerType: event.pointerType,
          position: event.position,
          buttons: event.buttons,
          pointers: event.pointers,
          insideElementPressed: event.insideElementPressed,
          buttonDownAny: event.buttonDownAny,
          originalEvent: event.originalEvent
      });
  }
  
  function onCanvasPress( event ) {
      /**
       * Raised when the primary mouse button is pressed or touch starts on the {@link OpenSeadragon.Viewer#canvas} element.
       *
       * @event canvas-press
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
       * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
       * @property {String} pointerType - "mouse", "touch", "pen", etc.
       * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
       * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
       * @property {Boolean} insideElementReleased - True if the cursor still inside the tracked element when the button was released.
       * @property {Object} originalEvent - The original DOM event.
       * @property {?Object} userData - Arbitrary subscriber-defined object.
       */
      this.raiseEvent( 'canvas-press', {
          tracker: event.eventSource,
          pointerType: event.pointerType,
          position: event.position,
          insideElementPressed: event.insideElementPressed,
          insideElementReleased: event.insideElementReleased,
          originalEvent: event.originalEvent
      });
  }
  
  function onCanvasRelease( event ) {
      /**
       * Raised when the primary mouse button is released or touch ends on the {@link OpenSeadragon.Viewer#canvas} element.
       *
       * @event canvas-release
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
       * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
       * @property {String} pointerType - "mouse", "touch", "pen", etc.
       * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
       * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
       * @property {Boolean} insideElementReleased - True if the cursor still inside the tracked element when the button was released.
       * @property {Object} originalEvent - The original DOM event.
       * @property {?Object} userData - Arbitrary subscriber-defined object.
       */
      this.raiseEvent( 'canvas-release', {
          tracker: event.eventSource,
          pointerType: event.pointerType,
          position: event.position,
          insideElementPressed: event.insideElementPressed,
          insideElementReleased: event.insideElementReleased,
          originalEvent: event.originalEvent
      });
  }
  
  function onCanvasNonPrimaryPress( event ) {
      /**
       * Raised when any non-primary pointer button is pressed on the {@link OpenSeadragon.Viewer#canvas} element.
       *
       * @event canvas-nonprimary-press
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
       * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
       * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
       * @property {String} pointerType - "mouse", "touch", "pen", etc.
       * @property {Number} button - Button which caused the event.
       *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
       * @property {Number} buttons - Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @property {Object} originalEvent - The original DOM event.
       * @property {?Object} userData - Arbitrary subscriber-defined object.
       */
      this.raiseEvent( 'canvas-nonprimary-press', {
          tracker: event.eventSource,
          position: event.position,
          pointerType: event.pointerType,
          button: event.button,
          buttons: event.buttons,
          originalEvent: event.originalEvent
      });
  }
  
  function onCanvasNonPrimaryRelease( event ) {
      /**
       * Raised when any non-primary pointer button is released on the {@link OpenSeadragon.Viewer#canvas} element.
       *
       * @event canvas-nonprimary-release
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
       * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
       * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
       * @property {String} pointerType - "mouse", "touch", "pen", etc.
       * @property {Number} button - Button which caused the event.
       *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
       * @property {Number} buttons - Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @property {Object} originalEvent - The original DOM event.
       * @property {?Object} userData - Arbitrary subscriber-defined object.
       */
      this.raiseEvent( 'canvas-nonprimary-release', {
          tracker: event.eventSource,
          position: event.position,
          pointerType: event.pointerType,
          button: event.button,
          buttons: event.buttons,
          originalEvent: event.originalEvent
      });
  }
  
  function onCanvasPinch( event ) {
      var gestureSettings,
          centerPt,
          lastCenterPt,
          panByPt;
  
      if ( !event.preventDefaultAction && this.viewport ) {
          gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );
          if ( gestureSettings.pinchToZoom ) {
              centerPt = this.viewport.pointFromPixel( event.center, true );
              lastCenterPt = this.viewport.pointFromPixel( event.lastCenter, true );
              panByPt = lastCenterPt.minus( centerPt );
              if( !this.panHorizontal ) {
                  panByPt.x = 0;
              }
              if( !this.panVertical ) {
                  panByPt.y = 0;
              }
              this.viewport.zoomBy( event.distance / event.lastDistance, centerPt, true );
              if ( gestureSettings.zoomToRefPoint ) {
                  this.viewport.panBy(panByPt, true);
              }
              this.viewport.applyConstraints();
          }
          if ( gestureSettings.pinchRotate ) {
              // Pinch rotate
              var angle1 = Math.atan2(event.gesturePoints[0].currentPos.y - event.gesturePoints[1].currentPos.y,
                  event.gesturePoints[0].currentPos.x - event.gesturePoints[1].currentPos.x);
              var angle2 = Math.atan2(event.gesturePoints[0].lastPos.y - event.gesturePoints[1].lastPos.y,
                  event.gesturePoints[0].lastPos.x - event.gesturePoints[1].lastPos.x);
              this.viewport.setRotation(this.viewport.getRotation() + ((angle1 - angle2) * (180 / Math.PI)));
          }
      }
      /**
       * Raised when a pinch event occurs on the {@link OpenSeadragon.Viewer#canvas} element.
       *
       * @event canvas-pinch
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
       * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
       * @property {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gesturePoints - Gesture points associated with the gesture. Velocity data can be found here.
       * @property {OpenSeadragon.Point} lastCenter - The previous center point of the two pinch contact points relative to the tracked element.
       * @property {OpenSeadragon.Point} center - The center point of the two pinch contact points relative to the tracked element.
       * @property {Number} lastDistance - The previous distance between the two pinch contact points in CSS pixels.
       * @property {Number} distance - The distance between the two pinch contact points in CSS pixels.
       * @property {Boolean} shift - True if the shift key was pressed during this event.
       * @property {Object} originalEvent - The original DOM event.
       * @property {?Object} userData - Arbitrary subscriber-defined object.
       */
      this.raiseEvent('canvas-pinch', {
          tracker: event.eventSource,
          gesturePoints: event.gesturePoints,
          lastCenter: event.lastCenter,
          center: event.center,
          lastDistance: event.lastDistance,
          distance: event.distance,
          shift: event.shift,
          originalEvent: event.originalEvent
      });
      //cancels event
      return false;
  }
  
  function onCanvasScroll( event ) {
      var gestureSettings,
          factor,
          thisScrollTime,
          deltaScrollTime;
  
      /* Certain scroll devices fire the scroll event way too fast so we are injecting a simple adjustment to keep things
       * partially normalized. If we have already fired an event within the last 'minScrollDelta' milliseconds we skip
       * this one and wait for the next event. */
      thisScrollTime = $.now();
      deltaScrollTime = thisScrollTime - this._lastScrollTime;
      if (deltaScrollTime > this.minScrollDeltaTime) {
          this._lastScrollTime = thisScrollTime;
  
          if(this.viewport.flipped){
            event.position.x = this.viewport.getContainerSize().x - event.position.x;
          }
  
          if ( !event.preventDefaultAction && this.viewport ) {
              gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );
              if ( gestureSettings.scrollToZoom ) {
                  factor = Math.pow( this.zoomPerScroll, event.scroll );
                  this.viewport.zoomBy(
                      factor,
                      gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel( event.position, true ) : null
                  );
                  this.viewport.applyConstraints();
              }
          }
          /**
           * Raised when a scroll event occurs on the {@link OpenSeadragon.Viewer#canvas} element (mouse wheel).
           *
           * @event canvas-scroll
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
           * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
           * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
           * @property {Number} scroll - The scroll delta for the event.
           * @property {Boolean} shift - True if the shift key was pressed during this event.
           * @property {Object} originalEvent - The original DOM event.
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent( 'canvas-scroll', {
              tracker: event.eventSource,
              position: event.position,
              scroll: event.scroll,
              shift: event.shift,
              originalEvent: event.originalEvent
          });
          if (gestureSettings && gestureSettings.scrollToZoom) {
              //cancels event
              return false;
          }
      }
      else {
          gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );
          if (gestureSettings && gestureSettings.scrollToZoom) {
              return false;   // We are swallowing this event
          }
      }
  }
  
  function onContainerEnter( event ) {
      THIS[ this.hash ].mouseInside = true;
      abortControlsAutoHide( this );
      /**
       * Raised when the cursor enters the {@link OpenSeadragon.Viewer#container} element.
       *
       * @event container-enter
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
       * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
       * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
       * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @property {Number} pointers - Number of pointers (all types) active in the tracked element.
       * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
       * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
       * @property {Object} originalEvent - The original DOM event.
       * @property {?Object} userData - Arbitrary subscriber-defined object.
       */
      this.raiseEvent( 'container-enter', {
          tracker: event.eventSource,
          position: event.position,
          buttons: event.buttons,
          pointers: event.pointers,
          insideElementPressed: event.insideElementPressed,
          buttonDownAny: event.buttonDownAny,
          originalEvent: event.originalEvent
      });
  }
  
  function onContainerExit( event ) {
      if ( event.pointers < 1 ) {
          THIS[ this.hash ].mouseInside = false;
          if ( !THIS[ this.hash ].animating ) {
              beginControlsAutoHide( this );
          }
      }
      /**
       * Raised when the cursor leaves the {@link OpenSeadragon.Viewer#container} element.
       *
       * @event container-exit
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
       * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
       * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
       * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @property {Number} pointers - Number of pointers (all types) active in the tracked element.
       * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
       * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
       * @property {Object} originalEvent - The original DOM event.
       * @property {?Object} userData - Arbitrary subscriber-defined object.
       */
      this.raiseEvent( 'container-exit', {
          tracker: event.eventSource,
          position: event.position,
          buttons: event.buttons,
          pointers: event.pointers,
          insideElementPressed: event.insideElementPressed,
          buttonDownAny: event.buttonDownAny,
          originalEvent: event.originalEvent
      });
  }
  
  
  ///////////////////////////////////////////////////////////////////////////////
  // Page update routines ( aka Views - for future reference )
  ///////////////////////////////////////////////////////////////////////////////
  
  function updateMulti( viewer ) {
      updateOnce( viewer );
  
      // Request the next frame, unless we've been closed
      if ( viewer.isOpen() ) {
          viewer._updateRequestId = scheduleUpdate( viewer, updateMulti );
      } else {
          viewer._updateRequestId = false;
      }
  }
  
  function updateOnce( viewer ) {
  
      //viewer.profiler.beginUpdate();
  
      if (viewer._opening) {
          return;
      }
  
      if (viewer.autoResize) {
          var containerSize = _getSafeElemSize(viewer.container);
          var prevContainerSize = THIS[viewer.hash].prevContainerSize;
          if (!containerSize.equals(prevContainerSize)) {
              var viewport = viewer.viewport;
              if (viewer.preserveImageSizeOnResize) {
                  var resizeRatio = prevContainerSize.x / containerSize.x;
                  var zoom = viewport.getZoom() * resizeRatio;
                  var center = viewport.getCenter();
                  viewport.resize(containerSize, false);
                  viewport.zoomTo(zoom, null, true);
                  viewport.panTo(center, true);
              } else {
                  // maintain image position
                  var oldBounds = viewport.getBounds();
                  viewport.resize(containerSize, true);
                  viewport.fitBoundsWithConstraints(oldBounds, true);
              }
              THIS[viewer.hash].prevContainerSize = containerSize;
              THIS[viewer.hash].forceRedraw = true;
          }
      }
  
      var viewportChange = viewer.viewport.update();
      var animated = viewer.world.update() || viewportChange;
  
      if (viewportChange) {
          /**
           * Raised when any spring animation update occurs (zoom, pan, etc.),
           * before the viewer has drawn the new location.
           *
           * @event viewport-change
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          viewer.raiseEvent('viewport-change');
      }
  
      if( viewer.referenceStrip ){
          animated = viewer.referenceStrip.update( viewer.viewport ) || animated;
      }
  
      if ( !THIS[ viewer.hash ].animating && animated ) {
          /**
           * Raised when any spring animation starts (zoom, pan, etc.).
           *
           * @event animation-start
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          viewer.raiseEvent( "animation-start" );
          abortControlsAutoHide( viewer );
      }
  
      if ( animated || THIS[ viewer.hash ].forceRedraw || viewer.world.needsDraw() ) {
          drawWorld( viewer );
          viewer._drawOverlays();
          if( viewer.navigator ){
            viewer.navigator.update( viewer.viewport );
          }
  
          THIS[ viewer.hash ].forceRedraw = false;
  
          if (animated) {
              /**
               * Raised when any spring animation update occurs (zoom, pan, etc.),
               * after the viewer has drawn the new location.
               *
               * @event animation
               * @memberof OpenSeadragon.Viewer
               * @type {object}
               * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
               * @property {?Object} userData - Arbitrary subscriber-defined object.
               */
              viewer.raiseEvent( "animation" );
          }
      }
  
      if ( THIS[ viewer.hash ].animating && !animated ) {
          /**
           * Raised when any spring animation ends (zoom, pan, etc.).
           *
           * @event animation-finish
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          viewer.raiseEvent( "animation-finish" );
  
          if ( !THIS[ viewer.hash ].mouseInside ) {
              beginControlsAutoHide( viewer );
          }
      }
  
      THIS[ viewer.hash ].animating = animated;
  
      //viewer.profiler.endUpdate();
  }
  
  function drawWorld( viewer ) {
      viewer.imageLoader.clear();
      viewer.drawer.clear();
      viewer.world.draw();
  
      /**
       * <em>- Needs documentation -</em>
       *
       * @event update-viewport
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
       * @property {?Object} userData - Arbitrary subscriber-defined object.
       */
      viewer.raiseEvent( 'update-viewport', {} );
  }
  
  ///////////////////////////////////////////////////////////////////////////////
  // Navigation Controls
  ///////////////////////////////////////////////////////////////////////////////
  function resolveUrl( prefix, url ) {
      return prefix ? prefix + url : url;
  }
  
  
  
  function beginZoomingIn() {
      THIS[ this.hash ].lastZoomTime = $.now();
      THIS[ this.hash ].zoomFactor = this.zoomPerSecond;
      THIS[ this.hash ].zooming = true;
      scheduleZoom( this );
  }
  
  
  function beginZoomingOut() {
      THIS[ this.hash ].lastZoomTime = $.now();
      THIS[ this.hash ].zoomFactor = 1.0 / this.zoomPerSecond;
      THIS[ this.hash ].zooming = true;
      scheduleZoom( this );
  }
  
  
  function endZooming() {
      THIS[ this.hash ].zooming = false;
  }
  
  
  function scheduleZoom( viewer ) {
      $.requestAnimationFrame( $.delegate( viewer, doZoom ) );
  }
  
  
  function doZoom() {
      var currentTime,
          deltaTime,
          adjustedFactor;
  
      if ( THIS[ this.hash ].zooming && this.viewport) {
          currentTime     = $.now();
          deltaTime       = currentTime - THIS[ this.hash ].lastZoomTime;
          adjustedFactor  = Math.pow( THIS[ this.hash ].zoomFactor, deltaTime / 1000 );
  
          this.viewport.zoomBy( adjustedFactor );
          this.viewport.applyConstraints();
          THIS[ this.hash ].lastZoomTime = currentTime;
          scheduleZoom( this );
      }
  }
  
  
  function doSingleZoomIn() {
      if ( this.viewport ) {
          THIS[ this.hash ].zooming = false;
          this.viewport.zoomBy(
              this.zoomPerClick / 1.0
          );
          this.viewport.applyConstraints();
      }
  }
  
  
  function doSingleZoomOut() {
      if ( this.viewport ) {
          THIS[ this.hash ].zooming = false;
          this.viewport.zoomBy(
              1.0 / this.zoomPerClick
          );
          this.viewport.applyConstraints();
      }
  }
  
  
  function lightUp() {
      this.buttons.emulateEnter();
      this.buttons.emulateExit();
  }
  
  
  function onHome() {
      if ( this.viewport ) {
          this.viewport.goHome();
      }
  }
  
  
  function onFullScreen() {
      if ( this.isFullPage() && !$.isFullScreen() ) {
          // Is fullPage but not fullScreen
          this.setFullPage( false );
      } else {
          this.setFullScreen( !this.isFullPage() );
      }
      // correct for no mouseout event on change
      if ( this.buttons ) {
          this.buttons.emulateExit();
      }
      this.fullPageButton.element.focus();
      if ( this.viewport ) {
          this.viewport.applyConstraints();
      }
  }
  
  function onRotateLeft() {
      if ( this.viewport ) {
          var currRotation = this.viewport.getRotation();
  
          if ( this.viewport.flipped ){
            currRotation = $.positiveModulo(currRotation + this.rotationIncrement, 360);
          } else {
            currRotation = $.positiveModulo(currRotation - this.rotationIncrement, 360);
          }
          this.viewport.setRotation(currRotation);
      }
  }
  
  function onRotateRight() {
      if ( this.viewport ) {
          var currRotation = this.viewport.getRotation();
  
          if ( this.viewport.flipped ){
            currRotation = $.positiveModulo(currRotation - this.rotationIncrement, 360);
          } else {
            currRotation = $.positiveModulo(currRotation + this.rotationIncrement, 360);
          }
          this.viewport.setRotation(currRotation);
      }
  }
  /**
   * Note: When pressed flip control button
   */
  function onFlip() {
     this.viewport.toggleFlip();
  }
  
  function onPrevious(){
      var previous = this._sequenceIndex - 1;
      if(this.navPrevNextWrap && previous < 0){
          previous += this.tileSources.length;
      }
      this.goToPage( previous );
  }
  
  
  function onNext(){
      var next = this._sequenceIndex + 1;
      if(this.navPrevNextWrap && next >= this.tileSources.length){
          next = 0;
      }
      this.goToPage( next );
  }
  
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - Navigator
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  /**
   * @class Navigator
   * @classdesc The Navigator provides a small view of the current image as fixed
   * while representing the viewport as a moving box serving as a frame
   * of reference in the larger viewport as to which portion of the image
   * is currently being examined.  The navigator's viewport can be interacted
   * with using the keyboard or the mouse.
   *
   * @memberof OpenSeadragon
   * @extends OpenSeadragon.Viewer
   * @extends OpenSeadragon.EventSource
   * @param {Object} options
   */
  $.Navigator = function( options ){
  
      var viewer      = options.viewer,
          _this = this,
          viewerSize,
          navigatorSize;
  
      //We may need to create a new element and id if they did not
      //provide the id for the existing element
      if( !options.id ){
          options.id              = 'navigator-' + $.now();
          this.element            = $.makeNeutralElement( "div" );
          options.controlOptions  = {
              anchor:           $.ControlAnchor.TOP_RIGHT,
              attachToViewer:   true,
              autoFade:         options.autoFade
          };
  
          if( options.position ){
              if( 'BOTTOM_RIGHT' == options.position ){
                 options.controlOptions.anchor = $.ControlAnchor.BOTTOM_RIGHT;
              } else if( 'BOTTOM_LEFT' == options.position ){
                 options.controlOptions.anchor = $.ControlAnchor.BOTTOM_LEFT;
              } else if( 'TOP_RIGHT' == options.position ){
                 options.controlOptions.anchor = $.ControlAnchor.TOP_RIGHT;
              } else if( 'TOP_LEFT' == options.position ){
                 options.controlOptions.anchor = $.ControlAnchor.TOP_LEFT;
              } else if( 'ABSOLUTE' == options.position ){
                 options.controlOptions.anchor = $.ControlAnchor.ABSOLUTE;
                 options.controlOptions.top = options.top;
                 options.controlOptions.left = options.left;
                 options.controlOptions.height = options.height;
                 options.controlOptions.width = options.width;
              }
          }
  
      } else {
          this.element            = document.getElementById( options.id );
          options.controlOptions  = {
              anchor:           $.ControlAnchor.NONE,
              attachToViewer:   false,
              autoFade:         false
          };
      }
      this.element.id         = options.id;
      this.element.className  += ' navigator';
  
      options = $.extend( true, {
          sizeRatio:     $.DEFAULT_SETTINGS.navigatorSizeRatio
      }, options, {
          element:                this.element,
          tabIndex:               -1, // No keyboard navigation, omit from tab order
          //These need to be overridden to prevent recursion since
          //the navigator is a viewer and a viewer has a navigator
          showNavigator:          false,
          mouseNavEnabled:        false,
          showNavigationControl:  false,
          showSequenceControl:    false,
          immediateRender:        true,
          blendTime:              0,
          animationTime:          0,
          autoResize:             options.autoResize,
          // prevent resizing the navigator from adding unwanted space around the image
          minZoomImageRatio:      1.0,
          background:             options.background,
          opacity:                options.opacity,
          borderColor:            options.borderColor,
          displayRegionColor:     options.displayRegionColor
      });
  
      options.minPixelRatio = this.minPixelRatio = viewer.minPixelRatio;
  
      $.setElementTouchActionNone( this.element );
  
      this.borderWidth = 2;
      //At some browser magnification levels the display regions lines up correctly, but at some there appears to
      //be a one pixel gap.
      this.fudge = new $.Point(1, 1);
      this.totalBorderWidths = new $.Point(this.borderWidth * 2, this.borderWidth * 2).minus(this.fudge);
  
  
      if ( options.controlOptions.anchor != $.ControlAnchor.NONE ) {
          (function( style, borderWidth ){
              style.margin        = '0px';
              style.border        = borderWidth + 'px solid ' + options.borderColor;
              style.padding       = '0px';
              style.background    = options.background;
              style.opacity       = options.opacity;
              style.overflow      = 'hidden';
          }( this.element.style, this.borderWidth));
      }
  
      this.displayRegion           = $.makeNeutralElement( "div" );
      this.displayRegion.id        = this.element.id + '-displayregion';
      this.displayRegion.className = 'displayregion';
  
      (function( style, borderWidth ){
          style.position      = 'relative';
          style.top           = '0px';
          style.left          = '0px';
          style.fontSize      = '0px';
          style.overflow      = 'hidden';
          style.border        = borderWidth + 'px solid ' + options.displayRegionColor;
          style.margin        = '0px';
          style.padding       = '0px';
          //TODO: IE doesn't like this property being set
          //try{ style.outline  = '2px auto #909'; }catch(e){/*ignore*/}
  
          style.background    = 'transparent';
  
          // We use square bracket notation on the statement below, because float is a keyword.
          // This is important for the Google Closure compiler, if nothing else.
          /*jshint sub:true */
          style['float']      = 'left'; //Webkit
  
          style.cssFloat      = 'left'; //Firefox
          style.styleFloat    = 'left'; //IE
          style.zIndex        = 999999999;
          style.cursor        = 'default';
      }( this.displayRegion.style, this.borderWidth ));
  
      this.displayRegionContainer = $.makeNeutralElement("div");
      this.displayRegionContainer.id = this.element.id + '-displayregioncontainer';
      this.displayRegionContainer.className = "displayregioncontainer";
      this.displayRegionContainer.style.width = "100%";
      this.displayRegionContainer.style.height = "100%";
  
      viewer.addControl(
          this.element,
          options.controlOptions
      );
  
      this._resizeWithViewer = options.controlOptions.anchor != $.ControlAnchor.ABSOLUTE &&
          options.controlOptions.anchor != $.ControlAnchor.NONE;
  
      if (options.width && options.height) {
          this.setWidth(options.width);
          this.setHeight(options.height);
      } else if ( this._resizeWithViewer ) {
          viewerSize = $.getElementSize( viewer.element );
          this.element.style.height = Math.round( viewerSize.y * options.sizeRatio ) + 'px';
          this.element.style.width  = Math.round( viewerSize.x * options.sizeRatio ) + 'px';
          this.oldViewerSize = viewerSize;
          navigatorSize = $.getElementSize( this.element );
          this.elementArea = navigatorSize.x * navigatorSize.y;
      }
  
      this.oldContainerSize = new $.Point( 0, 0 );
  
      $.Viewer.apply( this, [ options ] );
  
      this.displayRegionContainer.appendChild(this.displayRegion);
      this.element.getElementsByTagName('div')[0].appendChild(this.displayRegionContainer);
  
      function rotate(degrees) {
          _setTransformRotate(_this.displayRegionContainer, degrees);
          _setTransformRotate(_this.displayRegion, -degrees);
          _this.viewport.setRotation(degrees);
      }
      if (options.navigatorRotate) {
          var degrees = options.viewer.viewport ?
              options.viewer.viewport.getRotation() :
              options.viewer.degrees || 0;
  
          rotate(degrees);
          options.viewer.addHandler("rotate", function (args) {
              rotate(args.degrees);
          });
      }
  
  
      // Remove the base class' (Viewer's) innerTracker and replace it with our own
      this.innerTracker.destroy();
      this.innerTracker = new $.MouseTracker({
          element:         this.element,
          dragHandler:     $.delegate( this, onCanvasDrag ),
          clickHandler:    $.delegate( this, onCanvasClick ),
          releaseHandler:  $.delegate( this, onCanvasRelease ),
          scrollHandler:   $.delegate( this, onCanvasScroll )
      });
  
      this.addHandler("reset-size", function() {
          if (_this.viewport) {
              _this.viewport.goHome(true);
          }
      });
  
      viewer.world.addHandler("item-index-change", function(event) {
          window.setTimeout(function(){
              var item = _this.world.getItemAt(event.previousIndex);
              _this.world.setItemIndex(item, event.newIndex);
          }, 1);
      });
  
      viewer.world.addHandler("remove-item", function(event) {
          var theirItem = event.item;
          var myItem = _this._getMatchingItem(theirItem);
          if (myItem) {
              _this.world.removeItem(myItem);
          }
      });
  
      this.update(viewer.viewport);
  };
  
  $.extend( $.Navigator.prototype, $.EventSource.prototype, $.Viewer.prototype, /** @lends OpenSeadragon.Navigator.prototype */{
  
      /**
       * Used to notify the navigator when its size has changed.
       * Especially useful when {@link OpenSeadragon.Options}.navigatorAutoResize is set to false and the navigator is resizable.
       * @function
       */
      updateSize: function () {
          if ( this.viewport ) {
              var containerSize = new $.Point(
                      (this.container.clientWidth === 0 ? 1 : this.container.clientWidth),
                      (this.container.clientHeight === 0 ? 1 : this.container.clientHeight)
                  );
  
              if ( !containerSize.equals( this.oldContainerSize ) ) {
                  this.viewport.resize( containerSize, true );
                  this.viewport.goHome(true);
                  this.oldContainerSize = containerSize;
                  this.drawer.clear();
                  this.world.draw();
              }
          }
      },
  
      /**
       * Explicitly sets the width of the navigator, in web coordinates. Disables automatic resizing.
       * @param {Number|String} width - the new width, either a number of pixels or a CSS string, such as "100%"
       */
      setWidth: function(width) {
          this.width = width;
          this.element.style.width = typeof (width) == "number" ? (width + 'px') : width;
          this._resizeWithViewer = false;
      },
  
      /**
       * Explicitly sets the height of the navigator, in web coordinates. Disables automatic resizing.
       * @param {Number|String} height - the new height, either a number of pixels or a CSS string, such as "100%"
       */
      setHeight: function(height) {
          this.height = height;
          this.element.style.height = typeof (height) == "number" ? (height + 'px') : height;
          this._resizeWithViewer = false;
      },
  
      /**
        * Flip navigator element
        * @param {Boolean} state - Flip state to set.
        */
      setFlip: function(state) {
        this.viewport.setFlip(state);
  
        this.setDisplayTransform(this.viewer.viewport.getFlip() ? "scale(-1,1)" : "scale(1,1)");
        return this;
      },
  
      setDisplayTransform: function(rule) {
        setElementTransform(this.displayRegion, rule);
        setElementTransform(this.canvas, rule);
        setElementTransform(this.element, rule);
      },
  
      /**
       * Used to update the navigator minimap's viewport rectangle when a change in the viewer's viewport occurs.
       * @function
       * @param {OpenSeadragon.Viewport} The viewport this navigator is tracking.
       */
      update: function( viewport ) {
  
          var viewerSize,
              newWidth,
              newHeight,
              bounds,
              topleft,
              bottomright;
  
          viewerSize = $.getElementSize( this.viewer.element );
          if ( this._resizeWithViewer && viewerSize.x && viewerSize.y && !viewerSize.equals( this.oldViewerSize ) ) {
              this.oldViewerSize = viewerSize;
  
              if ( this.maintainSizeRatio || !this.elementArea) {
                  newWidth  = viewerSize.x * this.sizeRatio;
                  newHeight = viewerSize.y * this.sizeRatio;
              } else {
                  newWidth = Math.sqrt(this.elementArea * (viewerSize.x / viewerSize.y));
                  newHeight = this.elementArea / newWidth;
              }
  
              this.element.style.width  = Math.round( newWidth ) + 'px';
              this.element.style.height = Math.round( newHeight ) + 'px';
  
              if (!this.elementArea) {
                  this.elementArea = newWidth * newHeight;
              }
  
              this.updateSize();
          }
  
          if (viewport && this.viewport) {
              bounds      = viewport.getBoundsNoRotate(true);
              topleft     = this.viewport.pixelFromPointNoRotate(bounds.getTopLeft(), false);
              bottomright = this.viewport.pixelFromPointNoRotate(bounds.getBottomRight(), false)
                  .minus( this.totalBorderWidths );
  
              //update style for navigator-box
              var style = this.displayRegion.style;
              style.display = this.world.getItemCount() ? 'block' : 'none';
  
              style.top    = Math.round( topleft.y ) + 'px';
              style.left   = Math.round( topleft.x ) + 'px';
  
              var width = Math.abs( topleft.x - bottomright.x );
              var height = Math.abs( topleft.y - bottomright.y );
              // make sure width and height are non-negative so IE doesn't throw
              style.width  = Math.round( Math.max( width, 0 ) ) + 'px';
              style.height = Math.round( Math.max( height, 0 ) ) + 'px';
          }
  
      },
  
      // overrides Viewer.addTiledImage
      addTiledImage: function(options) {
          var _this = this;
  
          var original = options.originalTiledImage;
          delete options.original;
  
          var optionsClone = $.extend({}, options, {
              success: function(event) {
                  var myItem = event.item;
                  myItem._originalForNavigator = original;
                  _this._matchBounds(myItem, original, true);
  
                  function matchBounds() {
                      _this._matchBounds(myItem, original);
                  }
  
                  function matchOpacity() {
                      _this._matchOpacity(myItem, original);
                  }
  
                  function matchCompositeOperation() {
                      _this._matchCompositeOperation(myItem, original);
                  }
  
                  original.addHandler('bounds-change', matchBounds);
                  original.addHandler('clip-change', matchBounds);
                  original.addHandler('opacity-change', matchOpacity);
                  original.addHandler('composite-operation-change', matchCompositeOperation);
              }
          });
  
          return $.Viewer.prototype.addTiledImage.apply(this, [optionsClone]);
      },
  
      // private
      _getMatchingItem: function(theirItem) {
          var count = this.world.getItemCount();
          var item;
          for (var i = 0; i < count; i++) {
              item = this.world.getItemAt(i);
              if (item._originalForNavigator === theirItem) {
                  return item;
              }
          }
  
          return null;
      },
  
      // private
      _matchBounds: function(myItem, theirItem, immediately) {
          var bounds = theirItem.getBoundsNoRotate();
          myItem.setPosition(bounds.getTopLeft(), immediately);
          myItem.setWidth(bounds.width, immediately);
          myItem.setRotation(theirItem.getRotation(), immediately);
          myItem.setClip(theirItem.getClip());
      },
  
      // private
      _matchOpacity: function(myItem, theirItem) {
          myItem.setOpacity(theirItem.opacity);
      },
  
      // private
      _matchCompositeOperation: function(myItem, theirItem) {
          myItem.setCompositeOperation(theirItem.compositeOperation);
      }
  });
  
  
  /**
   * @private
   * @inner
   * @function
   */
  function onCanvasClick( event ) {
    var canvasClickEventArgs = {
      tracker: event.eventSource,
      position: event.position,
      quick: event.quick,
      shift: event.shift,
      originalEvent: event.originalEvent,
      preventDefaultAction: event.preventDefaultAction
    };
    /**
     * Raised when a click event occurs on the {@link OpenSeadragon.Viewer#navigator} element.
     *
     * @event navigator-click
     * @memberof OpenSeadragon.Viewer
     * @type {object}
     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
     * @property {Boolean} quick - True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for differentiating between clicks and drags.
     * @property {Boolean} shift - True if the shift key was pressed during this event.
     * @property {Object} originalEvent - The original DOM event.
     * @property {?Object} userData - Arbitrary subscriber-defined object.
     * @property {Boolean} preventDefaultAction - Set to true to prevent default click to zoom behaviour. Default: false.
     */
  
     this.viewer.raiseEvent('navigator-click', canvasClickEventArgs);
  
     if ( !canvasClickEventArgs.preventDefaultAction && event.quick && this.viewer.viewport && (this.panVertical || this.panHorizontal)) {
      if(this.viewer.viewport.flipped) {
        event.position.x = this.viewport.getContainerSize().x - event.position.x;
      }
      var target = this.viewport.pointFromPixel(event.position);
      if (!this.panVertical) {
        // perform only horizonal pan
        target.y = this.viewer.viewport.getCenter(true).y;
      } else if (!this.panHorizontal) {
        // perform only vertical pan
        target.x = this.viewer.viewport.getCenter(true).x;
      }
      this.viewer.viewport.panTo(target);
      this.viewer.viewport.applyConstraints();
    }
  
  }
  
  /**
   * @private
   * @inner
   * @function
   */
  function onCanvasDrag( event ) {
      var canvasDragEventArgs = {
        tracker: event.eventSource,
        position: event.position,
        delta: event.delta,
        speed: event.speed,
        direction: event.direction,
        shift: event.shift,
        originalEvent: event.originalEvent,
        preventDefaultAction: event.preventDefaultAction
      };
      /**
       * Raised when a drag event occurs on the {@link OpenSeadragon.Viewer#navigator} element.
       *
       * @event navigator-drag
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
       * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
       * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
       * @property {OpenSeadragon.Point} delta - The x,y components of the difference between start drag and end drag.
       * @property {Number} speed - Current computed speed, in pixels per second.
       * @property {Number} direction - Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
       * @property {Boolean} shift - True if the shift key was pressed during this event.
       * @property {Object} originalEvent - The original DOM event.
       * @property {?Object} userData - Arbitrary subscriber-defined object.
       * @property {Boolean} preventDefaultAction - Set to true to prevent default click to zoom behaviour. Default: false.
       */
       this.viewer.raiseEvent('navigator-drag', canvasDragEventArgs);
  
       if ( !canvasDragEventArgs.preventDefaultAction && this.viewer.viewport ) {
         if( !this.panHorizontal ){
              event.delta.x = 0;
          }
          if( !this.panVertical ){
              event.delta.y = 0;
          }
  
          if(this.viewer.viewport.flipped){
              event.delta.x = -event.delta.x;
          }
  
          this.viewer.viewport.panBy(
              this.viewport.deltaPointsFromPixels(
                  event.delta
              )
          );
          if( this.viewer.constrainDuringPan ){
              this.viewer.viewport.applyConstraints();
          }
      }
  }
  
  
  /**
   * @private
   * @inner
   * @function
   */
  function onCanvasRelease( event ) {
      if ( event.insideElementPressed && this.viewer.viewport ) {
          this.viewer.viewport.applyConstraints();
      }
  }
  
  
  /**
   * @private
   * @inner
   * @function
   */
  function onCanvasScroll( event ) {
      /**
       * Raised when a scroll event occurs on the {@link OpenSeadragon.Viewer#navigator} element (mouse wheel, touch pinch, etc.).
       *
       * @event navigator-scroll
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
       * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
       * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
       * @property {Number} scroll - The scroll delta for the event.
       * @property {Boolean} shift - True if the shift key was pressed during this event.
       * @property {Object} originalEvent - The original DOM event.
       * @property {?Object} userData - Arbitrary subscriber-defined object.
       */
      this.viewer.raiseEvent( 'navigator-scroll', {
          tracker: event.eventSource,
          position: event.position,
          scroll: event.scroll,
          shift: event.shift,
          originalEvent: event.originalEvent
      });
  
      //don't scroll the page up and down if the user is scrolling
      //in the navigator
      return false;
  }
  
  /**
      * @function
      * @private
      * @param {Object} element
      * @param {Number} degrees
      */
  function _setTransformRotate( element, degrees ) {
    setElementTransform(element, "rotate(" + degrees + "deg)");
  }
  
  function setElementTransform( element, rule ) {
    element.style.webkitTransform = rule;
    element.style.mozTransform = rule;
    element.style.msTransform = rule;
    element.style.oTransform = rule;
    element.style.transform = rule;
  }
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - getString/setString
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  //TODO: I guess this is where the i18n needs to be reimplemented.  I'll look
  //      into existing patterns for i18n in javascript but i think that mimicking
  //      pythons gettext might be a reasonable approach.
  var I18N = {
      Errors: {
          Dzc:            "Sorry, we don't support Deep Zoom Collections!",
          Dzi:            "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
          Xml:            "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
          ImageFormat:    "Sorry, we don't support {0}-based Deep Zoom Images.",
          Security:       "It looks like a security restriction stopped us from " +
                          "loading this Deep Zoom Image.",
          Status:         "This space unintentionally left blank ({0} {1}).",
          OpenFailed:     "Unable to open {0}: {1}"
      },
  
      Tooltips: {
          FullPage:       "Toggle full page",
          Home:           "Go home",
          ZoomIn:         "Zoom in",
          ZoomOut:        "Zoom out",
          NextPage:       "Next page",
          PreviousPage:   "Previous page",
          RotateLeft:     "Rotate left",
          RotateRight:    "Rotate right",
          Flip:           "Flip Horizontally"
      }
  };
  
  $.extend( $, /** @lends OpenSeadragon */{
  
      /**
       * @function
       * @param {String} property
       */
      getString: function( prop ) {
  
          var props   = prop.split('.'),
              string  = null,
              args    = arguments,
              container = I18N,
              i;
  
          for (i = 0; i < props.length - 1; i++) {
              // in case not a subproperty
              container = container[ props[ i ] ] || {};
          }
          string = container[ props[ i ] ];
  
          if ( typeof ( string ) != "string" ) {
              $.console.log( "Untranslated source string:", prop );
              string = ""; // FIXME: this breaks gettext()-style convention, which would return source
          }
  
          return string.replace(/\{\d+\}/g, function(capture) {
              var i = parseInt( capture.match( /\d+/ ), 10 ) + 1;
              return i < args.length ?
                  args[ i ] :
                  "";
          });
      },
  
      /**
       * @function
       * @param {String} property
       * @param {*} value
       */
      setString: function( prop, value ) {
  
          var props     = prop.split('.'),
              container = I18N,
              i;
  
          for ( i = 0; i < props.length - 1; i++ ) {
              if ( !container[ props[ i ] ] ) {
                  container[ props[ i ] ] = {};
              }
              container = container[ props[ i ] ];
          }
  
          container[ props[ i ] ] = value;
      }
  
  });
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - Point
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  /**
   * @class Point
   * @classdesc A Point is really used as a 2-dimensional vector, equally useful for
   * representing a point on a plane, or the height and width of a plane
   * not requiring any other frame of reference.
   *
   * @memberof OpenSeadragon
   * @param {Number} [x] The vector component 'x'. Defaults to the origin at 0.
   * @param {Number} [y] The vector component 'y'. Defaults to the origin at 0.
   */
  $.Point = function( x, y ) {
      /**
       * The vector component 'x'.
       * @member {Number} x
       * @memberof OpenSeadragon.Point#
       */
      this.x = typeof ( x ) == "number" ? x : 0;
      /**
       * The vector component 'y'.
       * @member {Number} y
       * @memberof OpenSeadragon.Point#
       */
      this.y = typeof ( y ) == "number" ? y : 0;
  };
  
  /** @lends OpenSeadragon.Point.prototype */
  $.Point.prototype = {
      /**
       * @function
       * @returns {OpenSeadragon.Point} a duplicate of this Point
       */
      clone: function() {
          return new $.Point(this.x, this.y);
      },
  
      /**
       * Add another Point to this point and return a new Point.
       * @function
       * @param {OpenSeadragon.Point} point The point to add vector components.
       * @returns {OpenSeadragon.Point} A new point representing the sum of the
       *  vector components
       */
      plus: function( point ) {
          return new $.Point(
              this.x + point.x,
              this.y + point.y
          );
      },
  
      /**
       * Subtract another Point to this point and return a new Point.
       * @function
       * @param {OpenSeadragon.Point} point The point to subtract vector components.
       * @returns {OpenSeadragon.Point} A new point representing the subtraction of the
       *  vector components
       */
      minus: function( point ) {
          return new $.Point(
              this.x - point.x,
              this.y - point.y
          );
      },
  
      /**
       * Multiply this point by a factor and return a new Point.
       * @function
       * @param {Number} factor The factor to multiply vector components.
       * @returns {OpenSeadragon.Point} A new point representing the multiplication
       *  of the vector components by the factor
       */
      times: function( factor ) {
          return new $.Point(
              this.x * factor,
              this.y * factor
          );
      },
  
      /**
       * Divide this point by a factor and return a new Point.
       * @function
       * @param {Number} factor The factor to divide vector components.
       * @returns {OpenSeadragon.Point} A new point representing the division of the
       *  vector components by the factor
       */
      divide: function( factor ) {
          return new $.Point(
              this.x / factor,
              this.y / factor
          );
      },
  
      /**
       * Compute the opposite of this point and return a new Point.
       * @function
       * @returns {OpenSeadragon.Point} A new point representing the opposite of the
       *  vector components
       */
      negate: function() {
          return new $.Point( -this.x, -this.y );
      },
  
      /**
       * Compute the distance between this point and another point.
       * @function
       * @param {OpenSeadragon.Point} point The point to compute the distance with.
       * @returns {Number} The distance between the 2 points
       */
      distanceTo: function( point ) {
          return Math.sqrt(
              Math.pow( this.x - point.x, 2 ) +
              Math.pow( this.y - point.y, 2 )
          );
      },
  
      /**
       * Compute the squared distance between this point and another point.
       * Useful for optimizing things like comparing distances.
       * @function
       * @param {OpenSeadragon.Point} point The point to compute the squared distance with.
       * @returns {Number} The squared distance between the 2 points
       */
      squaredDistanceTo: function( point ) {
          return Math.pow( this.x - point.x, 2 ) +
              Math.pow( this.y - point.y, 2 );
      },
  
      /**
       * Apply a function to each coordinate of this point and return a new point.
       * @function
       * @param {function} func The function to apply to each coordinate.
       * @returns {OpenSeadragon.Point} A new point with the coordinates computed
       * by the specified function
       */
      apply: function( func ) {
          return new $.Point( func( this.x ), func( this.y ) );
      },
  
      /**
       * Check if this point is equal to another one.
       * @function
       * @param {OpenSeadragon.Point} point The point to compare this point with.
       * @returns {Boolean} true if they are equal, false otherwise.
       */
      equals: function( point ) {
          return (
              point instanceof $.Point
          ) && (
              this.x === point.x
          ) && (
              this.y === point.y
          );
      },
  
      /**
       * Rotates the point around the specified pivot
       * From http://stackoverflow.com/questions/4465931/rotate-rectangle-around-a-point
       * @function
       * @param {Number} degress to rotate around the pivot.
       * @param {OpenSeadragon.Point} [pivot=(0,0)] Point around which to rotate.
       * Defaults to the origin.
       * @returns {OpenSeadragon.Point}. A new point representing the point rotated around the specified pivot
       */
      rotate: function (degrees, pivot) {
          pivot = pivot || new $.Point(0, 0);
          var cos;
          var sin;
          // Avoid float computations when possible
          if (degrees % 90 === 0) {
              var d = $.positiveModulo(degrees, 360);
              switch (d) {
                  case 0:
                      cos = 1;
                      sin = 0;
                      break;
                  case 90:
                      cos = 0;
                      sin = 1;
                      break;
                  case 180:
                      cos = -1;
                      sin = 0;
                      break;
                  case 270:
                      cos = 0;
                      sin = -1;
                      break;
              }
          } else {
              var angle = degrees * Math.PI / 180.0;
              cos = Math.cos(angle);
              sin = Math.sin(angle);
          }
          var x = cos * (this.x - pivot.x) - sin * (this.y - pivot.y) + pivot.x;
          var y = sin * (this.x - pivot.x) + cos * (this.y - pivot.y) + pivot.y;
          return new $.Point(x, y);
      },
  
      /**
       * Convert this point to a string in the format (x,y) where x and y are
       * rounded to the nearest integer.
       * @function
       * @returns {String} A string representation of this point.
       */
      toString: function() {
          return "(" + (Math.round(this.x * 100) / 100) + "," + (Math.round(this.y * 100) / 100) + ")";
      }
  };
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - TileSource
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  
  /**
   * @class TileSource
   * @classdesc The TileSource contains the most basic implementation required to create a
   * smooth transition between layers in an image pyramid. It has only a single key
   * interface that must be implemented to complete its key functionality:
   * 'getTileUrl'.  It also has several optional interfaces that can be
   * implemented if a new TileSource wishes to support configuration via a simple
   * object or array ('configure') and if the tile source supports or requires
   * configuration via retrieval of a document on the network ala AJAX or JSONP,
   * ('getImageInfo').
   * <br/>
   * By default the image pyramid is split into N layers where the image's longest
   * side in M (in pixels), where N is the smallest integer which satisfies
   *      <strong>2^(N+1) >= M</strong>.
   *
   * @memberof OpenSeadragon
   * @extends OpenSeadragon.EventSource
   * @param {Object} options
   *      You can either specify a URL, or literally define the TileSource (by specifying
   *      width, height, tileSize, tileOverlap, minLevel, and maxLevel). For the former,
   *      the extending class is expected to implement 'getImageInfo' and 'configure'.
   *      For the latter, the construction is assumed to occur through
   *      the extending classes implementation of 'configure'.
   * @param {String} [options.url]
   *      The URL for the data necessary for this TileSource.
   * @param {String} [options.referenceStripThumbnailUrl]
   *      The URL for a thumbnail image to be used by the reference strip
   * @param {Function} [options.success]
   *      A function to be called upon successful creation.
   * @param {Boolean} [options.ajaxWithCredentials]
   *      If this TileSource needs to make an AJAX call, this specifies whether to set
   *      the XHR's withCredentials (for accessing secure data).
   * @param {Object} [options.ajaxHeaders]
   *      A set of headers to include in AJAX requests.
   * @param {Number} [options.width]
   *      Width of the source image at max resolution in pixels.
   * @param {Number} [options.height]
   *      Height of the source image at max resolution in pixels.
   * @param {Number} [options.tileSize]
   *      The size of the tiles to assumed to make up each pyramid layer in pixels.
   *      Tile size determines the point at which the image pyramid must be
   *      divided into a matrix of smaller images.
   *      Use options.tileWidth and options.tileHeight to support non-square tiles.
   * @param {Number} [options.tileWidth]
   *      The width of the tiles to assumed to make up each pyramid layer in pixels.
   * @param {Number} [options.tileHeight]
   *      The height of the tiles to assumed to make up each pyramid layer in pixels.
   * @param {Number} [options.tileOverlap]
   *      The number of pixels each tile is expected to overlap touching tiles.
   * @param {Number} [options.minLevel]
   *      The minimum level to attempt to load.
   * @param {Number} [options.maxLevel]
   *      The maximum level to attempt to load.
   */
  $.TileSource = function( width, height, tileSize, tileOverlap, minLevel, maxLevel ) {
      var _this = this;
  
      var args = arguments,
          options,
          i;
  
      if( $.isPlainObject( width ) ){
          options = width;
      }else{
          options = {
              width: args[0],
              height: args[1],
              tileSize: args[2],
              tileOverlap: args[3],
              minLevel: args[4],
              maxLevel: args[5]
          };
      }
  
      //Tile sources supply some events, namely 'ready' when they must be configured
      //by asynchronously fetching their configuration data.
      $.EventSource.call( this );
  
      //we allow options to override anything we don't treat as
      //required via idiomatic options or which is functionally
      //set depending on the state of the readiness of this tile
      //source
      $.extend( true, this, options );
  
      if (!this.success) {
          //Any functions that are passed as arguments are bound to the ready callback
          for ( i = 0; i < arguments.length; i++ ) {
              if ( $.isFunction( arguments[ i ] ) ) {
                  this.success = arguments[ i ];
                  //only one callback per constructor
                  break;
              }
          }
      }
  
      if (this.success) {
          this.addHandler( 'ready', function ( event ) {
              _this.success( event );
          } );
      }
  
      /**
       * Ratio of width to height
       * @member {Number} aspectRatio
       * @memberof OpenSeadragon.TileSource#
       */
      /**
       * Vector storing x and y dimensions ( width and height respectively ).
       * @member {OpenSeadragon.Point} dimensions
       * @memberof OpenSeadragon.TileSource#
       */
      /**
       * The overlap in pixels each tile shares with its adjacent neighbors.
       * @member {Number} tileOverlap
       * @memberof OpenSeadragon.TileSource#
       */
      /**
       * The minimum pyramid level this tile source supports or should attempt to load.
       * @member {Number} minLevel
       * @memberof OpenSeadragon.TileSource#
       */
      /**
       * The maximum pyramid level this tile source supports or should attempt to load.
       * @member {Number} maxLevel
       * @memberof OpenSeadragon.TileSource#
       */
      /**
       *
       * @member {Boolean} ready
       * @memberof OpenSeadragon.TileSource#
       */
  
      if( 'string' == $.type( arguments[ 0 ] ) ){
          this.url = arguments[0];
      }
  
      if (this.url) {
          //in case the getImageInfo method is overridden and/or implies an
          //async mechanism set some safe defaults first
          this.aspectRatio = 1;
          this.dimensions  = new $.Point( 10, 10 );
          this._tileWidth  = 0;
          this._tileHeight = 0;
          this.tileOverlap = 0;
          this.minLevel    = 0;
          this.maxLevel    = 0;
          this.ready       = false;
          //configuration via url implies the extending class
          //implements and 'configure'
          this.getImageInfo( this.url );
  
      } else {
  
          //explicit configuration via positional args in constructor
          //or the more idiomatic 'options' object
          this.ready       = true;
          this.aspectRatio = (options.width && options.height) ?
              (options.width / options.height) : 1;
          this.dimensions  = new $.Point( options.width, options.height );
  
          if ( this.tileSize ){
              this._tileWidth = this._tileHeight = this.tileSize;
              delete this.tileSize;
          } else {
              if( this.tileWidth ){
                  // We were passed tileWidth in options, but we want to rename it
                  // with a leading underscore to make clear that it is not safe to directly modify it
                  this._tileWidth = this.tileWidth;
                  delete this.tileWidth;
              } else {
                  this._tileWidth = 0;
              }
  
              if( this.tileHeight ){
                  // See note above about renaming this.tileWidth
                  this._tileHeight = this.tileHeight;
                  delete this.tileHeight;
              } else {
                  this._tileHeight = 0;
              }
          }
  
          this.tileOverlap = options.tileOverlap ? options.tileOverlap : 0;
          this.minLevel    = options.minLevel ? options.minLevel : 0;
          this.maxLevel    = ( undefined !== options.maxLevel && null !== options.maxLevel ) ?
              options.maxLevel : (
                  ( options.width && options.height ) ? Math.ceil(
                      Math.log( Math.max( options.width, options.height ) ) /
                      Math.log( 2 )
                  ) : 0
              );
          if( this.success && $.isFunction( this.success ) ){
              this.success( this );
          }
      }
  
  
  };
  
  /** @lends OpenSeadragon.TileSource.prototype */
  $.TileSource.prototype = {
  
      getTileSize: function( level ) {
          $.console.error(
              "[TileSource.getTileSize] is deprecated. " +
              "Use TileSource.getTileWidth() and TileSource.getTileHeight() instead"
          );
          return this._tileWidth;
      },
  
      /**
       * Return the tileWidth for a given level.
       * Subclasses should override this if tileWidth can be different at different levels
       *   such as in IIIFTileSource.  Code should use this function rather than reading
       *   from ._tileWidth directly.
       * @function
       * @param {Number} level
       */
      getTileWidth: function( level ) {
          if (!this._tileWidth) {
              return this.getTileSize(level);
          }
          return this._tileWidth;
      },
  
      /**
       * Return the tileHeight for a given level.
       * Subclasses should override this if tileHeight can be different at different levels
       *   such as in IIIFTileSource.  Code should use this function rather than reading
       *   from ._tileHeight directly.
       * @function
       * @param {Number} level
       */
      getTileHeight: function( level ) {
          if (!this._tileHeight) {
              return this.getTileSize(level);
          }
          return this._tileHeight;
      },
  
      /**
       * @function
       * @param {Number} level
       */
      getLevelScale: function( level ) {
  
          // see https://github.com/openseadragon/openseadragon/issues/22
          // we use the tilesources implementation of getLevelScale to generate
          // a memoized re-implementation
          var levelScaleCache = {},
              i;
          for( i = 0; i <= this.maxLevel; i++ ){
              levelScaleCache[ i ] = 1 / Math.pow(2, this.maxLevel - i);
          }
          this.getLevelScale = function( _level ){
              return levelScaleCache[ _level ];
          };
          return this.getLevelScale( level );
      },
  
      /**
       * @function
       * @param {Number} level
       */
      getNumTiles: function( level ) {
          var scale = this.getLevelScale( level ),
              x = Math.ceil( scale * this.dimensions.x / this.getTileWidth(level) ),
              y = Math.ceil( scale * this.dimensions.y / this.getTileHeight(level) );
  
          return new $.Point( x, y );
      },
  
      /**
       * @function
       * @param {Number} level
       */
      getPixelRatio: function( level ) {
          var imageSizeScaled = this.dimensions.times( this.getLevelScale( level ) ),
              rx = 1.0 / imageSizeScaled.x,
              ry = 1.0 / imageSizeScaled.y;
  
          return new $.Point(rx, ry);
      },
  
  
      /**
       * @function
       * @returns {Number} The highest level in this tile source that can be contained in a single tile.
       */
      getClosestLevel: function() {
          var i,
              tiles;
  
          for (i = this.minLevel + 1; i <= this.maxLevel; i++){
              tiles = this.getNumTiles(i);
              if (tiles.x > 1 || tiles.y > 1) {
                  break;
              }
          }
  
          return i - 1;
      },
  
      /**
       * @function
       * @param {Number} level
       * @param {OpenSeadragon.Point} point
       */
      getTileAtPoint: function(level, point) {
          var validPoint = point.x >= 0 && point.x <= 1 &&
              point.y >= 0 && point.y <= 1 / this.aspectRatio;
          $.console.assert(validPoint, "[TileSource.getTileAtPoint] must be called with a valid point.");
  
          var widthScaled = this.dimensions.x * this.getLevelScale(level);
          var pixelX = point.x * widthScaled;
          var pixelY = point.y * widthScaled;
  
          var x = Math.floor(pixelX / this.getTileWidth(level));
          var y = Math.floor(pixelY / this.getTileHeight(level));
  
          // When point.x == 1 or point.y == 1 / this.aspectRatio we want to
          // return the last tile of the row/column
          if (point.x >= 1) {
              x = this.getNumTiles(level).x - 1;
          }
          var EPSILON = 1e-15;
          if (point.y >= 1 / this.aspectRatio - EPSILON) {
              y = this.getNumTiles(level).y - 1;
          }
  
          return new $.Point(x, y);
      },
  
      /**
       * @function
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       * @param {Boolean} [isSource=false] Whether to return the source bounds of the tile.
       * @returns {OpenSeadragon.Rect} Either where this tile fits (in normalized coordinates) or the
       * portion of the tile to use as the source of the drawing operation (in pixels), depending on
       * the isSource parameter.
       */
      getTileBounds: function( level, x, y, isSource ) {
          var dimensionsScaled = this.dimensions.times( this.getLevelScale( level ) ),
              tileWidth = this.getTileWidth(level),
              tileHeight = this.getTileHeight(level),
              px = ( x === 0 ) ? 0 : tileWidth * x - this.tileOverlap,
              py = ( y === 0 ) ? 0 : tileHeight * y - this.tileOverlap,
              sx = tileWidth + ( x === 0 ? 1 : 2 ) * this.tileOverlap,
              sy = tileHeight + ( y === 0 ? 1 : 2 ) * this.tileOverlap,
              scale = 1.0 / dimensionsScaled.x;
  
          sx = Math.min( sx, dimensionsScaled.x - px );
          sy = Math.min( sy, dimensionsScaled.y - py );
  
          if (isSource) {
              return new $.Rect(0, 0, sx, sy);
          }
  
          return new $.Rect( px * scale, py * scale, sx * scale, sy * scale );
      },
  
  
      /**
       * Responsible for retrieving, and caching the
       * image metadata pertinent to this TileSources implementation.
       * @function
       * @param {String} url
       * @throws {Error}
       */
      getImageInfo: function( url ) {
          var _this = this,
              callbackName,
              callback,
              readySource,
              options,
              urlParts,
              filename,
              lastDot;
  
  
          if( url ) {
              urlParts = url.split( '/' );
              filename = urlParts[ urlParts.length - 1 ];
              lastDot  = filename.lastIndexOf( '.' );
              if ( lastDot > -1 ) {
                  urlParts[ urlParts.length - 1 ] = filename.slice( 0, lastDot );
              }
          }
  
          callback = function( data ){
              if( typeof (data) === "string" ) {
                  data = $.parseXml( data );
              }
              var $TileSource = $.TileSource.determineType( _this, data, url );
              if ( !$TileSource ) {
                  /**
                   * Raised when an error occurs loading a TileSource.
                   *
                   * @event open-failed
                   * @memberof OpenSeadragon.TileSource
                   * @type {object}
                   * @property {OpenSeadragon.TileSource} eventSource - A reference to the TileSource which raised the event.
                   * @property {String} message
                   * @property {String} source
                   * @property {?Object} userData - Arbitrary subscriber-defined object.
                   */
                  _this.raiseEvent( 'open-failed', { message: "Unable to load TileSource", source: url } );
                  return;
              }
  
              options = $TileSource.prototype.configure.apply( _this, [ data, url ]);
              if (options.ajaxWithCredentials === undefined) {
                  options.ajaxWithCredentials = _this.ajaxWithCredentials;
              }
  
              readySource = new $TileSource( options );
              _this.ready = true;
              /**
               * Raised when a TileSource is opened and initialized.
               *
               * @event ready
               * @memberof OpenSeadragon.TileSource
               * @type {object}
               * @property {OpenSeadragon.TileSource} eventSource - A reference to the TileSource which raised the event.
               * @property {Object} tileSource
               * @property {?Object} userData - Arbitrary subscriber-defined object.
               */
              _this.raiseEvent( 'ready', { tileSource: readySource } );
          };
  
          if( url.match(/\.js$/) ){
              //TODO: Its not very flexible to require tile sources to end jsonp
              //      request for info  with a url that ends with '.js' but for
              //      now it's the only way I see to distinguish uniformly.
              callbackName = url.split('/').pop().replace('.js', '');
              $.jsonp({
                  url: url,
                  async: false,
                  callbackName: callbackName,
                  callback: callback
              });
          } else {
              // request info via xhr asynchronously.
              $.makeAjaxRequest( {
                  url: url,
                  withCredentials: this.ajaxWithCredentials,
                  headers: this.ajaxHeaders,
                  success: function( xhr ) {
                      var data = processResponse( xhr );
                      callback( data );
                  },
                  error: function ( xhr, exc ) {
                      var msg;
  
                      /*
                          IE < 10 will block XHR requests to different origins. Any property access on the request
                          object will raise an exception which we'll attempt to handle by formatting the original
                          exception rather than the second one raised when we try to access xhr.status
                       */
                      try {
                          msg = "HTTP " + xhr.status + " attempting to load TileSource";
                      } catch ( e ) {
                          var formattedExc;
                          if ( typeof ( exc ) == "undefined" || !exc.toString ) {
                              formattedExc = "Unknown error";
                          } else {
                              formattedExc = exc.toString();
                          }
  
                          msg = formattedExc + " attempting to load TileSource";
                      }
  
                      /***
                       * Raised when an error occurs loading a TileSource.
                       *
                       * @event open-failed
                       * @memberof OpenSeadragon.TileSource
                       * @type {object}
                       * @property {OpenSeadragon.TileSource} eventSource - A reference to the TileSource which raised the event.
                       * @property {String} message
                       * @property {String} source
                       * @property {?Object} userData - Arbitrary subscriber-defined object.
                       */
                      _this.raiseEvent( 'open-failed', {
                          message: msg,
                          source: url
                      });
                  }
              });
          }
  
      },
  
      /**
       * Responsible determining if a the particular TileSource supports the
       * data format ( and allowed to apply logic against the url the data was
       * loaded from, if any ). Overriding implementations are expected to do
       * something smart with data and / or url to determine support.  Also
       * understand that iteration order of TileSources is not guarunteed so
       * please make sure your data or url is expressive enough to ensure a simple
       * and sufficient mechanisim for clear determination.
       * @function
       * @param {String|Object|Array|Document} data
       * @param {String} url - the url the data was loaded
       *      from if any.
       * @return {Boolean}
       */
      supports: function( data, url ) {
          return false;
      },
  
      /**
       * Responsible for parsing and configuring the
       * image metadata pertinent to this TileSources implementation.
       * This method is not implemented by this class other than to throw an Error
       * announcing you have to implement it.  Because of the variety of tile
       * server technologies, and various specifications for building image
       * pyramids, this method is here to allow easy integration.
       * @function
       * @param {String|Object|Array|Document} data
       * @param {String} url - the url the data was loaded
       *      from if any.
       * @return {Object} options - A dictionary of keyword arguments sufficient
       *      to configure this tile sources constructor.
       * @throws {Error}
       */
      configure: function( data, url ) {
          throw new Error( "Method not implemented." );
      },
  
      /**
       * Responsible for retrieving the url which will return an image for the
       * region specified by the given x, y, and level components.
       * This method is not implemented by this class other than to throw an Error
       * announcing you have to implement it.  Because of the variety of tile
       * server technologies, and various specifications for building image
       * pyramids, this method is here to allow easy integration.
       * @function
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       * @throws {Error}
       */
      getTileUrl: function( level, x, y ) {
          throw new Error( "Method not implemented." );
      },
  
      /**
       * Responsible for retrieving the headers which will be attached to the image request for the
       * region specified by the given x, y, and level components.
       * This option is only relevant if {@link OpenSeadragon.Options}.loadTilesWithAjax is set to true.
       * The headers returned here will override headers specified at the Viewer or TiledImage level.
       * Specifying a falsy value for a header will clear its existing value set at the Viewer or
       * TiledImage level (if any).
       * @function
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       * @returns {Object}
       */
      getTileAjaxHeaders: function( level, x, y ) {
          return {};
      },
  
      /**
       * @function
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       */
      tileExists: function( level, x, y ) {
          var numTiles = this.getNumTiles( level );
          return level >= this.minLevel &&
                 level <= this.maxLevel &&
                 x >= 0 &&
                 y >= 0 &&
                 x < numTiles.x &&
                 y < numTiles.y;
      }
  };
  
  
  $.extend( true, $.TileSource.prototype, $.EventSource.prototype );
  
  
  /**
   * Decides whether to try to process the response as xml, json, or hand back
   * the text
   * @private
   * @inner
   * @function
   * @param {XMLHttpRequest} xhr - the completed network request
   */
  function processResponse( xhr ){
      var responseText = xhr.responseText,
          status       = xhr.status,
          statusText,
          data;
  
      if ( !xhr ) {
          throw new Error( $.getString( "Errors.Security" ) );
      } else if ( xhr.status !== 200 && xhr.status !== 0 ) {
          status     = xhr.status;
          statusText = ( status == 404 ) ?
              "Not Found" :
              xhr.statusText;
          throw new Error( $.getString( "Errors.Status", status, statusText ) );
      }
  
      if( responseText.match(/\s*<.*/) ){
          try{
          data = ( xhr.responseXML && xhr.responseXML.documentElement ) ?
              xhr.responseXML :
              $.parseXml( responseText );
          } catch (e){
              data = xhr.responseText;
          }
      }else if( responseText.match(/\s*[\{\[].*/) ){
          try{
            data = $.parseJSON(responseText);
          } catch(e){
            data =  responseText;
          }
      }else{
          data = responseText;
      }
      return data;
  }
  
  
  /**
   * Determines the TileSource Implementation by introspection of OpenSeadragon
   * namespace, calling each TileSource implementation of 'isType'
   * @private
   * @inner
   * @function
   * @param {Object|Array|Document} data - the tile source configuration object
   * @param {String} url - the url where the tile source configuration object was
   *      loaded from, if any.
   */
  $.TileSource.determineType = function( tileSource, data, url ){
      var property;
      for( property in OpenSeadragon ){
          if( property.match(/.+TileSource$/) &&
              $.isFunction( OpenSeadragon[ property ] ) &&
              $.isFunction( OpenSeadragon[ property ].prototype.supports ) &&
              OpenSeadragon[ property ].prototype.supports.call( tileSource, data, url )
          ){
              return OpenSeadragon[ property ];
          }
      }
  
      $.console.error( "No TileSource was able to open %s %s", url, data );
  };
  
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - DziTileSource
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  /**
   * @class DziTileSource
   * @memberof OpenSeadragon
   * @extends OpenSeadragon.TileSource
   * @param {Number|Object} width - the pixel width of the image or the idiomatic
   *      options object which is used instead of positional arguments.
   * @param {Number} height
   * @param {Number} tileSize
   * @param {Number} tileOverlap
   * @param {String} tilesUrl
   * @param {String} fileFormat
   * @param {OpenSeadragon.DisplayRect[]} displayRects
   * @property {String} tilesUrl
   * @property {String} fileFormat
   * @property {OpenSeadragon.DisplayRect[]} displayRects
   */
  $.DziTileSource = function( width, height, tileSize, tileOverlap, tilesUrl, fileFormat, displayRects, minLevel, maxLevel ) {
      var i,
          rect,
          level,
          options;
  
      if( $.isPlainObject( width ) ){
          options = width;
      }else{
          options = {
              width: arguments[ 0 ],
              height: arguments[ 1 ],
              tileSize: arguments[ 2 ],
              tileOverlap: arguments[ 3 ],
              tilesUrl: arguments[ 4 ],
              fileFormat: arguments[ 5 ],
              displayRects: arguments[ 6 ],
              minLevel: arguments[ 7 ],
              maxLevel: arguments[ 8 ]
          };
      }
  
      this._levelRects  = {};
      this.tilesUrl     = options.tilesUrl;
      this.fileFormat   = options.fileFormat;
      this.displayRects = options.displayRects;
  
      if ( this.displayRects ) {
          for ( i = this.displayRects.length - 1; i >= 0; i-- ) {
              rect = this.displayRects[ i ];
              for ( level = rect.minLevel; level <= rect.maxLevel; level++ ) {
                  if ( !this._levelRects[ level ] ) {
                      this._levelRects[ level ] = [];
                  }
                  this._levelRects[ level ].push( rect );
              }
          }
      }
  
      $.TileSource.apply( this, [ options ] );
  
  };
  
  $.extend( $.DziTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.DziTileSource.prototype */{
  
  
      /**
       * Determine if the data and/or url imply the image service is supported by
       * this tile source.
       * @function
       * @param {Object|Array} data
       * @param {String} optional - url
       */
      supports: function( data, url ){
          var ns;
          if ( data.Image ) {
              ns = data.Image.xmlns;
          } else if ( data.documentElement) {
              if ("Image" == data.documentElement.localName || "Image" == data.documentElement.tagName) {
                  ns = data.documentElement.namespaceURI;
              }
          }
  
          ns = (ns || '').toLowerCase();
  
          return (ns.indexOf('schemas.microsoft.com/deepzoom/2008') !== -1 ||
              ns.indexOf('schemas.microsoft.com/deepzoom/2009') !== -1);
      },
  
      /**
       *
       * @function
       * @param {Object|XMLDocument} data - the raw configuration
       * @param {String} url - the url the data was retrieved from if any.
       * @return {Object} options - A dictionary of keyword arguments sufficient
       *      to configure this tile sources constructor.
       */
      configure: function( data, url ){
  
          var options;
  
          if( !$.isPlainObject(data) ){
  
              options = configureFromXML( this, data );
  
          }else{
  
              options = configureFromObject( this, data );
          }
  
          if (url && !options.tilesUrl) {
              options.tilesUrl = url.replace(
                      /([^\/]+?)(\.(dzi|xml|js)?(\?[^\/]*)?)?\/?$/, '$1_files/');
  
              if (url.search(/\.(dzi|xml|js)\?/) != -1) {
                  options.queryParams = url.match(/\?.*/);
              }else{
                  options.queryParams = '';
              }
          }
  
          return options;
      },
  
  
      /**
       * @function
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       */
      getTileUrl: function( level, x, y ) {
          return [ this.tilesUrl, level, '/', x, '_', y, '.', this.fileFormat, this.queryParams ].join( '' );
      },
  
  
      /**
       * @function
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       */
      tileExists: function( level, x, y ) {
          var rects = this._levelRects[ level ],
              rect,
              scale,
              xMin,
              yMin,
              xMax,
              yMax,
              i;
  
          if ((this.minLevel && level < this.minLevel) || (this.maxLevel && level > this.maxLevel)) {
              return false;
          }
  
          if ( !rects || !rects.length ) {
              return true;
          }
  
          for ( i = rects.length - 1; i >= 0; i-- ) {
              rect = rects[ i ];
  
              if ( level < rect.minLevel || level > rect.maxLevel ) {
                  continue;
              }
  
              scale = this.getLevelScale( level );
              xMin = rect.x * scale;
              yMin = rect.y * scale;
              xMax = xMin + rect.width * scale;
              yMax = yMin + rect.height * scale;
  
              xMin = Math.floor( xMin / this._tileWidth );
              yMin = Math.floor( yMin / this._tileWidth ); // DZI tiles are square, so we just use _tileWidth
              xMax = Math.ceil( xMax / this._tileWidth );
              yMax = Math.ceil( yMax / this._tileWidth );
  
              if ( xMin <= x && x < xMax && yMin <= y && y < yMax ) {
                  return true;
              }
          }
  
          return false;
      }
  });
  
  
  /**
   * @private
   * @inner
   * @function
   */
  function configureFromXML( tileSource, xmlDoc ){
  
      if ( !xmlDoc || !xmlDoc.documentElement ) {
          throw new Error( $.getString( "Errors.Xml" ) );
      }
  
      var root           = xmlDoc.documentElement,
          rootName       = root.localName || root.tagName,
          ns             = xmlDoc.documentElement.namespaceURI,
          configuration  = null,
          displayRects   = [],
          dispRectNodes,
          dispRectNode,
          rectNode,
          sizeNode,
          i;
  
      if ( rootName == "Image" ) {
  
          try {
              sizeNode = root.getElementsByTagName("Size" )[ 0 ];
              if (sizeNode === undefined) {
                  sizeNode = root.getElementsByTagNameNS(ns, "Size" )[ 0 ];
              }
  
              configuration = {
                  Image: {
                      xmlns:       "http://schemas.microsoft.com/deepzoom/2008",
                      Url:         root.getAttribute( "Url" ),
                      Format:      root.getAttribute( "Format" ),
                      DisplayRect: null,
                      Overlap:     parseInt( root.getAttribute( "Overlap" ), 10 ),
                      TileSize:    parseInt( root.getAttribute( "TileSize" ), 10 ),
                      Size: {
                          Height: parseInt( sizeNode.getAttribute( "Height" ), 10 ),
                          Width:  parseInt( sizeNode.getAttribute( "Width" ), 10 )
                      }
                  }
              };
  
              if ( !$.imageFormatSupported( configuration.Image.Format ) ) {
                  throw new Error(
                      $.getString( "Errors.ImageFormat", configuration.Image.Format.toUpperCase() )
                  );
              }
  
              dispRectNodes = root.getElementsByTagName("DisplayRect" );
              if (dispRectNodes === undefined) {
                  dispRectNodes = root.getElementsByTagNameNS(ns, "DisplayRect" )[ 0 ];
              }
  
              for ( i = 0; i < dispRectNodes.length; i++ ) {
                  dispRectNode = dispRectNodes[ i ];
                  rectNode     = dispRectNode.getElementsByTagName("Rect" )[ 0 ];
                  if (rectNode === undefined) {
                      rectNode = dispRectNode.getElementsByTagNameNS(ns, "Rect" )[ 0 ];
                  }
  
                  displayRects.push({
                      Rect: {
                          X: parseInt( rectNode.getAttribute( "X" ), 10 ),
                          Y: parseInt( rectNode.getAttribute( "Y" ), 10 ),
                          Width: parseInt( rectNode.getAttribute( "Width" ), 10 ),
                          Height: parseInt( rectNode.getAttribute( "Height" ), 10 ),
                          MinLevel: parseInt( dispRectNode.getAttribute( "MinLevel" ), 10 ),
                          MaxLevel: parseInt( dispRectNode.getAttribute( "MaxLevel" ), 10 )
                      }
                  });
              }
  
              if( displayRects.length ){
                  configuration.Image.DisplayRect = displayRects;
              }
  
              return configureFromObject( tileSource, configuration );
  
          } catch ( e ) {
              throw (e instanceof Error) ?
                  e :
                  new Error( $.getString("Errors.Dzi") );
          }
      } else if ( rootName == "Collection" ) {
          throw new Error( $.getString( "Errors.Dzc" ) );
      } else if ( rootName == "Error" ) {
          var messageNode = root.getElementsByTagName("Message")[0];
          var message = messageNode.firstChild.nodeValue;
          throw new Error(message);
      }
  
      throw new Error( $.getString( "Errors.Dzi" ) );
  }
  
  /**
   * @private
   * @inner
   * @function
   */
  function configureFromObject( tileSource, configuration ){
      var imageData     = configuration.Image,
          tilesUrl      = imageData.Url,
          fileFormat    = imageData.Format,
          sizeData      = imageData.Size,
          dispRectData  = imageData.DisplayRect || [],
          width         = parseInt( sizeData.Width, 10 ),
          height        = parseInt( sizeData.Height, 10 ),
          tileSize      = parseInt( imageData.TileSize, 10 ),
          tileOverlap   = parseInt( imageData.Overlap, 10 ),
          displayRects  = [],
          rectData,
          i;
  
      //TODO: need to figure out out to better handle image format compatibility
      //      which actually includes additional file formats like xml and pdf
      //      and plain text for various tilesource implementations to avoid low
      //      level errors.
      //
      //      For now, just don't perform the check.
      //
      /*if ( !imageFormatSupported( fileFormat ) ) {
          throw new Error(
              $.getString( "Errors.ImageFormat", fileFormat.toUpperCase() )
          );
      }*/
  
      for ( i = 0; i < dispRectData.length; i++ ) {
          rectData = dispRectData[ i ].Rect;
  
          displayRects.push( new $.DisplayRect(
              parseInt( rectData.X, 10 ),
              parseInt( rectData.Y, 10 ),
              parseInt( rectData.Width, 10 ),
              parseInt( rectData.Height, 10 ),
              parseInt( rectData.MinLevel, 10 ),
              parseInt( rectData.MaxLevel, 10 )
          ));
      }
  
      return $.extend(true, {
          width: width, /* width *required */
          height: height, /* height *required */
          tileSize: tileSize, /* tileSize *required */
          tileOverlap: tileOverlap, /* tileOverlap *required */
          minLevel: null, /* minLevel */
          maxLevel: null, /* maxLevel */
          tilesUrl: tilesUrl, /* tilesUrl */
          fileFormat: fileFormat, /* fileFormat */
          displayRects: displayRects /* displayRects */
      }, configuration );
  
  }
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - IIIFTileSource
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  /**
   * @class IIIFTileSource
   * @classdesc A client implementation of the International Image Interoperability Framework
   * Format: Image API 1.0 - 2.1
   *
   * @memberof OpenSeadragon
   * @extends OpenSeadragon.TileSource
   * @see http://iiif.io/api/image/
   * @param {String} [options.tileFormat='jpg']
   *      The extension that will be used when requiring tiles.
   */
  $.IIIFTileSource = function( options ){
  
      /* eslint-disable camelcase */
  
      $.extend( true, this, options );
  
      if ( !( this.height && this.width && this['@id'] ) ) {
          throw new Error( 'IIIF required parameters not provided.' );
      }
  
      options.tileSizePerScaleFactor = {};
  
      this.tileFormat = this.tileFormat || 'jpg';
  
      this.version = options.version;
  
      // N.B. 2.0 renamed scale_factors to scaleFactors
      if ( this.tile_width && this.tile_height ) {
          options.tileWidth = this.tile_width;
          options.tileHeight = this.tile_height;
      } else if ( this.tile_width ) {
          options.tileSize = this.tile_width;
      } else if ( this.tile_height ) {
          options.tileSize = this.tile_height;
      } else if ( this.tiles ) {
          // Version 2.0 forwards
          if ( this.tiles.length == 1 ) {
              options.tileWidth  = this.tiles[0].width;
              // Use height if provided, otherwise assume square tiles and use width.
              options.tileHeight = this.tiles[0].height || this.tiles[0].width;
              this.scale_factors = this.tiles[0].scaleFactors;
          } else {
              // Multiple tile sizes at different levels
              this.scale_factors = [];
              for (var t = 0; t < this.tiles.length; t++ ) {
                  for (var sf = 0; sf < this.tiles[t].scaleFactors.length; sf++) {
                      var scaleFactor = this.tiles[t].scaleFactors[sf];
                      this.scale_factors.push(scaleFactor);
                      options.tileSizePerScaleFactor[scaleFactor] = {
                          width: this.tiles[t].width,
                          height: this.tiles[t].height || this.tiles[t].width
                      };
                  }
              }
          }
      } else if ( canBeTiled(options) ) {
          // use the largest of tileOptions that is smaller than the short dimension
          var shortDim = Math.min( this.height, this.width ),
              tileOptions = [256, 512, 1024],
              smallerTiles = [];
  
          for ( var c = 0; c < tileOptions.length; c++ ) {
              if ( tileOptions[c] <= shortDim ) {
                  smallerTiles.push( tileOptions[c] );
              }
          }
  
          if ( smallerTiles.length > 0 ) {
              options.tileSize = Math.max.apply( null, smallerTiles );
          } else {
              // If we're smaller than 256, just use the short side.
              options.tileSize = shortDim;
          }
      } else if (this.sizes && this.sizes.length > 0) {
          // This info.json can't be tiled, but we can still construct a legacy pyramid from the sizes array.
          // In this mode, IIIFTileSource will call functions from the abstract baseTileSource or the
          // LegacyTileSource instead of performing IIIF tiling.
          this.emulateLegacyImagePyramid = true;
  
          options.levels = constructLevels( this );
          // use the largest available size to define tiles
          $.extend( true, options, {
              width: options.levels[ options.levels.length - 1 ].width,
              height: options.levels[ options.levels.length - 1 ].height,
              tileSize: Math.max( options.height, options.width ),
              tileOverlap: 0,
              minLevel: 0,
              maxLevel: options.levels.length - 1
          });
          this.levels = options.levels;
      } else {
          $.console.error("Nothing in the info.json to construct image pyramids from");
      }
  
      if (!options.maxLevel && !this.emulateLegacyImagePyramid) {
          if (!this.scale_factors) {
              options.maxLevel = Number(Math.ceil(Math.log(Math.max(this.width, this.height), 2)));
          } else {
              var maxScaleFactor = Math.max.apply(null, this.scale_factors);
              options.maxLevel = Math.round(Math.log(maxScaleFactor) * Math.LOG2E);
          }
      }
  
      $.TileSource.apply( this, [ options ] );
  };
  
  $.extend( $.IIIFTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.IIIFTileSource.prototype */{
      /**
       * Determine if the data and/or url imply the image service is supported by
       * this tile source.
       * @function
       * @param {Object|Array} data
       * @param {String} optional - url
       */
  
      supports: function( data, url ) {
          // Version 2.0 and forwards
          if (data.protocol && data.protocol == 'http://iiif.io/api/image') {
              return true;
          // Version 1.1
          } else if ( data['@context'] && (
              data['@context'] == "http://library.stanford.edu/iiif/image-api/1.1/context.json" ||
              data['@context'] == "http://iiif.io/api/image/1/context.json") ) {
              // N.B. the iiif.io context is wrong, but where the representation lives so likely to be used
              return true;
  
          // Version 1.0
          } else if ( data.profile &&
              data.profile.indexOf("http://library.stanford.edu/iiif/image-api/compliance.html") === 0) {
              return true;
          } else if ( data.identifier && data.width && data.height ) {
              return true;
          } else if ( data.documentElement &&
              "info" == data.documentElement.tagName &&
              "http://library.stanford.edu/iiif/image-api/ns/" ==
                  data.documentElement.namespaceURI) {
              return true;
  
          // Not IIIF
          } else {
              return false;
          }
      },
  
      /**
       *
       * @function
       * @param {Object} data - the raw configuration
       * @example <caption>IIIF 1.1 Info Looks like this</caption>
       * {
       *   "@context" : "http://library.stanford.edu/iiif/image-api/1.1/context.json",
       *   "@id" : "http://iiif.example.com/prefix/1E34750D-38DB-4825-A38A-B60A345E591C",
       *   "width" : 6000,
       *   "height" : 4000,
       *   "scale_factors" : [ 1, 2, 4 ],
       *   "tile_width" : 1024,
       *   "tile_height" : 1024,
       *   "formats" : [ "jpg", "png" ],
       *   "qualities" : [ "native", "grey" ],
       *   "profile" : "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0"
       * }
       */
      configure: function( data, url ){
          // Try to deduce our version and fake it upwards if needed
          if ( !$.isPlainObject(data) ) {
              var options = configureFromXml10( data );
              options['@context'] = "http://iiif.io/api/image/1.0/context.json";
              options['@id'] = url.replace('/info.xml', '');
              options.version = 1;
              return options;
          } else {
              if ( !data['@context'] ) {
                  data['@context'] = 'http://iiif.io/api/image/1.0/context.json';
                  data['@id'] = url.replace('/info.json', '');
                  data.version = 1;
              } else {
                  var context = data['@context'];
                  if (Array.isArray(context)) {
                      for (var i = 0; i < context.length; i++) {
                          if (typeof context[i] === 'string' &&
                              ( /^http:\/\/iiif\.io\/api\/image\/[1-3]\/context\.json$/.test(context[i]) ||
                              context[i] === 'http://library.stanford.edu/iiif/image-api/1.1/context.json' ) ) {
                              context = context[i];
                              break;
                          }
                      }
                  }
                  switch (context) {
                      case 'http://iiif.io/api/image/1/context.json':
                      case 'http://library.stanford.edu/iiif/image-api/1.1/context.json':
                          data.version = 1;
                          break;
                      case 'http://iiif.io/api/image/2/context.json':
                          data.version = 2;
                          break;
                      case 'http://iiif.io/api/image/3/context.json':
                          data.version = 3;
                          break;
                      default:
                          $.console.error('Data has a @context property which contains no known IIIF context URI.');
                  }
              }
              if ( !data['@id'] && data['id'] ) {
                  data['@id'] = data['id'];
              }
              if(data.preferredFormats) {
                  for (var f = 0; f < data.preferredFormats.length; f++ ) {
                      if ( OpenSeadragon.imageFormatSupported(data.preferredFormats[f]) ) {
                          data.tileFormat = data.preferredFormats[f];
                          break;
                      }
                  }
              }
              return data;
          }
      },
  
      /**
       * Return the tileWidth for the given level.
       * @function
       * @param {Number} level
       */
      getTileWidth: function( level ) {
  
          if(this.emulateLegacyImagePyramid) {
              return $.TileSource.prototype.getTileWidth.call(this, level);
          }
  
          var scaleFactor = Math.pow(2, this.maxLevel - level);
  
          if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {
              return this.tileSizePerScaleFactor[scaleFactor].width;
          }
          return this._tileWidth;
      },
  
      /**
       * Return the tileHeight for the given level.
       * @function
       * @param {Number} level
       */
      getTileHeight: function( level ) {
  
          if(this.emulateLegacyImagePyramid) {
              return $.TileSource.prototype.getTileHeight.call(this, level);
          }
  
          var scaleFactor = Math.pow(2, this.maxLevel - level);
  
          if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {
              return this.tileSizePerScaleFactor[scaleFactor].height;
          }
          return this._tileHeight;
      },
  
      /**
       * @function
       * @param {Number} level
       */
      getLevelScale: function ( level ) {
  
          if(this.emulateLegacyImagePyramid) {
              var levelScale = NaN;
              if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
                  levelScale =
                      this.levels[level].width /
                      this.levels[this.maxLevel].width;
              }
              return levelScale;
          }
  
          return $.TileSource.prototype.getLevelScale.call(this, level);
      },
  
      /**
       * @function
       * @param {Number} level
       */
      getNumTiles: function( level ) {
  
          if(this.emulateLegacyImagePyramid) {
              var scale = this.getLevelScale(level);
              if (scale) {
                  return new $.Point(1, 1);
              } else {
                  return new $.Point(0, 0);
              }
          }
  
          return $.TileSource.prototype.getNumTiles.call(this, level);
      },
  
  
      /**
       * @function
       * @param {Number} level
       * @param {OpenSeadragon.Point} point
       */
      getTileAtPoint: function( level, point ) {
  
          if(this.emulateLegacyImagePyramid) {
              return new $.Point(0, 0);
          }
  
          return $.TileSource.prototype.getTileAtPoint.call(this, level, point);
      },
  
  
      /**
       * Responsible for retrieving the url which will return an image for the
       * region specified by the given x, y, and level components.
       * @function
       * @param {Number} level - z index
       * @param {Number} x
       * @param {Number} y
       * @throws {Error}
       */
      getTileUrl: function( level, x, y ){
  
          if(this.emulateLegacyImagePyramid) {
              var url = null;
              if ( this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel ) {
                  url = this.levels[ level ].url;
              }
              return url;
          }
  
          //# constants
          var IIIF_ROTATION = '0',
              //## get the scale (level as a decimal)
              scale = Math.pow( 0.5, this.maxLevel - level ),
  
              //# image dimensions at this level
              levelWidth = Math.ceil( this.width * scale ),
              levelHeight = Math.ceil( this.height * scale ),
  
              //## iiif region
              tileWidth,
              tileHeight,
              iiifTileSizeWidth,
              iiifTileSizeHeight,
              iiifRegion,
              iiifTileX,
              iiifTileY,
              iiifTileW,
              iiifTileH,
              iiifSize,
              iiifSizeW,
              iiifSizeH,
              iiifQuality,
              uri;
  
          tileWidth = this.getTileWidth(level);
          tileHeight = this.getTileHeight(level);
          iiifTileSizeWidth = Math.ceil( tileWidth / scale );
          iiifTileSizeHeight = Math.ceil( tileHeight / scale );
          if (this.version === 1) {
              iiifQuality = "native." + this.tileFormat;
          } else {
              iiifQuality = "default." + this.tileFormat;
          }
          if ( levelWidth < tileWidth && levelHeight < tileHeight ){
              if ( this.version === 2 && levelWidth === this.width ) {
                  iiifSize = "max";
              } else if ( this.version === 3 && levelWidth === this.width && levelHeight === this.height ) {
                  iiifSize = "max";
              } else if ( this.version === 3 ) {
                  iiifSize = levelWidth + "," + levelHeight;
              } else {
                  iiifSize = levelWidth + ",";
              }
              iiifRegion = 'full';
          } else {
              iiifTileX = x * iiifTileSizeWidth;
              iiifTileY = y * iiifTileSizeHeight;
              iiifTileW = Math.min( iiifTileSizeWidth, this.width - iiifTileX );
              iiifTileH = Math.min( iiifTileSizeHeight, this.height - iiifTileY );
              if ( x === 0 && y === 0 && iiifTileW === this.width && iiifTileH === this.height ) {
                  iiifRegion = "full";
              } else {
                  iiifRegion = [ iiifTileX, iiifTileY, iiifTileW, iiifTileH ].join( ',' );
              }
              iiifSizeW = Math.ceil( iiifTileW * scale );
              iiifSizeH = Math.ceil( iiifTileH * scale );
              if ( this.version === 2 && iiifSizeW === this.width ) {
                  iiifSize = "max";
              } else if ( this.version === 3 && iiifSizeW === this.width && iiifSizeH === this.height ) {
                  iiifSize = "max";
              } else if (this.version === 3) {
                  iiifSize = iiifSizeW + "," + iiifSizeH;
              } else {
                  iiifSize = iiifSizeW + ",";
              }
          }
          uri = [ this['@id'], iiifRegion, iiifSize, IIIF_ROTATION, iiifQuality ].join( '/' );
  
          return uri;
      },
  
      __testonly__: {
          canBeTiled: canBeTiled,
          constructLevels: constructLevels
      }
  
    });
  
      /**
       * Determine whether arbitrary tile requests can be made against a service with the given profile
       * @function
       * @param {array} profile - IIIF profile array
       * @throws {Error}
       */
      function canBeTiled ( options ) {
          var level0Profiles = [
              "http://library.stanford.edu/iiif/image-api/compliance.html#level0",
              "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0",
              "http://iiif.io/api/image/2/level0.json",
              "level0",
              "https://iiif.io/api/image/3/level0.json"
          ];
          var profileLevel = Array.isArray(options.profile) ? options.profile[0] : options.profile;
          var isLevel0 = (level0Profiles.indexOf(profileLevel) !== -1);
          var hasCanoncicalSizeFeature = false;
          if ( options.version === 2 && options.profile.length > 1 && options.profile[1].supports ) {
              hasCanoncicalSizeFeature = options.profile[1].supports.indexOf( "sizeByW" ) !== -1;
          }
          if ( options.version === 3 && options.extraFeatures ) {
              hasCanoncicalSizeFeature = options.extraFeatures.indexOf( "sizeByWh" ) !== -1;
          }
          return !isLevel0 || hasCanoncicalSizeFeature;
      }
  
      /**
       * Build the legacy pyramid URLs (one tile per level)
       * @function
       * @param {object} options - infoJson
       * @throws {Error}
       */
      function constructLevels(options) {
          var levels = [];
          for(var i = 0; i < options.sizes.length; i++) {
              levels.push({
                  url: options['@id'] + '/full/' + options.sizes[i].width + ',' +
                      (options.version === 3 ? options.sizes[i].height : '') +
                      '/0/default.' + options.tileFormat,
                  width: options.sizes[i].width,
                  height: options.sizes[i].height
              });
          }
          return levels.sort(function(a, b) {
              return a.width - b.width;
          });
      }
  
  
      function configureFromXml10(xmlDoc) {
          //parse the xml
          if ( !xmlDoc || !xmlDoc.documentElement ) {
              throw new Error( $.getString( "Errors.Xml" ) );
          }
  
          var root            = xmlDoc.documentElement,
              rootName        = root.tagName,
              configuration   = null;
  
          if ( rootName == "info" ) {
              try {
                  configuration = {};
                  parseXML10( root, configuration );
                  return configuration;
  
              } catch ( e ) {
                  throw (e instanceof Error) ?
                      e :
                      new Error( $.getString("Errors.IIIF") );
              }
          }
          throw new Error( $.getString( "Errors.IIIF" ) );
      }
  
      function parseXML10( node, configuration, property ) {
          var i,
              value;
          if ( node.nodeType == 3 && property ) {//text node
              value = node.nodeValue.trim();
              if( value.match(/^\d*$/)){
                  value = Number( value );
              }
              if( !configuration[ property ] ){
                  configuration[ property ] = value;
              }else{
                  if( !$.isArray( configuration[ property ] ) ){
                      configuration[ property ] = [ configuration[ property ] ];
                  }
                  configuration[ property ].push( value );
              }
          } else if( node.nodeType == 1 ){
              for( i = 0; i < node.childNodes.length; i++ ){
                  parseXML10( node.childNodes[ i ], configuration, node.nodeName );
              }
          }
      }
  
  
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - OsmTileSource
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  /*
   * Derived from the OSM tile source in Rainer Simon's seajax-utils project
   * <http://github.com/rsimon/seajax-utils>.  Rainer Simon has contributed
   * the included code to the OpenSeadragon project under the New BSD license;
   * see <https://github.com/openseadragon/openseadragon/issues/58>.
   */
  
  
  (function( $ ){
  
  /**
   * @class OsmTileSource
   * @classdesc A tilesource implementation for OpenStreetMap.<br><br>
   *
   * Note 1. Zoomlevels. Deep Zoom and OSM define zoom levels differently. In  Deep
   * Zoom, level 0 equals an image of 1x1 pixels. In OSM, level 0 equals an image of
   * 256x256 levels (see http://gasi.ch/blog/inside-deep-zoom-2). I.e. there is a
   * difference of log2(256)=8 levels.<br><br>
   *
   * Note 2. Image dimension. According to the OSM Wiki
   * (http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Zoom_levels)
   * the highest Mapnik zoom level has 256.144x256.144 tiles, with a 256x256
   * pixel size. I.e. the Deep Zoom image dimension is 65.572.864x65.572.864
   * pixels.
   *
   * @memberof OpenSeadragon
   * @extends OpenSeadragon.TileSource
   * @param {Number|Object} width - the pixel width of the image or the idiomatic
   *      options object which is used instead of positional arguments.
   * @param {Number} height
   * @param {Number} tileSize
   * @param {Number} tileOverlap
   * @param {String} tilesUrl
   */
  $.OsmTileSource = function( width, height, tileSize, tileOverlap, tilesUrl ) {
      var options;
  
      if( $.isPlainObject( width ) ){
          options = width;
      }else{
          options = {
              width: arguments[0],
              height: arguments[1],
              tileSize: arguments[2],
              tileOverlap: arguments[3],
              tilesUrl: arguments[4]
          };
      }
      //apply default setting for standard public OpenStreatMaps service
      //but allow them to be specified so fliks can host there own instance
      //or apply against other services supportting the same standard
      if( !options.width || !options.height ){
          options.width = 65572864;
          options.height = 65572864;
      }
      if( !options.tileSize ){
          options.tileSize = 256;
          options.tileOverlap = 0;
      }
      if( !options.tilesUrl ){
          options.tilesUrl = "http://tile.openstreetmap.org/";
      }
      options.minLevel = 8;
  
      $.TileSource.apply( this, [ options ] );
  
  };
  
  $.extend( $.OsmTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.OsmTileSource.prototype */{
  
  
      /**
       * Determine if the data and/or url imply the image service is supported by
       * this tile source.
       * @function
       * @param {Object|Array} data
       * @param {String} optional - url
       */
      supports: function( data, url ){
          return (
              data.type &&
              "openstreetmaps" == data.type
          );
      },
  
      /**
       *
       * @function
       * @param {Object} data - the raw configuration
       * @param {String} url - the url the data was retrieved from if any.
       * @return {Object} options - A dictionary of keyword arguments sufficient
       *      to configure this tile sources constructor.
       */
      configure: function( data, url ){
          return data;
      },
  
  
      /**
       * @function
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       */
      getTileUrl: function( level, x, y ) {
          return this.tilesUrl + (level - 8) + "/" + x + "/" + y + ".png";
      }
  });
  
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - TmsTileSource
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  /*
   * Derived from the TMS tile source in Rainer Simon's seajax-utils project
   * <http://github.com/rsimon/seajax-utils>.  Rainer Simon has contributed
   * the included code to the OpenSeadragon project under the New BSD license;
   * see <https://github.com/openseadragon/openseadragon/issues/58>.
   */
  
  
  (function( $ ){
  
  /**
   * @class TmsTileSource
   * @classdesc A tilesource implementation for Tiled Map Services (TMS).
   * TMS tile scheme ( [ as supported by OpenLayers ] is described here
   * ( http://openlayers.org/dev/examples/tms.html ).
   *
   * @memberof OpenSeadragon
   * @extends OpenSeadragon.TileSource
   * @param {Number|Object} width - the pixel width of the image or the idiomatic
   *      options object which is used instead of positional arguments.
   * @param {Number} height
   * @param {Number} tileSize
   * @param {Number} tileOverlap
   * @param {String} tilesUrl
   */
  $.TmsTileSource = function( width, height, tileSize, tileOverlap, tilesUrl ) {
      var options;
  
      if( $.isPlainObject( width ) ){
          options = width;
      }else{
          options = {
              width: arguments[0],
              height: arguments[1],
              tileSize: arguments[2],
              tileOverlap: arguments[3],
              tilesUrl: arguments[4]
          };
      }
      // TMS has integer multiples of 256 for width/height and adds buffer
      // if necessary -> account for this!
      var bufferedWidth = Math.ceil(options.width / 256) * 256,
          bufferedHeight = Math.ceil(options.height / 256) * 256,
          max;
  
      // Compute number of zoomlevels in this tileset
      if (bufferedWidth > bufferedHeight) {
          max = bufferedWidth / 256;
      } else {
          max = bufferedHeight / 256;
      }
      options.maxLevel = Math.ceil(Math.log(max) / Math.log(2)) - 1;
      options.tileSize = 256;
      options.width = bufferedWidth;
      options.height = bufferedHeight;
  
      $.TileSource.apply( this, [ options ] );
  
  };
  
  $.extend( $.TmsTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.TmsTileSource.prototype */{
  
  
      /**
       * Determine if the data and/or url imply the image service is supported by
       * this tile source.
       * @function
       * @param {Object|Array} data
       * @param {String} optional - url
       */
      supports: function( data, url ){
          return ( data.type && "tiledmapservice" == data.type );
      },
  
      /**
       *
       * @function
       * @param {Object} data - the raw configuration
       * @param {String} url - the url the data was retrieved from if any.
       * @return {Object} options - A dictionary of keyword arguments sufficient
       *      to configure this tile sources constructor.
       */
      configure: function( data, url ){
          return data;
      },
  
  
      /**
       * @function
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       */
      getTileUrl: function( level, x, y ) {
          // Convert from Deep Zoom definition to TMS zoom definition
          var yTiles = this.getNumTiles( level ).y - 1;
  
          return this.tilesUrl + level + "/" + x + "/" + (yTiles - y) + ".png";
      }
  });
  
  
  }( OpenSeadragon ));
  
  (function($) {
  
      /**
       * @class ZoomifyTileSource
       * @classdesc A tilesource implementation for the zoomify format.
       *
       * A description of the format can be found here:
       * https://ecommons.cornell.edu/bitstream/handle/1813/5410/Introducing_Zoomify_Image.pdf
       *
       * There are two ways of creating a zoomify tilesource for openseadragon
       *
       * 1) Supplying all necessary information in the tilesource object. A minimal example object for this method looks like this:
       *
       * {
       *      type: "zoomifytileservice",
       *      width: 1000,
       *      height: 1000,
       *      tilesUrl: "/test/data/zoomify/"
       * }
       *
       * The tileSize is currently hardcoded to 256 (the usual Zoomify default). The tileUrl must the path to the image _directory_.
       *
       * 2) Loading image metadata from xml file: (CURRENTLY NOT SUPPORTED)
       *
       * When creating zoomify formatted images one "xml" like file with name ImageProperties.xml
       * will be created as well. Here is an example of such a file:
       *
       * <IMAGE_PROPERTIES WIDTH="1000" HEIGHT="1000" NUMTILES="21" NUMIMAGES="1" VERSION="1.8" TILESIZE="256" />
       *
       * To use this xml file as metadata source you must supply the path to the ImageProperties.xml file and leave out all other parameters:
       * As stated above, this method of loading a zoomify tilesource is currently not supported
       *
       * {
       *      type: "zoomifytileservice",
       *      tilesUrl: "/test/data/zoomify/ImageProperties.xml"
       * }
  
      *
      * @memberof OpenSeadragon
       * @extends OpenSeadragon.TileSource
       * @param {Number} width - the pixel width of the image.
       * @param {Number} height
       * @param {Number} tileSize
       * @param {String} tilesUrl
       */
      $.ZoomifyTileSource = function(options) {
          options.tileSize = 256;
  
          var currentImageSize = {
              x: options.width,
              y: options.height
          };
          options.imageSizes = [{
              x: options.width,
              y: options.height
          }];
          options.gridSize = [this._getGridSize(options.width, options.height, options.tileSize)];
  
          while (parseInt(currentImageSize.x, 10) > options.tileSize || parseInt(currentImageSize.y, 10) > options.tileSize) {
              currentImageSize.x = Math.floor(currentImageSize.x / 2);
              currentImageSize.y = Math.floor(currentImageSize.y / 2);
              options.imageSizes.push({
                  x: currentImageSize.x,
                  y: currentImageSize.y
              });
              options.gridSize.push(this._getGridSize(currentImageSize.x, currentImageSize.y, options.tileSize));
          }
          options.imageSizes.reverse();
          options.gridSize.reverse();
          options.minLevel = 0;
          options.maxLevel = options.gridSize.length - 1;
  
          OpenSeadragon.TileSource.apply(this, [options]);
      };
  
      $.extend($.ZoomifyTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.ZoomifyTileSource.prototype */ {
  
          //private
          _getGridSize: function(width, height, tileSize) {
              return {
                  x: Math.ceil(width / tileSize),
                  y: Math.ceil(height / tileSize)
              };
          },
  
          //private
          _calculateAbsoluteTileNumber: function(level, x, y) {
              var num = 0;
              var size = {};
  
              //Sum up all tiles below the level we want the number of tiles
              for (var z = 0; z < level; z++) {
                  size = this.gridSize[z];
                  num += size.x * size.y;
              }
              //Add the tiles of the level
              size = this.gridSize[level];
              num += size.x * y + x;
              return num;
          },
  
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(data, url) {
              return (data.type && "zoomifytileservice" == data.type);
          },
  
          /**
           *
           * @function
           * @param {Object} data - the raw configuration
           * @param {String} url - the url the data was retrieved from if any.
           * @return {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(data, url) {
              return data;
          },
  
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          getTileUrl: function(level, x, y) {
              //console.log(level);
              var result = 0;
              var num = this._calculateAbsoluteTileNumber(level, x, y);
              result = Math.floor(num / 256);
              return this.tilesUrl + 'TileGroup' + result + '/' + level + '-' + x + '-' + y + '.jpg';
  
          }
      });
  
  }(OpenSeadragon));
  
  
  /*
   * OpenSeadragon - LegacyTileSource
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  /**
   * @class LegacyTileSource
   * @classdesc The LegacyTileSource allows simple, traditional image pyramids to be loaded
   * into an OpenSeadragon Viewer.  Basically, this translates to the historically
   * common practice of starting with a 'master' image, maybe a tiff for example,
   * and generating a set of 'service' images like one or more thumbnails, a medium
   * resolution image and a high resolution image in standard web formats like
   * png or jpg.
   *
   * @memberof OpenSeadragon
   * @extends OpenSeadragon.TileSource
   * @param {Array} levels An array of file descriptions, each is an object with
   *      a 'url', a 'width', and a 'height'.  Overriding classes can expect more
   *      properties but these properties are sufficient for this implementation.
   *      Additionally, the levels are required to be listed in order from
   *      smallest to largest.
   * @property {Number} aspectRatio
   * @property {Number} dimensions
   * @property {Number} tileSize
   * @property {Number} tileOverlap
   * @property {Number} minLevel
   * @property {Number} maxLevel
   * @property {Array}  levels
   */
  $.LegacyTileSource = function( levels ) {
  
      var options,
          width,
          height;
  
      if( $.isArray( levels ) ){
          options = {
              type: 'legacy-image-pyramid',
              levels: levels
          };
      }
  
      //clean up the levels to make sure we support all formats
      options.levels = filterFiles( options.levels );
  
      if ( options.levels.length > 0 ) {
          width = options.levels[ options.levels.length - 1 ].width;
          height = options.levels[ options.levels.length - 1 ].height;
      }
      else {
          width = 0;
          height = 0;
          $.console.error( "No supported image formats found" );
      }
  
      $.extend( true, options, {
          width: width,
          height: height,
          tileSize: Math.max( height, width ),
          tileOverlap: 0,
          minLevel: 0,
          maxLevel: options.levels.length > 0 ? options.levels.length - 1 : 0
      } );
  
      $.TileSource.apply( this, [ options ] );
  
      this.levels = options.levels;
  };
  
  $.extend( $.LegacyTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.LegacyTileSource.prototype */{
      /**
       * Determine if the data and/or url imply the image service is supported by
       * this tile source.
       * @function
       * @param {Object|Array} data
       * @param {String} optional - url
       */
      supports: function( data, url ){
          return (
              data.type &&
              "legacy-image-pyramid" == data.type
          ) || (
              data.documentElement &&
              "legacy-image-pyramid" == data.documentElement.getAttribute('type')
          );
      },
  
  
      /**
       *
       * @function
       * @param {Object|XMLDocument} configuration - the raw configuration
       * @param {String} dataUrl - the url the data was retrieved from if any.
       * @return {Object} options - A dictionary of keyword arguments sufficient
       *      to configure this tile sources constructor.
       */
      configure: function( configuration, dataUrl ){
  
          var options;
  
          if( !$.isPlainObject(configuration) ){
  
              options = configureFromXML( this, configuration );
  
          }else{
  
              options = configureFromObject( this, configuration );
          }
  
          return options;
  
      },
  
      /**
       * @function
       * @param {Number} level
       */
      getLevelScale: function ( level ) {
          var levelScale = NaN;
          if ( this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel ) {
              levelScale =
                  this.levels[ level ].width /
                  this.levels[ this.maxLevel ].width;
          }
          return levelScale;
      },
  
      /**
       * @function
       * @param {Number} level
       */
      getNumTiles: function( level ) {
          var scale = this.getLevelScale( level );
          if ( scale ){
              return new $.Point( 1, 1 );
          } else {
              return new $.Point( 0, 0 );
          }
      },
  
      /**
       * This method is not implemented by this class other than to throw an Error
       * announcing you have to implement it.  Because of the variety of tile
       * server technologies, and various specifications for building image
       * pyramids, this method is here to allow easy integration.
       * @function
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       * @throws {Error}
       */
      getTileUrl: function ( level, x, y ) {
          var url = null;
          if ( this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel ) {
              url = this.levels[ level ].url;
          }
          return url;
      }
  } );
  
  /**
   * This method removes any files from the Array which don't conform to our
   * basic requirements for a 'level' in the LegacyTileSource.
   * @private
   * @inner
   * @function
   */
  function filterFiles( files ){
      var filtered = [],
          file,
          i;
      for( i = 0; i < files.length; i++ ){
          file = files[ i ];
          if( file.height &&
              file.width &&
              file.url ){
              //This is sufficient to serve as a level
              filtered.push({
                  url: file.url,
                  width: Number( file.width ),
                  height: Number( file.height )
              });
          }
          else {
              $.console.error( 'Unsupported image format: %s', file.url ? file.url : '<no URL>' );
          }
      }
  
      return filtered.sort(function(a, b) {
          return a.height - b.height;
      });
  
  }
  
  /**
   * @private
   * @inner
   * @function
   */
  function configureFromXML( tileSource, xmlDoc ){
  
      if ( !xmlDoc || !xmlDoc.documentElement ) {
          throw new Error( $.getString( "Errors.Xml" ) );
      }
  
      var root         = xmlDoc.documentElement,
          rootName     = root.tagName,
          conf         = null,
          levels       = [],
          level,
          i;
  
      if ( rootName == "image" ) {
  
          try {
              conf = {
                  type:        root.getAttribute( "type" ),
                  levels:      []
              };
  
              levels = root.getElementsByTagName( "level" );
              for ( i = 0; i < levels.length; i++ ) {
                  level = levels[ i ];
  
                  conf.levels.push({
                      url:    level.getAttribute( "url" ),
                      width:  parseInt( level.getAttribute( "width" ), 10 ),
                      height: parseInt( level.getAttribute( "height" ), 10 )
                  });
              }
  
              return configureFromObject( tileSource, conf );
  
          } catch ( e ) {
              throw (e instanceof Error) ?
                  e :
                  new Error( 'Unknown error parsing Legacy Image Pyramid XML.' );
          }
      } else if ( rootName == "collection" ) {
          throw new Error( 'Legacy Image Pyramid Collections not yet supported.' );
      } else if ( rootName == "error" ) {
          throw new Error( 'Error: ' + xmlDoc );
      }
  
      throw new Error( 'Unknown element ' + rootName );
  }
  
  /**
   * @private
   * @inner
   * @function
   */
  function configureFromObject( tileSource, configuration ){
  
      return configuration.levels;
  
  }
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - ImageTileSource
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function ($) {
  
      /**
       * @class ImageTileSource
       * @classdesc The ImageTileSource allows a simple image to be loaded
       * into an OpenSeadragon Viewer.
       * There are 2 ways to open an ImageTileSource:
       * 1. viewer.open({type: 'image', url: fooUrl});
       * 2. viewer.open(new OpenSeadragon.ImageTileSource({url: fooUrl}));
       *
       * With the first syntax, the crossOriginPolicy, ajaxWithCredentials and
       * useCanvas options are inherited from the viewer if they are not
       * specified directly in the options object.
       *
       * @memberof OpenSeadragon
       * @extends OpenSeadragon.TileSource
       * @param {Object} options Options object.
       * @param {String} options.url URL of the image
       * @param {Boolean} [options.buildPyramid=true] If set to true (default), a
       * pyramid will be built internally to provide a better downsampling.
       * @param {String|Boolean} [options.crossOriginPolicy=false] Valid values are
       * 'Anonymous', 'use-credentials', and false. If false, image requests will
       * not use CORS preventing internal pyramid building for images from other
       * domains.
       * @param {String|Boolean} [options.ajaxWithCredentials=false] Whether to set
       * the withCredentials XHR flag for AJAX requests (when loading tile sources).
       * @param {Boolean} [options.useCanvas=true] Set to false to prevent any use
       * of the canvas API.
       */
      $.ImageTileSource = function (options) {
  
          options = $.extend({
              buildPyramid: true,
              crossOriginPolicy: false,
              ajaxWithCredentials: false,
              useCanvas: true
          }, options);
          $.TileSource.apply(this, [options]);
  
      };
  
      $.extend($.ImageTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.ImageTileSource.prototype */{
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function (data, url) {
              return data.type && data.type === "image";
          },
          /**
           *
           * @function
           * @param {Object} options - the options
           * @param {String} dataUrl - the url the image was retrieved from, if any.
           * @return {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function (options, dataUrl) {
              return options;
          },
          /**
           * Responsible for retrieving, and caching the
           * image metadata pertinent to this TileSources implementation.
           * @function
           * @param {String} url
           * @throws {Error}
           */
          getImageInfo: function (url) {
              var image = this._image = new Image();
              var _this = this;
  
              if (this.crossOriginPolicy) {
                  image.crossOrigin = this.crossOriginPolicy;
              }
              if (this.ajaxWithCredentials) {
                  image.useCredentials = this.ajaxWithCredentials;
              }
  
              $.addEvent(image, 'load', function () {
                  /* IE8 fix since it has no naturalWidth and naturalHeight */
                  _this.width = Object.prototype.hasOwnProperty.call(image, 'naturalWidth') ? image.naturalWidth : image.width;
                  _this.height = Object.prototype.hasOwnProperty.call(image, 'naturalHeight') ? image.naturalHeight : image.height;
                  _this.aspectRatio = _this.width / _this.height;
                  _this.dimensions = new $.Point(_this.width, _this.height);
                  _this._tileWidth = _this.width;
                  _this._tileHeight = _this.height;
                  _this.tileOverlap = 0;
                  _this.minLevel = 0;
                  _this.levels = _this._buildLevels();
                  _this.maxLevel = _this.levels.length - 1;
  
                  _this.ready = true;
  
                  // Note: this event is documented elsewhere, in TileSource
                  _this.raiseEvent('ready', {tileSource: _this});
              });
  
              $.addEvent(image, 'error', function () {
                  // Note: this event is documented elsewhere, in TileSource
                  _this.raiseEvent('open-failed', {
                      message: "Error loading image at " + url,
                      source: url
                  });
              });
  
              image.src = url;
          },
          /**
           * @function
           * @param {Number} level
           */
          getLevelScale: function (level) {
              var levelScale = NaN;
              if (level >= this.minLevel && level <= this.maxLevel) {
                  levelScale =
                          this.levels[level].width /
                          this.levels[this.maxLevel].width;
              }
              return levelScale;
          },
          /**
           * @function
           * @param {Number} level
           */
          getNumTiles: function (level) {
              var scale = this.getLevelScale(level);
              if (scale) {
                  return new $.Point(1, 1);
              } else {
                  return new $.Point(0, 0);
              }
          },
          /**
           * Retrieves a tile url
           * @function
           * @param {Number} level Level of the tile
           * @param {Number} x x coordinate of the tile
           * @param {Number} y y coordinate of the tile
           */
          getTileUrl: function (level, x, y) {
              var url = null;
              if (level >= this.minLevel && level <= this.maxLevel) {
                  url = this.levels[level].url;
              }
              return url;
          },
          /**
           * Retrieves a tile context 2D
           * @function
           * @param {Number} level Level of the tile
           * @param {Number} x x coordinate of the tile
           * @param {Number} y y coordinate of the tile
           */
          getContext2D: function (level, x, y) {
              var context = null;
              if (level >= this.minLevel && level <= this.maxLevel) {
                  context = this.levels[level].context2D;
              }
              return context;
          },
  
          // private
          //
          // Builds the different levels of the pyramid if possible
          // (i.e. if canvas API enabled and no canvas tainting issue).
          _buildLevels: function () {
              var levels = [{
                      url: this._image.src,
                      /* IE8 fix since it has no naturalWidth and naturalHeight */
                      width: Object.prototype.hasOwnProperty.call(this._image, 'naturalWidth') ? this._image.naturalWidth : this._image.width,
                      height:  Object.prototype.hasOwnProperty.call(this._image, 'naturalHeight') ? this._image.naturalHeight : this._image.height
                  }];
  
              if (!this.buildPyramid || !$.supportsCanvas || !this.useCanvas) {
                  // We don't need the image anymore. Allows it to be GC.
                  delete this._image;
                  return levels;
              }
  
              /* IE8 fix since it has no naturalWidth and naturalHeight */
              var currentWidth = Object.prototype.hasOwnProperty.call(this._image, 'naturalWidth') ? this._image.naturalWidth : this._image.width;
              var currentHeight = Object.prototype.hasOwnProperty.call(this._image, 'naturalHeight') ? this._image.naturalHeight : this._image.height;
  
  
              var bigCanvas = document.createElement("canvas");
              var bigContext = bigCanvas.getContext("2d");
  
              bigCanvas.width = currentWidth;
              bigCanvas.height = currentHeight;
              bigContext.drawImage(this._image, 0, 0, currentWidth, currentHeight);
              // We cache the context of the highest level because the browser
              // is a lot faster at downsampling something it already has
              // downsampled before.
              levels[0].context2D = bigContext;
              // We don't need the image anymore. Allows it to be GC.
              delete this._image;
  
              if ($.isCanvasTainted(bigCanvas)) {
                  // If the canvas is tainted, we can't compute the pyramid.
                  return levels;
              }
  
              // We build smaller levels until either width or height becomes
              // 1 pixel wide.
              while (currentWidth >= 2 && currentHeight >= 2) {
                  currentWidth = Math.floor(currentWidth / 2);
                  currentHeight = Math.floor(currentHeight / 2);
                  var smallCanvas = document.createElement("canvas");
                  var smallContext = smallCanvas.getContext("2d");
                  smallCanvas.width = currentWidth;
                  smallCanvas.height = currentHeight;
                  smallContext.drawImage(bigCanvas, 0, 0, currentWidth, currentHeight);
  
                  levels.splice(0, 0, {
                      context2D: smallContext,
                      width: currentWidth,
                      height: currentHeight
                  });
  
                  bigCanvas = smallCanvas;
                  bigContext = smallContext;
              }
              return levels;
          }
      });
  
  }(OpenSeadragon));
  
  /*
   * OpenSeadragon - TileSourceCollection
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function($) {
  
  // deprecated
  $.TileSourceCollection = function(tileSize, tileSources, rows, layout) {
      $.console.error('TileSourceCollection is deprecated; use World instead');
  };
  
  }(OpenSeadragon));
  
  /*
   * OpenSeadragon - Button
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  /**
   * An enumeration of button states
   * @member ButtonState
   * @memberof OpenSeadragon
   * @static
   * @type {Object}
   * @property {Number} REST
   * @property {Number} GROUP
   * @property {Number} HOVER
   * @property {Number} DOWN
   */
  $.ButtonState = {
      REST:   0,
      GROUP:  1,
      HOVER:  2,
      DOWN:   3
  };
  
  /**
   * @class Button
   * @classdesc Manages events, hover states for individual buttons, tool-tips, as well
   * as fading the buttons out when the user has not interacted with them
   * for a specified period.
   *
   * @memberof OpenSeadragon
   * @extends OpenSeadragon.EventSource
   * @param {Object} options
   * @param {Element} [options.element=null] Element to use as the button. If not specified, an HTML &lt;div&gt; element is created.
   * @param {String} [options.tooltip=null] Provides context help for the button when the
   *  user hovers over it.
   * @param {String} [options.srcRest=null] URL of image to use in 'rest' state.
   * @param {String} [options.srcGroup=null] URL of image to use in 'up' state.
   * @param {String} [options.srcHover=null] URL of image to use in 'hover' state.
   * @param {String} [options.srcDown=null] URL of image to use in 'down' state.
   * @param {Number} [options.fadeDelay=0] How long to wait before fading.
   * @param {Number} [options.fadeLength=2000] How long should it take to fade the button.
   * @param {OpenSeadragon.EventHandler} [options.onPress=null] Event handler callback for {@link OpenSeadragon.Button.event:press}.
   * @param {OpenSeadragon.EventHandler} [options.onRelease=null] Event handler callback for {@link OpenSeadragon.Button.event:release}.
   * @param {OpenSeadragon.EventHandler} [options.onClick=null] Event handler callback for {@link OpenSeadragon.Button.event:click}.
   * @param {OpenSeadragon.EventHandler} [options.onEnter=null] Event handler callback for {@link OpenSeadragon.Button.event:enter}.
   * @param {OpenSeadragon.EventHandler} [options.onExit=null] Event handler callback for {@link OpenSeadragon.Button.event:exit}.
   * @param {OpenSeadragon.EventHandler} [options.onFocus=null] Event handler callback for {@link OpenSeadragon.Button.event:focus}.
   * @param {OpenSeadragon.EventHandler} [options.onBlur=null] Event handler callback for {@link OpenSeadragon.Button.event:blur}.
   */
  $.Button = function( options ) {
  
      var _this = this;
  
      $.EventSource.call( this );
  
      $.extend( true, this, {
  
          tooltip:            null,
          srcRest:            null,
          srcGroup:           null,
          srcHover:           null,
          srcDown:            null,
          clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold,
          clickDistThreshold: $.DEFAULT_SETTINGS.clickDistThreshold,
          /**
           * How long to wait before fading.
           * @member {Number} fadeDelay
           * @memberof OpenSeadragon.Button#
           */
          fadeDelay:          0,
          /**
           * How long should it take to fade the button.
           * @member {Number} fadeLength
           * @memberof OpenSeadragon.Button#
           */
          fadeLength:         2000,
          onPress:            null,
          onRelease:          null,
          onClick:            null,
          onEnter:            null,
          onExit:             null,
          onFocus:            null,
          onBlur:             null
  
      }, options );
  
      /**
       * The button element.
       * @member {Element} element
       * @memberof OpenSeadragon.Button#
       */
      this.element = options.element || $.makeNeutralElement("div");
  
      //if the user has specified the element to bind the control to explicitly
      //then do not add the default control images
      if ( !options.element ) {
          this.imgRest      = $.makeTransparentImage( this.srcRest );
          this.imgGroup     = $.makeTransparentImage( this.srcGroup );
          this.imgHover     = $.makeTransparentImage( this.srcHover );
          this.imgDown      = $.makeTransparentImage( this.srcDown );
  
          this.imgRest.alt  =
          this.imgGroup.alt =
          this.imgHover.alt =
          this.imgDown.alt  =
              this.tooltip;
  
          this.element.style.position = "relative";
          $.setElementTouchActionNone( this.element );
  
          this.imgGroup.style.position =
          this.imgHover.style.position =
          this.imgDown.style.position  =
              "absolute";
  
          this.imgGroup.style.top =
          this.imgHover.style.top =
          this.imgDown.style.top  =
              "0px";
  
          this.imgGroup.style.left =
          this.imgHover.style.left =
          this.imgDown.style.left  =
              "0px";
  
          this.imgHover.style.visibility =
          this.imgDown.style.visibility  =
              "hidden";
  
          if ($.Browser.vendor == $.BROWSERS.FIREFOX && $.Browser.version < 3) {
              this.imgGroup.style.top =
              this.imgHover.style.top =
              this.imgDown.style.top  =
                  "";
          }
  
          this.element.appendChild( this.imgRest );
          this.element.appendChild( this.imgGroup );
          this.element.appendChild( this.imgHover );
          this.element.appendChild( this.imgDown );
      }
  
  
      this.addHandler("press", this.onPress);
      this.addHandler("release", this.onRelease);
      this.addHandler("click", this.onClick);
      this.addHandler("enter", this.onEnter);
      this.addHandler("exit", this.onExit);
      this.addHandler("focus", this.onFocus);
      this.addHandler("blur", this.onBlur);
  
      /**
       * The button's current state.
       * @member {OpenSeadragon.ButtonState} currentState
       * @memberof OpenSeadragon.Button#
       */
      this.currentState = $.ButtonState.GROUP;
  
      // When the button last began to fade.
      this.fadeBeginTime  = null;
      // Whether this button should fade after user stops interacting with the viewport.
      this.shouldFade     = false;
  
      this.element.style.display  = "inline-block";
      this.element.style.position = "relative";
      this.element.title          = this.tooltip;
  
      /**
       * Tracks mouse/touch/key events on the button.
       * @member {OpenSeadragon.MouseTracker} tracker
       * @memberof OpenSeadragon.Button#
       */
      this.tracker = new $.MouseTracker({
  
          element:            this.element,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
  
          enterHandler: function( event ) {
              if ( event.insideElementPressed ) {
                  inTo( _this, $.ButtonState.DOWN );
                  /**
                   * Raised when the cursor enters the Button element.
                   *
                   * @event enter
                   * @memberof OpenSeadragon.Button
                   * @type {object}
                   * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
                   * @property {Object} originalEvent - The original DOM event.
                   * @property {?Object} userData - Arbitrary subscriber-defined object.
                   */
                  _this.raiseEvent( "enter", { originalEvent: event.originalEvent } );
              } else if ( !event.buttonDownAny ) {
                  inTo( _this, $.ButtonState.HOVER );
              }
          },
  
          focusHandler: function ( event ) {
              this.enterHandler( event );
              /**
               * Raised when the Button element receives focus.
               *
               * @event focus
               * @memberof OpenSeadragon.Button
               * @type {object}
               * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
               * @property {Object} originalEvent - The original DOM event.
               * @property {?Object} userData - Arbitrary subscriber-defined object.
               */
              _this.raiseEvent( "focus", { originalEvent: event.originalEvent } );
          },
  
          exitHandler: function( event ) {
              outTo( _this, $.ButtonState.GROUP );
              if ( event.insideElementPressed ) {
                  /**
                   * Raised when the cursor leaves the Button element.
                   *
                   * @event exit
                   * @memberof OpenSeadragon.Button
                   * @type {object}
                   * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
                   * @property {Object} originalEvent - The original DOM event.
                   * @property {?Object} userData - Arbitrary subscriber-defined object.
                   */
                  _this.raiseEvent( "exit", { originalEvent: event.originalEvent } );
              }
          },
  
          blurHandler: function ( event ) {
              this.exitHandler( event );
              /**
               * Raised when the Button element loses focus.
               *
               * @event blur
               * @memberof OpenSeadragon.Button
               * @type {object}
               * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
               * @property {Object} originalEvent - The original DOM event.
               * @property {?Object} userData - Arbitrary subscriber-defined object.
               */
              _this.raiseEvent( "blur", { originalEvent: event.originalEvent } );
          },
  
          pressHandler: function ( event ) {
              inTo( _this, $.ButtonState.DOWN );
              /**
               * Raised when a mouse button is pressed or touch occurs in the Button element.
               *
               * @event press
               * @memberof OpenSeadragon.Button
               * @type {object}
               * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
               * @property {Object} originalEvent - The original DOM event.
               * @property {?Object} userData - Arbitrary subscriber-defined object.
               */
              _this.raiseEvent( "press", { originalEvent: event.originalEvent } );
          },
  
          releaseHandler: function( event ) {
              if ( event.insideElementPressed && event.insideElementReleased ) {
                  outTo( _this, $.ButtonState.HOVER );
                  /**
                   * Raised when the mouse button is released or touch ends in the Button element.
                   *
                   * @event release
                   * @memberof OpenSeadragon.Button
                   * @type {object}
                   * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
                   * @property {Object} originalEvent - The original DOM event.
                   * @property {?Object} userData - Arbitrary subscriber-defined object.
                   */
                  _this.raiseEvent( "release", { originalEvent: event.originalEvent } );
              } else if ( event.insideElementPressed ) {
                  outTo( _this, $.ButtonState.GROUP );
              } else {
                  inTo( _this, $.ButtonState.HOVER );
              }
          },
  
          clickHandler: function( event ) {
              if ( event.quick ) {
                  /**
                   * Raised when a mouse button is pressed and released or touch is initiated and ended in the Button element within the time and distance threshold.
                   *
                   * @event click
                   * @memberof OpenSeadragon.Button
                   * @type {object}
                   * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
                   * @property {Object} originalEvent - The original DOM event.
                   * @property {?Object} userData - Arbitrary subscriber-defined object.
                   */
                  _this.raiseEvent("click", { originalEvent: event.originalEvent });
              }
          },
  
          keyHandler: function( event ){
              //console.log( "%s : handling key %s!", _this.tooltip, event.keyCode);
              if( 13 === event.keyCode ){
                  /***
                   * Raised when a mouse button is pressed and released or touch is initiated and ended in the Button element within the time and distance threshold.
                   *
                   * @event click
                   * @memberof OpenSeadragon.Button
                   * @type {object}
                   * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
                   * @property {Object} originalEvent - The original DOM event.
                   * @property {?Object} userData - Arbitrary subscriber-defined object.
                   */
                  _this.raiseEvent( "click", { originalEvent: event.originalEvent } );
                  /***
                   * Raised when the mouse button is released or touch ends in the Button element.
                   *
                   * @event release
                   * @memberof OpenSeadragon.Button
                   * @type {object}
                   * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
                   * @property {Object} originalEvent - The original DOM event.
                   * @property {?Object} userData - Arbitrary subscriber-defined object.
                   */
                  _this.raiseEvent( "release", { originalEvent: event.originalEvent } );
                  return false;
              }
              return true;
          }
  
      });
  
      outTo( this, $.ButtonState.REST );
  };
  
  $.extend( $.Button.prototype, $.EventSource.prototype, /** @lends OpenSeadragon.Button.prototype */{
  
      /**
       * TODO: Determine what this function is intended to do and if it's actually
       * useful as an API point.
       * @function
       */
      notifyGroupEnter: function() {
          inTo( this, $.ButtonState.GROUP );
      },
  
      /**
       * TODO: Determine what this function is intended to do and if it's actually
       * useful as an API point.
       * @function
       */
      notifyGroupExit: function() {
          outTo( this, $.ButtonState.REST );
      },
  
      /**
       * @function
       */
      disable: function(){
          this.notifyGroupExit();
          this.element.disabled = true;
          $.setElementOpacity( this.element, 0.2, true );
      },
  
      /**
       * @function
       */
      enable: function(){
          this.element.disabled = false;
          $.setElementOpacity( this.element, 1.0, true );
          this.notifyGroupEnter();
      }
  
  });
  
  
  function scheduleFade( button ) {
      $.requestAnimationFrame(function(){
          updateFade( button );
      });
  }
  
  function updateFade( button ) {
      var currentTime,
          deltaTime,
          opacity;
  
      if ( button.shouldFade ) {
          currentTime = $.now();
          deltaTime   = currentTime - button.fadeBeginTime;
          opacity     = 1.0 - deltaTime / button.fadeLength;
          opacity     = Math.min( 1.0, opacity );
          opacity     = Math.max( 0.0, opacity );
  
          if( button.imgGroup ){
              $.setElementOpacity( button.imgGroup, opacity, true );
          }
          if ( opacity > 0 ) {
              // fade again
              scheduleFade( button );
          }
      }
  }
  
  function beginFading( button ) {
      button.shouldFade = true;
      button.fadeBeginTime = $.now() + button.fadeDelay;
      window.setTimeout( function(){
          scheduleFade( button );
      }, button.fadeDelay );
  }
  
  function stopFading( button ) {
      button.shouldFade = false;
      if( button.imgGroup ){
          $.setElementOpacity( button.imgGroup, 1.0, true );
      }
  }
  
  function inTo( button, newState ) {
  
      if( button.element.disabled ){
          return;
      }
  
      if ( newState >= $.ButtonState.GROUP &&
           button.currentState == $.ButtonState.REST ) {
          stopFading( button );
          button.currentState = $.ButtonState.GROUP;
      }
  
      if ( newState >= $.ButtonState.HOVER &&
           button.currentState == $.ButtonState.GROUP ) {
          if( button.imgHover ){
              button.imgHover.style.visibility = "";
          }
          button.currentState = $.ButtonState.HOVER;
      }
  
      if ( newState >= $.ButtonState.DOWN &&
           button.currentState == $.ButtonState.HOVER ) {
          if( button.imgDown ){
              button.imgDown.style.visibility = "";
          }
          button.currentState = $.ButtonState.DOWN;
      }
  }
  
  
  function outTo( button, newState ) {
  
      if( button.element.disabled ){
          return;
      }
  
      if ( newState <= $.ButtonState.HOVER &&
           button.currentState == $.ButtonState.DOWN ) {
          if( button.imgDown ){
              button.imgDown.style.visibility = "hidden";
          }
          button.currentState = $.ButtonState.HOVER;
      }
  
      if ( newState <= $.ButtonState.GROUP &&
           button.currentState == $.ButtonState.HOVER ) {
          if( button.imgHover ){
              button.imgHover.style.visibility = "hidden";
          }
          button.currentState = $.ButtonState.GROUP;
      }
  
      if ( newState <= $.ButtonState.REST &&
           button.currentState == $.ButtonState.GROUP ) {
          beginFading( button );
          button.currentState = $.ButtonState.REST;
      }
  }
  
  
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - ButtonGroup
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  /**
   * @class ButtonGroup
   * @classdesc Manages events on groups of buttons.
   *
   * @memberof OpenSeadragon
   * @param {Object} options - A dictionary of settings applied against the entire group of buttons.
   * @param {Array} options.buttons Array of buttons
   * @param {Element} [options.element] Element to use as the container
   **/
  $.ButtonGroup = function( options ) {
  
      $.extend( true, this, {
          /**
           * An array containing the buttons themselves.
           * @member {Array} buttons
           * @memberof OpenSeadragon.ButtonGroup#
           */
          buttons:            [],
          clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold,
          clickDistThreshold: $.DEFAULT_SETTINGS.clickDistThreshold,
          labelText:          ""
      }, options );
  
      // copy the button elements  TODO: Why?
      var buttons = this.buttons.concat([]),
          _this = this,
          i;
  
      /**
       * The shared container for the buttons.
       * @member {Element} element
       * @memberof OpenSeadragon.ButtonGroup#
       */
      this.element = options.element || $.makeNeutralElement( "div" );
  
      // TODO What if there IS an options.group specified?
      if( !options.group ){
          this.element.style.display = "inline-block";
          //this.label   = $.makeNeutralElement( "label" );
          //TODO: support labels for ButtonGroups
          //this.label.innerHTML = this.labelText;
          //this.element.appendChild( this.label );
          for ( i = 0; i < buttons.length; i++ ) {
              this.element.appendChild( buttons[ i ].element );
          }
      }
  
      $.setElementTouchActionNone( this.element );
  
      /**
       * Tracks mouse/touch/key events across the group of buttons.
       * @member {OpenSeadragon.MouseTracker} tracker
       * @memberof OpenSeadragon.ButtonGroup#
       */
      this.tracker = new $.MouseTracker({
          element:            this.element,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
          enterHandler: function ( event ) {
              var i;
              for ( i = 0; i < _this.buttons.length; i++ ) {
                  _this.buttons[ i ].notifyGroupEnter();
              }
          },
          exitHandler: function ( event ) {
              var i;
              if ( !event.insideElementPressed ) {
                  for ( i = 0; i < _this.buttons.length; i++ ) {
                      _this.buttons[ i ].notifyGroupExit();
                  }
              }
          },
      });
  };
  
  /** @lends OpenSeadragon.ButtonGroup.prototype */
  $.ButtonGroup.prototype = {
  
      /**
       * TODO: Figure out why this is used on the public API and if a more useful
       * api can be created.
       * @function
       * @private
       */
      emulateEnter: function() {
          this.tracker.enterHandler( { eventSource: this.tracker } );
      },
  
      /**
       * TODO: Figure out why this is used on the public API and if a more useful
       * api can be created.
       * @function
       * @private
       */
      emulateExit: function() {
          this.tracker.exitHandler( { eventSource: this.tracker } );
      }
  };
  
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - Rect
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function($) {
  
  /**
   * @class Rect
   * @classdesc A Rectangle is described by it top left coordinates (x, y), width,
   * height and degrees of rotation around (x, y).
   * Note that the coordinate system used is the one commonly used with images:
   * x increases when going to the right
   * y increases when going to the bottom
   * degrees increases clockwise with 0 being the horizontal
   *
   * The constructor normalizes the rectangle to always have 0 <= degrees < 90
   *
   * @memberof OpenSeadragon
   * @param {Number} [x=0] The vector component 'x'.
   * @param {Number} [y=0] The vector component 'y'.
   * @param {Number} [width=0] The vector component 'width'.
   * @param {Number} [height=0] The vector component 'height'.
   * @param {Number} [degrees=0] Rotation of the rectangle around (x,y) in degrees.
   */
  $.Rect = function(x, y, width, height, degrees) {
      /**
       * The vector component 'x'.
       * @member {Number} x
       * @memberof OpenSeadragon.Rect#
       */
      this.x = typeof (x) === "number" ? x : 0;
      /**
       * The vector component 'y'.
       * @member {Number} y
       * @memberof OpenSeadragon.Rect#
       */
      this.y = typeof (y) === "number" ? y : 0;
      /**
       * The vector component 'width'.
       * @member {Number} width
       * @memberof OpenSeadragon.Rect#
       */
      this.width  = typeof (width) === "number" ? width : 0;
      /**
       * The vector component 'height'.
       * @member {Number} height
       * @memberof OpenSeadragon.Rect#
       */
      this.height = typeof (height) === "number" ? height : 0;
  
      /**
       * The rotation of the rectangle, in degrees.
       * @member {Number} degrees
       * @memberof OpenSeadragon.Rect#
       */
      this.degrees = typeof (degrees) === "number" ? degrees : 0;
  
      // Normalizes the rectangle.
      this.degrees = $.positiveModulo(this.degrees, 360);
      var newTopLeft, newWidth;
      if (this.degrees >= 270) {
          newTopLeft = this.getTopRight();
          this.x = newTopLeft.x;
          this.y = newTopLeft.y;
          newWidth = this.height;
          this.height = this.width;
          this.width = newWidth;
          this.degrees -= 270;
      } else if (this.degrees >= 180) {
          newTopLeft = this.getBottomRight();
          this.x = newTopLeft.x;
          this.y = newTopLeft.y;
          this.degrees -= 180;
      } else if (this.degrees >= 90) {
          newTopLeft = this.getBottomLeft();
          this.x = newTopLeft.x;
          this.y = newTopLeft.y;
          newWidth = this.height;
          this.height = this.width;
          this.width = newWidth;
          this.degrees -= 90;
      }
  };
  
  /**
   * Builds a rectangle having the 3 specified points as summits.
   * @static
   * @memberof OpenSeadragon.Rect
   * @param {OpenSeadragon.Point} topLeft
   * @param {OpenSeadragon.Point} topRight
   * @param {OpenSeadragon.Point} bottomLeft
   * @returns {OpenSeadragon.Rect}
   */
  $.Rect.fromSummits = function(topLeft, topRight, bottomLeft) {
      var width = topLeft.distanceTo(topRight);
      var height = topLeft.distanceTo(bottomLeft);
      var diff = topRight.minus(topLeft);
      var radians = Math.atan(diff.y / diff.x);
      if (diff.x < 0) {
          radians += Math.PI;
      } else if (diff.y < 0) {
          radians += 2 * Math.PI;
      }
      return new $.Rect(
          topLeft.x,
          topLeft.y,
          width,
          height,
          radians / Math.PI * 180);
  };
  
  /** @lends OpenSeadragon.Rect.prototype */
  $.Rect.prototype = {
      /**
       * @function
       * @returns {OpenSeadragon.Rect} a duplicate of this Rect
       */
      clone: function() {
          return new $.Rect(
              this.x,
              this.y,
              this.width,
              this.height,
              this.degrees);
      },
  
      /**
       * The aspect ratio is simply the ratio of width to height.
       * @function
       * @returns {Number} The ratio of width to height.
       */
      getAspectRatio: function() {
          return this.width / this.height;
      },
  
      /**
       * Provides the coordinates of the upper-left corner of the rectangle as a
       * point.
       * @function
       * @returns {OpenSeadragon.Point} The coordinate of the upper-left corner of
       *  the rectangle.
       */
      getTopLeft: function() {
          return new $.Point(
              this.x,
              this.y
          );
      },
  
      /**
       * Provides the coordinates of the bottom-right corner of the rectangle as a
       * point.
       * @function
       * @returns {OpenSeadragon.Point} The coordinate of the bottom-right corner of
       *  the rectangle.
       */
      getBottomRight: function() {
          return new $.Point(this.x + this.width, this.y + this.height)
              .rotate(this.degrees, this.getTopLeft());
      },
  
      /**
       * Provides the coordinates of the top-right corner of the rectangle as a
       * point.
       * @function
       * @returns {OpenSeadragon.Point} The coordinate of the top-right corner of
       *  the rectangle.
       */
      getTopRight: function() {
          return new $.Point(this.x + this.width, this.y)
              .rotate(this.degrees, this.getTopLeft());
      },
  
      /**
       * Provides the coordinates of the bottom-left corner of the rectangle as a
       * point.
       * @function
       * @returns {OpenSeadragon.Point} The coordinate of the bottom-left corner of
       *  the rectangle.
       */
      getBottomLeft: function() {
          return new $.Point(this.x, this.y + this.height)
              .rotate(this.degrees, this.getTopLeft());
      },
  
      /**
       * Computes the center of the rectangle.
       * @function
       * @returns {OpenSeadragon.Point} The center of the rectangle as represented
       *  as represented by a 2-dimensional vector (x,y)
       */
      getCenter: function() {
          return new $.Point(
              this.x + this.width / 2.0,
              this.y + this.height / 2.0
          ).rotate(this.degrees, this.getTopLeft());
      },
  
      /**
       * Returns the width and height component as a vector OpenSeadragon.Point
       * @function
       * @returns {OpenSeadragon.Point} The 2 dimensional vector representing the
       *  the width and height of the rectangle.
       */
      getSize: function() {
          return new $.Point(this.width, this.height);
      },
  
      /**
       * Determines if two Rectangles have equivalent components.
       * @function
       * @param {OpenSeadragon.Rect} rectangle The Rectangle to compare to.
       * @return {Boolean} 'true' if all components are equal, otherwise 'false'.
       */
      equals: function(other) {
          return (other instanceof $.Rect) &&
              this.x === other.x &&
              this.y === other.y &&
              this.width === other.width &&
              this.height === other.height &&
              this.degrees === other.degrees;
      },
  
      /**
      * Multiply all dimensions (except degrees) in this Rect by a factor and
      * return a new Rect.
      * @function
      * @param {Number} factor The factor to multiply vector components.
      * @returns {OpenSeadragon.Rect} A new rect representing the multiplication
      *  of the vector components by the factor
      */
      times: function(factor) {
          return new $.Rect(
              this.x * factor,
              this.y * factor,
              this.width * factor,
              this.height * factor,
              this.degrees);
      },
  
      /**
      * Translate/move this Rect by a vector and return new Rect.
      * @function
      * @param {OpenSeadragon.Point} delta The translation vector.
      * @returns {OpenSeadragon.Rect} A new rect with altered position
      */
      translate: function(delta) {
          return new $.Rect(
              this.x + delta.x,
              this.y + delta.y,
              this.width,
              this.height,
              this.degrees);
      },
  
      /**
       * Returns the smallest rectangle that will contain this and the given
       * rectangle bounding boxes.
       * @param {OpenSeadragon.Rect} rect
       * @return {OpenSeadragon.Rect} The new rectangle.
       */
      union: function(rect) {
          var thisBoundingBox = this.getBoundingBox();
          var otherBoundingBox = rect.getBoundingBox();
  
          var left = Math.min(thisBoundingBox.x, otherBoundingBox.x);
          var top = Math.min(thisBoundingBox.y, otherBoundingBox.y);
          var right = Math.max(
              thisBoundingBox.x + thisBoundingBox.width,
              otherBoundingBox.x + otherBoundingBox.width);
          var bottom = Math.max(
              thisBoundingBox.y + thisBoundingBox.height,
              otherBoundingBox.y + otherBoundingBox.height);
  
          return new $.Rect(
              left,
              top,
              right - left,
              bottom - top);
      },
  
      /**
       * Returns the bounding box of the intersection of this rectangle with the
       * given rectangle.
       * @param {OpenSeadragon.Rect} rect
       * @return {OpenSeadragon.Rect} the bounding box of the intersection
       * or null if the rectangles don't intersect.
       */
      intersection: function(rect) {
          // Simplified version of Weiler Atherton clipping algorithm
          // https://en.wikipedia.org/wiki/Weiler%E2%80%93Atherton_clipping_algorithm
          // Because we just want the bounding box of the intersection,
          // we can just compute the bounding box of:
          // 1. all the summits of this which are inside rect
          // 2. all the summits of rect which are inside this
          // 3. all the intersections of rect and this
          var EPSILON = 0.0000000001;
  
          var intersectionPoints = [];
  
          var thisTopLeft = this.getTopLeft();
          if (rect.containsPoint(thisTopLeft, EPSILON)) {
              intersectionPoints.push(thisTopLeft);
          }
          var thisTopRight = this.getTopRight();
          if (rect.containsPoint(thisTopRight, EPSILON)) {
              intersectionPoints.push(thisTopRight);
          }
          var thisBottomLeft = this.getBottomLeft();
          if (rect.containsPoint(thisBottomLeft, EPSILON)) {
              intersectionPoints.push(thisBottomLeft);
          }
          var thisBottomRight = this.getBottomRight();
          if (rect.containsPoint(thisBottomRight, EPSILON)) {
              intersectionPoints.push(thisBottomRight);
          }
  
          var rectTopLeft = rect.getTopLeft();
          if (this.containsPoint(rectTopLeft, EPSILON)) {
              intersectionPoints.push(rectTopLeft);
          }
          var rectTopRight = rect.getTopRight();
          if (this.containsPoint(rectTopRight, EPSILON)) {
              intersectionPoints.push(rectTopRight);
          }
          var rectBottomLeft = rect.getBottomLeft();
          if (this.containsPoint(rectBottomLeft, EPSILON)) {
              intersectionPoints.push(rectBottomLeft);
          }
          var rectBottomRight = rect.getBottomRight();
          if (this.containsPoint(rectBottomRight, EPSILON)) {
              intersectionPoints.push(rectBottomRight);
          }
  
          var thisSegments = this._getSegments();
          var rectSegments = rect._getSegments();
          for (var i = 0; i < thisSegments.length; i++) {
              var thisSegment = thisSegments[i];
              for (var j = 0; j < rectSegments.length; j++) {
                  var rectSegment = rectSegments[j];
                  var intersect = getIntersection(thisSegment[0], thisSegment[1],
                      rectSegment[0], rectSegment[1]);
                  if (intersect) {
                      intersectionPoints.push(intersect);
                  }
              }
          }
  
          // Get intersection point of segments [a,b] and [c,d]
          function getIntersection(a, b, c, d) {
              // http://stackoverflow.com/a/1968345/1440403
              var abVector = b.minus(a);
              var cdVector = d.minus(c);
  
              var denom = -cdVector.x * abVector.y + abVector.x * cdVector.y;
              if (denom === 0) {
                  return null;
              }
  
              var s = (abVector.x * (a.y - c.y) - abVector.y * (a.x - c.x)) / denom;
              var t = (cdVector.x * (a.y - c.y) - cdVector.y * (a.x - c.x)) / denom;
  
              if (-EPSILON <= s && s <= 1 - EPSILON &&
                  -EPSILON <= t && t <= 1 - EPSILON) {
                  return new $.Point(a.x + t * abVector.x, a.y + t * abVector.y);
              }
              return null;
          }
  
          if (intersectionPoints.length === 0) {
              return null;
          }
  
          var minX = intersectionPoints[0].x;
          var maxX = intersectionPoints[0].x;
          var minY = intersectionPoints[0].y;
          var maxY = intersectionPoints[0].y;
          for (var k = 1; k < intersectionPoints.length; k++) {
              var point = intersectionPoints[k];
              if (point.x < minX) {
                  minX = point.x;
              }
              if (point.x > maxX) {
                  maxX = point.x;
              }
              if (point.y < minY) {
                  minY = point.y;
              }
              if (point.y > maxY) {
                  maxY = point.y;
              }
          }
          return new $.Rect(minX, minY, maxX - minX, maxY - minY);
      },
  
      // private
      _getSegments: function() {
          var topLeft = this.getTopLeft();
          var topRight = this.getTopRight();
          var bottomLeft = this.getBottomLeft();
          var bottomRight = this.getBottomRight();
          return [[topLeft, topRight],
              [topRight, bottomRight],
              [bottomRight, bottomLeft],
              [bottomLeft, topLeft]];
      },
  
      /**
       * Rotates a rectangle around a point.
       * @function
       * @param {Number} degrees The angle in degrees to rotate.
       * @param {OpenSeadragon.Point} [pivot] The point about which to rotate.
       * Defaults to the center of the rectangle.
       * @return {OpenSeadragon.Rect}
       */
      rotate: function(degrees, pivot) {
          degrees = $.positiveModulo(degrees, 360);
          if (degrees === 0) {
              return this.clone();
          }
  
          pivot = pivot || this.getCenter();
          var newTopLeft = this.getTopLeft().rotate(degrees, pivot);
          var newTopRight = this.getTopRight().rotate(degrees, pivot);
  
          var diff = newTopRight.minus(newTopLeft);
          // Handle floating point error
          diff = diff.apply(function(x) {
              var EPSILON = 1e-15;
              return Math.abs(x) < EPSILON ? 0 : x;
          });
          var radians = Math.atan(diff.y / diff.x);
          if (diff.x < 0) {
              radians += Math.PI;
          } else if (diff.y < 0) {
              radians += 2 * Math.PI;
          }
          return new $.Rect(
              newTopLeft.x,
              newTopLeft.y,
              this.width,
              this.height,
              radians / Math.PI * 180);
      },
  
      /**
       * Retrieves the smallest horizontal (degrees=0) rectangle which contains
       * this rectangle.
       * @returns {OpenSeadragon.Rect}
       */
      getBoundingBox: function() {
          if (this.degrees === 0) {
              return this.clone();
          }
          var topLeft = this.getTopLeft();
          var topRight = this.getTopRight();
          var bottomLeft = this.getBottomLeft();
          var bottomRight = this.getBottomRight();
          var minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
          var maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
          var minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
          var maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
          return new $.Rect(
              minX,
              minY,
              maxX - minX,
              maxY - minY);
      },
  
      /**
       * Retrieves the smallest horizontal (degrees=0) rectangle which contains
       * this rectangle and has integers x, y, width and height
       * @returns {OpenSeadragon.Rect}
       */
      getIntegerBoundingBox: function() {
          var boundingBox = this.getBoundingBox();
          var x = Math.floor(boundingBox.x);
          var y = Math.floor(boundingBox.y);
          var width = Math.ceil(boundingBox.width + boundingBox.x - x);
          var height = Math.ceil(boundingBox.height + boundingBox.y - y);
          return new $.Rect(x, y, width, height);
      },
  
      /**
       * Determines whether a point is inside this rectangle (edge included).
       * @function
       * @param {OpenSeadragon.Point} point
       * @param {Number} [epsilon=0] the margin of error allowed
       * @returns {Boolean} true if the point is inside this rectangle, false
       * otherwise.
       */
      containsPoint: function(point, epsilon) {
          epsilon = epsilon || 0;
  
          // See http://stackoverflow.com/a/2752754/1440403 for explanation
          var topLeft = this.getTopLeft();
          var topRight = this.getTopRight();
          var bottomLeft = this.getBottomLeft();
          var topDiff = topRight.minus(topLeft);
          var leftDiff = bottomLeft.minus(topLeft);
  
          return ((point.x - topLeft.x) * topDiff.x +
              (point.y - topLeft.y) * topDiff.y >= -epsilon) &&
  
              ((point.x - topRight.x) * topDiff.x +
              (point.y - topRight.y) * topDiff.y <= epsilon) &&
  
              ((point.x - topLeft.x) * leftDiff.x +
              (point.y - topLeft.y) * leftDiff.y >= -epsilon) &&
  
              ((point.x - bottomLeft.x) * leftDiff.x +
              (point.y - bottomLeft.y) * leftDiff.y <= epsilon);
      },
  
      /**
       * Provides a string representation of the rectangle which is useful for
       * debugging.
       * @function
       * @returns {String} A string representation of the rectangle.
       */
      toString: function() {
          return "[" +
              (Math.round(this.x * 100) / 100) + ", " +
              (Math.round(this.y * 100) / 100) + ", " +
              (Math.round(this.width * 100) / 100) + "x" +
              (Math.round(this.height * 100) / 100) + ", " +
              (Math.round(this.degrees * 100) / 100) + "deg" +
              "]";
      }
  };
  
  
  }(OpenSeadragon));
  
  /*
   * OpenSeadragon - ReferenceStrip
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function ( $ ) {
  
  // dictionary from id to private properties
  var THIS = {};
  
  /**
   *  The CollectionDrawer is a reimplementation if the Drawer API that
   *  focuses on allowing a viewport to be redefined as a collection
   *  of smaller viewports, defined by a clear number of rows and / or
   *  columns of which each item in the matrix of viewports has its own
   *  source.
   *
   *  This idea is a reexpression of the idea of dzi collections
   *  which allows a clearer algorithm to reuse the tile sources already
   *  supported by OpenSeadragon, in heterogenious or homogenious
   *  sequences just like mixed groups already supported by the viewer
   *  for the purpose of image sequnces.
   *
   *  TODO:   The difficult part of this feature is figuring out how to express
   *          this functionality as a combination of the functionality already
   *          provided by Drawer, Viewport, TileSource, and Navigator.  It may
   *          require better abstraction at those points in order to efficiently
   *          reuse those paradigms.
   */
  /**
   * @class ReferenceStrip
   * @memberof OpenSeadragon
   * @param {Object} options
   */
  $.ReferenceStrip = function ( options ) {
  
      var _this       = this,
          viewer      = options.viewer,
          viewerSize  = $.getElementSize( viewer.element ),
          element,
          style,
          i;
  
      //We may need to create a new element and id if they did not
      //provide the id for the existing element
      if ( !options.id ) {
          options.id              = 'referencestrip-' + $.now();
          this.element            = $.makeNeutralElement( "div" );
          this.element.id         = options.id;
          this.element.className  = 'referencestrip';
      }
  
      options = $.extend( true, {
          sizeRatio:  $.DEFAULT_SETTINGS.referenceStripSizeRatio,
          position:   $.DEFAULT_SETTINGS.referenceStripPosition,
          scroll:     $.DEFAULT_SETTINGS.referenceStripScroll,
          clickTimeThreshold:  $.DEFAULT_SETTINGS.clickTimeThreshold
      }, options, {
          //required overrides
          element:                this.element,
          //These need to be overridden to prevent recursion since
          //the navigator is a viewer and a viewer has a navigator
          showNavigator:          false,
          mouseNavEnabled:        false,
          showNavigationControl:  false,
          showSequenceControl:    false
      } );
  
      $.extend( this, options );
      //Private state properties
      THIS[this.id] = {
          "animating":           false
      };
  
      this.minPixelRatio = this.viewer.minPixelRatio;
  
      style = this.element.style;
      style.marginTop     = '0px';
      style.marginRight   = '0px';
      style.marginBottom  = '0px';
      style.marginLeft    = '0px';
      style.left          = '0px';
      style.bottom        = '0px';
      style.border        = '0px';
      style.background    = '#000';
      style.position      = 'relative';
  
      $.setElementTouchActionNone( this.element );
  
      $.setElementOpacity( this.element, 0.8 );
  
      this.viewer = viewer;
      this.innerTracker = new $.MouseTracker( {
          element:        this.element,
          dragHandler:    $.delegate( this, onStripDrag ),
          scrollHandler:  $.delegate( this, onStripScroll ),
          enterHandler:   $.delegate( this, onStripEnter ),
          exitHandler:    $.delegate( this, onStripExit ),
          keyDownHandler: $.delegate( this, onKeyDown ),
          keyHandler:     $.delegate( this, onKeyPress )
      } );
  
      //Controls the position and orientation of the reference strip and sets the
      //appropriate width and height
      if ( options.width && options.height ) {
          this.element.style.width  = options.width + 'px';
          this.element.style.height = options.height + 'px';
          viewer.addControl(
              this.element,
              { anchor: $.ControlAnchor.BOTTOM_LEFT }
          );
      } else {
          if ( "horizontal" == options.scroll ) {
              this.element.style.width = (
                  viewerSize.x *
                  options.sizeRatio *
                  viewer.tileSources.length
              ) + ( 12 * viewer.tileSources.length ) + 'px';
  
              this.element.style.height = (
                  viewerSize.y *
                  options.sizeRatio
              ) + 'px';
  
              viewer.addControl(
                  this.element,
                  { anchor: $.ControlAnchor.BOTTOM_LEFT }
              );
          } else {
              this.element.style.height = (
                  viewerSize.y *
                  options.sizeRatio *
                  viewer.tileSources.length
              ) + ( 12 * viewer.tileSources.length ) + 'px';
  
              this.element.style.width = (
                  viewerSize.x *
                  options.sizeRatio
              ) + 'px';
  
              viewer.addControl(
                  this.element,
                  { anchor: $.ControlAnchor.TOP_LEFT }
              );
  
          }
      }
  
      this.panelWidth = ( viewerSize.x * this.sizeRatio ) + 8;
      this.panelHeight = ( viewerSize.y * this.sizeRatio ) + 8;
      this.panels = [];
      this.miniViewers = {};
  
      /*jshint loopfunc:true*/
      for ( i = 0; i < viewer.tileSources.length; i++ ) {
  
          element = $.makeNeutralElement( 'div' );
          element.id = this.element.id + "-" + i;
  
          element.style.width         = _this.panelWidth + 'px';
          element.style.height        = _this.panelHeight + 'px';
          element.style.display       = 'inline';
          element.style.float         = 'left'; //Webkit
          element.style.cssFloat      = 'left'; //Firefox
          element.style.styleFloat    = 'left'; //IE
          element.style.padding       = '2px';
          $.setElementTouchActionNone( element );
  
          element.innerTracker = new $.MouseTracker( {
              element:            element,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              pressHandler: function ( event ) {
                  event.eventSource.dragging = $.now();
              },
              releaseHandler: function ( event ) {
                  var tracker = event.eventSource,
                      id      = tracker.element.id,
                      page    = Number( id.split( '-' )[2] ),
                      now     = $.now();
  
                  if ( event.insideElementPressed &&
                       event.insideElementReleased &&
                       tracker.dragging &&
                       ( now - tracker.dragging ) < tracker.clickTimeThreshold ) {
                      tracker.dragging = null;
                      viewer.goToPage( page );
                  }
              }
          } );
  
          this.element.appendChild( element );
  
          element.activePanel = false;
  
          this.panels.push( element );
  
      }
      loadPanels( this, this.scroll == 'vertical' ? viewerSize.y : viewerSize.x, 0 );
      this.setFocus( 0 );
  
  };
  
  $.extend( $.ReferenceStrip.prototype, $.EventSource.prototype, $.Viewer.prototype, /** @lends OpenSeadragon.ReferenceStrip.prototype */{
  
      /**
       * @function
       */
      setFocus: function ( page ) {
          var element      = this.element.querySelector('#' + this.element.id + '-' + page ),
              viewerSize   = $.getElementSize( this.viewer.canvas ),
              scrollWidth  = Number( this.element.style.width.replace( 'px', '' ) ),
              scrollHeight = Number( this.element.style.height.replace( 'px', '' ) ),
              offsetLeft   = -Number( this.element.style.marginLeft.replace( 'px', '' ) ),
              offsetTop    = -Number( this.element.style.marginTop.replace( 'px', '' ) ),
              offset;
  
          if ( this.currentSelected !== element ) {
              if ( this.currentSelected ) {
                  this.currentSelected.style.background = '#000';
              }
              this.currentSelected = element;
              this.currentSelected.style.background = '#999';
  
              if ( 'horizontal' == this.scroll ) {
                  //right left
                  offset = ( Number( page ) ) * ( this.panelWidth + 3 );
                  if ( offset > offsetLeft + viewerSize.x - this.panelWidth ) {
                      offset = Math.min( offset, ( scrollWidth - viewerSize.x ) );
                      this.element.style.marginLeft = -offset + 'px';
                      loadPanels( this, viewerSize.x, -offset );
                  } else if ( offset < offsetLeft ) {
                      offset = Math.max( 0, offset - viewerSize.x / 2 );
                      this.element.style.marginLeft = -offset + 'px';
                      loadPanels( this, viewerSize.x, -offset );
                  }
              } else {
                  offset = ( Number( page ) ) * ( this.panelHeight + 3 );
                  if ( offset > offsetTop + viewerSize.y - this.panelHeight ) {
                      offset = Math.min( offset, ( scrollHeight - viewerSize.y ) );
                      this.element.style.marginTop = -offset + 'px';
                      loadPanels( this, viewerSize.y, -offset );
                  } else if ( offset < offsetTop ) {
                      offset = Math.max( 0, offset - viewerSize.y / 2 );
                      this.element.style.marginTop = -offset + 'px';
                      loadPanels( this, viewerSize.y, -offset );
                  }
              }
  
              this.currentPage = page;
              onStripEnter.call( this, { eventSource: this.innerTracker } );
          }
      },
  
      /**
       * @function
       */
      update: function () {
          if ( THIS[this.id].animating ) {
              $.console.log( 'image reference strip update' );
              return true;
          }
          return false;
      },
  
      // Overrides Viewer.destroy
      destroy: function() {
          if (this.miniViewers) {
            for (var key in this.miniViewers) {
              this.miniViewers[key].destroy();
            }
          }
  
          if (this.element) {
              this.element.parentNode.removeChild(this.element);
          }
      }
  
  } );
  
  
  
  
  /**
   * @private
   * @inner
   * @function
   */
  function onStripDrag( event ) {
  
      var offsetLeft   = Number( this.element.style.marginLeft.replace( 'px', '' ) ),
          offsetTop    = Number( this.element.style.marginTop.replace( 'px', '' ) ),
          scrollWidth  = Number( this.element.style.width.replace( 'px', '' ) ),
          scrollHeight = Number( this.element.style.height.replace( 'px', '' ) ),
          viewerSize   = $.getElementSize( this.viewer.canvas );
      this.dragging = true;
      if ( this.element ) {
          if ( 'horizontal' == this.scroll ) {
              if ( -event.delta.x > 0 ) {
                  //forward
                  if ( offsetLeft > -( scrollWidth - viewerSize.x ) ) {
                      this.element.style.marginLeft = ( offsetLeft + ( event.delta.x * 2 ) ) + 'px';
                      loadPanels( this, viewerSize.x, offsetLeft + ( event.delta.x * 2 ) );
                  }
              } else if ( -event.delta.x < 0 ) {
                  //reverse
                  if ( offsetLeft < 0 ) {
                      this.element.style.marginLeft = ( offsetLeft + ( event.delta.x * 2 ) ) + 'px';
                      loadPanels( this, viewerSize.x, offsetLeft + ( event.delta.x * 2 ) );
                  }
              }
          } else {
              if ( -event.delta.y > 0 ) {
                  //forward
                  if ( offsetTop > -( scrollHeight - viewerSize.y ) ) {
                      this.element.style.marginTop = ( offsetTop + ( event.delta.y * 2 ) ) + 'px';
                      loadPanels( this, viewerSize.y, offsetTop + ( event.delta.y * 2 ) );
                  }
              } else if ( -event.delta.y < 0 ) {
                  //reverse
                  if ( offsetTop < 0 ) {
                      this.element.style.marginTop = ( offsetTop + ( event.delta.y * 2 ) ) + 'px';
                      loadPanels( this, viewerSize.y, offsetTop + ( event.delta.y * 2 ) );
                  }
              }
          }
      }
      return false;
  
  }
  
  
  
  /**
   * @private
   * @inner
   * @function
   */
  function onStripScroll( event ) {
      var offsetLeft   = Number( this.element.style.marginLeft.replace( 'px', '' ) ),
          offsetTop    = Number( this.element.style.marginTop.replace( 'px', '' ) ),
          scrollWidth  = Number( this.element.style.width.replace( 'px', '' ) ),
          scrollHeight = Number( this.element.style.height.replace( 'px', '' ) ),
          viewerSize   = $.getElementSize( this.viewer.canvas );
      if ( this.element ) {
          if ( 'horizontal' == this.scroll ) {
              if ( event.scroll > 0 ) {
                  //forward
                  if ( offsetLeft > -( scrollWidth - viewerSize.x ) ) {
                      this.element.style.marginLeft = ( offsetLeft - ( event.scroll * 60 ) ) + 'px';
                      loadPanels( this, viewerSize.x, offsetLeft - ( event.scroll * 60 ) );
                  }
              } else if ( event.scroll < 0 ) {
                  //reverse
                  if ( offsetLeft < 0 ) {
                      this.element.style.marginLeft = ( offsetLeft - ( event.scroll * 60 ) ) + 'px';
                      loadPanels( this, viewerSize.x, offsetLeft - ( event.scroll * 60 ) );
                  }
              }
          } else {
              if ( event.scroll < 0 ) {
                  //scroll up
                  if ( offsetTop > viewerSize.y - scrollHeight ) {
                      this.element.style.marginTop = ( offsetTop + ( event.scroll * 60 ) ) + 'px';
                      loadPanels( this, viewerSize.y, offsetTop + ( event.scroll * 60 ) );
                  }
              } else if ( event.scroll > 0 ) {
                  //scroll dowm
                  if ( offsetTop < 0 ) {
                      this.element.style.marginTop = ( offsetTop + ( event.scroll * 60 ) ) + 'px';
                      loadPanels( this, viewerSize.y, offsetTop + ( event.scroll * 60 ) );
                  }
              }
          }
      }
      //cancels event
      return false;
  }
  
  
  function loadPanels( strip, viewerSize, scroll ) {
      var panelSize,
          activePanelsStart,
          activePanelsEnd,
          miniViewer,
          style,
          i,
          element;
      if ( 'horizontal' == strip.scroll ) {
          panelSize = strip.panelWidth;
      } else {
          panelSize = strip.panelHeight;
      }
      activePanelsStart = Math.ceil( viewerSize / panelSize ) + 5;
      activePanelsEnd = Math.ceil( ( Math.abs( scroll ) + viewerSize ) / panelSize ) + 1;
      activePanelsStart = activePanelsEnd - activePanelsStart;
      activePanelsStart = activePanelsStart < 0 ? 0 : activePanelsStart;
  
      for ( i = activePanelsStart; i < activePanelsEnd && i < strip.panels.length; i++ ) {
          element = strip.panels[i];
          if ( !element.activePanel ) {
              var miniTileSource;
              var originalTileSource = strip.viewer.tileSources[i];
              if (originalTileSource.referenceStripThumbnailUrl) {
                  miniTileSource = {
                      type: 'image',
                      url: originalTileSource.referenceStripThumbnailUrl
                  };
              } else {
                  miniTileSource = originalTileSource;
              }
              miniViewer = new $.Viewer( {
                  id:                     element.id,
                  tileSources:            [miniTileSource],
                  element:                element,
                  navigatorSizeRatio:     strip.sizeRatio,
                  showNavigator:          false,
                  mouseNavEnabled:        false,
                  showNavigationControl:  false,
                  showSequenceControl:    false,
                  immediateRender:        true,
                  blendTime:              0,
                  animationTime:          0,
                  loadTilesWithAjax:      strip.viewer.loadTilesWithAjax,
                  ajaxHeaders:            strip.viewer.ajaxHeaders,
                  useCanvas:              strip.useCanvas
              } );
  
              miniViewer.displayRegion           = $.makeNeutralElement( "div" );
              miniViewer.displayRegion.id        = element.id + '-displayregion';
              miniViewer.displayRegion.className = 'displayregion';
  
              style               = miniViewer.displayRegion.style;
              style.position      = 'relative';
              style.top           = '0px';
              style.left          = '0px';
              style.fontSize      = '0px';
              style.overflow      = 'hidden';
              style.float         = 'left'; //Webkit
              style.cssFloat      = 'left'; //Firefox
              style.styleFloat    = 'left'; //IE
              style.zIndex        = 999999999;
              style.cursor        = 'default';
              style.width         = ( strip.panelWidth - 4 ) + 'px';
              style.height        = ( strip.panelHeight - 4 ) + 'px';
  
              // TODO: What is this for? Future keyboard navigation support?
              miniViewer.displayRegion.innerTracker = new $.MouseTracker( {
                  element: miniViewer.displayRegion,
                  startDisabled: true
              } );
  
              element.getElementsByTagName( 'div' )[0].appendChild(
                  miniViewer.displayRegion
              );
  
              strip.miniViewers[element.id] = miniViewer;
  
              element.activePanel = true;
          }
      }
  }
  
  
  /**
   * @private
   * @inner
   * @function
   */
  function onStripEnter( event ) {
      var element = event.eventSource.element;
  
      //$.setElementOpacity(element, 0.8);
  
      //element.style.border = '1px solid #555';
      //element.style.background = '#000';
  
      if ( 'horizontal' == this.scroll ) {
  
          //element.style.paddingTop = "0px";
          element.style.marginBottom = "0px";
  
      } else {
  
          //element.style.paddingRight = "0px";
          element.style.marginLeft = "0px";
  
      }
      return false;
  }
  
  
  /**
   * @private
   * @inner
   * @function
   */
  function onStripExit( event ) {
      var element = event.eventSource.element;
  
      if ( 'horizontal' == this.scroll ) {
  
          //element.style.paddingTop = "10px";
          element.style.marginBottom = "-" + ( $.getElementSize( element ).y / 2 ) + "px";
  
      } else {
  
          //element.style.paddingRight = "10px";
          element.style.marginLeft = "-" + ( $.getElementSize( element ).x / 2 ) + "px";
  
      }
      return false;
  }
  
  
  /**
   * @private
   * @inner
   * @function
   */
  function onKeyDown( event ) {
      //console.log( event.keyCode );
  
      if ( !event.preventDefaultAction && !event.ctrl && !event.alt && !event.meta ) {
          switch ( event.keyCode ) {
              case 38: //up arrow
                  onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );
                  return false;
              case 40: //down arrow
                  onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );
                  return false;
              case 37: //left arrow
                  onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );
                  return false;
              case 39: //right arrow
                  onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );
                  return false;
              default:
                  //console.log( 'navigator keycode %s', event.keyCode );
                  return true;
          }
      } else {
          return true;
      }
  }
  
  
  /**
   * @private
   * @inner
   * @function
   */
  function onKeyPress( event ) {
      //console.log( event.keyCode );
  
      if ( !event.preventDefaultAction && !event.ctrl && !event.alt && !event.meta ) {
          switch ( event.keyCode ) {
              case 61: //=|+
                  onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );
                  return false;
              case 45: //-|_
                  onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );
                  return false;
              case 48: //0|)
              case 119: //w
              case 87: //W
                  onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );
                  return false;
              case 115: //s
              case 83: //S
                  onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );
                  return false;
              case 97: //a
                  onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );
                  return false;
              case 100: //d
                  onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );
                  return false;
              default:
                  //console.log( 'navigator keycode %s', event.keyCode );
                  return true;
          }
      } else {
          return true;
      }
  }
  
  }(OpenSeadragon));
  
  /*
   * OpenSeadragon - DisplayRect
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  /**
   * @class DisplayRect
   * @classdesc A display rectangle is very similar to {@link OpenSeadragon.Rect} but adds two
   * fields, 'minLevel' and 'maxLevel' which denote the supported zoom levels
   * for this rectangle.
   *
   * @memberof OpenSeadragon
   * @extends OpenSeadragon.Rect
   * @param {Number} x The vector component 'x'.
   * @param {Number} y The vector component 'y'.
   * @param {Number} width The vector component 'height'.
   * @param {Number} height The vector component 'width'.
   * @param {Number} minLevel The lowest zoom level supported.
   * @param {Number} maxLevel The highest zoom level supported.
   */
  $.DisplayRect = function( x, y, width, height, minLevel, maxLevel ) {
      $.Rect.apply( this, [ x, y, width, height ] );
  
      /**
       * The lowest zoom level supported.
       * @member {Number} minLevel
       * @memberof OpenSeadragon.DisplayRect#
       */
      this.minLevel = minLevel;
      /**
       * The highest zoom level supported.
       * @member {Number} maxLevel
       * @memberof OpenSeadragon.DisplayRect#
       */
      this.maxLevel = maxLevel;
  };
  
  $.extend( $.DisplayRect.prototype, $.Rect.prototype );
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - Spring
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  /**
   * @class Spring
   * @memberof OpenSeadragon
   * @param {Object} options - Spring configuration settings.
   * @param {Number} options.springStiffness - Spring stiffness. Must be greater than zero.
   * The closer to zero, the closer to linear animation.
   * @param {Number} options.animationTime - Animation duration per spring, in seconds.
   * Must be zero or greater.
   * @param {Number} [options.initial=0] - Initial value of spring.
   * @param {Boolean} [options.exponential=false] - Whether this spring represents
   * an exponential scale (such as zoom) and should be animated accordingly. Note that
   * exponential springs must have non-zero values.
   */
  $.Spring = function( options ) {
      var args = arguments;
  
      if( typeof ( options ) != 'object' ){
          //allows backward compatible use of ( initialValue, config ) as
          //constructor parameters
          options = {
              initial: args.length && typeof ( args[ 0 ] ) == "number" ?
                  args[ 0 ] :
                  undefined,
              /**
               * Spring stiffness.
               * @member {Number} springStiffness
               * @memberof OpenSeadragon.Spring#
               */
              springStiffness: args.length > 1 ?
                  args[ 1 ].springStiffness :
                  5.0,
              /**
               * Animation duration per spring.
               * @member {Number} animationTime
               * @memberof OpenSeadragon.Spring#
               */
              animationTime: args.length > 1 ?
                  args[ 1 ].animationTime :
                  1.5
          };
      }
  
      $.console.assert(typeof options.springStiffness === "number" && options.springStiffness !== 0,
          "[OpenSeadragon.Spring] options.springStiffness must be a non-zero number");
  
      $.console.assert(typeof options.animationTime === "number" && options.animationTime >= 0,
          "[OpenSeadragon.Spring] options.animationTime must be a number greater than or equal to 0");
  
      if (options.exponential) {
          this._exponential = true;
          delete options.exponential;
      }
  
      $.extend( true, this, options);
  
      /**
       * @member {Object} current
       * @memberof OpenSeadragon.Spring#
       * @property {Number} value
       * @property {Number} time
       */
      this.current = {
          value: typeof ( this.initial ) == "number" ?
              this.initial :
              (this._exponential ? 0 : 1),
          time:  $.now() // always work in milliseconds
      };
  
      $.console.assert(!this._exponential || this.current.value !== 0,
          "[OpenSeadragon.Spring] value must be non-zero for exponential springs");
  
      /**
       * @member {Object} start
       * @memberof OpenSeadragon.Spring#
       * @property {Number} value
       * @property {Number} time
       */
      this.start = {
          value: this.current.value,
          time:  this.current.time
      };
  
      /**
       * @member {Object} target
       * @memberof OpenSeadragon.Spring#
       * @property {Number} value
       * @property {Number} time
       */
      this.target = {
          value: this.current.value,
          time:  this.current.time
      };
  
      if (this._exponential) {
          this.start._logValue = Math.log(this.start.value);
          this.target._logValue = Math.log(this.target.value);
          this.current._logValue = Math.log(this.current.value);
      }
  };
  
  /** @lends OpenSeadragon.Spring.prototype */
  $.Spring.prototype = {
  
      /**
       * @function
       * @param {Number} target
       */
      resetTo: function( target ) {
          $.console.assert(!this._exponential || target !== 0,
              "[OpenSeadragon.Spring.resetTo] target must be non-zero for exponential springs");
  
          this.start.value = this.target.value = this.current.value = target;
          this.start.time = this.target.time = this.current.time = $.now();
  
          if (this._exponential) {
              this.start._logValue = Math.log(this.start.value);
              this.target._logValue = Math.log(this.target.value);
              this.current._logValue = Math.log(this.current.value);
          }
      },
  
      /**
       * @function
       * @param {Number} target
       */
      springTo: function( target ) {
          $.console.assert(!this._exponential || target !== 0,
              "[OpenSeadragon.Spring.springTo] target must be non-zero for exponential springs");
  
          this.start.value  = this.current.value;
          this.start.time   = this.current.time;
          this.target.value = target;
          this.target.time  = this.start.time + 1000 * this.animationTime;
  
          if (this._exponential) {
              this.start._logValue = Math.log(this.start.value);
              this.target._logValue = Math.log(this.target.value);
          }
      },
  
      /**
       * @function
       * @param {Number} delta
       */
      shiftBy: function( delta ) {
          this.start.value  += delta;
          this.target.value += delta;
  
          if (this._exponential) {
              $.console.assert(this.target.value !== 0 && this.start.value !== 0,
                  "[OpenSeadragon.Spring.shiftBy] spring value must be non-zero for exponential springs");
  
              this.start._logValue = Math.log(this.start.value);
              this.target._logValue = Math.log(this.target.value);
          }
      },
  
      setExponential: function(value) {
          this._exponential = value;
  
          if (this._exponential) {
              $.console.assert(this.current.value !== 0 && this.target.value !== 0 && this.start.value !== 0,
                  "[OpenSeadragon.Spring.setExponential] spring value must be non-zero for exponential springs");
  
              this.start._logValue = Math.log(this.start.value);
              this.target._logValue = Math.log(this.target.value);
              this.current._logValue = Math.log(this.current.value);
          }
      },
  
      /**
       * @function
       * @returns true if the value got updated, false otherwise
       */
      update: function() {
          this.current.time  = $.now();
  
          var startValue, targetValue;
          if (this._exponential) {
              startValue = this.start._logValue;
              targetValue = this.target._logValue;
          } else {
              startValue = this.start.value;
              targetValue = this.target.value;
          }
  
          var currentValue = (this.current.time >= this.target.time) ?
              targetValue :
              startValue +
                  ( targetValue - startValue ) *
                  transform(
                      this.springStiffness,
                      ( this.current.time - this.start.time ) /
                      ( this.target.time - this.start.time )
                  );
  
          var oldValue = this.current.value;
          if (this._exponential) {
              this.current.value = Math.exp(currentValue);
          } else {
              this.current.value = currentValue;
          }
  
          return oldValue != this.current.value;
      },
  
      /**
       * Returns whether the spring is at the target value
       * @function
       * @returns {Boolean} True if at target value, false otherwise
       */
      isAtTargetValue: function() {
          return this.current.value === this.target.value;
      }
  };
  
  /**
   * @private
   */
  function transform( stiffness, x ) {
      return ( 1.0 - Math.exp( stiffness * -x ) ) /
          ( 1.0 - Math.exp( -stiffness ) );
  }
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - ImageLoader
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
  
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function($){
  
  /**
   * @private
   * @class ImageJob
   * @classdesc Handles downloading of a single image.
   * @param {Object} options - Options for this ImageJob.
   * @param {String} [options.src] - URL of image to download.
   * @param {String} [options.loadWithAjax] - Whether to load this image with AJAX.
   * @param {String} [options.ajaxHeaders] - Headers to add to the image request if using AJAX.
   * @param {String} [options.crossOriginPolicy] - CORS policy to use for downloads
   * @param {Function} [options.callback] - Called once image has been downloaded.
   * @param {Function} [options.abort] - Called when this image job is aborted.
   * @param {Number} [options.timeout] - The max number of milliseconds that this image job may take to complete.
   */
  function ImageJob (options) {
  
      $.extend(true, this, {
          timeout: $.DEFAULT_SETTINGS.timeout,
          jobId: null
      }, options);
  
      /**
       * Image object which will contain downloaded image.
       * @member {Image} image
       * @memberof OpenSeadragon.ImageJob#
       */
      this.image = null;
  }
  
  ImageJob.prototype = {
      errorMsg: null,
  
      /**
       * Starts the image job.
       * @method
       */
      start: function(){
          var self = this;
          var selfAbort = this.abort;
  
          this.image = new Image();
  
          this.image.onload = function(){
              self.finish(true);
          };
          this.image.onabort = this.image.onerror = function() {
              self.errorMsg = "Image load aborted";
              self.finish(false);
          };
  
          this.jobId = window.setTimeout(function(){
              self.errorMsg = "Image load exceeded timeout (" + self.timeout + " ms)";
              self.finish(false);
          }, this.timeout);
  
          // Load the tile with an AJAX request if the loadWithAjax option is
          // set. Otherwise load the image by setting the source proprety of the image object.
          if (this.loadWithAjax) {
              this.request = $.makeAjaxRequest({
                  url: this.src,
                  withCredentials: this.ajaxWithCredentials,
                  headers: this.ajaxHeaders,
                  responseType: "arraybuffer",
                  success: function(request) {
                      var blb;
                      // Make the raw data into a blob.
                      // BlobBuilder fallback adapted from
                      // http://stackoverflow.com/questions/15293694/blob-constructor-browser-compatibility
                      try {
                          blb = new window.Blob([request.response]);
                      } catch (e) {
                          var BlobBuilder = (
                              window.BlobBuilder ||
                              window.WebKitBlobBuilder ||
                              window.MozBlobBuilder ||
                              window.MSBlobBuilder
                          );
                          if (e.name === 'TypeError' && BlobBuilder) {
                              var bb = new BlobBuilder();
                              bb.append(request.response);
                              blb = bb.getBlob();
                          }
                      }
                      // If the blob is empty for some reason consider the image load a failure.
                      if (blb.size === 0) {
                          self.errorMsg = "Empty image response.";
                          self.finish(false);
                      }
                      // Create a URL for the blob data and make it the source of the image object.
                      // This will still trigger Image.onload to indicate a successful tile load.
                      var url = (window.URL || window.webkitURL).createObjectURL(blb);
                      self.image.src = url;
                  },
                  error: function(request) {
                      self.errorMsg = "Image load aborted - XHR error";
                      self.finish(false);
                  }
              });
  
              // Provide a function to properly abort the request.
              this.abort = function() {
                  self.request.abort();
  
                  // Call the existing abort function if available
                  if (typeof selfAbort === "function") {
                      selfAbort();
                  }
              };
          } else {
              if (this.crossOriginPolicy !== false) {
                  this.image.crossOrigin = this.crossOriginPolicy;
              }
  
              this.image.src = this.src;
          }
      },
  
      finish: function(successful) {
          this.image.onload = this.image.onerror = this.image.onabort = null;
          if (!successful) {
              this.image = null;
          }
  
          if (this.jobId) {
              window.clearTimeout(this.jobId);
          }
  
          this.callback(this);
      }
  
  };
  
  /**
   * @class ImageLoader
   * @memberof OpenSeadragon
   * @classdesc Handles downloading of a set of images using asynchronous queue pattern.
   * You generally won't have to interact with the ImageLoader directly.
   * @param {Object} options - Options for this ImageLoader.
   * @param {Number} [options.jobLimit] - The number of concurrent image requests. See imageLoaderLimit in {@link OpenSeadragon.Options} for details.
   * @param {Number} [options.timeout] - The max number of milliseconds that an image job may take to complete.
   */
  $.ImageLoader = function(options) {
  
      $.extend(true, this, {
          jobLimit:       $.DEFAULT_SETTINGS.imageLoaderLimit,
          timeout:        $.DEFAULT_SETTINGS.timeout,
          jobQueue:       [],
          jobsInProgress: 0
      }, options);
  
  };
  
  /** @lends OpenSeadragon.ImageLoader.prototype */
  $.ImageLoader.prototype = {
  
      /**
       * Add an unloaded image to the loader queue.
       * @method
       * @param {Object} options - Options for this job.
       * @param {String} [options.src] - URL of image to download.
       * @param {String} [options.loadWithAjax] - Whether to load this image with AJAX.
       * @param {String} [options.ajaxHeaders] - Headers to add to the image request if using AJAX.
       * @param {String|Boolean} [options.crossOriginPolicy] - CORS policy to use for downloads
       * @param {Boolean} [options.ajaxWithCredentials] - Whether to set withCredentials on AJAX
       * requests.
       * @param {Function} [options.callback] - Called once image has been downloaded.
       * @param {Function} [options.abort] - Called when this image job is aborted.
       */
      addJob: function(options) {
          var _this = this,
              complete = function(job) {
                  completeJob(_this, job, options.callback);
              },
              jobOptions = {
                  src: options.src,
                  loadWithAjax: options.loadWithAjax,
                  ajaxHeaders: options.loadWithAjax ? options.ajaxHeaders : null,
                  crossOriginPolicy: options.crossOriginPolicy,
                  ajaxWithCredentials: options.ajaxWithCredentials,
                  callback: complete,
                  abort: options.abort,
                  timeout: this.timeout
              },
              newJob = new ImageJob(jobOptions);
  
          if ( !this.jobLimit || this.jobsInProgress < this.jobLimit ) {
              newJob.start();
              this.jobsInProgress++;
          }
          else {
              this.jobQueue.push( newJob );
          }
      },
  
      /**
       * Clear any unstarted image loading jobs from the queue.
       * @method
       */
      clear: function() {
          for( var i = 0; i < this.jobQueue.length; i++ ) {
              var job = this.jobQueue[i];
              if ( typeof job.abort === "function" ) {
                  job.abort();
              }
          }
  
          this.jobQueue = [];
      }
  };
  
  /**
   * Cleans up ImageJob once completed.
   * @method
   * @private
   * @param loader - ImageLoader used to start job.
   * @param job - The ImageJob that has completed.
   * @param callback - Called once cleanup is finished.
   */
  function completeJob(loader, job, callback) {
      var nextJob;
  
      loader.jobsInProgress--;
  
      if ((!loader.jobLimit || loader.jobsInProgress < loader.jobLimit) && loader.jobQueue.length > 0) {
          nextJob = loader.jobQueue.shift();
          nextJob.start();
          loader.jobsInProgress++;
      }
  
      callback(job.image, job.errorMsg, job.request);
  }
  
  }(OpenSeadragon));
  
  /*
   * OpenSeadragon - Tile
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  /**
   * @class Tile
   * @memberof OpenSeadragon
   * @param {Number} level The zoom level this tile belongs to.
   * @param {Number} x The vector component 'x'.
   * @param {Number} y The vector component 'y'.
   * @param {OpenSeadragon.Rect} bounds Where this tile fits, in normalized
   *      coordinates.
   * @param {Boolean} exists Is this tile a part of a sparse image? ( Also has
   *      this tile failed to load? )
   * @param {String} url The URL of this tile's image.
   * @param {CanvasRenderingContext2D} context2D The context2D of this tile if it
   * is provided directly by the tile source.
   * @param {Boolean} loadWithAjax Whether this tile image should be loaded with an AJAX request .
   * @param {Object} ajaxHeaders The headers to send with this tile's AJAX request (if applicable).
   * @param {OpenSeadragon.Rect} sourceBounds The portion of the tile to use as the source of the
   * drawing operation, in pixels. Note that this only works when drawing with canvas; when drawing
   * with HTML the entire tile is always used.
   */
  $.Tile = function(level, x, y, bounds, exists, url, context2D, loadWithAjax, ajaxHeaders, sourceBounds) {
      /**
       * The zoom level this tile belongs to.
       * @member {Number} level
       * @memberof OpenSeadragon.Tile#
       */
      this.level   = level;
      /**
       * The vector component 'x'.
       * @member {Number} x
       * @memberof OpenSeadragon.Tile#
       */
      this.x       = x;
      /**
       * The vector component 'y'.
       * @member {Number} y
       * @memberof OpenSeadragon.Tile#
       */
      this.y       = y;
      /**
       * Where this tile fits, in normalized coordinates
       * @member {OpenSeadragon.Rect} bounds
       * @memberof OpenSeadragon.Tile#
       */
      this.bounds  = bounds;
      /**
      * The portion of the tile to use as the source of the drawing operation, in pixels. Note that
      * this only works when drawing with canvas; when drawing with HTML the entire tile is always used.
      * @member {OpenSeadragon.Rect} sourceBounds
      * @memberof OpenSeadragon.Tile#
      */
      this.sourceBounds = sourceBounds;
      /**
       * Is this tile a part of a sparse image? Also has this tile failed to load?
       * @member {Boolean} exists
       * @memberof OpenSeadragon.Tile#
       */
      this.exists  = exists;
      /**
       * The URL of this tile's image.
       * @member {String} url
       * @memberof OpenSeadragon.Tile#
       */
      this.url     = url;
      /**
       * The context2D of this tile if it is provided directly by the tile source.
       * @member {CanvasRenderingContext2D} context2D
       * @memberOf OpenSeadragon.Tile#
       */
      this.context2D = context2D;
      /**
       * Whether to load this tile's image with an AJAX request.
       * @member {Boolean} loadWithAjax
       * @memberof OpenSeadragon.Tile#
       */
      this.loadWithAjax = loadWithAjax;
      /**
       * The headers to be used in requesting this tile's image.
       * Only used if loadWithAjax is set to true.
       * @member {Object} ajaxHeaders
       * @memberof OpenSeadragon.Tile#
       */
      this.ajaxHeaders = ajaxHeaders;
      /**
       * The unique cache key for this tile.
       * @member {String} cacheKey
       * @memberof OpenSeadragon.Tile#
       */
      if (this.ajaxHeaders) {
          this.cacheKey = this.url + "+" + JSON.stringify(this.ajaxHeaders);
      } else {
          this.cacheKey = this.url;
      }
      /**
       * Is this tile loaded?
       * @member {Boolean} loaded
       * @memberof OpenSeadragon.Tile#
       */
      this.loaded  = false;
      /**
       * Is this tile loading?
       * @member {Boolean} loading
       * @memberof OpenSeadragon.Tile#
       */
      this.loading = false;
  
      /**
       * The HTML div element for this tile
       * @member {Element} element
       * @memberof OpenSeadragon.Tile#
       */
      this.element    = null;
      /**
       * The HTML img element for this tile.
       * @member {Element} imgElement
       * @memberof OpenSeadragon.Tile#
       */
      this.imgElement = null;
      /**
       * The Image object for this tile.
       * @member {Object} image
       * @memberof OpenSeadragon.Tile#
       */
      this.image      = null;
  
      /**
       * The alias of this.element.style.
       * @member {String} style
       * @memberof OpenSeadragon.Tile#
       */
      this.style      = null;
      /**
       * This tile's position on screen, in pixels.
       * @member {OpenSeadragon.Point} position
       * @memberof OpenSeadragon.Tile#
       */
      this.position   = null;
      /**
       * This tile's size on screen, in pixels.
       * @member {OpenSeadragon.Point} size
       * @memberof OpenSeadragon.Tile#
       */
      this.size       = null;
      /**
       * The start time of this tile's blending.
       * @member {Number} blendStart
       * @memberof OpenSeadragon.Tile#
       */
      this.blendStart = null;
      /**
       * The current opacity this tile should be.
       * @member {Number} opacity
       * @memberof OpenSeadragon.Tile#
       */
      this.opacity    = null;
      /**
       * The squared distance of this tile to the viewport center.
       * Use for comparing tiles.
       * @private
       * @member {Number} squaredDistance
       * @memberof OpenSeadragon.Tile#
       */
      this.squaredDistance   = null;
      /**
       * The visibility score of this tile.
       * @member {Number} visibility
       * @memberof OpenSeadragon.Tile#
       */
      this.visibility = null;
  
      /**
       * Whether this tile is currently being drawn.
       * @member {Boolean} beingDrawn
       * @memberof OpenSeadragon.Tile#
       */
      this.beingDrawn     = false;
  
      /**
       * Timestamp the tile was last touched.
       * @member {Number} lastTouchTime
       * @memberof OpenSeadragon.Tile#
       */
      this.lastTouchTime  = 0;
  
      /**
       * Whether this tile is in the right-most column for its level.
       * @member {Boolean} isRightMost
       * @memberof OpenSeadragon.Tile#
       */
      this.isRightMost = false;
  
      /**
       * Whether this tile is in the bottom-most row for its level.
       * @member {Boolean} isBottomMost
       * @memberof OpenSeadragon.Tile#
       */
      this.isBottomMost = false;
  };
  
  /** @lends OpenSeadragon.Tile.prototype */
  $.Tile.prototype = {
  
      /**
       * Provides a string representation of this tiles level and (x,y)
       * components.
       * @function
       * @returns {String}
       */
      toString: function() {
          return this.level + "/" + this.x + "_" + this.y;
      },
  
      // private
      _hasTransparencyChannel: function() {
          return !!this.context2D || this.url.match('.png');
      },
  
      /**
       * Renders the tile in an html container.
       * @function
       * @param {Element} container
       */
      drawHTML: function( container ) {
          if (!this.cacheImageRecord) {
              $.console.warn(
                  '[Tile.drawHTML] attempting to draw tile %s when it\'s not cached',
                  this.toString());
              return;
          }
  
          if ( !this.loaded ) {
              $.console.warn(
                  "Attempting to draw tile %s when it's not yet loaded.",
                  this.toString()
              );
              return;
          }
  
          //EXPERIMENTAL - trying to figure out how to scale the container
          //               content during animation of the container size.
  
          if ( !this.element ) {
              this.element                              = $.makeNeutralElement( "div" );
              this.imgElement                           = this.cacheImageRecord.getImage().cloneNode();
              this.imgElement.style.msInterpolationMode = "nearest-neighbor";
              this.imgElement.style.width               = "100%";
              this.imgElement.style.height              = "100%";
  
              this.style                     = this.element.style;
              this.style.position            = "absolute";
          }
          if ( this.element.parentNode != container ) {
              container.appendChild( this.element );
          }
          if ( this.imgElement.parentNode != this.element ) {
              this.element.appendChild( this.imgElement );
          }
  
          this.style.top     = this.position.y + "px";
          this.style.left    = this.position.x + "px";
          this.style.height  = this.size.y + "px";
          this.style.width   = this.size.x + "px";
  
          $.setElementOpacity( this.element, this.opacity );
      },
  
      /**
       * Renders the tile in a canvas-based context.
       * @function
       * @param {Canvas} context
       * @param {Function} drawingHandler - Method for firing the drawing event.
       * drawingHandler({context, tile, rendered})
       * where <code>rendered</code> is the context with the pre-drawn image.
       * @param {Number} [scale=1] - Apply a scale to position and size
       * @param {OpenSeadragon.Point} [translate] - A translation vector
       */
      drawCanvas: function( context, drawingHandler, scale, translate ) {
  
          var position = this.position.times($.pixelDensityRatio),
              size     = this.size.times($.pixelDensityRatio),
              rendered;
  
          if (!this.context2D && !this.cacheImageRecord) {
              $.console.warn(
                  '[Tile.drawCanvas] attempting to draw tile %s when it\'s not cached',
                  this.toString());
              return;
          }
  
          rendered = this.context2D || this.cacheImageRecord.getRenderedContext();
  
          if ( !this.loaded || !rendered ){
              $.console.warn(
                  "Attempting to draw tile %s when it's not yet loaded.",
                  this.toString()
              );
  
              return;
          }
  
          context.save();
  
          context.globalAlpha = this.opacity;
  
          if (typeof scale === 'number' && scale !== 1) {
              // draw tile at a different scale
              position = position.times(scale);
              size = size.times(scale);
          }
  
          if (translate instanceof $.Point) {
              // shift tile position slightly
              position = position.plus(translate);
          }
  
          //if we are supposed to be rendering fully opaque rectangle,
          //ie its done fading or fading is turned off, and if we are drawing
          //an image with an alpha channel, then the only way
          //to avoid seeing the tile underneath is to clear the rectangle
          if (context.globalAlpha === 1 && this._hasTransparencyChannel()) {
              //clearing only the inside of the rectangle occupied
              //by the png prevents edge flikering
              context.clearRect(
                  position.x,
                  position.y,
                  size.x,
                  size.y
              );
          }
  
          // This gives the application a chance to make image manipulation
          // changes as we are rendering the image
          drawingHandler({context: context, tile: this, rendered: rendered});
  
          var sourceWidth, sourceHeight;
          if (this.sourceBounds) {
              sourceWidth = Math.min(this.sourceBounds.width, rendered.canvas.width);
              sourceHeight = Math.min(this.sourceBounds.height, rendered.canvas.height);
          } else {
              sourceWidth = rendered.canvas.width;
              sourceHeight = rendered.canvas.height;
          }
  
          context.drawImage(
              rendered.canvas,
              0,
              0,
              sourceWidth,
              sourceHeight,
              position.x,
              position.y,
              size.x,
              size.y
          );
  
          context.restore();
      },
  
      /**
       * Get the ratio between current and original size.
       * @function
       * @return {Float}
       */
      getScaleForEdgeSmoothing: function() {
          var context;
          if (this.cacheImageRecord) {
              context = this.cacheImageRecord.getRenderedContext();
          } else if (this.context2D) {
              context = this.context2D;
          } else {
              $.console.warn(
                  '[Tile.drawCanvas] attempting to get tile scale %s when tile\'s not cached',
                  this.toString());
              return 1;
          }
          return context.canvas.width / (this.size.x * $.pixelDensityRatio);
      },
  
      /**
       * Get a translation vector that when applied to the tile position produces integer coordinates.
       * Needed to avoid swimming and twitching.
       * @function
       * @param {Number} [scale=1] - Scale to be applied to position.
       * @return {OpenSeadragon.Point}
       */
      getTranslationForEdgeSmoothing: function(scale, canvasSize, sketchCanvasSize) {
          // The translation vector must have positive values, otherwise the image goes a bit off
          // the sketch canvas to the top and left and we must use negative coordinates to repaint it
          // to the main canvas. In that case, some browsers throw:
          // INDEX_SIZE_ERR: DOM Exception 1: Index or size was negative, or greater than the allowed value.
          var x = Math.max(1, Math.ceil((sketchCanvasSize.x - canvasSize.x) / 2));
          var y = Math.max(1, Math.ceil((sketchCanvasSize.y - canvasSize.y) / 2));
          return new $.Point(x, y).minus(
              this.position
                  .times($.pixelDensityRatio)
                  .times(scale || 1)
                  .apply(function(x) {
                      return x % 1;
                  })
          );
      },
  
      /**
       * Removes tile from its container.
       * @function
       */
      unload: function() {
          if ( this.imgElement && this.imgElement.parentNode ) {
              this.imgElement.parentNode.removeChild( this.imgElement );
          }
          if ( this.element && this.element.parentNode ) {
              this.element.parentNode.removeChild( this.element );
          }
  
          this.element    = null;
          this.imgElement = null;
          this.loaded     = false;
          this.loading    = false;
      }
  };
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - Overlay
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function($) {
  
      /**
       * An enumeration of positions that an overlay may be assigned relative to
       * the viewport.
       * It is identical to OpenSeadragon.Placement but is kept for backward
       * compatibility.
       * @member OverlayPlacement
       * @memberof OpenSeadragon
       * @see OpenSeadragon.Placement
       * @static
       * @readonly
       * @type {Object}
       * @property {Number} CENTER
       * @property {Number} TOP_LEFT
       * @property {Number} TOP
       * @property {Number} TOP_RIGHT
       * @property {Number} RIGHT
       * @property {Number} BOTTOM_RIGHT
       * @property {Number} BOTTOM
       * @property {Number} BOTTOM_LEFT
       * @property {Number} LEFT
       */
      $.OverlayPlacement = $.Placement;
  
      /**
       * An enumeration of possible ways to handle overlays rotation
       * @member OverlayRotationMode
       * @memberOf OpenSeadragon
       * @static
       * @readonly
       * @property {Number} NO_ROTATION The overlay ignore the viewport rotation.
       * @property {Number} EXACT The overlay use CSS 3 transforms to rotate with
       * the viewport. If the overlay contains text, it will get rotated as well.
       * @property {Number} BOUNDING_BOX The overlay adjusts for rotation by
       * taking the size of the bounding box of the rotated bounds.
       * Only valid for overlays with Rect location and scalable in both directions.
       */
      $.OverlayRotationMode = $.freezeObject({
          NO_ROTATION: 1,
          EXACT: 2,
          BOUNDING_BOX: 3
      });
  
      /**
       * @class Overlay
       * @classdesc Provides a way to float an HTML element on top of the viewer element.
       *
       * @memberof OpenSeadragon
       * @param {Object} options
       * @param {Element} options.element
       * @param {OpenSeadragon.Point|OpenSeadragon.Rect} options.location - The
       * location of the overlay on the image. If a {@link OpenSeadragon.Point}
       * is specified, the overlay will be located at this location with respect
       * to the placement option. If a {@link OpenSeadragon.Rect} is specified,
       * the overlay will be placed at this location with the corresponding width
       * and height and placement TOP_LEFT.
       * @param {OpenSeadragon.Placement} [options.placement=OpenSeadragon.Placement.TOP_LEFT]
       * Defines what part of the overlay should be at the specified options.location
       * @param {OpenSeadragon.Overlay.OnDrawCallback} [options.onDraw]
       * @param {Boolean} [options.checkResize=true] Set to false to avoid to
       * check the size of the overlay every time it is drawn in the directions
       * which are not scaled. It will improve performances but will cause a
       * misalignment if the overlay size changes.
       * @param {Number} [options.width] The width of the overlay in viewport
       * coordinates. If specified, the width of the overlay will be adjusted when
       * the zoom changes.
       * @param {Number} [options.height] The height of the overlay in viewport
       * coordinates. If specified, the height of the overlay will be adjusted when
       * the zoom changes.
       * @param {Boolean} [options.rotationMode=OpenSeadragon.OverlayRotationMode.EXACT]
       * How to handle the rotation of the viewport.
       */
      $.Overlay = function(element, location, placement) {
  
          /**
           * onDraw callback signature used by {@link OpenSeadragon.Overlay}.
           *
           * @callback OnDrawCallback
           * @memberof OpenSeadragon.Overlay
           * @param {OpenSeadragon.Point} position
           * @param {OpenSeadragon.Point} size
           * @param {Element} element
           */
  
          var options;
          if ($.isPlainObject(element)) {
              options = element;
          } else {
              options = {
                  element: element,
                  location: location,
                  placement: placement
              };
          }
  
          this.element = options.element;
          this.style = options.element.style;
          this._init(options);
      };
  
      /** @lends OpenSeadragon.Overlay.prototype */
      $.Overlay.prototype = {
  
          // private
          _init: function(options) {
              this.location = options.location;
              this.placement = options.placement === undefined ?
                  $.Placement.TOP_LEFT : options.placement;
              this.onDraw = options.onDraw;
              this.checkResize = options.checkResize === undefined ?
                  true : options.checkResize;
  
              // When this.width is not null, the overlay get scaled horizontally
              this.width = options.width === undefined ? null : options.width;
  
              // When this.height is not null, the overlay get scaled vertically
              this.height = options.height === undefined ? null : options.height;
  
              this.rotationMode = options.rotationMode || $.OverlayRotationMode.EXACT;
  
              // Having a rect as location is a syntactic sugar
              if (this.location instanceof $.Rect) {
                  this.width = this.location.width;
                  this.height = this.location.height;
                  this.location = this.location.getTopLeft();
                  this.placement = $.Placement.TOP_LEFT;
              }
  
              // Deprecated properties kept for backward compatibility.
              this.scales = this.width !== null && this.height !== null;
              this.bounds = new $.Rect(
                  this.location.x, this.location.y, this.width, this.height);
              this.position = this.location;
          },
  
          /**
           * Internal function to adjust the position of an overlay
           * depending on it size and placement.
           * @function
           * @param {OpenSeadragon.Point} position
           * @param {OpenSeadragon.Point} size
           */
          adjust: function(position, size) {
              var properties = $.Placement.properties[this.placement];
              if (!properties) {
                  return;
              }
              if (properties.isHorizontallyCentered) {
                  position.x -= size.x / 2;
              } else if (properties.isRight) {
                  position.x -= size.x;
              }
              if (properties.isVerticallyCentered) {
                  position.y -= size.y / 2;
              } else if (properties.isBottom) {
                  position.y -= size.y;
              }
          },
  
          /**
           * @function
           */
          destroy: function() {
              var element = this.element;
              var style = this.style;
  
              if (element.parentNode) {
                  element.parentNode.removeChild(element);
                  //this should allow us to preserve overlays when required between
                  //pages
                  if (element.prevElementParent) {
                      style.display = 'none';
                      //element.prevElementParent.insertBefore(
                      //    element,
                      //    element.prevNextSibling
                      //);
                      document.body.appendChild(element);
                  }
              }
  
              // clear the onDraw callback
              this.onDraw = null;
  
              style.top = "";
              style.left = "";
              style.position = "";
  
              if (this.width !== null) {
                  style.width = "";
              }
              if (this.height !== null) {
                  style.height = "";
              }
              var transformOriginProp = $.getCssPropertyWithVendorPrefix(
                  'transformOrigin');
              var transformProp = $.getCssPropertyWithVendorPrefix(
                  'transform');
              if (transformOriginProp && transformProp) {
                  style[transformOriginProp] = "";
                  style[transformProp] = "";
              }
          },
  
          /**
           * @function
           * @param {Element} container
           */
          drawHTML: function(container, viewport) {
              var element = this.element;
              if (element.parentNode !== container) {
                  //save the source parent for later if we need it
                  element.prevElementParent = element.parentNode;
                  element.prevNextSibling = element.nextSibling;
                  container.appendChild(element);
  
                  // have to set position before calculating size, fix #1116
                  this.style.position = "absolute";
                  // this.size is used by overlays which don't get scaled in at
                  // least one direction when this.checkResize is set to false.
                  this.size = $.getElementSize(element);
              }
  
              var positionAndSize = this._getOverlayPositionAndSize(viewport);
  
              var position = positionAndSize.position;
              var size = this.size = positionAndSize.size;
              var rotate = positionAndSize.rotate;
  
              // call the onDraw callback if it exists to allow one to overwrite
              // the drawing/positioning/sizing of the overlay
              if (this.onDraw) {
                  this.onDraw(position, size, this.element);
              } else {
                  var style = this.style;
                  style.left = position.x + "px";
                  style.top = position.y + "px";
                  if (this.width !== null) {
                      style.width = size.x + "px";
                  }
                  if (this.height !== null) {
                      style.height = size.y + "px";
                  }
                  var transformOriginProp = $.getCssPropertyWithVendorPrefix(
                      'transformOrigin');
                  var transformProp = $.getCssPropertyWithVendorPrefix(
                      'transform');
                  if (transformOriginProp && transformProp) {
                      if (rotate) {
                          style[transformOriginProp] = this._getTransformOrigin();
                          style[transformProp] = "rotate(" + rotate + "deg)";
                      } else {
                          style[transformOriginProp] = "";
                          style[transformProp] = "";
                      }
                  }
  
                  if (style.display !== 'none') {
                      style.display = 'block';
                  }
              }
          },
  
          // private
          _getOverlayPositionAndSize: function(viewport) {
              var position = viewport.pixelFromPoint(this.location, true);
              var size = this._getSizeInPixels(viewport);
              this.adjust(position, size);
  
              var rotate = 0;
              if (viewport.degrees &&
                  this.rotationMode !== $.OverlayRotationMode.NO_ROTATION) {
                  // BOUNDING_BOX is only valid if both directions get scaled.
                  // Get replaced by EXACT otherwise.
                  if (this.rotationMode === $.OverlayRotationMode.BOUNDING_BOX &&
                      this.width !== null && this.height !== null) {
                      var rect = new $.Rect(position.x, position.y, size.x, size.y);
                      var boundingBox = this._getBoundingBox(rect, viewport.degrees);
                      position = boundingBox.getTopLeft();
                      size = boundingBox.getSize();
                  } else {
                      rotate = viewport.degrees;
                  }
              }
  
              return {
                  position: position,
                  size: size,
                  rotate: rotate
              };
          },
  
          // private
          _getSizeInPixels: function(viewport) {
              var width = this.size.x;
              var height = this.size.y;
              if (this.width !== null || this.height !== null) {
                  var scaledSize = viewport.deltaPixelsFromPointsNoRotate(
                      new $.Point(this.width || 0, this.height || 0), true);
                  if (this.width !== null) {
                      width = scaledSize.x;
                  }
                  if (this.height !== null) {
                      height = scaledSize.y;
                  }
              }
              if (this.checkResize &&
                  (this.width === null || this.height === null)) {
                  var eltSize = this.size = $.getElementSize(this.element);
                  if (this.width === null) {
                      width = eltSize.x;
                  }
                  if (this.height === null) {
                      height = eltSize.y;
                  }
              }
              return new $.Point(width, height);
          },
  
          // private
          _getBoundingBox: function(rect, degrees) {
              var refPoint = this._getPlacementPoint(rect);
              return rect.rotate(degrees, refPoint).getBoundingBox();
          },
  
          // private
          _getPlacementPoint: function(rect) {
              var result = new $.Point(rect.x, rect.y);
              var properties = $.Placement.properties[this.placement];
              if (properties) {
                  if (properties.isHorizontallyCentered) {
                      result.x += rect.width / 2;
                  } else if (properties.isRight) {
                      result.x += rect.width;
                  }
                  if (properties.isVerticallyCentered) {
                      result.y += rect.height / 2;
                  } else if (properties.isBottom) {
                      result.y += rect.height;
                  }
              }
              return result;
          },
  
          // private
          _getTransformOrigin: function() {
              var result = "";
              var properties = $.Placement.properties[this.placement];
              if (!properties) {
                  return result;
              }
              if (properties.isLeft) {
                  result = "left";
              } else if (properties.isRight) {
                  result = "right";
              }
              if (properties.isTop) {
                  result += " top";
              } else if (properties.isBottom) {
                  result += " bottom";
              }
              return result;
          },
  
          /**
           * Changes the overlay settings.
           * @function
           * @param {OpenSeadragon.Point|OpenSeadragon.Rect|Object} location
           * If an object is specified, the options are the same than the constructor
           * except for the element which can not be changed.
           * @param {OpenSeadragon.Placement} placement
           */
          update: function(location, placement) {
              var options = $.isPlainObject(location) ? location : {
                  location: location,
                  placement: placement
              };
              this._init({
                  location: options.location || this.location,
                  placement: options.placement !== undefined ?
                      options.placement : this.placement,
                  onDraw: options.onDraw || this.onDraw,
                  checkResize: options.checkResize || this.checkResize,
                  width: options.width !== undefined ? options.width : this.width,
                  height: options.height !== undefined ? options.height : this.height,
                  rotationMode: options.rotationMode || this.rotationMode
              });
          },
  
          /**
           * Returns the current bounds of the overlay in viewport coordinates
           * @function
           * @param {OpenSeadragon.Viewport} viewport the viewport
           * @returns {OpenSeadragon.Rect} overlay bounds
           */
          getBounds: function(viewport) {
              $.console.assert(viewport,
                  'A viewport must now be passed to Overlay.getBounds.');
              var width = this.width;
              var height = this.height;
              if (width === null || height === null) {
                  var size = viewport.deltaPointsFromPixelsNoRotate(this.size, true);
                  if (width === null) {
                      width = size.x;
                  }
                  if (height === null) {
                      height = size.y;
                  }
              }
              var location = this.location.clone();
              this.adjust(location, new $.Point(width, height));
              return this._adjustBoundsForRotation(
                  viewport, new $.Rect(location.x, location.y, width, height));
          },
  
          // private
          _adjustBoundsForRotation: function(viewport, bounds) {
              if (!viewport ||
                  viewport.degrees === 0 ||
                  this.rotationMode === $.OverlayRotationMode.EXACT) {
                  return bounds;
              }
              if (this.rotationMode === $.OverlayRotationMode.BOUNDING_BOX) {
                  // If overlay not fully scalable, BOUNDING_BOX falls back to EXACT
                  if (this.width === null || this.height === null) {
                      return bounds;
                  }
                  // It is easier to just compute the position and size and
                  // convert to viewport coordinates.
                  var positionAndSize = this._getOverlayPositionAndSize(viewport);
                  return viewport.viewerElementToViewportRectangle(new $.Rect(
                      positionAndSize.position.x,
                      positionAndSize.position.y,
                      positionAndSize.size.x,
                      positionAndSize.size.y));
              }
  
              // NO_ROTATION case
              return bounds.rotate(-viewport.degrees,
                  this._getPlacementPoint(bounds));
          }
      };
  
  }(OpenSeadragon));
  
  /*
   * OpenSeadragon - Drawer
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  /**
   * @class Drawer
   * @memberof OpenSeadragon
   * @classdesc Handles rendering of tiles for an {@link OpenSeadragon.Viewer}.
   * @param {Object} options - Options for this Drawer.
   * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this Drawer.
   * @param {OpenSeadragon.Viewport} options.viewport - Reference to Viewer viewport.
   * @param {Element} options.element - Parent element.
   * @param {Number} [options.debugGridColor] - See debugGridColor in {@link OpenSeadragon.Options} for details.
   */
  $.Drawer = function( options ) {
  
      $.console.assert( options.viewer, "[Drawer] options.viewer is required" );
  
      //backward compatibility for positional args while preferring more
      //idiomatic javascript options object as the only argument
      var args  = arguments;
  
      if( !$.isPlainObject( options ) ){
          options = {
              source:     args[ 0 ], // Reference to Viewer tile source.
              viewport:   args[ 1 ], // Reference to Viewer viewport.
              element:    args[ 2 ]  // Parent element.
          };
      }
  
      $.console.assert( options.viewport, "[Drawer] options.viewport is required" );
      $.console.assert( options.element, "[Drawer] options.element is required" );
  
      if ( options.source ) {
          $.console.error( "[Drawer] options.source is no longer accepted; use TiledImage instead" );
      }
  
      this.viewer = options.viewer;
      this.viewport = options.viewport;
      this.debugGridColor = typeof options.debugGridColor === 'string' ? [options.debugGridColor] : options.debugGridColor || $.DEFAULT_SETTINGS.debugGridColor;
      if (options.opacity) {
          $.console.error( "[Drawer] options.opacity is no longer accepted; set the opacity on the TiledImage instead" );
      }
  
      this.useCanvas  = $.supportsCanvas && ( this.viewer ? this.viewer.useCanvas : true );
      /**
       * The parent element of this Drawer instance, passed in when the Drawer was created.
       * The parent of {@link OpenSeadragon.Drawer#canvas}.
       * @member {Element} container
       * @memberof OpenSeadragon.Drawer#
       */
      this.container  = $.getElement( options.element );
      /**
       * A &lt;canvas&gt; element if the browser supports them, otherwise a &lt;div&gt; element.
       * Child element of {@link OpenSeadragon.Drawer#container}.
       * @member {Element} canvas
       * @memberof OpenSeadragon.Drawer#
       */
      this.canvas     = $.makeNeutralElement( this.useCanvas ? "canvas" : "div" );
      /**
       * 2d drawing context for {@link OpenSeadragon.Drawer#canvas} if it's a &lt;canvas&gt; element, otherwise null.
       * @member {Object} context
       * @memberof OpenSeadragon.Drawer#
       */
      this.context    = this.useCanvas ? this.canvas.getContext( "2d" ) : null;
  
      /**
       * Sketch canvas used to temporarily draw tiles which cannot be drawn directly
       * to the main canvas due to opacity. Lazily initialized.
       */
      this.sketchCanvas = null;
      this.sketchContext = null;
  
      /**
       * @member {Element} element
       * @memberof OpenSeadragon.Drawer#
       * @deprecated Alias for {@link OpenSeadragon.Drawer#container}.
       */
      this.element    = this.container;
  
      // We force our container to ltr because our drawing math doesn't work in rtl.
      // This issue only affects our canvas renderer, but we do it always for consistency.
      // Note that this means overlays you want to be rtl need to be explicitly set to rtl.
      this.container.dir = 'ltr';
  
      // check canvas available width and height, set canvas width and height such that the canvas backing store is set to the proper pixel density
      if (this.useCanvas) {
          var viewportSize = this._calculateCanvasSize();
          this.canvas.width = viewportSize.x;
          this.canvas.height = viewportSize.y;
      }
  
      this.canvas.style.width     = "100%";
      this.canvas.style.height    = "100%";
      this.canvas.style.position  = "absolute";
      $.setElementOpacity( this.canvas, this.opacity, true );
  
      // explicit left-align
      this.container.style.textAlign = "left";
      this.container.appendChild( this.canvas );
  
      // Image smoothing for canvas rendering (only if canvas is used).
      // Canvas default is "true", so this will only be changed if user specified "false".
      this._imageSmoothingEnabled = true;
  };
  
  /** @lends OpenSeadragon.Drawer.prototype */
  $.Drawer.prototype = {
      // deprecated
      addOverlay: function( element, location, placement, onDraw ) {
          $.console.error("drawer.addOverlay is deprecated. Use viewer.addOverlay instead.");
          this.viewer.addOverlay( element, location, placement, onDraw );
          return this;
      },
  
      // deprecated
      updateOverlay: function( element, location, placement ) {
          $.console.error("drawer.updateOverlay is deprecated. Use viewer.updateOverlay instead.");
          this.viewer.updateOverlay( element, location, placement );
          return this;
      },
  
      // deprecated
      removeOverlay: function( element ) {
          $.console.error("drawer.removeOverlay is deprecated. Use viewer.removeOverlay instead.");
          this.viewer.removeOverlay( element );
          return this;
      },
  
      // deprecated
      clearOverlays: function() {
          $.console.error("drawer.clearOverlays is deprecated. Use viewer.clearOverlays instead.");
          this.viewer.clearOverlays();
          return this;
      },
  
      /**
       * This function converts the given point from to the drawer coordinate by
       * multiplying it with the pixel density.
       * This function does not take rotation into account, thus assuming provided
       * point is at 0 degree.
       * @param {OpenSeadragon.Point} point - the pixel point to convert
       */
      viewportCoordToDrawerCoord: function(point) {
          var vpPoint = this.viewport.pixelFromPointNoRotate(point, true);
          return new $.Point(
              vpPoint.x * $.pixelDensityRatio,
              vpPoint.y * $.pixelDensityRatio
          );
      },
  
      /**
       * This function will create multiple polygon paths on the drawing context by provided polygons,
       * then clip the context to the paths.
       * @param {(OpenSeadragon.Point[])[]} polygons - an array of polygons. A polygon is an array of OpenSeadragon.Point
       * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
       */
      clipWithPolygons: function (polygons, useSketch) {
          if (!this.useCanvas) {
              return;
          }
          var context = this._getContext(useSketch);
          context.beginPath();
          polygons.forEach(function (polygon) {
              polygon.forEach(function (coord, i) {
                  context[i === 0 ? 'moveTo' : 'lineTo'](coord.x, coord.y);
            });
          });
          context.clip();
      },
  
      /**
       * Set the opacity of the drawer.
       * @param {Number} opacity
       * @return {OpenSeadragon.Drawer} Chainable.
       */
      setOpacity: function( opacity ) {
          $.console.error("drawer.setOpacity is deprecated. Use tiledImage.setOpacity instead.");
          var world = this.viewer.world;
          for (var i = 0; i < world.getItemCount(); i++) {
              world.getItemAt( i ).setOpacity( opacity );
          }
          return this;
      },
  
      /**
       * Get the opacity of the drawer.
       * @returns {Number}
       */
      getOpacity: function() {
          $.console.error("drawer.getOpacity is deprecated. Use tiledImage.getOpacity instead.");
          var world = this.viewer.world;
          var maxOpacity = 0;
          for (var i = 0; i < world.getItemCount(); i++) {
              var opacity = world.getItemAt( i ).getOpacity();
              if ( opacity > maxOpacity ) {
                  maxOpacity = opacity;
              }
          }
          return maxOpacity;
      },
  
      // deprecated
      needsUpdate: function() {
          $.console.error( "[Drawer.needsUpdate] this function is deprecated. Use World.needsDraw instead." );
          return this.viewer.world.needsDraw();
      },
  
      // deprecated
      numTilesLoaded: function() {
          $.console.error( "[Drawer.numTilesLoaded] this function is deprecated. Use TileCache.numTilesLoaded instead." );
          return this.viewer.tileCache.numTilesLoaded();
      },
  
      // deprecated
      reset: function() {
          $.console.error( "[Drawer.reset] this function is deprecated. Use World.resetItems instead." );
          this.viewer.world.resetItems();
          return this;
      },
  
      // deprecated
      update: function() {
          $.console.error( "[Drawer.update] this function is deprecated. Use Drawer.clear and World.draw instead." );
          this.clear();
          this.viewer.world.draw();
          return this;
      },
  
      /**
       * @return {Boolean} True if rotation is supported.
       */
      canRotate: function() {
          return this.useCanvas;
      },
  
      /**
       * Destroy the drawer (unload current loaded tiles)
       */
      destroy: function() {
          //force unloading of current canvas (1x1 will be gc later, trick not necessarily needed)
          this.canvas.width  = 1;
          this.canvas.height = 1;
          this.sketchCanvas = null;
          this.sketchContext = null;
      },
  
      /**
       * Clears the Drawer so it's ready to draw another frame.
       */
      clear: function() {
          this.canvas.innerHTML = "";
          if ( this.useCanvas ) {
              var viewportSize = this._calculateCanvasSize();
              if( this.canvas.width != viewportSize.x ||
                  this.canvas.height != viewportSize.y ) {
                  this.canvas.width = viewportSize.x;
                  this.canvas.height = viewportSize.y;
                  this._updateImageSmoothingEnabled(this.context);
                  if ( this.sketchCanvas !== null ) {
                      var sketchCanvasSize = this._calculateSketchCanvasSize();
                      this.sketchCanvas.width = sketchCanvasSize.x;
                      this.sketchCanvas.height = sketchCanvasSize.y;
                      this._updateImageSmoothingEnabled(this.sketchContext);
                  }
              }
              this._clear();
          }
      },
  
      _clear: function (useSketch, bounds) {
          if (!this.useCanvas) {
              return;
          }
          var context = this._getContext(useSketch);
          if (bounds) {
              context.clearRect(bounds.x, bounds.y, bounds.width, bounds.height);
          } else {
              var canvas = context.canvas;
              context.clearRect(0, 0, canvas.width, canvas.height);
          }
      },
  
      /**
       * Scale from OpenSeadragon viewer rectangle to drawer rectangle
       * (ignoring rotation)
       * @param {OpenSeadragon.Rect} rectangle - The rectangle in viewport coordinate system.
       * @return {OpenSeadragon.Rect} Rectangle in drawer coordinate system.
       */
      viewportToDrawerRectangle: function(rectangle) {
          var topLeft = this.viewport.pixelFromPointNoRotate(rectangle.getTopLeft(), true);
          var size = this.viewport.deltaPixelsFromPointsNoRotate(rectangle.getSize(), true);
  
          return new $.Rect(
              topLeft.x * $.pixelDensityRatio,
              topLeft.y * $.pixelDensityRatio,
              size.x * $.pixelDensityRatio,
              size.y * $.pixelDensityRatio
          );
      },
  
      /**
       * Draws the given tile.
       * @param {OpenSeadragon.Tile} tile - The tile to draw.
       * @param {Function} drawingHandler - Method for firing the drawing event if using canvas.
       * drawingHandler({context, tile, rendered})
       * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
       * where <code>rendered</code> is the context with the pre-drawn image.
       * @param {Float} [scale=1] - Apply a scale to tile position and size. Defaults to 1.
       * @param {OpenSeadragon.Point} [translate] A translation vector to offset tile position
       */
      drawTile: function(tile, drawingHandler, useSketch, scale, translate) {
          $.console.assert(tile, '[Drawer.drawTile] tile is required');
          $.console.assert(drawingHandler, '[Drawer.drawTile] drawingHandler is required');
  
          if (this.useCanvas) {
              var context = this._getContext(useSketch);
              scale = scale || 1;
              tile.drawCanvas(context, drawingHandler, scale, translate);
          } else {
              tile.drawHTML( this.canvas );
          }
      },
  
      _getContext: function( useSketch ) {
          var context = this.context;
          if ( useSketch ) {
              if (this.sketchCanvas === null) {
                  this.sketchCanvas = document.createElement( "canvas" );
                  var sketchCanvasSize = this._calculateSketchCanvasSize();
                  this.sketchCanvas.width = sketchCanvasSize.x;
                  this.sketchCanvas.height = sketchCanvasSize.y;
                  this.sketchContext = this.sketchCanvas.getContext( "2d" );
  
                  // If the viewport is not currently rotated, the sketchCanvas
                  // will have the same size as the main canvas. However, if
                  // the viewport get rotated later on, we will need to resize it.
                  if (this.viewport.getRotation() === 0) {
                      var self = this;
                      this.viewer.addHandler('rotate', function resizeSketchCanvas() {
                          if (self.viewport.getRotation() === 0) {
                              return;
                          }
                          self.viewer.removeHandler('rotate', resizeSketchCanvas);
                          var sketchCanvasSize = self._calculateSketchCanvasSize();
                          self.sketchCanvas.width = sketchCanvasSize.x;
                          self.sketchCanvas.height = sketchCanvasSize.y;
                      });
                  }
                  this._updateImageSmoothingEnabled(this.sketchContext);
              }
              context = this.sketchContext;
          }
          return context;
      },
  
      // private
      saveContext: function( useSketch ) {
          if (!this.useCanvas) {
              return;
          }
  
          this._getContext( useSketch ).save();
      },
  
      // private
      restoreContext: function( useSketch ) {
          if (!this.useCanvas) {
              return;
          }
  
          this._getContext( useSketch ).restore();
      },
  
      // private
      setClip: function(rect, useSketch) {
          if (!this.useCanvas) {
              return;
          }
  
          var context = this._getContext( useSketch );
          context.beginPath();
          context.rect(rect.x, rect.y, rect.width, rect.height);
          context.clip();
      },
  
      // private
      drawRectangle: function(rect, fillStyle, useSketch) {
          if (!this.useCanvas) {
              return;
          }
  
          var context = this._getContext( useSketch );
          context.save();
          context.fillStyle = fillStyle;
          context.fillRect(rect.x, rect.y, rect.width, rect.height);
          context.restore();
      },
  
      /**
       * Blends the sketch canvas in the main canvas.
       * @param {Object} options The options
       * @param {Float} options.opacity The opacity of the blending.
       * @param {Float} [options.scale=1] The scale at which tiles were drawn on
       * the sketch. Default is 1.
       * Use scale to draw at a lower scale and then enlarge onto the main canvas.
       * @param {OpenSeadragon.Point} [options.translate] A translation vector
       * that was used to draw the tiles
       * @param {String} [options.compositeOperation] - How the image is
       * composited onto other images; see compositeOperation in
       * {@link OpenSeadragon.Options} for possible values.
       * @param {OpenSeadragon.Rect} [options.bounds] The part of the sketch
       * canvas to blend in the main canvas. If specified, options.scale and
       * options.translate get ignored.
       */
      blendSketch: function(opacity, scale, translate, compositeOperation) {
          var options = opacity;
          if (!$.isPlainObject(options)) {
              options = {
                  opacity: opacity,
                  scale: scale,
                  translate: translate,
                  compositeOperation: compositeOperation
              };
          }
          if (!this.useCanvas || !this.sketchCanvas) {
              return;
          }
          opacity = options.opacity;
          compositeOperation = options.compositeOperation;
          var bounds = options.bounds;
  
          this.context.save();
          this.context.globalAlpha = opacity;
          if (compositeOperation) {
              this.context.globalCompositeOperation = compositeOperation;
          }
          if (bounds) {
              // Internet Explorer, Microsoft Edge, and Safari have problems
              // when you call context.drawImage with negative x or y
              // or x + width or y + height greater than the canvas width or height respectively.
              if (bounds.x < 0) {
                  bounds.width += bounds.x;
                  bounds.x = 0;
              }
              if (bounds.x + bounds.width > this.canvas.width) {
                  bounds.width = this.canvas.width - bounds.x;
              }
              if (bounds.y < 0) {
                  bounds.height += bounds.y;
                  bounds.y = 0;
              }
              if (bounds.y + bounds.height > this.canvas.height) {
                  bounds.height = this.canvas.height - bounds.y;
              }
  
              this.context.drawImage(
                  this.sketchCanvas,
                  bounds.x,
                  bounds.y,
                  bounds.width,
                  bounds.height,
                  bounds.x,
                  bounds.y,
                  bounds.width,
                  bounds.height
              );
          } else {
              scale = options.scale || 1;
              translate = options.translate;
              var position = translate instanceof $.Point ?
                  translate : new $.Point(0, 0);
  
              var widthExt = 0;
              var heightExt = 0;
              if (translate) {
                  var widthDiff = this.sketchCanvas.width - this.canvas.width;
                  var heightDiff = this.sketchCanvas.height - this.canvas.height;
                  widthExt = Math.round(widthDiff / 2);
                  heightExt = Math.round(heightDiff / 2);
              }
              this.context.drawImage(
                  this.sketchCanvas,
                  position.x - widthExt * scale,
                  position.y - heightExt * scale,
                  (this.canvas.width + 2 * widthExt) * scale,
                  (this.canvas.height + 2 * heightExt) * scale,
                  -widthExt,
                  -heightExt,
                  this.canvas.width + 2 * widthExt,
                  this.canvas.height + 2 * heightExt
              );
          }
          this.context.restore();
      },
  
      // private
      drawDebugInfo: function(tile, count, i, tiledImage) {
          if ( !this.useCanvas ) {
              return;
          }
  
          var colorIndex = this.viewer.world.getIndexOfItem(tiledImage) % this.debugGridColor.length;
          var context = this.context;
          context.save();
          context.lineWidth = 2 * $.pixelDensityRatio;
          context.font = 'small-caps bold ' + (13 * $.pixelDensityRatio) + 'px arial';
          context.strokeStyle = this.debugGridColor[colorIndex];
          context.fillStyle = this.debugGridColor[colorIndex];
  
          if ( this.viewport.degrees !== 0 ) {
              this._offsetForRotation({degrees: this.viewport.degrees});
          }
          if (tiledImage.getRotation(true) % 360 !== 0) {
              this._offsetForRotation({
                  degrees: tiledImage.getRotation(true),
                  point: tiledImage.viewport.pixelFromPointNoRotate(
                      tiledImage._getRotationPoint(true), true)
              });
          }
          if (tiledImage.viewport.degrees === 0 && tiledImage.getRotation(true) % 360 === 0){
            if(tiledImage._drawer.viewer.viewport.getFlip()) {
                tiledImage._drawer._flip();
            }
          }
  
          context.strokeRect(
              tile.position.x * $.pixelDensityRatio,
              tile.position.y * $.pixelDensityRatio,
              tile.size.x * $.pixelDensityRatio,
              tile.size.y * $.pixelDensityRatio
          );
  
          var tileCenterX = (tile.position.x + (tile.size.x / 2)) * $.pixelDensityRatio;
          var tileCenterY = (tile.position.y + (tile.size.y / 2)) * $.pixelDensityRatio;
  
          // Rotate the text the right way around.
          context.translate( tileCenterX, tileCenterY );
          context.rotate( Math.PI / 180 * -this.viewport.degrees );
          context.translate( -tileCenterX, -tileCenterY );
  
          if( tile.x === 0 && tile.y === 0 ){
              context.fillText(
                  "Zoom: " + this.viewport.getZoom(),
                  tile.position.x * $.pixelDensityRatio,
                  (tile.position.y - 30) * $.pixelDensityRatio
              );
              context.fillText(
                  "Pan: " + this.viewport.getBounds().toString(),
                  tile.position.x * $.pixelDensityRatio,
                  (tile.position.y - 20) * $.pixelDensityRatio
              );
          }
          context.fillText(
              "Level: " + tile.level,
              (tile.position.x + 10) * $.pixelDensityRatio,
              (tile.position.y + 20) * $.pixelDensityRatio
          );
          context.fillText(
              "Column: " + tile.x,
              (tile.position.x + 10) * $.pixelDensityRatio,
              (tile.position.y + 30) * $.pixelDensityRatio
          );
          context.fillText(
              "Row: " + tile.y,
              (tile.position.x + 10) * $.pixelDensityRatio,
              (tile.position.y + 40) * $.pixelDensityRatio
          );
          context.fillText(
              "Order: " + i + " of " + count,
              (tile.position.x + 10) * $.pixelDensityRatio,
              (tile.position.y + 50) * $.pixelDensityRatio
          );
          context.fillText(
              "Size: " + tile.size.toString(),
              (tile.position.x + 10) * $.pixelDensityRatio,
              (tile.position.y + 60) * $.pixelDensityRatio
          );
          context.fillText(
              "Position: " + tile.position.toString(),
              (tile.position.x + 10) * $.pixelDensityRatio,
              (tile.position.y + 70) * $.pixelDensityRatio
          );
  
          if ( this.viewport.degrees !== 0 ) {
              this._restoreRotationChanges();
          }
          if (tiledImage.getRotation(true) % 360 !== 0) {
              this._restoreRotationChanges();
          }
  
          if (tiledImage.viewport.degrees === 0 && tiledImage.getRotation(true) % 360 === 0){
            if(tiledImage._drawer.viewer.viewport.getFlip()) {
                tiledImage._drawer._flip();
            }
          }
  
          context.restore();
      },
  
      // private
      debugRect: function(rect) {
          if ( this.useCanvas ) {
              var context = this.context;
              context.save();
              context.lineWidth = 2 * $.pixelDensityRatio;
              context.strokeStyle = this.debugGridColor[0];
              context.fillStyle = this.debugGridColor[0];
  
              context.strokeRect(
                  rect.x * $.pixelDensityRatio,
                  rect.y * $.pixelDensityRatio,
                  rect.width * $.pixelDensityRatio,
                  rect.height * $.pixelDensityRatio
              );
  
              context.restore();
          }
      },
  
      /**
       * Turns image smoothing on or off for this viewer. Note: Ignored in some (especially older) browsers that do not support this property.
       *
       * @function
       * @param {Boolean} [imageSmoothingEnabled] - Whether or not the image is
       * drawn smoothly on the canvas; see imageSmoothingEnabled in
       * {@link OpenSeadragon.Options} for more explanation.
       */
      setImageSmoothingEnabled: function(imageSmoothingEnabled){
          if ( this.useCanvas ) {
              this._imageSmoothingEnabled = imageSmoothingEnabled;
              this._updateImageSmoothingEnabled(this.context);
              this.viewer.forceRedraw();
          }
      },
  
      // private
      _updateImageSmoothingEnabled: function(context){
          context.msImageSmoothingEnabled = this._imageSmoothingEnabled;
          context.imageSmoothingEnabled = this._imageSmoothingEnabled;
      },
  
      /**
       * Get the canvas size
       * @param {Boolean} sketch If set to true return the size of the sketch canvas
       * @returns {OpenSeadragon.Point} The size of the canvas
       */
      getCanvasSize: function(sketch) {
          var canvas = this._getContext(sketch).canvas;
          return new $.Point(canvas.width, canvas.height);
      },
  
      getCanvasCenter: function() {
          return new $.Point(this.canvas.width / 2, this.canvas.height / 2);
      },
  
      // private
      _offsetForRotation: function(options) {
          var point = options.point ?
              options.point.times($.pixelDensityRatio) :
              this.getCanvasCenter();
  
          var context = this._getContext(options.useSketch);
          context.save();
  
          context.translate(point.x, point.y);
          if(this.viewer.viewport.flipped){
            context.rotate(Math.PI / 180 * -options.degrees);
            context.scale(-1, 1);
          } else{
            context.rotate(Math.PI / 180 * options.degrees);
          }
          context.translate(-point.x, -point.y);
      },
  
      // private
      _flip: function(options) {
        options = options || {};
        var point = options.point ?
          options.point.times($.pixelDensityRatio) :
          this.getCanvasCenter();
        var context = this._getContext(options.useSketch);
  
        context.translate(point.x, 0);
        context.scale(-1, 1);
        context.translate(-point.x, 0);
      },
  
      // private
      _restoreRotationChanges: function(useSketch) {
          var context = this._getContext(useSketch);
          context.restore();
      },
  
      // private
      _calculateCanvasSize: function() {
          var pixelDensityRatio = $.pixelDensityRatio;
          var viewportSize = this.viewport.getContainerSize();
          return {
              // canvas width and height are integers
              x: Math.round(viewportSize.x * pixelDensityRatio),
              y: Math.round(viewportSize.y * pixelDensityRatio)
          };
      },
  
      // private
      _calculateSketchCanvasSize: function() {
          var canvasSize = this._calculateCanvasSize();
          if (this.viewport.getRotation() === 0) {
              return canvasSize;
          }
          // If the viewport is rotated, we need a larger sketch canvas in order
          // to support edge smoothing.
          var sketchCanvasSize = Math.ceil(Math.sqrt(
              canvasSize.x * canvasSize.x +
              canvasSize.y * canvasSize.y));
          return {
              x: sketchCanvasSize,
              y: sketchCanvasSize
          };
      }
  };
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - Viewport
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  
  /**
   * @class Viewport
   * @memberof OpenSeadragon
   * @classdesc Handles coordinate-related functionality (zoom, pan, rotation, etc.)
   * for an {@link OpenSeadragon.Viewer}.
   * @param {Object} options - Options for this Viewport.
   * @param {Object} [options.margins] - See viewportMargins in {@link OpenSeadragon.Options}.
   * @param {Number} [options.springStiffness] - See springStiffness in {@link OpenSeadragon.Options}.
   * @param {Number} [options.animationTime] - See animationTime in {@link OpenSeadragon.Options}.
   * @param {Number} [options.minZoomImageRatio] - See minZoomImageRatio in {@link OpenSeadragon.Options}.
   * @param {Number} [options.maxZoomPixelRatio] - See maxZoomPixelRatio in {@link OpenSeadragon.Options}.
   * @param {Number} [options.visibilityRatio] - See visibilityRatio in {@link OpenSeadragon.Options}.
   * @param {Boolean} [options.wrapHorizontal] - See wrapHorizontal in {@link OpenSeadragon.Options}.
   * @param {Boolean} [options.wrapVertical] - See wrapVertical in {@link OpenSeadragon.Options}.
   * @param {Number} [options.defaultZoomLevel] - See defaultZoomLevel in {@link OpenSeadragon.Options}.
   * @param {Number} [options.minZoomLevel] - See minZoomLevel in {@link OpenSeadragon.Options}.
   * @param {Number} [options.maxZoomLevel] - See maxZoomLevel in {@link OpenSeadragon.Options}.
   * @param {Number} [options.degrees] - See degrees in {@link OpenSeadragon.Options}.
   * @param {Boolean} [options.homeFillsViewer] - See homeFillsViewer in {@link OpenSeadragon.Options}.
   */
  $.Viewport = function( options ) {
  
      //backward compatibility for positional args while preferring more
      //idiomatic javascript options object as the only argument
      var args = arguments;
      if (args.length && args[0] instanceof $.Point) {
          options = {
              containerSize:  args[0],
              contentSize:    args[1],
              config:         args[2]
          };
      }
  
      //options.config and the general config argument are deprecated
      //in favor of the more direct specification of optional settings
      //being passed directly on the options object
      if ( options.config ){
          $.extend( true, options, options.config );
          delete options.config;
      }
  
      this._margins = $.extend({
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
      }, options.margins || {});
  
      delete options.margins;
  
      $.extend( true, this, {
  
          //required settings
          containerSize:      null,
          contentSize:        null,
  
          //internal state properties
          zoomPoint:          null,
          viewer:           null,
  
          //configurable options
          springStiffness:    $.DEFAULT_SETTINGS.springStiffness,
          animationTime:      $.DEFAULT_SETTINGS.animationTime,
          minZoomImageRatio:  $.DEFAULT_SETTINGS.minZoomImageRatio,
          maxZoomPixelRatio:  $.DEFAULT_SETTINGS.maxZoomPixelRatio,
          visibilityRatio:    $.DEFAULT_SETTINGS.visibilityRatio,
          wrapHorizontal:     $.DEFAULT_SETTINGS.wrapHorizontal,
          wrapVertical:       $.DEFAULT_SETTINGS.wrapVertical,
          defaultZoomLevel:   $.DEFAULT_SETTINGS.defaultZoomLevel,
          minZoomLevel:       $.DEFAULT_SETTINGS.minZoomLevel,
          maxZoomLevel:       $.DEFAULT_SETTINGS.maxZoomLevel,
          degrees:            $.DEFAULT_SETTINGS.degrees,
          flipped:            $.DEFAULT_SETTINGS.flipped,
          homeFillsViewer:    $.DEFAULT_SETTINGS.homeFillsViewer
  
      }, options );
  
      this._updateContainerInnerSize();
  
      this.centerSpringX = new $.Spring({
          initial: 0,
          springStiffness: this.springStiffness,
          animationTime:   this.animationTime
      });
      this.centerSpringY = new $.Spring({
          initial: 0,
          springStiffness: this.springStiffness,
          animationTime:   this.animationTime
      });
      this.zoomSpring    = new $.Spring({
          exponential: true,
          initial: 1,
          springStiffness: this.springStiffness,
          animationTime:   this.animationTime
      });
  
      this._oldCenterX = this.centerSpringX.current.value;
      this._oldCenterY = this.centerSpringY.current.value;
      this._oldZoom    = this.zoomSpring.current.value;
  
      this._setContentBounds(new $.Rect(0, 0, 1, 1), 1);
  
      this.goHome(true);
      this.update();
  };
  
  /** @lends OpenSeadragon.Viewport.prototype */
  $.Viewport.prototype = {
      /**
       * Updates the viewport's home bounds and constraints for the given content size.
       * @function
       * @param {OpenSeadragon.Point} contentSize - size of the content in content units
       * @return {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:reset-size
       */
      resetContentSize: function(contentSize) {
          $.console.assert(contentSize, "[Viewport.resetContentSize] contentSize is required");
          $.console.assert(contentSize instanceof $.Point, "[Viewport.resetContentSize] contentSize must be an OpenSeadragon.Point");
          $.console.assert(contentSize.x > 0, "[Viewport.resetContentSize] contentSize.x must be greater than 0");
          $.console.assert(contentSize.y > 0, "[Viewport.resetContentSize] contentSize.y must be greater than 0");
  
          this._setContentBounds(new $.Rect(0, 0, 1, contentSize.y / contentSize.x), contentSize.x);
          return this;
      },
  
      // deprecated
      setHomeBounds: function(bounds, contentFactor) {
          $.console.error("[Viewport.setHomeBounds] this function is deprecated; The content bounds should not be set manually.");
          this._setContentBounds(bounds, contentFactor);
      },
  
      // Set the viewport's content bounds
      // @param {OpenSeadragon.Rect} bounds - the new bounds in viewport coordinates
      // without rotation
      // @param {Number} contentFactor - how many content units per viewport unit
      // @fires OpenSeadragon.Viewer.event:reset-size
      // @private
      _setContentBounds: function(bounds, contentFactor) {
          $.console.assert(bounds, "[Viewport._setContentBounds] bounds is required");
          $.console.assert(bounds instanceof $.Rect, "[Viewport._setContentBounds] bounds must be an OpenSeadragon.Rect");
          $.console.assert(bounds.width > 0, "[Viewport._setContentBounds] bounds.width must be greater than 0");
          $.console.assert(bounds.height > 0, "[Viewport._setContentBounds] bounds.height must be greater than 0");
  
          this._contentBoundsNoRotate = bounds.clone();
          this._contentSizeNoRotate = this._contentBoundsNoRotate.getSize().times(
              contentFactor);
  
          this._contentBounds = bounds.rotate(this.degrees).getBoundingBox();
          this._contentSize = this._contentBounds.getSize().times(contentFactor);
          this._contentAspectRatio = this._contentSize.x / this._contentSize.y;
  
          if (this.viewer) {
              /**
               * Raised when the viewer's content size or home bounds are reset
               * (see {@link OpenSeadragon.Viewport#resetContentSize}).
               *
               * @event reset-size
               * @memberof OpenSeadragon.Viewer
               * @type {object}
               * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
               * @property {OpenSeadragon.Point} contentSize
               * @property {OpenSeadragon.Rect} contentBounds - Content bounds.
               * @property {OpenSeadragon.Rect} homeBounds - Content bounds.
               * Deprecated use contentBounds instead.
               * @property {Number} contentFactor
               * @property {?Object} userData - Arbitrary subscriber-defined object.
               */
              this.viewer.raiseEvent('reset-size', {
                  contentSize: this._contentSizeNoRotate.clone(),
                  contentFactor: contentFactor,
                  homeBounds: this._contentBoundsNoRotate.clone(),
                  contentBounds: this._contentBounds.clone()
              });
          }
      },
  
      /**
       * Returns the home zoom in "viewport zoom" value.
       * @function
       * @returns {Number} The home zoom in "viewport zoom".
       */
      getHomeZoom: function() {
          if (this.defaultZoomLevel) {
              return this.defaultZoomLevel;
          }
  
          var aspectFactor = this._contentAspectRatio / this.getAspectRatio();
          var output;
          if (this.homeFillsViewer) { // fill the viewer and clip the image
              output = aspectFactor >= 1 ? aspectFactor : 1;
          } else {
              output = aspectFactor >= 1 ? 1 : aspectFactor;
          }
  
          return output / this._contentBounds.width;
      },
  
      /**
       * Returns the home bounds in viewport coordinates.
       * @function
       * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
       */
      getHomeBounds: function() {
          return this.getHomeBoundsNoRotate().rotate(-this.getRotation());
      },
  
      /**
       * Returns the home bounds in viewport coordinates.
       * This method ignores the viewport rotation. Use
       * {@link OpenSeadragon.Viewport#getHomeBounds} to take it into account.
       * @function
       * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
       */
      getHomeBoundsNoRotate: function() {
          var center = this._contentBounds.getCenter();
          var width  = 1.0 / this.getHomeZoom();
          var height = width / this.getAspectRatio();
  
          return new $.Rect(
              center.x - (width / 2.0),
              center.y - (height / 2.0),
              width,
              height
          );
      },
  
      /**
       * @function
       * @param {Boolean} immediately
       * @fires OpenSeadragon.Viewer.event:home
       */
      goHome: function(immediately) {
          if (this.viewer) {
              /**
               * Raised when the "home" operation occurs (see {@link OpenSeadragon.Viewport#goHome}).
               *
               * @event home
               * @memberof OpenSeadragon.Viewer
               * @type {object}
               * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
               * @property {Boolean} immediately
               * @property {?Object} userData - Arbitrary subscriber-defined object.
               */
              this.viewer.raiseEvent('home', {
                  immediately: immediately
              });
          }
          return this.fitBounds(this.getHomeBounds(), immediately);
      },
  
      /**
       * @function
       */
      getMinZoom: function() {
          var homeZoom = this.getHomeZoom(),
              zoom = this.minZoomLevel ?
              this.minZoomLevel :
                  this.minZoomImageRatio * homeZoom;
  
          return zoom;
      },
  
      /**
       * @function
       */
      getMaxZoom: function() {
          var zoom = this.maxZoomLevel;
          if (!zoom) {
              zoom = this._contentSize.x * this.maxZoomPixelRatio / this._containerInnerSize.x;
              zoom /= this._contentBounds.width;
          }
  
          return Math.max( zoom, this.getHomeZoom() );
      },
  
      /**
       * @function
       */
      getAspectRatio: function() {
          return this._containerInnerSize.x / this._containerInnerSize.y;
      },
  
      /**
       * @function
       * @returns {OpenSeadragon.Point} The size of the container, in screen coordinates.
       */
      getContainerSize: function() {
          return new $.Point(
              this.containerSize.x,
              this.containerSize.y
          );
      },
  
      /**
       * The margins push the "home" region in from the sides by the specified amounts.
       * @function
       * @returns {Object} Properties (Numbers, in screen coordinates): left, top, right, bottom.
       */
      getMargins: function() {
          return $.extend({}, this._margins); // Make a copy so we are not returning our original
      },
  
      /**
       * The margins push the "home" region in from the sides by the specified amounts.
       * @function
       * @param {Object} margins - Properties (Numbers, in screen coordinates): left, top, right, bottom.
       */
      setMargins: function(margins) {
          $.console.assert($.type(margins) === 'object', '[Viewport.setMargins] margins must be an object');
  
          this._margins = $.extend({
              left: 0,
              top: 0,
              right: 0,
              bottom: 0
          }, margins);
  
          this._updateContainerInnerSize();
          if (this.viewer) {
              this.viewer.forceRedraw();
          }
      },
  
      /**
       * Returns the bounds of the visible area in viewport coordinates.
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
       */
      getBounds: function(current) {
          return this.getBoundsNoRotate(current).rotate(-this.getRotation());
      },
  
      /**
       * Returns the bounds of the visible area in viewport coordinates.
       * This method ignores the viewport rotation. Use
       * {@link OpenSeadragon.Viewport#getBounds} to take it into account.
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
       */
      getBoundsNoRotate: function(current) {
          var center = this.getCenter(current);
          var width  = 1.0 / this.getZoom(current);
          var height = width / this.getAspectRatio();
  
          return new $.Rect(
              center.x - (width / 2.0),
              center.y - (height / 2.0),
              width,
              height
          );
      },
  
      /**
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
       * including the space taken by margins, in viewport coordinates.
       */
      getBoundsWithMargins: function(current) {
          return this.getBoundsNoRotateWithMargins(current).rotate(
              -this.getRotation(), this.getCenter(current));
      },
  
      /**
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
       * including the space taken by margins, in viewport coordinates.
       */
      getBoundsNoRotateWithMargins: function(current) {
          var bounds = this.getBoundsNoRotate(current);
          var factor = this._containerInnerSize.x * this.getZoom(current);
          bounds.x -= this._margins.left / factor;
          bounds.y -= this._margins.top / factor;
          bounds.width += (this._margins.left + this._margins.right) / factor;
          bounds.height += (this._margins.top + this._margins.bottom) / factor;
          return bounds;
      },
  
      /**
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       */
      getCenter: function( current ) {
          var centerCurrent = new $.Point(
                  this.centerSpringX.current.value,
                  this.centerSpringY.current.value
              ),
              centerTarget = new $.Point(
                  this.centerSpringX.target.value,
                  this.centerSpringY.target.value
              ),
              oldZoomPixel,
              zoom,
              width,
              height,
              bounds,
              newZoomPixel,
              deltaZoomPixels,
              deltaZoomPoints;
  
          if ( current ) {
              return centerCurrent;
          } else if ( !this.zoomPoint ) {
              return centerTarget;
          }
  
          oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
  
          zoom    = this.getZoom();
          width   = 1.0 / zoom;
          height  = width / this.getAspectRatio();
          bounds  = new $.Rect(
              centerCurrent.x - width / 2.0,
              centerCurrent.y - height / 2.0,
              width,
              height
          );
  
          newZoomPixel = this._pixelFromPoint(this.zoomPoint, bounds);
          deltaZoomPixels = newZoomPixel.minus( oldZoomPixel );
          deltaZoomPoints = deltaZoomPixels.divide( this._containerInnerSize.x * zoom );
  
          return centerTarget.plus( deltaZoomPoints );
      },
  
      /**
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       */
      getZoom: function( current ) {
          if ( current ) {
              return this.zoomSpring.current.value;
          } else {
              return this.zoomSpring.target.value;
          }
      },
  
      // private
      _applyZoomConstraints: function(zoom) {
          return Math.max(
              Math.min(zoom, this.getMaxZoom()),
              this.getMinZoom());
      },
  
      /**
       * @function
       * @private
       * @param {OpenSeadragon.Rect} bounds
       * @return {OpenSeadragon.Rect} constrained bounds.
       */
      _applyBoundaryConstraints: function(bounds) {
          var newBounds = new $.Rect(
                  bounds.x,
                  bounds.y,
                  bounds.width,
                  bounds.height);
  
          if (this.wrapHorizontal) {
              //do nothing
          } else {
              var horizontalThreshold = this.visibilityRatio * newBounds.width;
              var boundsRight = newBounds.x + newBounds.width;
              var contentRight = this._contentBoundsNoRotate.x + this._contentBoundsNoRotate.width;
              var leftDx = this._contentBoundsNoRotate.x - boundsRight + horizontalThreshold;
              var rightDx = contentRight - newBounds.x - horizontalThreshold;
  
              if (horizontalThreshold > this._contentBoundsNoRotate.width) {
                  newBounds.x += (leftDx + rightDx) / 2;
              } else if (rightDx < 0) {
                  newBounds.x += rightDx;
              } else if (leftDx > 0) {
                  newBounds.x += leftDx;
              }
          }
  
          if (this.wrapVertical) {
              //do nothing
          } else {
              var verticalThreshold   = this.visibilityRatio * newBounds.height;
              var boundsBottom = newBounds.y + newBounds.height;
              var contentBottom = this._contentBoundsNoRotate.y + this._contentBoundsNoRotate.height;
              var topDy = this._contentBoundsNoRotate.y - boundsBottom + verticalThreshold;
              var bottomDy = contentBottom - newBounds.y - verticalThreshold;
  
              if (verticalThreshold > this._contentBoundsNoRotate.height) {
                  newBounds.y += (topDy + bottomDy) / 2;
              } else if (bottomDy < 0) {
                  newBounds.y += bottomDy;
              } else if (topDy > 0) {
                  newBounds.y += topDy;
              }
          }
  
          return newBounds;
      },
  
      /**
       * @function
       * @private
       * @param {Boolean} [immediately=false] - whether the function that triggered this event was
       * called with the "immediately" flag
       */
      _raiseConstraintsEvent: function(immediately) {
          if (this.viewer) {
              /**
               * Raised when the viewport constraints are applied (see {@link OpenSeadragon.Viewport#applyConstraints}).
               *
               * @event constrain
               * @memberof OpenSeadragon.Viewer
               * @type {object}
               * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
               * @property {Boolean} immediately - whether the function that triggered this event was
               * called with the "immediately" flag
               * @property {?Object} userData - Arbitrary subscriber-defined object.
               */
              this.viewer.raiseEvent( 'constrain', {
                  immediately: immediately
              });
          }
      },
  
      /**
       * Enforces the minZoom, maxZoom and visibilityRatio constraints by
       * zooming and panning to the closest acceptable zoom and location.
       * @function
       * @param {Boolean} [immediately=false]
       * @return {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:constrain
       */
      applyConstraints: function(immediately) {
          var actualZoom = this.getZoom();
          var constrainedZoom = this._applyZoomConstraints(actualZoom);
  
          if (actualZoom !== constrainedZoom) {
              this.zoomTo(constrainedZoom, this.zoomPoint, immediately);
          }
  
          var bounds = this.getBoundsNoRotate();
          var constrainedBounds = this._applyBoundaryConstraints(bounds);
          this._raiseConstraintsEvent(immediately);
  
          if (bounds.x !== constrainedBounds.x ||
              bounds.y !== constrainedBounds.y ||
              immediately) {
              this.fitBounds(
                  constrainedBounds.rotate(-this.getRotation()),
                  immediately);
          }
          return this;
      },
  
      /**
       * Equivalent to {@link OpenSeadragon.Viewport#applyConstraints}
       * @function
       * @param {Boolean} [immediately=false]
       * @return {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:constrain
       */
      ensureVisible: function(immediately) {
          return this.applyConstraints(immediately);
      },
  
      /**
       * @function
       * @private
       * @param {OpenSeadragon.Rect} bounds
       * @param {Object} options (immediately=false, constraints=false)
       * @return {OpenSeadragon.Viewport} Chainable.
       */
      _fitBounds: function(bounds, options) {
          options = options || {};
          var immediately = options.immediately || false;
          var constraints = options.constraints || false;
  
          var aspect = this.getAspectRatio();
          var center = bounds.getCenter();
  
          // Compute width and height of bounding box.
          var newBounds = new $.Rect(
              bounds.x,
              bounds.y,
              bounds.width,
              bounds.height,
              bounds.degrees + this.getRotation())
              .getBoundingBox();
  
          if (newBounds.getAspectRatio() >= aspect) {
              newBounds.height = newBounds.width / aspect;
          } else {
              newBounds.width = newBounds.height * aspect;
          }
  
          // Compute x and y from width, height and center position
          newBounds.x = center.x - newBounds.width / 2;
          newBounds.y = center.y - newBounds.height / 2;
          var newZoom = 1.0 / newBounds.width;
  
          if (constraints) {
              var newBoundsAspectRatio = newBounds.getAspectRatio();
              var newConstrainedZoom = this._applyZoomConstraints(newZoom);
  
              if (newZoom !== newConstrainedZoom) {
                  newZoom = newConstrainedZoom;
                  newBounds.width = 1.0 / newZoom;
                  newBounds.x = center.x - newBounds.width / 2;
                  newBounds.height = newBounds.width / newBoundsAspectRatio;
                  newBounds.y = center.y - newBounds.height / 2;
              }
  
              newBounds = this._applyBoundaryConstraints(newBounds);
              center = newBounds.getCenter();
              this._raiseConstraintsEvent(immediately);
          }
  
          if (immediately) {
              this.panTo(center, true);
              return this.zoomTo(newZoom, null, true);
          }
  
          this.panTo(this.getCenter(true), true);
          this.zoomTo(this.getZoom(true), null, true);
  
          var oldBounds = this.getBounds();
          var oldZoom   = this.getZoom();
  
          if (oldZoom === 0 || Math.abs(newZoom / oldZoom - 1) < 0.00000001) {
              this.zoomTo(newZoom, true);
              return this.panTo(center, immediately);
          }
  
          newBounds = newBounds.rotate(-this.getRotation());
          var referencePoint = newBounds.getTopLeft().times(newZoom)
              .minus(oldBounds.getTopLeft().times(oldZoom))
              .divide(newZoom - oldZoom);
  
          return this.zoomTo(newZoom, referencePoint, immediately);
      },
  
      /**
       * Makes the viewport zoom and pan so that the specified bounds take
       * as much space as possible in the viewport.
       * Note: this method ignores the constraints (minZoom, maxZoom and
       * visibilityRatio).
       * Use {@link OpenSeadragon.Viewport#fitBoundsWithConstraints} to enforce
       * them.
       * @function
       * @param {OpenSeadragon.Rect} bounds
       * @param {Boolean} [immediately=false]
       * @return {OpenSeadragon.Viewport} Chainable.
       */
      fitBounds: function(bounds, immediately) {
          return this._fitBounds(bounds, {
              immediately: immediately,
              constraints: false
          });
      },
  
      /**
       * Makes the viewport zoom and pan so that the specified bounds take
       * as much space as possible in the viewport while enforcing the constraints
       * (minZoom, maxZoom and visibilityRatio).
       * Note: because this method enforces the constraints, part of the
       * provided bounds may end up outside of the viewport.
       * Use {@link OpenSeadragon.Viewport#fitBounds} to ignore them.
       * @function
       * @param {OpenSeadragon.Rect} bounds
       * @param {Boolean} [immediately=false]
       * @return {OpenSeadragon.Viewport} Chainable.
       */
      fitBoundsWithConstraints: function(bounds, immediately) {
          return this._fitBounds(bounds, {
              immediately: immediately,
              constraints: true
          });
      },
  
      /**
       * Zooms so the image just fills the viewer vertically.
       * @param {Boolean} immediately
       * @return {OpenSeadragon.Viewport} Chainable.
       */
      fitVertically: function(immediately) {
          var box = new $.Rect(
              this._contentBounds.x + (this._contentBounds.width / 2),
              this._contentBounds.y,
              0,
              this._contentBounds.height);
          return this.fitBounds(box, immediately);
      },
  
      /**
       * Zooms so the image just fills the viewer horizontally.
       * @param {Boolean} immediately
       * @return {OpenSeadragon.Viewport} Chainable.
       */
      fitHorizontally: function(immediately) {
          var box = new $.Rect(
              this._contentBounds.x,
              this._contentBounds.y + (this._contentBounds.height / 2),
              this._contentBounds.width,
              0);
          return this.fitBounds(box, immediately);
      },
  
  
      /**
       * Returns bounds taking constraints into account
       * Added to improve constrained panning
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       * @return {OpenSeadragon.Viewport} Chainable.
       */
      getConstrainedBounds: function(current) {
          var bounds,
              constrainedBounds;
  
          bounds = this.getBounds(current);
  
          constrainedBounds = this._applyBoundaryConstraints(bounds);
  
          return constrainedBounds;
      },
  
      /**
       * @function
       * @param {OpenSeadragon.Point} delta
       * @param {Boolean} immediately
       * @return {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:pan
       */
      panBy: function( delta, immediately ) {
          var center = new $.Point(
              this.centerSpringX.target.value,
              this.centerSpringY.target.value
          );
          return this.panTo( center.plus( delta ), immediately );
      },
  
      /**
       * @function
       * @param {OpenSeadragon.Point} center
       * @param {Boolean} immediately
       * @return {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:pan
       */
      panTo: function( center, immediately ) {
          if ( immediately ) {
              this.centerSpringX.resetTo( center.x );
              this.centerSpringY.resetTo( center.y );
          } else {
              this.centerSpringX.springTo( center.x );
              this.centerSpringY.springTo( center.y );
          }
  
          if( this.viewer ){
              /**
               * Raised when the viewport is panned (see {@link OpenSeadragon.Viewport#panBy} and {@link OpenSeadragon.Viewport#panTo}).
               *
               * @event pan
               * @memberof OpenSeadragon.Viewer
               * @type {object}
               * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
               * @property {OpenSeadragon.Point} center
               * @property {Boolean} immediately
               * @property {?Object} userData - Arbitrary subscriber-defined object.
               */
              this.viewer.raiseEvent( 'pan', {
                  center: center,
                  immediately: immediately
              });
          }
  
          return this;
      },
  
      /**
       * @function
       * @return {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:zoom
       */
      zoomBy: function(factor, refPoint, immediately) {
          return this.zoomTo(
              this.zoomSpring.target.value * factor, refPoint, immediately);
      },
  
      /**
       * Zooms to the specified zoom level
       * @function
       * @param {Number} zoom The zoom level to zoom to.
       * @param {OpenSeadragon.Point} [refPoint] The point which will stay at
       * the same screen location. Defaults to the viewport center.
       * @param {Boolean} [immediately=false]
       * @return {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:zoom
       */
      zoomTo: function(zoom, refPoint, immediately) {
          var _this = this;
  
          this.zoomPoint = refPoint instanceof $.Point &&
              !isNaN(refPoint.x) &&
              !isNaN(refPoint.y) ?
              refPoint :
              null;
  
          if (immediately) {
              this._adjustCenterSpringsForZoomPoint(function() {
                  _this.zoomSpring.resetTo(zoom);
              });
          } else {
              this.zoomSpring.springTo(zoom);
          }
  
          if (this.viewer) {
              /**
               * Raised when the viewport zoom level changes (see {@link OpenSeadragon.Viewport#zoomBy} and {@link OpenSeadragon.Viewport#zoomTo}).
               *
               * @event zoom
               * @memberof OpenSeadragon.Viewer
               * @type {object}
               * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
               * @property {Number} zoom
               * @property {OpenSeadragon.Point} refPoint
               * @property {Boolean} immediately
               * @property {?Object} userData - Arbitrary subscriber-defined object.
               */
              this.viewer.raiseEvent('zoom', {
                  zoom: zoom,
                  refPoint: refPoint,
                  immediately: immediately
              });
          }
  
          return this;
      },
  
      /**
       * Rotates this viewport to the angle specified.
       * @function
       * @param {Number} degrees The degrees to set the rotation to.
       * @return {OpenSeadragon.Viewport} Chainable.
       */
      setRotation: function(degrees) {
          if (!this.viewer || !this.viewer.drawer.canRotate()) {
              return this;
          }
          this.degrees = $.positiveModulo(degrees, 360);
          this._setContentBounds(
              this.viewer.world.getHomeBounds(),
              this.viewer.world.getContentFactor());
          this.viewer.forceRedraw();
  
          /**
           * Raised when rotation has been changed.
           *
           * @event rotate
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
           * @property {Number} degrees - The number of degrees the rotation was set to.
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.viewer.raiseEvent('rotate', {"degrees": degrees});
          return this;
      },
  
      /**
       * Gets the current rotation in degrees.
       * @function
       * @return {Number} The current rotation in degrees.
       */
      getRotation: function() {
          return this.degrees;
      },
  
      /**
       * @function
       * @return {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:resize
       */
      resize: function( newContainerSize, maintain ) {
          var oldBounds = this.getBoundsNoRotate(),
              newBounds = oldBounds,
              widthDeltaFactor;
  
          this.containerSize.x = newContainerSize.x;
          this.containerSize.y = newContainerSize.y;
  
          this._updateContainerInnerSize();
  
          if ( maintain ) {
              // TODO: widthDeltaFactor will always be 1; probably not what's intended
              widthDeltaFactor = newContainerSize.x / this.containerSize.x;
              newBounds.width  = oldBounds.width * widthDeltaFactor;
              newBounds.height = newBounds.width / this.getAspectRatio();
          }
  
          if( this.viewer ){
              /**
               * Raised when the viewer is resized (see {@link OpenSeadragon.Viewport#resize}).
               *
               * @event resize
               * @memberof OpenSeadragon.Viewer
               * @type {object}
               * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
               * @property {OpenSeadragon.Point} newContainerSize
               * @property {Boolean} maintain
               * @property {?Object} userData - Arbitrary subscriber-defined object.
               */
              this.viewer.raiseEvent( 'resize', {
                  newContainerSize: newContainerSize,
                  maintain: maintain
              });
          }
  
          return this.fitBounds( newBounds, true );
      },
  
      // private
      _updateContainerInnerSize: function() {
          this._containerInnerSize = new $.Point(
              Math.max(1, this.containerSize.x - (this._margins.left + this._margins.right)),
              Math.max(1, this.containerSize.y - (this._margins.top + this._margins.bottom))
          );
      },
  
      /**
       * Update the zoom and center (X and Y) springs.
       * @function
       * @returns {Boolean} True if any change has been made, false otherwise.
       */
      update: function() {
          var _this = this;
          this._adjustCenterSpringsForZoomPoint(function() {
              _this.zoomSpring.update();
          });
  
          this.centerSpringX.update();
          this.centerSpringY.update();
  
          var changed = this.centerSpringX.current.value !== this._oldCenterX ||
              this.centerSpringY.current.value !== this._oldCenterY ||
              this.zoomSpring.current.value !== this._oldZoom;
  
          this._oldCenterX = this.centerSpringX.current.value;
          this._oldCenterY = this.centerSpringY.current.value;
          this._oldZoom    = this.zoomSpring.current.value;
  
          return changed;
      },
  
      _adjustCenterSpringsForZoomPoint: function(zoomSpringHandler) {
          if (this.zoomPoint) {
              var oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
              zoomSpringHandler();
              var newZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
  
              var deltaZoomPixels = newZoomPixel.minus(oldZoomPixel);
              var deltaZoomPoints = this.deltaPointsFromPixels(
                  deltaZoomPixels, true);
  
              this.centerSpringX.shiftBy(deltaZoomPoints.x);
              this.centerSpringY.shiftBy(deltaZoomPoints.y);
  
              if (this.zoomSpring.isAtTargetValue()) {
                  this.zoomPoint = null;
              }
          } else {
              zoomSpringHandler();
          }
      },
  
      /**
       * Convert a delta (translation vector) from viewport coordinates to pixels
       * coordinates. This method does not take rotation into account.
       * Consider using deltaPixelsFromPoints if you need to account for rotation.
       * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      deltaPixelsFromPointsNoRotate: function(deltaPoints, current) {
          return deltaPoints.times(
              this._containerInnerSize.x * this.getZoom(current)
          );
      },
  
      /**
       * Convert a delta (translation vector) from viewport coordinates to pixels
       * coordinates.
       * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      deltaPixelsFromPoints: function(deltaPoints, current) {
          return this.deltaPixelsFromPointsNoRotate(
              deltaPoints.rotate(this.getRotation()),
              current);
      },
  
      /**
       * Convert a delta (translation vector) from pixels coordinates to viewport
       * coordinates. This method does not take rotation into account.
       * Consider using deltaPointsFromPixels if you need to account for rotation.
       * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      deltaPointsFromPixelsNoRotate: function(deltaPixels, current) {
          return deltaPixels.divide(
              this._containerInnerSize.x * this.getZoom(current)
          );
      },
  
      /**
       * Convert a delta (translation vector) from pixels coordinates to viewport
       * coordinates.
       * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      deltaPointsFromPixels: function(deltaPixels, current) {
          return this.deltaPointsFromPixelsNoRotate(deltaPixels, current)
              .rotate(-this.getRotation());
      },
  
      /**
       * Convert viewport coordinates to pixels coordinates.
       * This method does not take rotation into account.
       * Consider using pixelFromPoint if you need to account for rotation.
       * @param {OpenSeadragon.Point} point the viewport coordinates
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      pixelFromPointNoRotate: function(point, current) {
          return this._pixelFromPointNoRotate(
              point, this.getBoundsNoRotate(current));
      },
  
      /**
       * Convert viewport coordinates to pixel coordinates.
       * @param {OpenSeadragon.Point} point the viewport coordinates
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      pixelFromPoint: function(point, current) {
          return this._pixelFromPoint(point, this.getBoundsNoRotate(current));
      },
  
      // private
      _pixelFromPointNoRotate: function(point, bounds) {
          return point.minus(
              bounds.getTopLeft()
          ).times(
              this._containerInnerSize.x / bounds.width
          ).plus(
              new $.Point(this._margins.left, this._margins.top)
          );
      },
  
      // private
      _pixelFromPoint: function(point, bounds) {
          return this._pixelFromPointNoRotate(
              point.rotate(this.getRotation(), this.getCenter(true)),
              bounds);
      },
  
      /**
       * Convert pixel coordinates to viewport coordinates.
       * This method does not take rotation into account.
       * Consider using pointFromPixel if you need to account for rotation.
       * @param {OpenSeadragon.Point} pixel Pixel coordinates
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      pointFromPixelNoRotate: function(pixel, current) {
          var bounds = this.getBoundsNoRotate(current);
          return pixel.minus(
              new $.Point(this._margins.left, this._margins.top)
          ).divide(
              this._containerInnerSize.x / bounds.width
          ).plus(
              bounds.getTopLeft()
          );
      },
  
      /**
       * Convert pixel coordinates to viewport coordinates.
       * @param {OpenSeadragon.Point} pixel Pixel coordinates
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      pointFromPixel: function(pixel, current) {
          return this.pointFromPixelNoRotate(pixel, current).rotate(
              -this.getRotation(),
              this.getCenter(true)
          );
      },
  
      // private
      _viewportToImageDelta: function( viewerX, viewerY ) {
          var scale = this._contentBoundsNoRotate.width;
          return new $.Point(
              viewerX * this._contentSizeNoRotate.x / scale,
              viewerY * this._contentSizeNoRotate.x / scale);
      },
  
      /**
       * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
       * This method can be called either by passing X,Y coordinates or an
       * OpenSeadragon.Point
       * Note: not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.
       * @function
       * @param {(OpenSeadragon.Point|Number)} viewerX either a point or the X
       * coordinate in viewport coordinate system.
       * @param {Number} [viewerY] Y coordinate in viewport coordinate system.
       * @return {OpenSeadragon.Point} a point representing the coordinates in the image.
       */
      viewportToImageCoordinates: function(viewerX, viewerY) {
          if (viewerX instanceof $.Point) {
              //they passed a point instead of individual components
              return this.viewportToImageCoordinates(viewerX.x, viewerX.y);
          }
  
          if (this.viewer) {
              var count = this.viewer.world.getItemCount();
              if (count > 1) {
                  $.console.error('[Viewport.viewportToImageCoordinates] is not accurate ' +
                      'with multi-image; use TiledImage.viewportToImageCoordinates instead.');
              } else if (count === 1) {
                  // It is better to use TiledImage.viewportToImageCoordinates
                  // because this._contentBoundsNoRotate can not be relied on
                  // with clipping.
                  var item = this.viewer.world.getItemAt(0);
                  return item.viewportToImageCoordinates(viewerX, viewerY, true);
              }
          }
  
          return this._viewportToImageDelta(
              viewerX - this._contentBoundsNoRotate.x,
              viewerY - this._contentBoundsNoRotate.y);
      },
  
      // private
      _imageToViewportDelta: function( imageX, imageY ) {
          var scale = this._contentBoundsNoRotate.width;
          return new $.Point(
              imageX / this._contentSizeNoRotate.x * scale,
              imageY / this._contentSizeNoRotate.x * scale);
      },
  
      /**
       * Translates from image coordinate system to OpenSeadragon viewer coordinate system
       * This method can be called either by passing X,Y coordinates or an
       * OpenSeadragon.Point
       * Note: not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.
       * @function
       * @param {(OpenSeadragon.Point | Number)} imageX the point or the
       * X coordinate in image coordinate system.
       * @param {Number} [imageY] Y coordinate in image coordinate system.
       * @return {OpenSeadragon.Point} a point representing the coordinates in the viewport.
       */
      imageToViewportCoordinates: function(imageX, imageY) {
          if (imageX instanceof $.Point) {
              //they passed a point instead of individual components
              return this.imageToViewportCoordinates(imageX.x, imageX.y);
          }
  
          if (this.viewer) {
              var count = this.viewer.world.getItemCount();
              if (count > 1) {
                  $.console.error('[Viewport.imageToViewportCoordinates] is not accurate ' +
                      'with multi-image; use TiledImage.imageToViewportCoordinates instead.');
              } else if (count === 1) {
                  // It is better to use TiledImage.viewportToImageCoordinates
                  // because this._contentBoundsNoRotate can not be relied on
                  // with clipping.
                  var item = this.viewer.world.getItemAt(0);
                  return item.imageToViewportCoordinates(imageX, imageY, true);
              }
          }
  
          var point = this._imageToViewportDelta(imageX, imageY);
          point.x += this._contentBoundsNoRotate.x;
          point.y += this._contentBoundsNoRotate.y;
          return point;
      },
  
      /**
       * Translates from a rectangle which describes a portion of the image in
       * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
       * This method can be called either by passing X,Y,width,height or an
       * OpenSeadragon.Rect
       * Note: not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.
       * @function
       * @param {(OpenSeadragon.Rect | Number)} imageX the rectangle or the X
       * coordinate of the top left corner of the rectangle in image coordinate system.
       * @param {Number} [imageY] the Y coordinate of the top left corner of the rectangle
       * in image coordinate system.
       * @param {Number} [pixelWidth] the width in pixel of the rectangle.
       * @param {Number} [pixelHeight] the height in pixel of the rectangle.
       * @returns {OpenSeadragon.Rect} This image's bounds in viewport coordinates
       */
      imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight) {
          var rect = imageX;
          if (!(rect instanceof $.Rect)) {
              //they passed individual components instead of a rectangle
              rect = new $.Rect(imageX, imageY, pixelWidth, pixelHeight);
          }
  
          if (this.viewer) {
              var count = this.viewer.world.getItemCount();
              if (count > 1) {
                  $.console.error('[Viewport.imageToViewportRectangle] is not accurate ' +
                      'with multi-image; use TiledImage.imageToViewportRectangle instead.');
              } else if (count === 1) {
                  // It is better to use TiledImage.imageToViewportRectangle
                  // because this._contentBoundsNoRotate can not be relied on
                  // with clipping.
                  var item = this.viewer.world.getItemAt(0);
                  return item.imageToViewportRectangle(
                      imageX, imageY, pixelWidth, pixelHeight, true);
              }
          }
  
          var coordA = this.imageToViewportCoordinates(rect.x, rect.y);
          var coordB = this._imageToViewportDelta(rect.width, rect.height);
          return new $.Rect(
              coordA.x,
              coordA.y,
              coordB.x,
              coordB.y,
              rect.degrees
          );
      },
  
      /**
       * Translates from a rectangle which describes a portion of
       * the viewport in point coordinates to image rectangle coordinates.
       * This method can be called either by passing X,Y,width,height or an
       * OpenSeadragon.Rect
       * Note: not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.
       * @function
       * @param {(OpenSeadragon.Rect | Number)} viewerX either a rectangle or
       * the X coordinate of the top left corner of the rectangle in viewport
       * coordinate system.
       * @param {Number} [viewerY] the Y coordinate of the top left corner of the rectangle
       * in viewport coordinate system.
       * @param {Number} [pointWidth] the width of the rectangle in viewport coordinate system.
       * @param {Number} [pointHeight] the height of the rectangle in viewport coordinate system.
       */
      viewportToImageRectangle: function(viewerX, viewerY, pointWidth, pointHeight) {
          var rect = viewerX;
          if (!(rect instanceof $.Rect)) {
              //they passed individual components instead of a rectangle
              rect = new $.Rect(viewerX, viewerY, pointWidth, pointHeight);
          }
  
          if (this.viewer) {
              var count = this.viewer.world.getItemCount();
              if (count > 1) {
                  $.console.error('[Viewport.viewportToImageRectangle] is not accurate ' +
                      'with multi-image; use TiledImage.viewportToImageRectangle instead.');
              } else if (count === 1) {
                  // It is better to use TiledImage.viewportToImageCoordinates
                  // because this._contentBoundsNoRotate can not be relied on
                  // with clipping.
                  var item = this.viewer.world.getItemAt(0);
                  return item.viewportToImageRectangle(
                      viewerX, viewerY, pointWidth, pointHeight, true);
              }
          }
  
          var coordA = this.viewportToImageCoordinates(rect.x, rect.y);
          var coordB = this._viewportToImageDelta(rect.width, rect.height);
          return new $.Rect(
              coordA.x,
              coordA.y,
              coordB.x,
              coordB.y,
              rect.degrees
          );
      },
  
      /**
       * Convert pixel coordinates relative to the viewer element to image
       * coordinates.
       * Note: not accurate with multi-image.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      viewerElementToImageCoordinates: function( pixel ) {
          var point = this.pointFromPixel( pixel, true );
          return this.viewportToImageCoordinates( point );
      },
  
      /**
       * Convert pixel coordinates relative to the image to
       * viewer element coordinates.
       * Note: not accurate with multi-image.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      imageToViewerElementCoordinates: function( pixel ) {
          var point = this.imageToViewportCoordinates( pixel );
          return this.pixelFromPoint( point, true );
      },
  
      /**
       * Convert pixel coordinates relative to the window to image coordinates.
       * Note: not accurate with multi-image.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      windowToImageCoordinates: function(pixel) {
          $.console.assert(this.viewer,
              "[Viewport.windowToImageCoordinates] the viewport must have a viewer.");
          var viewerCoordinates = pixel.minus(
                  $.getElementPosition(this.viewer.element));
          return this.viewerElementToImageCoordinates(viewerCoordinates);
      },
  
      /**
       * Convert image coordinates to pixel coordinates relative to the window.
       * Note: not accurate with multi-image.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      imageToWindowCoordinates: function(pixel) {
          $.console.assert(this.viewer,
              "[Viewport.imageToWindowCoordinates] the viewport must have a viewer.");
          var viewerCoordinates = this.imageToViewerElementCoordinates(pixel);
          return viewerCoordinates.plus(
                  $.getElementPosition(this.viewer.element));
      },
  
      /**
       * Convert pixel coordinates relative to the viewer element to viewport
       * coordinates.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      viewerElementToViewportCoordinates: function( pixel ) {
          return this.pointFromPixel( pixel, true );
      },
  
      /**
       * Convert viewport coordinates to pixel coordinates relative to the
       * viewer element.
       * @param {OpenSeadragon.Point} point
       * @returns {OpenSeadragon.Point}
       */
      viewportToViewerElementCoordinates: function( point ) {
          return this.pixelFromPoint( point, true );
      },
  
      /**
       * Convert a rectangle in pixel coordinates relative to the viewer element
       * to viewport coordinates.
       * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
       * @returns {OpenSeadragon.Rect} the converted rectangle
       */
      viewerElementToViewportRectangle: function(rectangle) {
          return $.Rect.fromSummits(
              this.pointFromPixel(rectangle.getTopLeft(), true),
              this.pointFromPixel(rectangle.getTopRight(), true),
              this.pointFromPixel(rectangle.getBottomLeft(), true)
          );
      },
  
      /**
       * Convert a rectangle in viewport coordinates to pixel coordinates relative
       * to the viewer element.
       * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
       * @returns {OpenSeadragon.Rect} the converted rectangle
       */
      viewportToViewerElementRectangle: function(rectangle) {
          return $.Rect.fromSummits(
              this.pixelFromPoint(rectangle.getTopLeft(), true),
              this.pixelFromPoint(rectangle.getTopRight(), true),
              this.pixelFromPoint(rectangle.getBottomLeft(), true)
          );
      },
  
      /**
       * Convert pixel coordinates relative to the window to viewport coordinates.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      windowToViewportCoordinates: function(pixel) {
          $.console.assert(this.viewer,
              "[Viewport.windowToViewportCoordinates] the viewport must have a viewer.");
          var viewerCoordinates = pixel.minus(
                  $.getElementPosition(this.viewer.element));
          return this.viewerElementToViewportCoordinates(viewerCoordinates);
      },
  
      /**
       * Convert viewport coordinates to pixel coordinates relative to the window.
       * @param {OpenSeadragon.Point} point
       * @returns {OpenSeadragon.Point}
       */
      viewportToWindowCoordinates: function(point) {
          $.console.assert(this.viewer,
              "[Viewport.viewportToWindowCoordinates] the viewport must have a viewer.");
          var viewerCoordinates = this.viewportToViewerElementCoordinates(point);
          return viewerCoordinates.plus(
                  $.getElementPosition(this.viewer.element));
      },
  
      /**
       * Convert a viewport zoom to an image zoom.
       * Image zoom: ratio of the original image size to displayed image size.
       * 1 means original image size, 0.5 half size...
       * Viewport zoom: ratio of the displayed image's width to viewport's width.
       * 1 means identical width, 2 means image's width is twice the viewport's width...
       * Note: not accurate with multi-image.
       * @function
       * @param {Number} viewportZoom The viewport zoom
       * target zoom.
       * @returns {Number} imageZoom The image zoom
       */
      viewportToImageZoom: function(viewportZoom) {
          if (this.viewer) {
              var count = this.viewer.world.getItemCount();
              if (count > 1) {
                  $.console.error('[Viewport.viewportToImageZoom] is not ' +
                      'accurate with multi-image.');
              } else if (count === 1) {
                  // It is better to use TiledImage.viewportToImageZoom
                  // because this._contentBoundsNoRotate can not be relied on
                  // with clipping.
                  var item = this.viewer.world.getItemAt(0);
                  return item.viewportToImageZoom(viewportZoom);
              }
          }
  
          var imageWidth = this._contentSizeNoRotate.x;
          var containerWidth = this._containerInnerSize.x;
          var scale = this._contentBoundsNoRotate.width;
          var viewportToImageZoomRatio = (containerWidth / imageWidth) * scale;
          return viewportZoom * viewportToImageZoomRatio;
      },
  
      /**
       * Convert an image zoom to a viewport zoom.
       * Image zoom: ratio of the original image size to displayed image size.
       * 1 means original image size, 0.5 half size...
       * Viewport zoom: ratio of the displayed image's width to viewport's width.
       * 1 means identical width, 2 means image's width is twice the viewport's width...
       * Note: not accurate with multi-image.
       * @function
       * @param {Number} imageZoom The image zoom
       * target zoom.
       * @returns {Number} viewportZoom The viewport zoom
       */
      imageToViewportZoom: function(imageZoom) {
          if (this.viewer) {
              var count = this.viewer.world.getItemCount();
              if (count > 1) {
                  $.console.error('[Viewport.imageToViewportZoom] is not accurate ' +
                      'with multi-image.');
              } else if (count === 1) {
                  // It is better to use TiledImage.imageToViewportZoom
                  // because this._contentBoundsNoRotate can not be relied on
                  // with clipping.
                  var item = this.viewer.world.getItemAt(0);
                  return item.imageToViewportZoom(imageZoom);
              }
          }
  
          var imageWidth = this._contentSizeNoRotate.x;
          var containerWidth = this._containerInnerSize.x;
          var scale = this._contentBoundsNoRotate.width;
          var viewportToImageZoomRatio = (imageWidth / containerWidth) / scale;
          return imageZoom * viewportToImageZoomRatio;
      },
  
      /**
       * Toggles flip state and demands a new drawing on navigator and viewer objects.
       * @function
       * @return {OpenSeadragon.Viewport} Chainable.
       */
      toggleFlip: function() {
        this.setFlip(!this.getFlip());
        return this;
      },
  
      /**
       * Get flip state stored on viewport.
       * @function
       * @return {Boolean} Flip state.
       */
      getFlip: function() {
        return this.flipped;
      },
  
      /**
       * Sets flip state according to the state input argument.
       * @function
       * @param {Boolean} state - Flip state to set.
       * @return {OpenSeadragon.Viewport} Chainable.
       */
      setFlip: function( state ) {
        if ( this.flipped === state ) {
          return this;
        }
  
        this.flipped = state;
        if(this.viewer.navigator){
          this.viewer.navigator.setFlip(this.getFlip());
        }
        this.viewer.forceRedraw();
  
        /**
         * Raised when flip state has been changed.
         *
         * @event flip
         * @memberof OpenSeadragon.Viewer
         * @type {object}
         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
         * @property {Number} flipped - The flip state after this change.
         * @property {?Object} userData - Arbitrary subscriber-defined object.
         */
        this.viewer.raiseEvent('flip', {"flipped": state});
        return this;
      }
  
  };
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - TiledImage
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  /**
   * You shouldn't have to create a TiledImage instance directly; get it asynchronously by
   * using {@link OpenSeadragon.Viewer#open} or {@link OpenSeadragon.Viewer#addTiledImage} instead.
   * @class TiledImage
   * @memberof OpenSeadragon
   * @extends OpenSeadragon.EventSource
   * @classdesc Handles rendering of tiles for an {@link OpenSeadragon.Viewer}.
   * A new instance is created for each TileSource opened.
   * @param {Object} options - Configuration for this TiledImage.
   * @param {OpenSeadragon.TileSource} options.source - The TileSource that defines this TiledImage.
   * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this TiledImage.
   * @param {OpenSeadragon.TileCache} options.tileCache - The TileCache for this TiledImage to use.
   * @param {OpenSeadragon.Drawer} options.drawer - The Drawer for this TiledImage to draw onto.
   * @param {OpenSeadragon.ImageLoader} options.imageLoader - The ImageLoader for this TiledImage to use.
   * @param {Number} [options.x=0] - Left position, in viewport coordinates.
   * @param {Number} [options.y=0] - Top position, in viewport coordinates.
   * @param {Number} [options.width=1] - Width, in viewport coordinates.
   * @param {Number} [options.height] - Height, in viewport coordinates.
   * @param {OpenSeadragon.Rect} [options.fitBounds] The bounds in viewport coordinates
   * to fit the image into. If specified, x, y, width and height get ignored.
   * @param {OpenSeadragon.Placement} [options.fitBoundsPlacement=OpenSeadragon.Placement.CENTER]
   * How to anchor the image in the bounds if options.fitBounds is set.
   * @param {OpenSeadragon.Rect} [options.clip] - An area, in image pixels, to clip to
   * (portions of the image outside of this area will not be visible). Only works on
   * browsers that support the HTML5 canvas.
   * @param {Number} [options.springStiffness] - See {@link OpenSeadragon.Options}.
   * @param {Boolean} [options.animationTime] - See {@link OpenSeadragon.Options}.
   * @param {Number} [options.minZoomImageRatio] - See {@link OpenSeadragon.Options}.
   * @param {Boolean} [options.wrapHorizontal] - See {@link OpenSeadragon.Options}.
   * @param {Boolean} [options.wrapVertical] - See {@link OpenSeadragon.Options}.
   * @param {Boolean} [options.immediateRender] - See {@link OpenSeadragon.Options}.
   * @param {Number} [options.blendTime] - See {@link OpenSeadragon.Options}.
   * @param {Boolean} [options.alwaysBlend] - See {@link OpenSeadragon.Options}.
   * @param {Number} [options.minPixelRatio] - See {@link OpenSeadragon.Options}.
   * @param {Number} [options.smoothTileEdgesMinZoom] - See {@link OpenSeadragon.Options}.
   * @param {Boolean} [options.iOSDevice] - See {@link OpenSeadragon.Options}.
   * @param {Number} [options.opacity=1] - Set to draw at proportional opacity. If zero, images will not draw.
   * @param {Boolean} [options.preload=false] - Set true to load even when the image is hidden by zero opacity.
   * @param {String} [options.compositeOperation] - How the image is composited onto other images; see compositeOperation in {@link OpenSeadragon.Options} for possible values.
   * @param {Boolean} [options.debugMode] - See {@link OpenSeadragon.Options}.
   * @param {String|CanvasGradient|CanvasPattern|Function} [options.placeholderFillStyle] - See {@link OpenSeadragon.Options}.
   * @param {String|Boolean} [options.crossOriginPolicy] - See {@link OpenSeadragon.Options}.
   * @param {Boolean} [options.ajaxWithCredentials] - See {@link OpenSeadragon.Options}.
   * @param {Boolean} [options.loadTilesWithAjax]
   *      Whether to load tile data using AJAX requests.
   *      Defaults to the setting in {@link OpenSeadragon.Options}.
   * @param {Object} [options.ajaxHeaders={}]
   *      A set of headers to include when making tile AJAX requests.
   */
  $.TiledImage = function( options ) {
      var _this = this;
      /**
       * The {@link OpenSeadragon.TileSource} that defines this TiledImage.
       * @member {OpenSeadragon.TileSource} source
       * @memberof OpenSeadragon.TiledImage#
       */
      $.console.assert( options.tileCache, "[TiledImage] options.tileCache is required" );
      $.console.assert( options.drawer, "[TiledImage] options.drawer is required" );
      $.console.assert( options.viewer, "[TiledImage] options.viewer is required" );
      $.console.assert( options.imageLoader, "[TiledImage] options.imageLoader is required" );
      $.console.assert( options.source, "[TiledImage] options.source is required" );
      $.console.assert(!options.clip || options.clip instanceof $.Rect,
          "[TiledImage] options.clip must be an OpenSeadragon.Rect if present");
  
      $.EventSource.call( this );
  
      this._tileCache = options.tileCache;
      delete options.tileCache;
  
      this._drawer = options.drawer;
      delete options.drawer;
  
      this._imageLoader = options.imageLoader;
      delete options.imageLoader;
  
      if (options.clip instanceof $.Rect) {
          this._clip = options.clip.clone();
      }
  
      delete options.clip;
  
      var x = options.x || 0;
      delete options.x;
      var y = options.y || 0;
      delete options.y;
  
      // Ratio of zoomable image height to width.
      this.normHeight = options.source.dimensions.y / options.source.dimensions.x;
      this.contentAspectX = options.source.dimensions.x / options.source.dimensions.y;
  
      var scale = 1;
      if ( options.width ) {
          scale = options.width;
          delete options.width;
  
          if ( options.height ) {
              $.console.error( "specifying both width and height to a tiledImage is not supported" );
              delete options.height;
          }
      } else if ( options.height ) {
          scale = options.height / this.normHeight;
          delete options.height;
      }
  
      var fitBounds = options.fitBounds;
      delete options.fitBounds;
      var fitBoundsPlacement = options.fitBoundsPlacement || OpenSeadragon.Placement.CENTER;
      delete options.fitBoundsPlacement;
  
      var degrees = options.degrees || 0;
      delete options.degrees;
  
      $.extend( true, this, {
  
          //internal state properties
          viewer:         null,
          tilesMatrix:    {},    // A '3d' dictionary [level][x][y] --> Tile.
          coverage:       {},    // A '3d' dictionary [level][x][y] --> Boolean; shows what areas have been drawn.
          loadingCoverage: {},   // A '3d' dictionary [level][x][y] --> Boolean; shows what areas are loaded or are being loaded/blended.
          lastDrawn:      [],    // An unordered list of Tiles drawn last frame.
          lastResetTime:  0,     // Last time for which the tiledImage was reset.
          _midDraw:       false, // Is the tiledImage currently updating the viewport?
          _needsDraw:     true,  // Does the tiledImage need to update the viewport again?
          _hasOpaqueTile: false,  // Do we have even one fully opaque tile?
          _tilesLoading:  0,     // The number of pending tile requests.
          //configurable settings
          springStiffness:        $.DEFAULT_SETTINGS.springStiffness,
          animationTime:          $.DEFAULT_SETTINGS.animationTime,
          minZoomImageRatio:      $.DEFAULT_SETTINGS.minZoomImageRatio,
          wrapHorizontal:         $.DEFAULT_SETTINGS.wrapHorizontal,
          wrapVertical:           $.DEFAULT_SETTINGS.wrapVertical,
          immediateRender:        $.DEFAULT_SETTINGS.immediateRender,
          blendTime:              $.DEFAULT_SETTINGS.blendTime,
          alwaysBlend:            $.DEFAULT_SETTINGS.alwaysBlend,
          minPixelRatio:          $.DEFAULT_SETTINGS.minPixelRatio,
          smoothTileEdgesMinZoom: $.DEFAULT_SETTINGS.smoothTileEdgesMinZoom,
          iOSDevice:              $.DEFAULT_SETTINGS.iOSDevice,
          debugMode:              $.DEFAULT_SETTINGS.debugMode,
          crossOriginPolicy:      $.DEFAULT_SETTINGS.crossOriginPolicy,
          ajaxWithCredentials:    $.DEFAULT_SETTINGS.ajaxWithCredentials,
          placeholderFillStyle:   $.DEFAULT_SETTINGS.placeholderFillStyle,
          opacity:                $.DEFAULT_SETTINGS.opacity,
          preload:                $.DEFAULT_SETTINGS.preload,
          compositeOperation:     $.DEFAULT_SETTINGS.compositeOperation
      }, options );
  
      this._preload = this.preload;
      delete this.preload;
  
      this._fullyLoaded = false;
  
      this._xSpring = new $.Spring({
          initial: x,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
      });
  
      this._ySpring = new $.Spring({
          initial: y,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
      });
  
      this._scaleSpring = new $.Spring({
          initial: scale,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
      });
  
      this._degreesSpring = new $.Spring({
          initial: degrees,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
      });
  
      this._updateForScale();
  
      if (fitBounds) {
          this.fitBounds(fitBounds, fitBoundsPlacement, true);
      }
  
      // We need a callback to give image manipulation a chance to happen
      this._drawingHandler = function(args) {
        /**
         * This event is fired just before the tile is drawn giving the application a chance to alter the image.
         *
         * NOTE: This event is only fired when the drawer is using a &lt;canvas&gt;.
         *
         * @event tile-drawing
         * @memberof OpenSeadragon.Viewer
         * @type {object}
         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
         * @property {OpenSeadragon.Tile} tile - The Tile being drawn.
         * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
         * @property {OpenSeadragon.Tile} context - The HTML canvas context being drawn into.
         * @property {OpenSeadragon.Tile} rendered - The HTML canvas context containing the tile imagery.
         * @property {?Object} userData - Arbitrary subscriber-defined object.
         */
          _this.viewer.raiseEvent('tile-drawing', $.extend({
              tiledImage: _this
          }, args));
      };
  };
  
  $.extend($.TiledImage.prototype, $.EventSource.prototype, /** @lends OpenSeadragon.TiledImage.prototype */{
      /**
       * @returns {Boolean} Whether the TiledImage needs to be drawn.
       */
      needsDraw: function() {
          return this._needsDraw;
      },
  
      /**
       * @returns {Boolean} Whether all tiles necessary for this TiledImage to draw at the current view have been loaded.
       */
      getFullyLoaded: function() {
          return this._fullyLoaded;
      },
  
      // private
      _setFullyLoaded: function(flag) {
          if (flag === this._fullyLoaded) {
              return;
          }
  
          this._fullyLoaded = flag;
  
          /**
           * Fired when the TiledImage's "fully loaded" flag (whether all tiles necessary for this TiledImage
           * to draw at the current view have been loaded) changes.
           *
           * @event fully-loaded-change
           * @memberof OpenSeadragon.TiledImage
           * @type {object}
           * @property {Boolean} fullyLoaded - The new "fully loaded" value.
           * @property {OpenSeadragon.TiledImage} eventSource - A reference to the TiledImage which raised the event.
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent('fully-loaded-change', {
              fullyLoaded: this._fullyLoaded
          });
      },
  
      /**
       * Clears all tiles and triggers an update on the next call to
       * {@link OpenSeadragon.TiledImage#update}.
       */
      reset: function() {
          this._tileCache.clearTilesFor(this);
          this.lastResetTime = $.now();
          this._needsDraw = true;
      },
  
      /**
       * Updates the TiledImage's bounds, animating if needed.
       * @returns {Boolean} Whether the TiledImage animated.
       */
      update: function() {
          var xUpdated = this._xSpring.update();
          var yUpdated = this._ySpring.update();
          var scaleUpdated = this._scaleSpring.update();
          var degreesUpdated = this._degreesSpring.update();
  
          if (xUpdated || yUpdated || scaleUpdated || degreesUpdated) {
              this._updateForScale();
              this._needsDraw = true;
              return true;
          }
  
          return false;
      },
  
      /**
       * Draws the TiledImage to its Drawer.
       */
      draw: function() {
          if (this.opacity !== 0 || this._preload) {
              this._midDraw = true;
              this._updateViewport();
              this._midDraw = false;
          }
          // Images with opacity 0 should not need to be drawn in future. this._needsDraw = false is set in this._updateViewport() for other images.
          else {
              this._needsDraw = false;
          }
      },
  
      /**
       * Destroy the TiledImage (unload current loaded tiles).
       */
      destroy: function() {
          this.reset();
      },
  
      /**
       * Get this TiledImage's bounds in viewport coordinates.
       * @param {Boolean} [current=false] - Pass true for the current location;
       * false for target location.
       * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
       */
      getBounds: function(current) {
          return this.getBoundsNoRotate(current)
              .rotate(this.getRotation(current), this._getRotationPoint(current));
      },
  
      /**
       * Get this TiledImage's bounds in viewport coordinates without taking
       * rotation into account.
       * @param {Boolean} [current=false] - Pass true for the current location;
       * false for target location.
       * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
       */
      getBoundsNoRotate: function(current) {
          return current ?
              new $.Rect(
                  this._xSpring.current.value,
                  this._ySpring.current.value,
                  this._worldWidthCurrent,
                  this._worldHeightCurrent) :
              new $.Rect(
                  this._xSpring.target.value,
                  this._ySpring.target.value,
                  this._worldWidthTarget,
                  this._worldHeightTarget);
      },
  
      // deprecated
      getWorldBounds: function() {
          $.console.error('[TiledImage.getWorldBounds] is deprecated; use TiledImage.getBounds instead');
          return this.getBounds();
      },
  
      /**
       * Get the bounds of the displayed part of the tiled image.
       * @param {Boolean} [current=false] Pass true for the current location,
       * false for the target location.
       * @returns {$.Rect} The clipped bounds in viewport coordinates.
       */
      getClippedBounds: function(current) {
          var bounds = this.getBoundsNoRotate(current);
          if (this._clip) {
              var worldWidth = current ?
                  this._worldWidthCurrent : this._worldWidthTarget;
              var ratio = worldWidth / this.source.dimensions.x;
              var clip = this._clip.times(ratio);
              bounds = new $.Rect(
                  bounds.x + clip.x,
                  bounds.y + clip.y,
                  clip.width,
                  clip.height);
          }
          return bounds.rotate(this.getRotation(current), this._getRotationPoint(current));
      },
  
      /**
       * @returns {OpenSeadragon.Point} This TiledImage's content size, in original pixels.
       */
      getContentSize: function() {
          return new $.Point(this.source.dimensions.x, this.source.dimensions.y);
      },
  
      // private
      _viewportToImageDelta: function( viewerX, viewerY, current ) {
          var scale = (current ? this._scaleSpring.current.value : this._scaleSpring.target.value);
          return new $.Point(viewerX * (this.source.dimensions.x / scale),
              viewerY * ((this.source.dimensions.y * this.contentAspectX) / scale));
      },
  
      /**
       * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
       * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
       * @param {Number|OpenSeadragon.Point} viewerX - The X coordinate or point in viewport coordinate system.
       * @param {Number} [viewerY] - The Y coordinate in viewport coordinate system.
       * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
       * @return {OpenSeadragon.Point} A point representing the coordinates in the image.
       */
      viewportToImageCoordinates: function(viewerX, viewerY, current) {
          var point;
          if (viewerX instanceof $.Point) {
              //they passed a point instead of individual components
              current = viewerY;
              point = viewerX;
          } else {
              point = new $.Point(viewerX, viewerY);
          }
  
          point = point.rotate(-this.getRotation(current), this._getRotationPoint(current));
          return current ?
              this._viewportToImageDelta(
                  point.x - this._xSpring.current.value,
                  point.y - this._ySpring.current.value) :
              this._viewportToImageDelta(
                  point.x - this._xSpring.target.value,
                  point.y - this._ySpring.target.value);
      },
  
      // private
      _imageToViewportDelta: function( imageX, imageY, current ) {
          var scale = (current ? this._scaleSpring.current.value : this._scaleSpring.target.value);
          return new $.Point((imageX / this.source.dimensions.x) * scale,
              (imageY / this.source.dimensions.y / this.contentAspectX) * scale);
      },
  
      /**
       * Translates from image coordinate system to OpenSeadragon viewer coordinate system
       * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
       * @param {Number|OpenSeadragon.Point} imageX - The X coordinate or point in image coordinate system.
       * @param {Number} [imageY] - The Y coordinate in image coordinate system.
       * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
       * @return {OpenSeadragon.Point} A point representing the coordinates in the viewport.
       */
      imageToViewportCoordinates: function(imageX, imageY, current) {
          if (imageX instanceof $.Point) {
              //they passed a point instead of individual components
              current = imageY;
              imageY = imageX.y;
              imageX = imageX.x;
          }
  
          var point = this._imageToViewportDelta(imageX, imageY);
          if (current) {
              point.x += this._xSpring.current.value;
              point.y += this._ySpring.current.value;
          } else {
              point.x += this._xSpring.target.value;
              point.y += this._ySpring.target.value;
          }
  
          return point.rotate(this.getRotation(current), this._getRotationPoint(current));
      },
  
      /**
       * Translates from a rectangle which describes a portion of the image in
       * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
       * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
       * @param {Number|OpenSeadragon.Rect} imageX - The left coordinate or rectangle in image coordinate system.
       * @param {Number} [imageY] - The top coordinate in image coordinate system.
       * @param {Number} [pixelWidth] - The width in pixel of the rectangle.
       * @param {Number} [pixelHeight] - The height in pixel of the rectangle.
       * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
       * @return {OpenSeadragon.Rect} A rect representing the coordinates in the viewport.
       */
      imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight, current) {
          var rect = imageX;
          if (rect instanceof $.Rect) {
              //they passed a rect instead of individual components
              current = imageY;
          } else {
              rect = new $.Rect(imageX, imageY, pixelWidth, pixelHeight);
          }
  
          var coordA = this.imageToViewportCoordinates(rect.getTopLeft(), current);
          var coordB = this._imageToViewportDelta(rect.width, rect.height, current);
  
          return new $.Rect(
              coordA.x,
              coordA.y,
              coordB.x,
              coordB.y,
              rect.degrees + this.getRotation(current)
          );
      },
  
      /**
       * Translates from a rectangle which describes a portion of
       * the viewport in point coordinates to image rectangle coordinates.
       * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
       * @param {Number|OpenSeadragon.Rect} viewerX - The left coordinate or rectangle in viewport coordinate system.
       * @param {Number} [viewerY] - The top coordinate in viewport coordinate system.
       * @param {Number} [pointWidth] - The width in viewport coordinate system.
       * @param {Number} [pointHeight] - The height in viewport coordinate system.
       * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
       * @return {OpenSeadragon.Rect} A rect representing the coordinates in the image.
       */
      viewportToImageRectangle: function( viewerX, viewerY, pointWidth, pointHeight, current ) {
          var rect = viewerX;
          if (viewerX instanceof $.Rect) {
              //they passed a rect instead of individual components
              current = viewerY;
          } else {
              rect = new $.Rect(viewerX, viewerY, pointWidth, pointHeight);
          }
  
          var coordA = this.viewportToImageCoordinates(rect.getTopLeft(), current);
          var coordB = this._viewportToImageDelta(rect.width, rect.height, current);
  
          return new $.Rect(
              coordA.x,
              coordA.y,
              coordB.x,
              coordB.y,
              rect.degrees - this.getRotation(current)
          );
      },
  
      /**
       * Convert pixel coordinates relative to the viewer element to image
       * coordinates.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      viewerElementToImageCoordinates: function( pixel ) {
          var point = this.viewport.pointFromPixel( pixel, true );
          return this.viewportToImageCoordinates( point );
      },
  
      /**
       * Convert pixel coordinates relative to the image to
       * viewer element coordinates.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      imageToViewerElementCoordinates: function( pixel ) {
          var point = this.imageToViewportCoordinates( pixel );
          return this.viewport.pixelFromPoint( point, true );
      },
  
      /**
       * Convert pixel coordinates relative to the window to image coordinates.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      windowToImageCoordinates: function( pixel ) {
          var viewerCoordinates = pixel.minus(
                  OpenSeadragon.getElementPosition( this.viewer.element ));
          return this.viewerElementToImageCoordinates( viewerCoordinates );
      },
  
      /**
       * Convert image coordinates to pixel coordinates relative to the window.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      imageToWindowCoordinates: function( pixel ) {
          var viewerCoordinates = this.imageToViewerElementCoordinates( pixel );
          return viewerCoordinates.plus(
                  OpenSeadragon.getElementPosition( this.viewer.element ));
      },
  
      // private
      // Convert rectangle in viewport coordinates to this tiled image point
      // coordinates (x in [0, 1] and y in [0, aspectRatio])
      _viewportToTiledImageRectangle: function(rect) {
          var scale = this._scaleSpring.current.value;
          rect = rect.rotate(-this.getRotation(true), this._getRotationPoint(true));
          return new $.Rect(
              (rect.x - this._xSpring.current.value) / scale,
              (rect.y - this._ySpring.current.value) / scale,
              rect.width / scale,
              rect.height / scale,
              rect.degrees);
      },
  
      /**
       * Convert a viewport zoom to an image zoom.
       * Image zoom: ratio of the original image size to displayed image size.
       * 1 means original image size, 0.5 half size...
       * Viewport zoom: ratio of the displayed image's width to viewport's width.
       * 1 means identical width, 2 means image's width is twice the viewport's width...
       * @function
       * @param {Number} viewportZoom The viewport zoom
       * @returns {Number} imageZoom The image zoom
       */
      viewportToImageZoom: function( viewportZoom ) {
          var ratio = this._scaleSpring.current.value *
                  this.viewport._containerInnerSize.x / this.source.dimensions.x;
          return ratio * viewportZoom;
      },
  
      /**
       * Convert an image zoom to a viewport zoom.
       * Image zoom: ratio of the original image size to displayed image size.
       * 1 means original image size, 0.5 half size...
       * Viewport zoom: ratio of the displayed image's width to viewport's width.
       * 1 means identical width, 2 means image's width is twice the viewport's width...
       * Note: not accurate with multi-image.
       * @function
       * @param {Number} imageZoom The image zoom
       * @returns {Number} viewportZoom The viewport zoom
       */
      imageToViewportZoom: function( imageZoom ) {
          var ratio = this._scaleSpring.current.value *
                  this.viewport._containerInnerSize.x / this.source.dimensions.x;
          return imageZoom / ratio;
      },
  
      /**
       * Sets the TiledImage's position in the world.
       * @param {OpenSeadragon.Point} position - The new position, in viewport coordinates.
       * @param {Boolean} [immediately=false] - Whether to animate to the new position or snap immediately.
       * @fires OpenSeadragon.TiledImage.event:bounds-change
       */
      setPosition: function(position, immediately) {
          var sameTarget = (this._xSpring.target.value === position.x &&
              this._ySpring.target.value === position.y);
  
          if (immediately) {
              if (sameTarget && this._xSpring.current.value === position.x &&
                      this._ySpring.current.value === position.y) {
                  return;
              }
  
              this._xSpring.resetTo(position.x);
              this._ySpring.resetTo(position.y);
              this._needsDraw = true;
          } else {
              if (sameTarget) {
                  return;
              }
  
              this._xSpring.springTo(position.x);
              this._ySpring.springTo(position.y);
              this._needsDraw = true;
          }
  
          if (!sameTarget) {
              this._raiseBoundsChange();
          }
      },
  
      /**
       * Sets the TiledImage's width in the world, adjusting the height to match based on aspect ratio.
       * @param {Number} width - The new width, in viewport coordinates.
       * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
       * @fires OpenSeadragon.TiledImage.event:bounds-change
       */
      setWidth: function(width, immediately) {
          this._setScale(width, immediately);
      },
  
      /**
       * Sets the TiledImage's height in the world, adjusting the width to match based on aspect ratio.
       * @param {Number} height - The new height, in viewport coordinates.
       * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
       * @fires OpenSeadragon.TiledImage.event:bounds-change
       */
      setHeight: function(height, immediately) {
          this._setScale(height / this.normHeight, immediately);
      },
  
      /**
       * Sets an array of polygons to crop the TiledImage during draw tiles.
       * The render function will use the default non-zero winding rule.
       * @param Polygons represented in an array of point object in image coordinates.
       * Example format: [
       *  [{x: 197, y:172}, {x: 226, y:172}, {x: 226, y:198}, {x: 197, y:198}], // First polygon
       *  [{x: 328, y:200}, {x: 330, y:199}, {x: 332, y:201}, {x: 329, y:202}]  // Second polygon
       *  [{x: 321, y:201}, {x: 356, y:205}, {x: 341, y:250}] // Third polygon
       * ]
       */
      setCroppingPolygons: function( polygons ) {
  
          var isXYObject = function(obj) {
              return obj instanceof $.Point || (typeof obj.x === 'number' && typeof obj.y === 'number');
          };
  
          var objectToSimpleXYObject = function(objs) {
              return objs.map(function(obj) {
                  try {
                      if (isXYObject(obj)) {
                          return { x: obj.x, y: obj.y };
                      } else {
                          throw new Error();
                      }
                  } catch(e) {
                      throw new Error('A Provided cropping polygon point is not supported');
                  }
              });
          };
  
          try {
              if (!$.isArray(polygons)) {
                  throw new Error('Provided cropping polygon is not an array');
              }
              this._croppingPolygons = polygons.map(function(polygon){
                  return objectToSimpleXYObject(polygon);
              });
          } catch (e) {
              $.console.error('[TiledImage.setCroppingPolygons] Cropping polygon format not supported');
              $.console.error(e);
              this._croppingPolygons = null;
          }
      },
  
      /**
       * Resets the cropping polygons, thus next render will remove all cropping
       * polygon effects.
       */
      resetCroppingPolygons: function() {
          this._croppingPolygons = null;
      },
  
      /**
       * Positions and scales the TiledImage to fit in the specified bounds.
       * Note: this method fires OpenSeadragon.TiledImage.event:bounds-change
       * twice
       * @param {OpenSeadragon.Rect} bounds The bounds to fit the image into.
       * @param {OpenSeadragon.Placement} [anchor=OpenSeadragon.Placement.CENTER]
       * How to anchor the image in the bounds.
       * @param {Boolean} [immediately=false] Whether to animate to the new size
       * or snap immediately.
       * @fires OpenSeadragon.TiledImage.event:bounds-change
       */
      fitBounds: function(bounds, anchor, immediately) {
          anchor = anchor || $.Placement.CENTER;
          var anchorProperties = $.Placement.properties[anchor];
          var aspectRatio = this.contentAspectX;
          var xOffset = 0;
          var yOffset = 0;
          var displayedWidthRatio = 1;
          var displayedHeightRatio = 1;
          if (this._clip) {
              aspectRatio = this._clip.getAspectRatio();
              displayedWidthRatio = this._clip.width / this.source.dimensions.x;
              displayedHeightRatio = this._clip.height / this.source.dimensions.y;
              if (bounds.getAspectRatio() > aspectRatio) {
                  xOffset = this._clip.x / this._clip.height * bounds.height;
                  yOffset = this._clip.y / this._clip.height * bounds.height;
              } else {
                  xOffset = this._clip.x / this._clip.width * bounds.width;
                  yOffset = this._clip.y / this._clip.width * bounds.width;
              }
          }
  
          if (bounds.getAspectRatio() > aspectRatio) {
              // We will have margins on the X axis
              var height = bounds.height / displayedHeightRatio;
              var marginLeft = 0;
              if (anchorProperties.isHorizontallyCentered) {
                  marginLeft = (bounds.width - bounds.height * aspectRatio) / 2;
              } else if (anchorProperties.isRight) {
                  marginLeft = bounds.width - bounds.height * aspectRatio;
              }
              this.setPosition(
                  new $.Point(bounds.x - xOffset + marginLeft, bounds.y - yOffset),
                  immediately);
              this.setHeight(height, immediately);
          } else {
              // We will have margins on the Y axis
              var width = bounds.width / displayedWidthRatio;
              var marginTop = 0;
              if (anchorProperties.isVerticallyCentered) {
                  marginTop = (bounds.height - bounds.width / aspectRatio) / 2;
              } else if (anchorProperties.isBottom) {
                  marginTop = bounds.height - bounds.width / aspectRatio;
              }
              this.setPosition(
                  new $.Point(bounds.x - xOffset, bounds.y - yOffset + marginTop),
                  immediately);
              this.setWidth(width, immediately);
          }
      },
  
      /**
       * @returns {OpenSeadragon.Rect|null} The TiledImage's current clip rectangle,
       * in image pixels, or null if none.
       */
      getClip: function() {
          if (this._clip) {
              return this._clip.clone();
          }
  
          return null;
      },
  
      /**
       * @param {OpenSeadragon.Rect|null} newClip - An area, in image pixels, to clip to
       * (portions of the image outside of this area will not be visible). Only works on
       * browsers that support the HTML5 canvas.
       * @fires OpenSeadragon.TiledImage.event:clip-change
       */
      setClip: function(newClip) {
          $.console.assert(!newClip || newClip instanceof $.Rect,
              "[TiledImage.setClip] newClip must be an OpenSeadragon.Rect or null");
  
          if (newClip instanceof $.Rect) {
              this._clip = newClip.clone();
          } else {
              this._clip = null;
          }
  
          this._needsDraw = true;
          /**
           * Raised when the TiledImage's clip is changed.
           * @event clip-change
           * @memberOf OpenSeadragon.TiledImage
           * @type {object}
           * @property {OpenSeadragon.TiledImage} eventSource - A reference to the
           * TiledImage which raised the event.
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent('clip-change');
      },
  
      /**
       * @returns {Number} The TiledImage's current opacity.
       */
      getOpacity: function() {
          return this.opacity;
      },
  
      /**
       * @param {Number} opacity Opacity the tiled image should be drawn at.
       * @fires OpenSeadragon.TiledImage.event:opacity-change
       */
      setOpacity: function(opacity) {
          if (opacity === this.opacity) {
              return;
          }
  
          this.opacity = opacity;
          this._needsDraw = true;
          /**
           * Raised when the TiledImage's opacity is changed.
           * @event opacity-change
           * @memberOf OpenSeadragon.TiledImage
           * @type {object}
           * @property {Number} opacity - The new opacity value.
           * @property {OpenSeadragon.TiledImage} eventSource - A reference to the
           * TiledImage which raised the event.
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent('opacity-change', {
              opacity: this.opacity
          });
      },
  
      /**
       * @returns {Boolean} whether the tiledImage can load its tiles even when it has zero opacity.
       */
      getPreload: function() {
          return this._preload;
      },
  
      /**
       * Set true to load even when hidden. Set false to block loading when hidden.
       */
      setPreload: function(preload) {
          this._preload = !!preload;
          this._needsDraw = true;
      },
  
      /**
       * Get the rotation of this tiled image in degrees.
       * @param {Boolean} [current=false] True for current rotation, false for target.
       * @returns {Number} the rotation of this tiled image in degrees.
       */
      getRotation: function(current) {
          return current ?
              this._degreesSpring.current.value :
              this._degreesSpring.target.value;
      },
  
      /**
       * Set the current rotation of this tiled image in degrees.
       * @param {Number} degrees the rotation in degrees.
       * @param {Boolean} [immediately=false] Whether to animate to the new angle
       * or rotate immediately.
       * @fires OpenSeadragon.TiledImage.event:bounds-change
       */
      setRotation: function(degrees, immediately) {
          if (this._degreesSpring.target.value === degrees &&
              this._degreesSpring.isAtTargetValue()) {
              return;
          }
          if (immediately) {
              this._degreesSpring.resetTo(degrees);
          } else {
              this._degreesSpring.springTo(degrees);
          }
          this._needsDraw = true;
          this._raiseBoundsChange();
      },
  
      /**
       * Get the point around which this tiled image is rotated
       * @private
       * @param {Boolean} current True for current rotation point, false for target.
       * @returns {OpenSeadragon.Point}
       */
      _getRotationPoint: function(current) {
          return this.getBoundsNoRotate(current).getCenter();
      },
  
      /**
       * @returns {String} The TiledImage's current compositeOperation.
       */
      getCompositeOperation: function() {
          return this.compositeOperation;
      },
  
      /**
       * @param {String} compositeOperation the tiled image should be drawn with this globalCompositeOperation.
       * @fires OpenSeadragon.TiledImage.event:composite-operation-change
       */
      setCompositeOperation: function(compositeOperation) {
          if (compositeOperation === this.compositeOperation) {
              return;
          }
  
          this.compositeOperation = compositeOperation;
          this._needsDraw = true;
          /**
           * Raised when the TiledImage's opacity is changed.
           * @event composite-operation-change
           * @memberOf OpenSeadragon.TiledImage
           * @type {object}
           * @property {String} compositeOperation - The new compositeOperation value.
           * @property {OpenSeadragon.TiledImage} eventSource - A reference to the
           * TiledImage which raised the event.
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent('composite-operation-change', {
              compositeOperation: this.compositeOperation
          });
      },
  
      // private
      _setScale: function(scale, immediately) {
          var sameTarget = (this._scaleSpring.target.value === scale);
          if (immediately) {
              if (sameTarget && this._scaleSpring.current.value === scale) {
                  return;
              }
  
              this._scaleSpring.resetTo(scale);
              this._updateForScale();
              this._needsDraw = true;
          } else {
              if (sameTarget) {
                  return;
              }
  
              this._scaleSpring.springTo(scale);
              this._updateForScale();
              this._needsDraw = true;
          }
  
          if (!sameTarget) {
              this._raiseBoundsChange();
          }
      },
  
      // private
      _updateForScale: function() {
          this._worldWidthTarget = this._scaleSpring.target.value;
          this._worldHeightTarget = this.normHeight * this._scaleSpring.target.value;
          this._worldWidthCurrent = this._scaleSpring.current.value;
          this._worldHeightCurrent = this.normHeight * this._scaleSpring.current.value;
      },
  
      // private
      _raiseBoundsChange: function() {
          /**
           * Raised when the TiledImage's bounds are changed.
           * Note that this event is triggered only when the animation target is changed;
           * not for every frame of animation.
           * @event bounds-change
           * @memberOf OpenSeadragon.TiledImage
           * @type {object}
           * @property {OpenSeadragon.TiledImage} eventSource - A reference to the
           * TiledImage which raised the event.
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent('bounds-change');
      },
  
      // private
      _isBottomItem: function() {
          return this.viewer.world.getItemAt(0) === this;
      },
  
      // private
      _getLevelsInterval: function() {
          var lowestLevel = Math.max(
              this.source.minLevel,
              Math.floor(Math.log(this.minZoomImageRatio) / Math.log(2))
          );
          var currentZeroRatio = this.viewport.deltaPixelsFromPointsNoRotate(
              this.source.getPixelRatio(0), true).x *
              this._scaleSpring.current.value;
          var highestLevel = Math.min(
              Math.abs(this.source.maxLevel),
              Math.abs(Math.floor(
                  Math.log(currentZeroRatio / this.minPixelRatio) / Math.log(2)
              ))
          );
  
          // Calculations for the interval of levels to draw
          // can return invalid intervals; fix that here if necessary
          highestLevel = Math.max(highestLevel, this.source.minLevel || 0);
          lowestLevel = Math.min(lowestLevel, highestLevel);
          return {
              lowestLevel: lowestLevel,
              highestLevel: highestLevel
          };
      },
  
      /**
       * @private
       * @inner
       * Pretty much every other line in this needs to be documented so it's clear
       * how each piece of this routine contributes to the drawing process.  That's
       * why there are so many TODO's inside this function.
       */
      _updateViewport: function() {
          this._needsDraw = false;
          this._tilesLoading = 0;
          this.loadingCoverage = {};
  
          // Reset tile's internal drawn state
          while (this.lastDrawn.length > 0) {
              var tile = this.lastDrawn.pop();
              tile.beingDrawn = false;
          }
  
          var viewport = this.viewport;
          var drawArea = this._viewportToTiledImageRectangle(
              viewport.getBoundsWithMargins(true));
  
          if (!this.wrapHorizontal && !this.wrapVertical) {
              var tiledImageBounds = this._viewportToTiledImageRectangle(
                  this.getClippedBounds(true));
              drawArea = drawArea.intersection(tiledImageBounds);
              if (drawArea === null) {
                  return;
              }
          }
  
          var levelsInterval = this._getLevelsInterval();
          var lowestLevel = levelsInterval.lowestLevel;
          var highestLevel = levelsInterval.highestLevel;
          var bestTile = null;
          var haveDrawn = false;
          var currentTime = $.now();
  
          // Update any level that will be drawn
          for (var level = highestLevel; level >= lowestLevel; level--) {
              var drawLevel = false;
  
              //Avoid calculations for draw if we have already drawn this
              var currentRenderPixelRatio = viewport.deltaPixelsFromPointsNoRotate(
                  this.source.getPixelRatio(level),
                  true
              ).x * this._scaleSpring.current.value;
  
              if (level === lowestLevel ||
                  (!haveDrawn && currentRenderPixelRatio >= this.minPixelRatio)) {
                  drawLevel = true;
                  haveDrawn = true;
              } else if (!haveDrawn) {
                  continue;
              }
  
              //Perform calculations for draw if we haven't drawn this
              var targetRenderPixelRatio = viewport.deltaPixelsFromPointsNoRotate(
                  this.source.getPixelRatio(level),
                  false
              ).x * this._scaleSpring.current.value;
  
              var targetZeroRatio = viewport.deltaPixelsFromPointsNoRotate(
                  this.source.getPixelRatio(
                      Math.max(
                          this.source.getClosestLevel(),
                          0
                      )
                  ),
                  false
              ).x * this._scaleSpring.current.value;
  
              var optimalRatio = this.immediateRender ? 1 : targetZeroRatio;
              var levelOpacity = Math.min(1, (currentRenderPixelRatio - 0.5) / 0.5);
              var levelVisibility = optimalRatio / Math.abs(
                  optimalRatio - targetRenderPixelRatio
              );
  
              // Update the level and keep track of 'best' tile to load
              bestTile = updateLevel(
                  this,
                  haveDrawn,
                  drawLevel,
                  level,
                  levelOpacity,
                  levelVisibility,
                  drawArea,
                  currentTime,
                  bestTile
              );
  
              // Stop the loop if lower-res tiles would all be covered by
              // already drawn tiles
              if (providesCoverage(this.coverage, level)) {
                  break;
              }
          }
  
          // Perform the actual drawing
          drawTiles(this, this.lastDrawn);
  
          // Load the new 'best' tile
          if (bestTile && !bestTile.context2D) {
              loadTile(this, bestTile, currentTime);
              this._needsDraw = true;
              this._setFullyLoaded(false);
          } else {
              this._setFullyLoaded(this._tilesLoading === 0);
          }
      },
  
      // private
      _getCornerTiles: function(level, topLeftBound, bottomRightBound) {
          var leftX;
          var rightX;
          if (this.wrapHorizontal) {
              leftX = $.positiveModulo(topLeftBound.x, 1);
              rightX = $.positiveModulo(bottomRightBound.x, 1);
          } else {
              leftX = Math.max(0, topLeftBound.x);
              rightX = Math.min(1, bottomRightBound.x);
          }
          var topY;
          var bottomY;
          var aspectRatio = 1 / this.source.aspectRatio;
          if (this.wrapVertical) {
              topY = $.positiveModulo(topLeftBound.y, aspectRatio);
              bottomY = $.positiveModulo(bottomRightBound.y, aspectRatio);
          } else {
              topY = Math.max(0, topLeftBound.y);
              bottomY = Math.min(aspectRatio, bottomRightBound.y);
          }
  
          var topLeftTile = this.source.getTileAtPoint(level, new $.Point(leftX, topY));
          var bottomRightTile = this.source.getTileAtPoint(level, new $.Point(rightX, bottomY));
          var numTiles  = this.source.getNumTiles(level);
  
          if (this.wrapHorizontal) {
              topLeftTile.x += numTiles.x * Math.floor(topLeftBound.x);
              bottomRightTile.x += numTiles.x * Math.floor(bottomRightBound.x);
          }
          if (this.wrapVertical) {
              topLeftTile.y += numTiles.y * Math.floor(topLeftBound.y / aspectRatio);
              bottomRightTile.y += numTiles.y * Math.floor(bottomRightBound.y / aspectRatio);
          }
  
          return {
              topLeft: topLeftTile,
              bottomRight: bottomRightTile,
          };
      }
  });
  
  /**
   * @private
   * @inner
   * Updates all tiles at a given resolution level.
   * @param {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
   * @param {Boolean} haveDrawn
   * @param {Boolean} drawLevel
   * @param {Number} level
   * @param {Number} levelOpacity
   * @param {Number} levelVisibility
   * @param {OpenSeadragon.Point} viewportTL - The index of the most top-left visible tile.
   * @param {OpenSeadragon.Point} viewportBR - The index of the most bottom-right visible tile.
   * @param {Number} currentTime
   * @param {OpenSeadragon.Tile} best - The current "best" tile to draw.
   */
  function updateLevel(tiledImage, haveDrawn, drawLevel, level, levelOpacity,
      levelVisibility, drawArea, currentTime, best) {
  
      var topLeftBound = drawArea.getBoundingBox().getTopLeft();
      var bottomRightBound = drawArea.getBoundingBox().getBottomRight();
  
      if (tiledImage.viewer) {
          /**
           * <em>- Needs documentation -</em>
           *
           * @event update-level
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
           * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
           * @property {Object} havedrawn
           * @property {Object} level
           * @property {Object} opacity
           * @property {Object} visibility
           * @property {OpenSeadragon.Rect} drawArea
           * @property {Object} topleft deprecated, use drawArea instead
           * @property {Object} bottomright deprecated, use drawArea instead
           * @property {Object} currenttime
           * @property {Object} best
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          tiledImage.viewer.raiseEvent('update-level', {
              tiledImage: tiledImage,
              havedrawn: haveDrawn,
              level: level,
              opacity: levelOpacity,
              visibility: levelVisibility,
              drawArea: drawArea,
              topleft: topLeftBound,
              bottomright: bottomRightBound,
              currenttime: currentTime,
              best: best
          });
      }
  
      resetCoverage(tiledImage.coverage, level);
      resetCoverage(tiledImage.loadingCoverage, level);
  
      //OK, a new drawing so do your calculations
      var cornerTiles = tiledImage._getCornerTiles(level, topLeftBound, bottomRightBound);
      var topLeftTile = cornerTiles.topLeft;
      var bottomRightTile = cornerTiles.bottomRight;
      var numberOfTiles  = tiledImage.source.getNumTiles(level);
  
      var viewportCenter = tiledImage.viewport.pixelFromPoint(
          tiledImage.viewport.getCenter());
      for (var x = topLeftTile.x; x <= bottomRightTile.x; x++) {
          for (var y = topLeftTile.y; y <= bottomRightTile.y; y++) {
  
              // Optimisation disabled with wrapping because getTileBounds does not
              // work correctly with x and y outside of the number of tiles
              if (!tiledImage.wrapHorizontal && !tiledImage.wrapVertical) {
                  var tileBounds = tiledImage.source.getTileBounds(level, x, y);
                  if (drawArea.intersection(tileBounds) === null) {
                      // This tile is outside of the viewport, no need to draw it
                      continue;
                  }
              }
  
              best = updateTile(
                  tiledImage,
                  drawLevel,
                  haveDrawn,
                  x, y,
                  level,
                  levelOpacity,
                  levelVisibility,
                  viewportCenter,
                  numberOfTiles,
                  currentTime,
                  best
              );
  
          }
      }
  
      return best;
  }
  
  /**
   * @private
   * @inner
   * Update a single tile at a particular resolution level.
   * @param {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
   * @param {Boolean} haveDrawn
   * @param {Boolean} drawLevel
   * @param {Number} x
   * @param {Number} y
   * @param {Number} level
   * @param {Number} levelOpacity
   * @param {Number} levelVisibility
   * @param {OpenSeadragon.Point} viewportCenter
   * @param {Number} numberOfTiles
   * @param {Number} currentTime
   * @param {OpenSeadragon.Tile} best - The current "best" tile to draw.
   */
  function updateTile( tiledImage, haveDrawn, drawLevel, x, y, level, levelOpacity, levelVisibility, viewportCenter, numberOfTiles, currentTime, best){
  
      var tile = getTile(
              x, y,
              level,
              tiledImage,
              tiledImage.source,
              tiledImage.tilesMatrix,
              currentTime,
              numberOfTiles,
              tiledImage._worldWidthCurrent,
              tiledImage._worldHeightCurrent
          ),
          drawTile = drawLevel;
  
      if( tiledImage.viewer ){
          /**
           * <em>- Needs documentation -</em>
           *
           * @event update-tile
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
           * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
           * @property {OpenSeadragon.Tile} tile
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          tiledImage.viewer.raiseEvent( 'update-tile', {
              tiledImage: tiledImage,
              tile: tile
          });
      }
  
      setCoverage( tiledImage.coverage, level, x, y, false );
  
      var loadingCoverage = tile.loaded || tile.loading || isCovered(tiledImage.loadingCoverage, level, x, y);
      setCoverage(tiledImage.loadingCoverage, level, x, y, loadingCoverage);
  
      if ( !tile.exists ) {
          return best;
      }
  
      if ( haveDrawn && !drawTile ) {
          if ( isCovered( tiledImage.coverage, level, x, y ) ) {
              setCoverage( tiledImage.coverage, level, x, y, true );
          } else {
              drawTile = true;
          }
      }
  
      if ( !drawTile ) {
          return best;
      }
  
      positionTile(
          tile,
          tiledImage.source.tileOverlap,
          tiledImage.viewport,
          viewportCenter,
          levelVisibility,
          tiledImage
      );
  
      if (!tile.loaded) {
          if (tile.context2D) {
              setTileLoaded(tiledImage, tile);
          } else {
              var imageRecord = tiledImage._tileCache.getImageRecord(tile.cacheKey);
              if (imageRecord) {
                  var image = imageRecord.getImage();
                  setTileLoaded(tiledImage, tile, image);
              }
          }
      }
  
      if ( tile.loaded ) {
          var needsDraw = blendTile(
              tiledImage,
              tile,
              x, y,
              level,
              levelOpacity,
              currentTime
          );
  
          if ( needsDraw ) {
              tiledImage._needsDraw = true;
          }
      } else if ( tile.loading ) {
          // the tile is already in the download queue
          tiledImage._tilesLoading++;
      } else if (!loadingCoverage) {
          best = compareTiles( best, tile );
      }
  
      return best;
  }
  
  /**
   * @private
   * @inner
   * Obtains a tile at the given location.
   * @param {Number} x
   * @param {Number} y
   * @param {Number} level
   * @param {OpenSeadragon.TiledImage} tiledImage
   * @param {OpenSeadragon.TileSource} tileSource
   * @param {Object} tilesMatrix - A '3d' dictionary [level][x][y] --> Tile.
   * @param {Number} time
   * @param {Number} numTiles
   * @param {Number} worldWidth
   * @param {Number} worldHeight
   * @returns {OpenSeadragon.Tile}
   */
  function getTile(
      x, y,
      level,
      tiledImage,
      tileSource,
      tilesMatrix,
      time,
      numTiles,
      worldWidth,
      worldHeight
  ) {
      var xMod,
          yMod,
          bounds,
          sourceBounds,
          exists,
          url,
          ajaxHeaders,
          context2D,
          tile;
  
      if ( !tilesMatrix[ level ] ) {
          tilesMatrix[ level ] = {};
      }
      if ( !tilesMatrix[ level ][ x ] ) {
          tilesMatrix[ level ][ x ] = {};
      }
  
      if ( !tilesMatrix[ level ][ x ][ y ] ) {
          xMod    = ( numTiles.x + ( x % numTiles.x ) ) % numTiles.x;
          yMod    = ( numTiles.y + ( y % numTiles.y ) ) % numTiles.y;
          bounds  = tileSource.getTileBounds( level, xMod, yMod );
          sourceBounds = tileSource.getTileBounds( level, xMod, yMod, true );
          exists  = tileSource.tileExists( level, xMod, yMod );
          url     = tileSource.getTileUrl( level, xMod, yMod );
  
          // Headers are only applicable if loadTilesWithAjax is set
          if (tiledImage.loadTilesWithAjax) {
              ajaxHeaders = tileSource.getTileAjaxHeaders( level, xMod, yMod );
              // Combine tile AJAX headers with tiled image AJAX headers (if applicable)
              if ($.isPlainObject(tiledImage.ajaxHeaders)) {
                  ajaxHeaders = $.extend({}, tiledImage.ajaxHeaders, ajaxHeaders);
              }
          } else {
              ajaxHeaders = null;
          }
  
          context2D = tileSource.getContext2D ?
              tileSource.getContext2D(level, xMod, yMod) : undefined;
  
          bounds.x += ( x - xMod ) / numTiles.x;
          bounds.y += (worldHeight / worldWidth) * (( y - yMod ) / numTiles.y);
  
          tile = new $.Tile(
              level,
              x,
              y,
              bounds,
              exists,
              url,
              context2D,
              tiledImage.loadTilesWithAjax,
              ajaxHeaders,
              sourceBounds
          );
  
          if (xMod === numTiles.x - 1) {
              tile.isRightMost = true;
          }
  
          if (yMod === numTiles.y - 1) {
              tile.isBottomMost = true;
          }
  
          tilesMatrix[ level ][ x ][ y ] = tile;
      }
  
      tile = tilesMatrix[ level ][ x ][ y ];
      tile.lastTouchTime = time;
  
      return tile;
  }
  
  /**
   * @private
   * @inner
   * Dispatch a job to the ImageLoader to load the Image for a Tile.
   * @param {OpenSeadragon.TiledImage} tiledImage
   * @param {OpenSeadragon.Tile} tile
   * @param {Number} time
   */
  function loadTile( tiledImage, tile, time ) {
      tile.loading = true;
      tiledImage._imageLoader.addJob({
          src: tile.url,
          loadWithAjax: tile.loadWithAjax,
          ajaxHeaders: tile.ajaxHeaders,
          crossOriginPolicy: tiledImage.crossOriginPolicy,
          ajaxWithCredentials: tiledImage.ajaxWithCredentials,
          callback: function( image, errorMsg, tileRequest ){
              onTileLoad( tiledImage, tile, time, image, errorMsg, tileRequest );
          },
          abort: function() {
              tile.loading = false;
          }
      });
  }
  
  /**
   * @private
   * @inner
   * Callback fired when a Tile's Image finished downloading.
   * @param {OpenSeadragon.TiledImage} tiledImage
   * @param {OpenSeadragon.Tile} tile
   * @param {Number} time
   * @param {Image} image
   * @param {String} errorMsg
   * @param {XMLHttpRequest} tileRequest
   */
  function onTileLoad( tiledImage, tile, time, image, errorMsg, tileRequest ) {
      if ( !image ) {
          $.console.log( "Tile %s failed to load: %s - error: %s", tile, tile.url, errorMsg );
          /**
           * Triggered when a tile fails to load.
           *
           * @event tile-load-failed
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.Tile} tile - The tile that failed to load.
           * @property {OpenSeadragon.TiledImage} tiledImage - The tiled image the tile belongs to.
           * @property {number} time - The time in milliseconds when the tile load began.
           * @property {string} message - The error message.
           * @property {XMLHttpRequest} tileRequest - The XMLHttpRequest used to load the tile if available.
           */
          tiledImage.viewer.raiseEvent("tile-load-failed", {
              tile: tile,
              tiledImage: tiledImage,
              time: time,
              message: errorMsg,
              tileRequest: tileRequest
          });
          tile.loading = false;
          tile.exists = false;
          return;
      }
  
      if ( time < tiledImage.lastResetTime ) {
          $.console.log( "Ignoring tile %s loaded before reset: %s", tile, tile.url );
          tile.loading = false;
          return;
      }
  
      var finish = function() {
          var cutoff = tiledImage.source.getClosestLevel();
          setTileLoaded(tiledImage, tile, image, cutoff, tileRequest);
      };
  
      // Check if we're mid-update; this can happen on IE8 because image load events for
      // cached images happen immediately there
      if ( !tiledImage._midDraw ) {
          finish();
      } else {
          // Wait until after the update, in case caching unloads any tiles
          window.setTimeout( finish, 1);
      }
  }
  
  /**
   * @private
   * @inner
   * @param {OpenSeadragon.TiledImage} tiledImage
   * @param {OpenSeadragon.Tile} tile
   * @param {Image} image
   * @param {Number} cutoff
   */
  function setTileLoaded(tiledImage, tile, image, cutoff, tileRequest) {
      var increment = 0;
  
      function getCompletionCallback() {
          increment++;
          return completionCallback;
      }
  
      function completionCallback() {
          increment--;
          if (increment === 0) {
              tile.loading = false;
              tile.loaded = true;
              if (!tile.context2D) {
                  tiledImage._tileCache.cacheTile({
                      image: image,
                      tile: tile,
                      cutoff: cutoff,
                      tiledImage: tiledImage
                  });
              }
              tiledImage._needsDraw = true;
          }
      }
  
      /**
       * Triggered when a tile has just been loaded in memory. That means that the
       * image has been downloaded and can be modified before being drawn to the canvas.
       *
       * @event tile-loaded
       * @memberof OpenSeadragon.Viewer
       * @type {object}
       * @property {Image} image - The image of the tile.
       * @property {OpenSeadragon.TiledImage} tiledImage - The tiled image of the loaded tile.
       * @property {OpenSeadragon.Tile} tile - The tile which has been loaded.
       * @property {XMLHttpRequest} tiledImage - The AJAX request that loaded this tile (if applicable).
       * @property {function} getCompletionCallback - A function giving a callback to call
       * when the asynchronous processing of the image is done. The image will be
       * marked as entirely loaded when the callback has been called once for each
       * call to getCompletionCallback.
       */
      tiledImage.viewer.raiseEvent("tile-loaded", {
          tile: tile,
          tiledImage: tiledImage,
          tileRequest: tileRequest,
          image: image,
          getCompletionCallback: getCompletionCallback
      });
      // In case the completion callback is never called, we at least force it once.
      getCompletionCallback()();
  }
  
  /**
   * @private
   * @inner
   * @param {OpenSeadragon.Tile} tile
   * @param {Boolean} overlap
   * @param {OpenSeadragon.Viewport} viewport
   * @param {OpenSeadragon.Point} viewportCenter
   * @param {Number} levelVisibility
   * @param {OpenSeadragon.TiledImage} tiledImage
   */
  function positionTile( tile, overlap, viewport, viewportCenter, levelVisibility, tiledImage ){
      var boundsTL     = tile.bounds.getTopLeft();
  
      boundsTL.x *= tiledImage._scaleSpring.current.value;
      boundsTL.y *= tiledImage._scaleSpring.current.value;
      boundsTL.x += tiledImage._xSpring.current.value;
      boundsTL.y += tiledImage._ySpring.current.value;
  
      var boundsSize   = tile.bounds.getSize();
  
      boundsSize.x *= tiledImage._scaleSpring.current.value;
      boundsSize.y *= tiledImage._scaleSpring.current.value;
  
      var positionC = viewport.pixelFromPointNoRotate(boundsTL, true),
          positionT = viewport.pixelFromPointNoRotate(boundsTL, false),
          sizeC = viewport.deltaPixelsFromPointsNoRotate(boundsSize, true),
          sizeT = viewport.deltaPixelsFromPointsNoRotate(boundsSize, false),
          tileCenter = positionT.plus( sizeT.divide( 2 ) ),
          tileSquaredDistance = viewportCenter.squaredDistanceTo( tileCenter );
  
      if ( !overlap ) {
          sizeC = sizeC.plus( new $.Point( 1, 1 ) );
      }
  
      if (tile.isRightMost && tiledImage.wrapHorizontal) {
          sizeC.x += 0.75; // Otherwise Firefox and Safari show seams
      }
  
      if (tile.isBottomMost && tiledImage.wrapVertical) {
          sizeC.y += 0.75; // Otherwise Firefox and Safari show seams
      }
  
      tile.position   = positionC;
      tile.size       = sizeC;
      tile.squaredDistance   = tileSquaredDistance;
      tile.visibility = levelVisibility;
  }
  
  /**
   * @private
   * @inner
   * Updates the opacity of a tile according to the time it has been on screen
   * to perform a fade-in.
   * Updates coverage once a tile is fully opaque.
   * Returns whether the fade-in has completed.
   *
   * @param {OpenSeadragon.TiledImage} tiledImage
   * @param {OpenSeadragon.Tile} tile
   * @param {Number} x
   * @param {Number} y
   * @param {Number} level
   * @param {Number} levelOpacity
   * @param {Number} currentTime
   * @returns {Boolean}
   */
  function blendTile( tiledImage, tile, x, y, level, levelOpacity, currentTime ){
      var blendTimeMillis = 1000 * tiledImage.blendTime,
          deltaTime,
          opacity;
  
      if ( !tile.blendStart ) {
          tile.blendStart = currentTime;
      }
  
      deltaTime   = currentTime - tile.blendStart;
      opacity     = blendTimeMillis ? Math.min( 1, deltaTime / ( blendTimeMillis ) ) : 1;
  
      if ( tiledImage.alwaysBlend ) {
          opacity *= levelOpacity;
      }
  
      tile.opacity = opacity;
  
      tiledImage.lastDrawn.push( tile );
  
      if ( opacity === 1 ) {
          setCoverage( tiledImage.coverage, level, x, y, true );
          tiledImage._hasOpaqueTile = true;
      } else if ( deltaTime < blendTimeMillis ) {
          return true;
      }
  
      return false;
  }
  
  /**
   * @private
   * @inner
   * Returns true if the given tile provides coverage to lower-level tiles of
   * lower resolution representing the same content. If neither x nor y is
   * given, returns true if the entire visible level provides coverage.
   *
   * Note that out-of-bounds tiles provide coverage in this sense, since
   * there's no content that they would need to cover. Tiles at non-existent
   * levels that are within the image bounds, however, do not.
   *
   * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
   * @param {Number} level - The resolution level of the tile.
   * @param {Number} x - The X position of the tile.
   * @param {Number} y - The Y position of the tile.
   * @returns {Boolean}
   */
  function providesCoverage( coverage, level, x, y ) {
      var rows,
          cols,
          i, j;
  
      if ( !coverage[ level ] ) {
          return false;
      }
  
      if ( x === undefined || y === undefined ) {
          rows = coverage[ level ];
          for ( i in rows ) {
              if ( Object.prototype.hasOwnProperty.call( rows, i ) ) {
                  cols = rows[ i ];
                  for ( j in cols ) {
                      if ( Object.prototype.hasOwnProperty.call( cols, j ) && !cols[ j ] ) {
                          return false;
                      }
                  }
              }
          }
  
          return true;
      }
  
      return (
          coverage[ level ][ x] === undefined ||
          coverage[ level ][ x ][ y ] === undefined ||
          coverage[ level ][ x ][ y ] === true
      );
  }
  
  /**
   * @private
   * @inner
   * Returns true if the given tile is completely covered by higher-level
   * tiles of higher resolution representing the same content. If neither x
   * nor y is given, returns true if the entire visible level is covered.
   *
   * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
   * @param {Number} level - The resolution level of the tile.
   * @param {Number} x - The X position of the tile.
   * @param {Number} y - The Y position of the tile.
   * @returns {Boolean}
   */
  function isCovered( coverage, level, x, y ) {
      if ( x === undefined || y === undefined ) {
          return providesCoverage( coverage, level + 1 );
      } else {
          return (
               providesCoverage( coverage, level + 1, 2 * x, 2 * y ) &&
               providesCoverage( coverage, level + 1, 2 * x, 2 * y + 1 ) &&
               providesCoverage( coverage, level + 1, 2 * x + 1, 2 * y ) &&
               providesCoverage( coverage, level + 1, 2 * x + 1, 2 * y + 1 )
          );
      }
  }
  
  /**
   * @private
   * @inner
   * Sets whether the given tile provides coverage or not.
   *
   * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
   * @param {Number} level - The resolution level of the tile.
   * @param {Number} x - The X position of the tile.
   * @param {Number} y - The Y position of the tile.
   * @param {Boolean} covers - Whether the tile provides coverage.
   */
  function setCoverage( coverage, level, x, y, covers ) {
      if ( !coverage[ level ] ) {
          $.console.warn(
              "Setting coverage for a tile before its level's coverage has been reset: %s",
              level
          );
          return;
      }
  
      if ( !coverage[ level ][ x ] ) {
          coverage[ level ][ x ] = {};
      }
  
      coverage[ level ][ x ][ y ] = covers;
  }
  
  /**
   * @private
   * @inner
   * Resets coverage information for the given level. This should be called
   * after every draw routine. Note that at the beginning of the next draw
   * routine, coverage for every visible tile should be explicitly set.
   *
   * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
   * @param {Number} level - The resolution level of tiles to completely reset.
   */
  function resetCoverage( coverage, level ) {
      coverage[ level ] = {};
  }
  
  /**
   * @private
   * @inner
   * Determines whether the 'last best' tile for the area is better than the
   * tile in question.
   *
   * @param {OpenSeadragon.Tile} previousBest
   * @param {OpenSeadragon.Tile} tile
   * @returns {OpenSeadragon.Tile} The new best tile.
   */
  function compareTiles( previousBest, tile ) {
      if ( !previousBest ) {
          return tile;
      }
  
      if ( tile.visibility > previousBest.visibility ) {
          return tile;
      } else if ( tile.visibility == previousBest.visibility ) {
          if ( tile.squaredDistance < previousBest.squaredDistance ) {
              return tile;
          }
      }
  
      return previousBest;
  }
  
  /**
   * @private
   * @inner
   * Draws a TiledImage.
   * @param {OpenSeadragon.TiledImage} tiledImage
   * @param {OpenSeadragon.Tile[]} lastDrawn - An unordered list of Tiles drawn last frame.
   */
  function drawTiles( tiledImage, lastDrawn ) {
      if (tiledImage.opacity === 0 || (lastDrawn.length === 0 && !tiledImage.placeholderFillStyle)) {
          return;
      }
  
      var tile = lastDrawn[0];
      var useSketch;
  
      if (tile) {
          useSketch = tiledImage.opacity < 1 ||
              (tiledImage.compositeOperation &&
                  tiledImage.compositeOperation !== 'source-over') ||
              (!tiledImage._isBottomItem() && tile._hasTransparencyChannel());
      }
  
      var sketchScale;
      var sketchTranslate;
  
      var zoom = tiledImage.viewport.getZoom(true);
      var imageZoom = tiledImage.viewportToImageZoom(zoom);
  
      if (lastDrawn.length > 1 &&
          imageZoom > tiledImage.smoothTileEdgesMinZoom &&
          !tiledImage.iOSDevice &&
          tiledImage.getRotation(true) % 360 === 0 && // TODO: support tile edge smoothing with tiled image rotation.
          $.supportsCanvas) {
          // When zoomed in a lot (>100%) the tile edges are visible.
          // So we have to composite them at ~100% and scale them up together.
          // Note: Disabled on iOS devices per default as it causes a native crash
          useSketch = true;
          sketchScale = tile.getScaleForEdgeSmoothing();
          sketchTranslate = tile.getTranslationForEdgeSmoothing(sketchScale,
              tiledImage._drawer.getCanvasSize(false),
              tiledImage._drawer.getCanvasSize(true));
      }
  
      var bounds;
      if (useSketch) {
          if (!sketchScale) {
              // Except when edge smoothing, we only clean the part of the
              // sketch canvas we are going to use for performance reasons.
              bounds = tiledImage.viewport.viewportToViewerElementRectangle(
                  tiledImage.getClippedBounds(true))
                  .getIntegerBoundingBox();
  
              if(tiledImage._drawer.viewer.viewport.getFlip()) {
                if (tiledImage.viewport.degrees !== 0 || tiledImage.getRotation(true) % 360 !== 0){
                  bounds.x = tiledImage._drawer.viewer.container.clientWidth - (bounds.x + bounds.width);
                }
              }
  
              bounds = bounds.times($.pixelDensityRatio);
          }
          tiledImage._drawer._clear(true, bounds);
      }
  
      // When scaling, we must rotate only when blending the sketch canvas to
      // avoid interpolation
      if (!sketchScale) {
          if (tiledImage.viewport.degrees !== 0) {
              tiledImage._drawer._offsetForRotation({
                  degrees: tiledImage.viewport.degrees,
                  useSketch: useSketch
              });
          }
          if (tiledImage.getRotation(true) % 360 !== 0) {
              tiledImage._drawer._offsetForRotation({
                  degrees: tiledImage.getRotation(true),
                  point: tiledImage.viewport.pixelFromPointNoRotate(
                      tiledImage._getRotationPoint(true), true),
                  useSketch: useSketch
              });
          }
  
          if (tiledImage.viewport.degrees === 0 && tiledImage.getRotation(true) % 360 === 0){
            if(tiledImage._drawer.viewer.viewport.getFlip()) {
                tiledImage._drawer._flip();
            }
          }
      }
  
      var usedClip = false;
      if ( tiledImage._clip ) {
          tiledImage._drawer.saveContext(useSketch);
  
          var box = tiledImage.imageToViewportRectangle(tiledImage._clip, true);
          box = box.rotate(-tiledImage.getRotation(true), tiledImage._getRotationPoint(true));
          var clipRect = tiledImage._drawer.viewportToDrawerRectangle(box);
          if (sketchScale) {
              clipRect = clipRect.times(sketchScale);
          }
          if (sketchTranslate) {
              clipRect = clipRect.translate(sketchTranslate);
          }
          tiledImage._drawer.setClip(clipRect, useSketch);
  
          usedClip = true;
      }
  
      if (tiledImage._croppingPolygons) {
          tiledImage._drawer.saveContext(useSketch);
          try {
              var polygons = tiledImage._croppingPolygons.map(function (polygon) {
                  return polygon.map(function (coord) {
                      var point = tiledImage
                          .imageToViewportCoordinates(coord.x, coord.y, true)
                          .rotate(-tiledImage.getRotation(true), tiledImage._getRotationPoint(true));
                      var clipPoint = tiledImage._drawer.viewportCoordToDrawerCoord(point);
                      if (sketchScale) {
                          clipPoint = clipPoint.times(sketchScale);
                      }
                      return clipPoint;
                  });
              });
              tiledImage._drawer.clipWithPolygons(polygons, useSketch);
          } catch (e) {
              $.console.error(e);
          }
          usedClip = true;
      }
  
      if ( tiledImage.placeholderFillStyle && tiledImage._hasOpaqueTile === false ) {
          var placeholderRect = tiledImage._drawer.viewportToDrawerRectangle(tiledImage.getBounds(true));
          if (sketchScale) {
              placeholderRect = placeholderRect.times(sketchScale);
          }
          if (sketchTranslate) {
              placeholderRect = placeholderRect.translate(sketchTranslate);
          }
  
          var fillStyle = null;
          if ( typeof tiledImage.placeholderFillStyle === "function" ) {
              fillStyle = tiledImage.placeholderFillStyle(tiledImage, tiledImage._drawer.context);
          }
          else {
              fillStyle = tiledImage.placeholderFillStyle;
          }
  
          tiledImage._drawer.drawRectangle(placeholderRect, fillStyle, useSketch);
      }
  
      for (var i = lastDrawn.length - 1; i >= 0; i--) {
          tile = lastDrawn[ i ];
          tiledImage._drawer.drawTile( tile, tiledImage._drawingHandler, useSketch, sketchScale, sketchTranslate );
          tile.beingDrawn = true;
  
          if( tiledImage.viewer ){
              /**
               * <em>- Needs documentation -</em>
               *
               * @event tile-drawn
               * @memberof OpenSeadragon.Viewer
               * @type {object}
               * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
               * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
               * @property {OpenSeadragon.Tile} tile
               * @property {?Object} userData - Arbitrary subscriber-defined object.
               */
              tiledImage.viewer.raiseEvent( 'tile-drawn', {
                  tiledImage: tiledImage,
                  tile: tile
              });
          }
      }
  
      if ( usedClip ) {
          tiledImage._drawer.restoreContext( useSketch );
      }
  
      if (!sketchScale) {
          if (tiledImage.getRotation(true) % 360 !== 0) {
              tiledImage._drawer._restoreRotationChanges(useSketch);
          }
          if (tiledImage.viewport.degrees !== 0) {
              tiledImage._drawer._restoreRotationChanges(useSketch);
          }
      }
  
      if (useSketch) {
          if (sketchScale) {
              if (tiledImage.viewport.degrees !== 0) {
                  tiledImage._drawer._offsetForRotation({
                      degrees: tiledImage.viewport.degrees,
                      useSketch: false
                  });
              }
              if (tiledImage.getRotation(true) % 360 !== 0) {
                  tiledImage._drawer._offsetForRotation({
                      degrees: tiledImage.getRotation(true),
                      point: tiledImage.viewport.pixelFromPointNoRotate(
                          tiledImage._getRotationPoint(true), true),
                      useSketch: false
                  });
              }
          }
          tiledImage._drawer.blendSketch({
              opacity: tiledImage.opacity,
              scale: sketchScale,
              translate: sketchTranslate,
              compositeOperation: tiledImage.compositeOperation,
              bounds: bounds
          });
          if (sketchScale) {
              if (tiledImage.getRotation(true) % 360 !== 0) {
                  tiledImage._drawer._restoreRotationChanges(false);
              }
              if (tiledImage.viewport.degrees !== 0) {
                  tiledImage._drawer._restoreRotationChanges(false);
              }
          }
      }
  
      if (!sketchScale) {
        if (tiledImage.viewport.degrees === 0 && tiledImage.getRotation(true) % 360 === 0){
          if(tiledImage._drawer.viewer.viewport.getFlip()) {
              tiledImage._drawer._flip();
          }
        }
      }
  
      drawDebugInfo( tiledImage, lastDrawn );
  }
  
  /**
   * @private
   * @inner
   * Draws special debug information for a TiledImage if in debug mode.
   * @param {OpenSeadragon.TiledImage} tiledImage
   * @param {OpenSeadragon.Tile[]} lastDrawn - An unordered list of Tiles drawn last frame.
   */
  function drawDebugInfo( tiledImage, lastDrawn ) {
      if( tiledImage.debugMode ) {
          for ( var i = lastDrawn.length - 1; i >= 0; i-- ) {
              var tile = lastDrawn[ i ];
              try {
                  tiledImage._drawer.drawDebugInfo(
                      tile, lastDrawn.length, i, tiledImage);
              } catch(e) {
                  $.console.error(e);
              }
          }
      }
  }
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - TileCache
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  // private class
  var TileRecord = function( options ) {
      $.console.assert( options, "[TileCache.cacheTile] options is required" );
      $.console.assert( options.tile, "[TileCache.cacheTile] options.tile is required" );
      $.console.assert( options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required" );
      this.tile = options.tile;
      this.tiledImage = options.tiledImage;
  };
  
  // private class
  var ImageRecord = function(options) {
      $.console.assert( options, "[ImageRecord] options is required" );
      $.console.assert( options.image, "[ImageRecord] options.image is required" );
      this._image = options.image;
      this._tiles = [];
  };
  
  ImageRecord.prototype = {
      destroy: function() {
          this._image = null;
          this._renderedContext = null;
          this._tiles = null;
      },
  
      getImage: function() {
          return this._image;
      },
  
      getRenderedContext: function() {
          if (!this._renderedContext) {
              var canvas = document.createElement( 'canvas' );
              canvas.width = this._image.width;
              canvas.height = this._image.height;
              this._renderedContext = canvas.getContext('2d');
              this._renderedContext.drawImage( this._image, 0, 0 );
              //since we are caching the prerendered image on a canvas
              //allow the image to not be held in memory
              this._image = null;
          }
          return this._renderedContext;
      },
  
      setRenderedContext: function(renderedContext) {
          $.console.error("ImageRecord.setRenderedContext is deprecated. " +
                  "The rendered context should be created by the ImageRecord " +
                  "itself when calling ImageRecord.getRenderedContext.");
          this._renderedContext = renderedContext;
      },
  
      addTile: function(tile) {
          $.console.assert(tile, '[ImageRecord.addTile] tile is required');
          this._tiles.push(tile);
      },
  
      removeTile: function(tile) {
          for (var i = 0; i < this._tiles.length; i++) {
              if (this._tiles[i] === tile) {
                  this._tiles.splice(i, 1);
                  return;
              }
          }
  
          $.console.warn('[ImageRecord.removeTile] trying to remove unknown tile', tile);
      },
  
      getTileCount: function() {
          return this._tiles.length;
      }
  };
  
  /**
   * @class TileCache
   * @memberof OpenSeadragon
   * @classdesc Stores all the tiles displayed in a {@link OpenSeadragon.Viewer}.
   * You generally won't have to interact with the TileCache directly.
   * @param {Object} options - Configuration for this TileCache.
   * @param {Number} [options.maxImageCacheCount] - See maxImageCacheCount in
   * {@link OpenSeadragon.Options} for details.
   */
  $.TileCache = function( options ) {
      options = options || {};
  
      this._maxImageCacheCount = options.maxImageCacheCount || $.DEFAULT_SETTINGS.maxImageCacheCount;
      this._tilesLoaded = [];
      this._imagesLoaded = [];
      this._imagesLoadedCount = 0;
  };
  
  /** @lends OpenSeadragon.TileCache.prototype */
  $.TileCache.prototype = {
      /**
       * @returns {Number} The total number of tiles that have been loaded by
       * this TileCache.
       */
      numTilesLoaded: function() {
          return this._tilesLoaded.length;
      },
  
      /**
       * Caches the specified tile, removing an old tile if necessary to stay under the
       * maxImageCacheCount specified on construction. Note that if multiple tiles reference
       * the same image, there may be more tiles than maxImageCacheCount; the goal is to keep
       * the number of images below that number. Note, as well, that even the number of images
       * may temporarily surpass that number, but should eventually come back down to the max specified.
       * @param {Object} options - Tile info.
       * @param {OpenSeadragon.Tile} options.tile - The tile to cache.
       * @param {String} options.tile.cacheKey - The unique key used to identify this tile in the cache.
       * @param {Image} options.image - The image of the tile to cache.
       * @param {OpenSeadragon.TiledImage} options.tiledImage - The TiledImage that owns that tile.
       * @param {Number} [options.cutoff=0] - If adding this tile goes over the cache max count, this
       * function will release an old tile. The cutoff option specifies a tile level at or below which
       * tiles will not be released.
       */
      cacheTile: function( options ) {
          $.console.assert( options, "[TileCache.cacheTile] options is required" );
          $.console.assert( options.tile, "[TileCache.cacheTile] options.tile is required" );
          $.console.assert( options.tile.cacheKey, "[TileCache.cacheTile] options.tile.cacheKey is required" );
          $.console.assert( options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required" );
  
          var cutoff = options.cutoff || 0;
          var insertionIndex = this._tilesLoaded.length;
  
          var imageRecord = this._imagesLoaded[options.tile.cacheKey];
          if (!imageRecord) {
              $.console.assert( options.image, "[TileCache.cacheTile] options.image is required to create an ImageRecord" );
              imageRecord = this._imagesLoaded[options.tile.cacheKey] = new ImageRecord({
                  image: options.image
              });
  
              this._imagesLoadedCount++;
          }
  
          imageRecord.addTile(options.tile);
          options.tile.cacheImageRecord = imageRecord;
  
          // Note that just because we're unloading a tile doesn't necessarily mean
          // we're unloading an image. With repeated calls it should sort itself out, though.
          if ( this._imagesLoadedCount > this._maxImageCacheCount ) {
              var worstTile       = null;
              var worstTileIndex  = -1;
              var worstTileRecord = null;
              var prevTile, worstTime, worstLevel, prevTime, prevLevel, prevTileRecord;
  
              for ( var i = this._tilesLoaded.length - 1; i >= 0; i-- ) {
                  prevTileRecord = this._tilesLoaded[ i ];
                  prevTile = prevTileRecord.tile;
  
                  if ( prevTile.level <= cutoff || prevTile.beingDrawn ) {
                      continue;
                  } else if ( !worstTile ) {
                      worstTile       = prevTile;
                      worstTileIndex  = i;
                      worstTileRecord = prevTileRecord;
                      continue;
                  }
  
                  prevTime    = prevTile.lastTouchTime;
                  worstTime   = worstTile.lastTouchTime;
                  prevLevel   = prevTile.level;
                  worstLevel  = worstTile.level;
  
                  if ( prevTime < worstTime ||
                     ( prevTime == worstTime && prevLevel > worstLevel ) ) {
                      worstTile       = prevTile;
                      worstTileIndex  = i;
                      worstTileRecord = prevTileRecord;
                  }
              }
  
              if ( worstTile && worstTileIndex >= 0 ) {
                  this._unloadTile(worstTileRecord);
                  insertionIndex = worstTileIndex;
              }
          }
  
          this._tilesLoaded[ insertionIndex ] = new TileRecord({
              tile: options.tile,
              tiledImage: options.tiledImage
          });
      },
  
      /**
       * Clears all tiles associated with the specified tiledImage.
       * @param {OpenSeadragon.TiledImage} tiledImage
       */
      clearTilesFor: function( tiledImage ) {
          $.console.assert(tiledImage, '[TileCache.clearTilesFor] tiledImage is required');
          var tileRecord;
          for ( var i = 0; i < this._tilesLoaded.length; ++i ) {
              tileRecord = this._tilesLoaded[ i ];
              if ( tileRecord.tiledImage === tiledImage ) {
                  this._unloadTile(tileRecord);
                  this._tilesLoaded.splice( i, 1 );
                  i--;
              }
          }
      },
  
      // private
      getImageRecord: function(cacheKey) {
          $.console.assert(cacheKey, '[TileCache.getImageRecord] cacheKey is required');
          return this._imagesLoaded[cacheKey];
      },
  
      // private
      _unloadTile: function(tileRecord) {
          $.console.assert(tileRecord, '[TileCache._unloadTile] tileRecord is required');
          var tile = tileRecord.tile;
          var tiledImage = tileRecord.tiledImage;
  
          tile.unload();
          tile.cacheImageRecord = null;
  
          var imageRecord = this._imagesLoaded[tile.cacheKey];
          imageRecord.removeTile(tile);
          if (!imageRecord.getTileCount()) {
              imageRecord.destroy();
              delete this._imagesLoaded[tile.cacheKey];
              this._imagesLoadedCount--;
          }
  
          /**
           * Triggered when a tile has just been unloaded from memory.
           *
           * @event tile-unloaded
           * @memberof OpenSeadragon.Viewer
           * @type {object}
           * @property {OpenSeadragon.TiledImage} tiledImage - The tiled image of the unloaded tile.
           * @property {OpenSeadragon.Tile} tile - The tile which has been unloaded.
           */
          tiledImage.viewer.raiseEvent("tile-unloaded", {
              tile: tile,
              tiledImage: tiledImage
          });
      }
  };
  
  }( OpenSeadragon ));
  
  /*
   * OpenSeadragon - World
   *
   * Copyright (C) 2009 CodePlex Foundation
   * Copyright (C) 2010-2013 OpenSeadragon contributors
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   * - Redistributions of source code must retain the above copyright notice,
   *   this list of conditions and the following disclaimer.
   *
   * - Redistributions in binary form must reproduce the above copyright
   *   notice, this list of conditions and the following disclaimer in the
   *   documentation and/or other materials provided with the distribution.
   *
   * - Neither the name of CodePlex Foundation nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  (function( $ ){
  
  /**
   * @class World
   * @memberof OpenSeadragon
   * @extends OpenSeadragon.EventSource
   * @classdesc Keeps track of all of the tiled images in the scene.
   * @param {Object} options - World options.
   * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this World.
   **/
  $.World = function( options ) {
      var _this = this;
  
      $.console.assert( options.viewer, "[World] options.viewer is required" );
  
      $.EventSource.call( this );
  
      this.viewer = options.viewer;
      this._items = [];
      this._needsDraw = false;
      this._autoRefigureSizes = true;
      this._needsSizesFigured = false;
      this._delegatedFigureSizes = function(event) {
          if (_this._autoRefigureSizes) {
              _this._figureSizes();
          } else {
              _this._needsSizesFigured = true;
          }
      };
  
      this._figureSizes();
  };
  
  $.extend( $.World.prototype, $.EventSource.prototype, /** @lends OpenSeadragon.World.prototype */{
      /**
       * Add the specified item.
       * @param {OpenSeadragon.TiledImage} item - The item to add.
       * @param {Number} [options.index] - Index for the item. If not specified, goes at the top.
       * @fires OpenSeadragon.World.event:add-item
       * @fires OpenSeadragon.World.event:metrics-change
       */
      addItem: function( item, options ) {
          $.console.assert(item, "[World.addItem] item is required");
          $.console.assert(item instanceof $.TiledImage, "[World.addItem] only TiledImages supported at this time");
  
          options = options || {};
          if (options.index !== undefined) {
              var index = Math.max(0, Math.min(this._items.length, options.index));
              this._items.splice(index, 0, item);
          } else {
              this._items.push( item );
          }
  
          if (this._autoRefigureSizes) {
              this._figureSizes();
          } else {
              this._needsSizesFigured = true;
          }
  
          this._needsDraw = true;
  
          item.addHandler('bounds-change', this._delegatedFigureSizes);
          item.addHandler('clip-change', this._delegatedFigureSizes);
  
          /**
           * Raised when an item is added to the World.
           * @event add-item
           * @memberOf OpenSeadragon.World
           * @type {object}
           * @property {OpenSeadragon.Viewer} eventSource - A reference to the World which raised the event.
           * @property {OpenSeadragon.TiledImage} item - The item that has been added.
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent( 'add-item', {
              item: item
          } );
      },
  
      /**
       * Get the item at the specified index.
       * @param {Number} index - The item's index.
       * @returns {OpenSeadragon.TiledImage} The item at the specified index.
       */
      getItemAt: function( index ) {
          $.console.assert(index !== undefined, "[World.getItemAt] index is required");
          return this._items[ index ];
      },
  
      /**
       * Get the index of the given item or -1 if not present.
       * @param {OpenSeadragon.TiledImage} item - The item.
       * @returns {Number} The index of the item or -1 if not present.
       */
      getIndexOfItem: function( item ) {
          $.console.assert(item, "[World.getIndexOfItem] item is required");
          return $.indexOf( this._items, item );
      },
  
      /**
       * @returns {Number} The number of items used.
       */
      getItemCount: function() {
          return this._items.length;
      },
  
      /**
       * Change the index of a item so that it appears over or under others.
       * @param {OpenSeadragon.TiledImage} item - The item to move.
       * @param {Number} index - The new index.
       * @fires OpenSeadragon.World.event:item-index-change
       */
      setItemIndex: function( item, index ) {
          $.console.assert(item, "[World.setItemIndex] item is required");
          $.console.assert(index !== undefined, "[World.setItemIndex] index is required");
  
          var oldIndex = this.getIndexOfItem( item );
  
          if ( index >= this._items.length ) {
              throw new Error( "Index bigger than number of layers." );
          }
  
          if ( index === oldIndex || oldIndex === -1 ) {
              return;
          }
  
          this._items.splice( oldIndex, 1 );
          this._items.splice( index, 0, item );
          this._needsDraw = true;
  
          /**
           * Raised when the order of the indexes has been changed.
           * @event item-index-change
           * @memberOf OpenSeadragon.World
           * @type {object}
           * @property {OpenSeadragon.World} eventSource - A reference to the World which raised the event.
           * @property {OpenSeadragon.TiledImage} item - The item whose index has
           * been changed
           * @property {Number} previousIndex - The previous index of the item
           * @property {Number} newIndex - The new index of the item
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent( 'item-index-change', {
              item: item,
              previousIndex: oldIndex,
              newIndex: index
          } );
      },
  
      /**
       * Remove an item.
       * @param {OpenSeadragon.TiledImage} item - The item to remove.
       * @fires OpenSeadragon.World.event:remove-item
       * @fires OpenSeadragon.World.event:metrics-change
       */
      removeItem: function( item ) {
          $.console.assert(item, "[World.removeItem] item is required");
  
          var index = $.indexOf(this._items, item );
          if ( index === -1 ) {
              return;
          }
  
          item.removeHandler('bounds-change', this._delegatedFigureSizes);
          item.removeHandler('clip-change', this._delegatedFigureSizes);
          item.destroy();
          this._items.splice( index, 1 );
          this._figureSizes();
          this._needsDraw = true;
          this._raiseRemoveItem(item);
      },
  
      /**
       * Remove all items.
       * @fires OpenSeadragon.World.event:remove-item
       * @fires OpenSeadragon.World.event:metrics-change
       */
      removeAll: function() {
          // We need to make sure any pending images are canceled so the world items don't get messed up
          this.viewer._cancelPendingImages();
          var item;
          var i;
          for (i = 0; i < this._items.length; i++) {
              item = this._items[i];
              item.removeHandler('bounds-change', this._delegatedFigureSizes);
              item.removeHandler('clip-change', this._delegatedFigureSizes);
              item.destroy();
          }
  
          var removedItems = this._items;
          this._items = [];
          this._figureSizes();
          this._needsDraw = true;
  
          for (i = 0; i < removedItems.length; i++) {
              item = removedItems[i];
              this._raiseRemoveItem(item);
          }
      },
  
      /**
       * Clears all tiles and triggers updates for all items.
       */
      resetItems: function() {
          for ( var i = 0; i < this._items.length; i++ ) {
              this._items[i].reset();
          }
      },
  
      /**
       * Updates (i.e. animates bounds of) all items.
       */
      update: function() {
          var animated = false;
          for ( var i = 0; i < this._items.length; i++ ) {
              animated = this._items[i].update() || animated;
          }
  
          return animated;
      },
  
      /**
       * Draws all items.
       */
      draw: function() {
          for ( var i = 0; i < this._items.length; i++ ) {
              this._items[i].draw();
          }
  
          this._needsDraw = false;
      },
  
      /**
       * @returns {Boolean} true if any items need updating.
       */
      needsDraw: function() {
          for ( var i = 0; i < this._items.length; i++ ) {
              if ( this._items[i].needsDraw() ) {
                  return true;
              }
          }
          return this._needsDraw;
      },
  
      /**
       * @returns {OpenSeadragon.Rect} The smallest rectangle that encloses all items, in viewport coordinates.
       */
      getHomeBounds: function() {
          return this._homeBounds.clone();
      },
  
      /**
       * To facilitate zoom constraints, we keep track of the pixel density of the
       * densest item in the World (i.e. the item whose content size to viewport size
       * ratio is the highest) and save it as this "content factor".
       * @returns {Number} the number of content units per viewport unit.
       */
      getContentFactor: function() {
          return this._contentFactor;
      },
  
      /**
       * As a performance optimization, setting this flag to false allows the bounds-change event handler
       * on tiledImages to skip calculations on the world bounds. If a lot of images are going to be positioned in
       * rapid succession, this is a good idea. When finished, setAutoRefigureSizes should be called with true
       * or the system may behave oddly.
       * @param {Boolean} [value] The value to which to set the flag.
       */
      setAutoRefigureSizes: function(value) {
          this._autoRefigureSizes = value;
          if (value & this._needsSizesFigured) {
              this._figureSizes();
              this._needsSizesFigured = false;
          }
      },
  
      /**
       * Arranges all of the TiledImages with the specified settings.
       * @param {Object} options - Specifies how to arrange.
       * @param {Boolean} [options.immediately=false] - Whether to animate to the new arrangement.
       * @param {String} [options.layout] - See collectionLayout in {@link OpenSeadragon.Options}.
       * @param {Number} [options.rows] - See collectionRows in {@link OpenSeadragon.Options}.
       * @param {Number} [options.columns] - See collectionColumns in {@link OpenSeadragon.Options}.
       * @param {Number} [options.tileSize] - See collectionTileSize in {@link OpenSeadragon.Options}.
       * @param {Number} [options.tileMargin] - See collectionTileMargin in {@link OpenSeadragon.Options}.
       * @fires OpenSeadragon.World.event:metrics-change
       */
      arrange: function(options) {
          options = options || {};
          var immediately = options.immediately || false;
          var layout = options.layout || $.DEFAULT_SETTINGS.collectionLayout;
          var rows = options.rows || $.DEFAULT_SETTINGS.collectionRows;
          var columns = options.columns || $.DEFAULT_SETTINGS.collectionColumns;
          var tileSize = options.tileSize || $.DEFAULT_SETTINGS.collectionTileSize;
          var tileMargin = options.tileMargin || $.DEFAULT_SETTINGS.collectionTileMargin;
          var increment = tileSize + tileMargin;
          var wrap;
          if (!options.rows && columns) {
              wrap = columns;
          } else {
              wrap = Math.ceil(this._items.length / rows);
          }
          var x = 0;
          var y = 0;
          var item, box, width, height, position;
  
          this.setAutoRefigureSizes(false);
          for (var i = 0; i < this._items.length; i++) {
              if (i && (i % wrap) === 0) {
                  if (layout === 'horizontal') {
                      y += increment;
                      x = 0;
                  } else {
                      x += increment;
                      y = 0;
                  }
              }
  
              item = this._items[i];
              box = item.getBounds();
              if (box.width > box.height) {
                  width = tileSize;
              } else {
                  width = tileSize * (box.width / box.height);
              }
  
              height = width * (box.height / box.width);
              position = new $.Point(x + ((tileSize - width) / 2),
                  y + ((tileSize - height) / 2));
  
              item.setPosition(position, immediately);
              item.setWidth(width, immediately);
  
              if (layout === 'horizontal') {
                  x += increment;
              } else {
                  y += increment;
              }
          }
          this.setAutoRefigureSizes(true);
      },
  
      // private
      _figureSizes: function() {
          var oldHomeBounds = this._homeBounds ? this._homeBounds.clone() : null;
          var oldContentSize = this._contentSize ? this._contentSize.clone() : null;
          var oldContentFactor = this._contentFactor || 0;
  
          if (!this._items.length) {
              this._homeBounds = new $.Rect(0, 0, 1, 1);
              this._contentSize = new $.Point(1, 1);
              this._contentFactor = 1;
          } else {
              var item = this._items[0];
              var bounds = item.getBounds();
              this._contentFactor = item.getContentSize().x / bounds.width;
              var clippedBounds = item.getClippedBounds().getBoundingBox();
              var left = clippedBounds.x;
              var top = clippedBounds.y;
              var right = clippedBounds.x + clippedBounds.width;
              var bottom = clippedBounds.y + clippedBounds.height;
              for (var i = 1; i < this._items.length; i++) {
                  item = this._items[i];
                  bounds = item.getBounds();
                  this._contentFactor = Math.max(this._contentFactor,
                      item.getContentSize().x / bounds.width);
                  clippedBounds = item.getClippedBounds().getBoundingBox();
                  left = Math.min(left, clippedBounds.x);
                  top = Math.min(top, clippedBounds.y);
                  right = Math.max(right, clippedBounds.x + clippedBounds.width);
                  bottom = Math.max(bottom, clippedBounds.y + clippedBounds.height);
              }
  
              this._homeBounds = new $.Rect(left, top, right - left, bottom - top);
              this._contentSize = new $.Point(
                  this._homeBounds.width * this._contentFactor,
                  this._homeBounds.height * this._contentFactor);
          }
  
          if (this._contentFactor !== oldContentFactor ||
              !this._homeBounds.equals(oldHomeBounds) ||
              !this._contentSize.equals(oldContentSize)) {
              /**
               * Raised when the home bounds or content factor change.
               * @event metrics-change
               * @memberOf OpenSeadragon.World
               * @type {object}
               * @property {OpenSeadragon.World} eventSource - A reference to the World which raised the event.
               * @property {?Object} userData - Arbitrary subscriber-defined object.
               */
              this.raiseEvent('metrics-change', {});
          }
      },
  
      // private
      _raiseRemoveItem: function(item) {
          /**
           * Raised when an item is removed.
           * @event remove-item
           * @memberOf OpenSeadragon.World
           * @type {object}
           * @property {OpenSeadragon.World} eventSource - A reference to the World which raised the event.
           * @property {OpenSeadragon.TiledImage} item - The item's underlying item.
           * @property {?Object} userData - Arbitrary subscriber-defined object.
           */
          this.raiseEvent( 'remove-item', { item: item } );
      }
  });
  
  }( OpenSeadragon ));
  ;
  /*! @openseadragon-imaging/openseadragon-viewerinputhook 2.1.0 5dd91e5 (clean) */
  
  /**
   * Copyright (c) 2016-2020, The Cytoscape Consortium.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy of
   * this software and associated documentation files (the “Software”), to deal in
   * the Software without restriction, including without limitation the rights to
   * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
   * of the Software, and to permit persons to whom the Software is furnished to do
   * so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
  
  
  (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.cytoscape = factory());
  }(this, (function () { 'use strict';
  
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
          return typeof obj;
        };
      } else {
        _typeof = function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }
  
      return _typeof(obj);
    }
  
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
  
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
  
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
  
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
  
      return obj;
    }
  
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
    }
  
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
  
    function _iterableToArrayLimit(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
  
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
  
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
  
      return _arr;
    }
  
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  
    var window$1 = typeof window === 'undefined' ? null : window; // eslint-disable-line no-undef
  
    var navigator = window$1 ? window$1.navigator : null;
    var document$1 = window$1 ? window$1.document : null;
  
    var typeofstr = _typeof('');
  
    var typeofobj = _typeof({});
  
    var typeoffn = _typeof(function () {});
  
    var typeofhtmlele = typeof HTMLElement === "undefined" ? "undefined" : _typeof(HTMLElement);
  
    var instanceStr = function instanceStr(obj) {
      return obj && obj.instanceString && fn(obj.instanceString) ? obj.instanceString() : null;
    };
  
    var string = function string(obj) {
      return obj != null && _typeof(obj) == typeofstr;
    };
    var fn = function fn(obj) {
      return obj != null && _typeof(obj) === typeoffn;
    };
    var array = function array(obj) {
      return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;
    };
    var plainObject = function plainObject(obj) {
      return obj != null && _typeof(obj) === typeofobj && !array(obj) && obj.constructor === Object;
    };
    var object = function object(obj) {
      return obj != null && _typeof(obj) === typeofobj;
    };
    var number = function number(obj) {
      return obj != null && _typeof(obj) === _typeof(1) && !isNaN(obj);
    };
    var integer = function integer(obj) {
      return number(obj) && Math.floor(obj) === obj;
    };
    var htmlElement = function htmlElement(obj) {
      if ('undefined' === typeofhtmlele) {
        return undefined;
      } else {
        return null != obj && obj instanceof HTMLElement;
      }
    };
    var elementOrCollection = function elementOrCollection(obj) {
      return element(obj) || collection(obj);
    };
    var element = function element(obj) {
      return instanceStr(obj) === 'collection' && obj._private.single;
    };
    var collection = function collection(obj) {
      return instanceStr(obj) === 'collection' && !obj._private.single;
    };
    var core = function core(obj) {
      return instanceStr(obj) === 'core';
    };
    var stylesheet = function stylesheet(obj) {
      return instanceStr(obj) === 'stylesheet';
    };
    var event = function event(obj) {
      return instanceStr(obj) === 'event';
    };
    var emptyString = function emptyString(obj) {
      if (obj === undefined || obj === null) {
        // null is empty
        return true;
      } else if (obj === '' || obj.match(/^\s+$/)) {
        return true; // empty string is empty
      }
  
      return false; // otherwise, we don't know what we've got
    };
    var domElement = function domElement(obj) {
      if (typeof HTMLElement === 'undefined') {
        return false; // we're not in a browser so it doesn't matter
      } else {
        return obj instanceof HTMLElement;
      }
    };
    var boundingBox = function boundingBox(obj) {
      return plainObject(obj) && number(obj.x1) && number(obj.x2) && number(obj.y1) && number(obj.y2);
    };
    var promise = function promise(obj) {
      return object(obj) && fn(obj.then);
    };
    var ms = function ms() {
      return navigator && navigator.userAgent.match(/msie|trident|edge/i);
    }; // probably a better way to detect this...
  
    var memoize = function memoize(fn, keyFn) {
      if (!keyFn) {
        keyFn = function keyFn() {
          if (arguments.length === 1) {
            return arguments[0];
          } else if (arguments.length === 0) {
            return 'undefined';
          }
  
          var args = [];
  
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
  
          return args.join('$');
        };
      }
  
      var memoizedFn = function memoizedFn() {
        var self = this;
        var args = arguments;
        var ret;
        var k = keyFn.apply(self, args);
        var cache = memoizedFn.cache;
  
        if (!(ret = cache[k])) {
          ret = cache[k] = fn.apply(self, args);
        }
  
        return ret;
      };
  
      memoizedFn.cache = {};
      return memoizedFn;
    };
  
    var camel2dash = memoize(function (str) {
      return str.replace(/([A-Z])/g, function (v) {
        return '-' + v.toLowerCase();
      });
    });
    var dash2camel = memoize(function (str) {
      return str.replace(/(-\w)/g, function (v) {
        return v[1].toUpperCase();
      });
    });
    var prependCamel = memoize(function (prefix, str) {
      return prefix + str[0].toUpperCase() + str.substring(1);
    }, function (prefix, str) {
      return prefix + '$' + str;
    });
    var capitalize = function capitalize(str) {
      if (emptyString(str)) {
        return str;
      }
  
      return str.charAt(0).toUpperCase() + str.substring(1);
    };
  
    var number$1 = '(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))';
    var rgba = 'rgb[a]?\\((' + number$1 + '[%]?)\\s*,\\s*(' + number$1 + '[%]?)\\s*,\\s*(' + number$1 + '[%]?)(?:\\s*,\\s*(' + number$1 + '))?\\)';
    var rgbaNoBackRefs = 'rgb[a]?\\((?:' + number$1 + '[%]?)\\s*,\\s*(?:' + number$1 + '[%]?)\\s*,\\s*(?:' + number$1 + '[%]?)(?:\\s*,\\s*(?:' + number$1 + '))?\\)';
    var hsla = 'hsl[a]?\\((' + number$1 + ')\\s*,\\s*(' + number$1 + '[%])\\s*,\\s*(' + number$1 + '[%])(?:\\s*,\\s*(' + number$1 + '))?\\)';
    var hslaNoBackRefs = 'hsl[a]?\\((?:' + number$1 + ')\\s*,\\s*(?:' + number$1 + '[%])\\s*,\\s*(?:' + number$1 + '[%])(?:\\s*,\\s*(?:' + number$1 + '))?\\)';
    var hex3 = '\\#[0-9a-fA-F]{3}';
    var hex6 = '\\#[0-9a-fA-F]{6}';
  
    var ascending = function ascending(a, b) {
      if (a < b) {
        return -1;
      } else if (a > b) {
        return 1;
      } else {
        return 0;
      }
    };
    var descending = function descending(a, b) {
      return -1 * ascending(a, b);
    };
  
    var extend = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {
      var args = arguments;
  
      for (var i = 1; i < args.length; i++) {
        var obj = args[i];
  
        if (obj == null) {
          continue;
        }
  
        var keys = Object.keys(obj);
  
        for (var j = 0; j < keys.length; j++) {
          var k = keys[j];
          tgt[k] = obj[k];
        }
      }
  
      return tgt;
    };
  
    var hex2tuple = function hex2tuple(hex) {
      if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {
        return;
      }
  
      var shortHex = hex.length === 4;
      var r, g, b;
      var base = 16;
  
      if (shortHex) {
        r = parseInt(hex[1] + hex[1], base);
        g = parseInt(hex[2] + hex[2], base);
        b = parseInt(hex[3] + hex[3], base);
      } else {
        r = parseInt(hex[1] + hex[2], base);
        g = parseInt(hex[3] + hex[4], base);
        b = parseInt(hex[5] + hex[6], base);
      }
  
      return [r, g, b];
    }; // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
  
    var hsl2tuple = function hsl2tuple(hsl) {
      var ret;
      var h, s, l, a, r, g, b;
  
      function hue2rgb(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      }
  
      var m = new RegExp('^' + hsla + '$').exec(hsl);
  
      if (m) {
        // get hue
        h = parseInt(m[1]);
  
        if (h < 0) {
          h = (360 - -1 * h % 360) % 360;
        } else if (h > 360) {
          h = h % 360;
        }
  
        h /= 360; // normalise on [0, 1]
  
        s = parseFloat(m[2]);
  
        if (s < 0 || s > 100) {
          return;
        } // saturation is [0, 100]
  
  
        s = s / 100; // normalise on [0, 1]
  
        l = parseFloat(m[3]);
  
        if (l < 0 || l > 100) {
          return;
        } // lightness is [0, 100]
  
  
        l = l / 100; // normalise on [0, 1]
  
        a = m[4];
  
        if (a !== undefined) {
          a = parseFloat(a);
  
          if (a < 0 || a > 1) {
            return;
          } // alpha is [0, 1]
  
        } // now, convert to rgb
        // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
  
  
        if (s === 0) {
          r = g = b = Math.round(l * 255); // achromatic
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));
          g = Math.round(255 * hue2rgb(p, q, h));
          b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));
        }
  
        ret = [r, g, b, a];
      }
  
      return ret;
    }; // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
  
    var rgb2tuple = function rgb2tuple(rgb) {
      var ret;
      var m = new RegExp('^' + rgba + '$').exec(rgb);
  
      if (m) {
        ret = [];
        var isPct = [];
  
        for (var i = 1; i <= 3; i++) {
          var channel = m[i];
  
          if (channel[channel.length - 1] === '%') {
            isPct[i] = true;
          }
  
          channel = parseFloat(channel);
  
          if (isPct[i]) {
            channel = channel / 100 * 255; // normalise to [0, 255]
          }
  
          if (channel < 0 || channel > 255) {
            return;
          } // invalid channel value
  
  
          ret.push(Math.floor(channel));
        }
  
        var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
        var allArePct = isPct[1] && isPct[2] && isPct[3];
  
        if (atLeastOneIsPct && !allArePct) {
          return;
        } // must all be percent values if one is
  
  
        var alpha = m[4];
  
        if (alpha !== undefined) {
          alpha = parseFloat(alpha);
  
          if (alpha < 0 || alpha > 1) {
            return;
          } // invalid alpha value
  
  
          ret.push(alpha);
        }
      }
  
      return ret;
    };
    var colorname2tuple = function colorname2tuple(color) {
      return colors[color.toLowerCase()];
    };
    var color2tuple = function color2tuple(color) {
      return (array(color) ? color : null) || colorname2tuple(color) || hex2tuple(color) || rgb2tuple(color) || hsl2tuple(color);
    };
    var colors = {
      // special colour names
      transparent: [0, 0, 0, 0],
      // NB alpha === 0
      // regular colours
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      grey: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
  
    var setMap = function setMap(options) {
      var obj = options.map;
      var keys = options.keys;
      var l = keys.length;
  
      for (var i = 0; i < l; i++) {
        var key = keys[i];
  
        if (plainObject(key)) {
          throw Error('Tried to set map with object key');
        }
  
        if (i < keys.length - 1) {
          // extend the map if necessary
          if (obj[key] == null) {
            obj[key] = {};
          }
  
          obj = obj[key];
        } else {
          // set the value
          obj[key] = options.value;
        }
      }
    }; // gets the value in a map even if it's not built in places
  
    var getMap = function getMap(options) {
      var obj = options.map;
      var keys = options.keys;
      var l = keys.length;
  
      for (var i = 0; i < l; i++) {
        var key = keys[i];
  
        if (plainObject(key)) {
          throw Error('Tried to get map with object key');
        }
  
        obj = obj[key];
  
        if (obj == null) {
          return obj;
        }
      }
  
      return obj;
    }; // deletes the entry in the map
  
    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
  
    function createCommonjsModule(fn, module) {
        return module = { exports: {} }, fn(module, module.exports), module.exports;
    }
  
    /**
     * lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright jQuery Foundation and other contributors <https://jquery.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
  
    /** Used as the `TypeError` message for "Functions" methods. */
    var FUNC_ERROR_TEXT = 'Expected a function';
  
    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;
  
    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';
  
    /** Used to match leading and trailing whitespace. */
    var reTrim = /^\s+|\s+$/g;
  
    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  
    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;
  
    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;
  
    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;
  
    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  
    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  
    /** Used as a reference to the global object. */
    var root = freeGlobal || freeSelf || Function('return this')();
  
    /** Used for built-in method references. */
    var objectProto = Object.prototype;
  
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
  
    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max,
        nativeMin = Math.min;
  
    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = function() {
      return root.Date.now();
    };
  
    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;
  
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
  
      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;
  
        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
  
      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }
  
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            result = wait - timeSinceLastCall;
  
        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
      }
  
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;
  
        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }
  
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
  
      function trailingEdge(time) {
        timerId = undefined;
  
        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }
  
      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }
  
      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }
  
      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);
  
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
  
        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
  
    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
  
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
  
    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && objectToString.call(value) == symbolTag);
    }
  
    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }
  
    var lodash_debounce = debounce;
  
    var performance = window$1 ? window$1.performance : null;
    var pnow = performance && performance.now ? function () {
      return performance.now();
    } : function () {
      return Date.now();
    };
  
    var raf = function () {
      if (window$1) {
        if (window$1.requestAnimationFrame) {
          return function (fn) {
            window$1.requestAnimationFrame(fn);
          };
        } else if (window$1.mozRequestAnimationFrame) {
          return function (fn) {
            window$1.mozRequestAnimationFrame(fn);
          };
        } else if (window$1.webkitRequestAnimationFrame) {
          return function (fn) {
            window$1.webkitRequestAnimationFrame(fn);
          };
        } else if (window$1.msRequestAnimationFrame) {
          return function (fn) {
            window$1.msRequestAnimationFrame(fn);
          };
        }
      }
  
      return function (fn) {
        if (fn) {
          setTimeout(function () {
            fn(pnow());
          }, 1000 / 60);
        }
      };
    }();
  
    var requestAnimationFrame = function requestAnimationFrame(fn) {
      return raf(fn);
    };
    var performanceNow = pnow;
  
    var DEFAULT_HASH_SEED = 9261;
    var K = 65599; // 37 also works pretty well
  
    var DEFAULT_HASH_SEED_ALT = 5381;
    var hashIterableInts = function hashIterableInts(iterator) {
      var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;
      // sdbm/string-hash
      var hash = seed;
      var entry;
  
      for (;;) {
        entry = iterator.next();
  
        if (entry.done) {
          break;
        }
  
        hash = hash * K + entry.value | 0;
      }
  
      return hash;
    };
    var hashInt = function hashInt(num) {
      var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;
      // sdbm/string-hash
      return seed * K + num | 0;
    };
    var hashIntAlt = function hashIntAlt(num) {
      var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED_ALT;
      // djb2/string-hash
      return (seed << 5) + seed + num | 0;
    };
    var combineHashes = function combineHashes(hash1, hash2) {
      return hash1 * 0x200000 + hash2;
    };
    var combineHashesArray = function combineHashesArray(hashes) {
      return hashes[0] * 0x200000 + hashes[1];
    };
    var hashArrays = function hashArrays(hashes1, hashes2) {
      return [hashInt(hashes1[0], hashes2[0]), hashIntAlt(hashes1[1], hashes2[1])];
    };
    var hashIntsArray = function hashIntsArray(ints, seed) {
      var entry = {
        value: 0,
        done: false
      };
      var i = 0;
      var length = ints.length;
      var iterator = {
        next: function next() {
          if (i < length) {
            entry.value = ints[i++];
          } else {
            entry.done = true;
          }
  
          return entry;
        }
      };
      return hashIterableInts(iterator, seed);
    };
    var hashString = function hashString(str, seed) {
      var entry = {
        value: 0,
        done: false
      };
      var i = 0;
      var length = str.length;
      var iterator = {
        next: function next() {
          if (i < length) {
            entry.value = str.charCodeAt(i++);
          } else {
            entry.done = true;
          }
  
          return entry;
        }
      };
      return hashIterableInts(iterator, seed);
    };
    var hashStrings = function hashStrings() {
      return hashStringsArray(arguments);
    };
    var hashStringsArray = function hashStringsArray(strs) {
      var hash;
  
      for (var i = 0; i < strs.length; i++) {
        var str = strs[i];
  
        if (i === 0) {
          hash = hashString(str);
        } else {
          hash = hashString(str, hash);
        }
      }
  
      return hash;
    };
  
    /*global console */
    var warningsEnabled = true;
    var warnSupported = console.warn != null; // eslint-disable-line no-console
  
    var traceSupported = console.trace != null; // eslint-disable-line no-console
  
    var MAX_INT = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var trueify = function trueify() {
      return true;
    };
    var falsify = function falsify() {
      return false;
    };
    var zeroify = function zeroify() {
      return 0;
    };
    var noop = function noop() {};
    var error = function error(msg) {
      throw new Error(msg);
    };
    var warnings = function warnings(enabled) {
      if (enabled !== undefined) {
        warningsEnabled = !!enabled;
      } else {
        return warningsEnabled;
      }
    };
    var warn = function warn(msg) {
      /* eslint-disable no-console */
      if (!warnings()) {
        return;
      }
  
      if (warnSupported) {
        console.warn(msg);
      } else {
        console.log(msg);
  
        if (traceSupported) {
          console.trace();
        }
      }
    };
    /* eslint-enable */
  
    var clone = function clone(obj) {
      return extend({}, obj);
    }; // gets a shallow copy of the argument
  
    var copy = function copy(obj) {
      if (obj == null) {
        return obj;
      }
  
      if (array(obj)) {
        return obj.slice();
      } else if (plainObject(obj)) {
        return clone(obj);
      } else {
        return obj;
      }
    };
    var copyArray = function copyArray(arr) {
      return arr.slice();
    };
    var uuid = function uuid(a, b
    /* placeholders */
    ) {
      for ( // loop :)
      b = a = ''; // b - result , a - numeric letiable
      a++ < 36; //
      b += a * 51 & 52 // if "a" is not 9 or 14 or 19 or 24
      ? //  return a random number or 4
      (a ^ 15 // if "a" is not 15
      ? // genetate a random number from 0 to 15
      8 ^ Math.random() * (a ^ 20 ? 16 : 4) // unless "a" is 20, in which case a random number from 8 to 11
      : 4 //  otherwise 4
      ).toString(16) : '-' //  in other cases (if "a" is 9,14,19,24) insert "-"
      ) {
      }
  
      return b;
    };
    var _staticEmptyObject = {};
    var staticEmptyObject = function staticEmptyObject() {
      return _staticEmptyObject;
    };
    var defaults = function defaults(_defaults) {
      var keys = Object.keys(_defaults);
      return function (opts) {
        var filledOpts = {};
  
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var optVal = opts == null ? undefined : opts[key];
          filledOpts[key] = optVal === undefined ? _defaults[key] : optVal;
        }
  
        return filledOpts;
      };
    };
    var removeFromArray = function removeFromArray(arr, ele, manyCopies) {
      for (var i = arr.length; i >= 0; i--) {
        if (arr[i] === ele) {
          arr.splice(i, 1);
  
          if (!manyCopies) {
            break;
          }
        }
      }
    };
    var clearArray = function clearArray(arr) {
      arr.splice(0, arr.length);
    };
    var push = function push(arr, otherArr) {
      for (var i = 0; i < otherArr.length; i++) {
        var el = otherArr[i];
        arr.push(el);
      }
    };
    var getPrefixedProperty = function getPrefixedProperty(obj, propName, prefix) {
      if (prefix) {
        propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
      }
  
      return obj[propName];
    };
    var setPrefixedProperty = function setPrefixedProperty(obj, propName, prefix, value) {
      if (prefix) {
        propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
      }
  
      obj[propName] = value;
    };
  
    /* global Map */
    var ObjectMap =
    /*#__PURE__*/
    function () {
      function ObjectMap() {
        _classCallCheck(this, ObjectMap);
  
        this._obj = {};
      }
  
      _createClass(ObjectMap, [{
        key: "set",
        value: function set(key, val) {
          this._obj[key] = val;
          return this;
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          this._obj[key] = undefined;
          return this;
        }
      }, {
        key: "clear",
        value: function clear() {
          this._obj = {};
        }
      }, {
        key: "has",
        value: function has(key) {
          return this._obj[key] !== undefined;
        }
      }, {
        key: "get",
        value: function get(key) {
          return this._obj[key];
        }
      }]);
  
      return ObjectMap;
    }();
  
    var Map$1 = typeof Map !== 'undefined' ? Map : ObjectMap;
  
    /* global Set */
    var undef =  "undefined" ;
  
    var ObjectSet =
    /*#__PURE__*/
    function () {
      function ObjectSet(arrayOrObjectSet) {
        _classCallCheck(this, ObjectSet);
  
        this._obj = Object.create(null);
        this.size = 0;
  
        if (arrayOrObjectSet != null) {
          var arr;
  
          if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {
            arr = arrayOrObjectSet.toArray();
          } else {
            arr = arrayOrObjectSet;
          }
  
          for (var i = 0; i < arr.length; i++) {
            this.add(arr[i]);
          }
        }
      }
  
      _createClass(ObjectSet, [{
        key: "instanceString",
        value: function instanceString() {
          return 'set';
        }
      }, {
        key: "add",
        value: function add(val) {
          var o = this._obj;
  
          if (o[val] !== 1) {
            o[val] = 1;
            this.size++;
          }
        }
      }, {
        key: "delete",
        value: function _delete(val) {
          var o = this._obj;
  
          if (o[val] === 1) {
            o[val] = 0;
            this.size--;
          }
        }
      }, {
        key: "clear",
        value: function clear() {
          this._obj = Object.create(null);
        }
      }, {
        key: "has",
        value: function has(val) {
          return this._obj[val] === 1;
        }
      }, {
        key: "toArray",
        value: function toArray() {
          var _this = this;
  
          return Object.keys(this._obj).filter(function (key) {
            return _this.has(key);
          });
        }
      }, {
        key: "forEach",
        value: function forEach(callback, thisArg) {
          return this.toArray().forEach(callback, thisArg);
        }
      }]);
  
      return ObjectSet;
    }();
  
    var Set$1 = (typeof Set === "undefined" ? "undefined" : _typeof(Set)) !== undef ? Set : ObjectSet;
  
    var Element = function Element(cy, params, restore) {
      restore = restore === undefined || restore ? true : false;
  
      if (cy === undefined || params === undefined || !core(cy)) {
        error('An element must have a core reference and parameters set');
        return;
      }
  
      var group = params.group; // try to automatically infer the group if unspecified
  
      if (group == null) {
        if (params.data && params.data.source != null && params.data.target != null) {
          group = 'edges';
        } else {
          group = 'nodes';
        }
      } // validate group
  
  
      if (group !== 'nodes' && group !== 'edges') {
        error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');
        return;
      } // make the element array-like, just like a collection
  
  
      this.length = 1;
      this[0] = this; // NOTE: when something is added here, add also to ele.json()
  
      var _p = this._private = {
        cy: cy,
        single: true,
        // indicates this is an element
        data: params.data || {},
        // data object
        position: params.position || {
          x: 0,
          y: 0
        },
        // (x, y) position pair
        autoWidth: undefined,
        // width and height of nodes calculated by the renderer when set to special 'auto' value
        autoHeight: undefined,
        autoPadding: undefined,
        compoundBoundsClean: false,
        // whether the compound dimensions need to be recalculated the next time dimensions are read
        listeners: [],
        // array of bound listeners
        group: group,
        // string; 'nodes' or 'edges'
        style: {},
        // properties as set by the style
        rstyle: {},
        // properties for style sent from the renderer to the core
        styleCxts: [],
        // applied style contexts from the styler
        styleKeys: {},
        // per-group keys of style property values
        removed: true,
        // whether it's inside the vis; true if removed (set true here since we call restore)
        selected: params.selected ? true : false,
        // whether it's selected
        selectable: params.selectable === undefined ? true : params.selectable ? true : false,
        // whether it's selectable
        locked: params.locked ? true : false,
        // whether the element is locked (cannot be moved)
        grabbed: false,
        // whether the element is grabbed by the mouse; renderer sets this privately
        grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false,
        // whether the element can be grabbed
        pannable: params.pannable === undefined ? group === 'edges' ? true : false : params.pannable ? true : false,
        // whether the element has passthrough panning enabled
        active: false,
        // whether the element is active from user interaction
        classes: new Set$1(),
        // map ( className => true )
        animation: {
          // object for currently-running animations
          current: [],
          queue: []
        },
        rscratch: {},
        // object in which the renderer can store information
        scratch: params.scratch || {},
        // scratch objects
        edges: [],
        // array of connected edges
        children: [],
        // array of children
        parent: null,
        // parent ref
        traversalCache: {},
        // cache of output of traversal functions
        backgrounding: false,
        // whether background images are loading
        bbCache: null,
        // cache of the current bounding box
        bbCacheShift: {
          x: 0,
          y: 0
        },
        // shift applied to cached bb to be applied on next get
        bodyBounds: null,
        // bounds cache of element body, w/o overlay
        overlayBounds: null,
        // bounds cache of element body, including overlay
        labelBounds: {
          // bounds cache of labels
          all: null,
          source: null,
          target: null,
          main: null
        },
        arrowBounds: {
          // bounds cache of edge arrows
          source: null,
          target: null,
          'mid-source': null,
          'mid-target': null
        }
      };
  
      if (_p.position.x == null) {
        _p.position.x = 0;
      }
  
      if (_p.position.y == null) {
        _p.position.y = 0;
      } // renderedPosition overrides if specified
  
  
      if (params.renderedPosition) {
        var rpos = params.renderedPosition;
        var pan = cy.pan();
        var zoom = cy.zoom();
        _p.position = {
          x: (rpos.x - pan.x) / zoom,
          y: (rpos.y - pan.y) / zoom
        };
      }
  
      var classes = [];
  
      if (array(params.classes)) {
        classes = params.classes;
      } else if (string(params.classes)) {
        classes = params.classes.split(/\s+/);
      }
  
      for (var i = 0, l = classes.length; i < l; i++) {
        var cls = classes[i];
  
        if (!cls || cls === '') {
          continue;
        }
  
        _p.classes.add(cls);
      }
  
      this.createEmitter();
      var bypass = params.style || params.css;
  
      if (bypass) {
        warn('Setting a `style` bypass at element creation is deprecated');
        this.style(bypass);
      }
  
      if (restore === undefined || restore) {
        this.restore();
      }
    };
  
    var defineSearch = function defineSearch(params) {
      params = {
        bfs: params.bfs || !params.dfs,
        dfs: params.dfs || !params.bfs
      }; // from pseudocode on wikipedia
  
      return function searchFn(roots, fn$1, directed) {
        var options;
  
        if (plainObject(roots) && !elementOrCollection(roots)) {
          options = roots;
          roots = options.roots || options.root;
          fn$1 = options.visit;
          directed = options.directed;
        }
  
        directed = arguments.length === 2 && !fn(fn$1) ? fn$1 : directed;
        fn$1 = fn(fn$1) ? fn$1 : function () {};
        var cy = this._private.cy;
        var v = roots = string(roots) ? this.filter(roots) : roots;
        var Q = [];
        var connectedNodes = [];
        var connectedBy = {};
        var id2depth = {};
        var V = {};
        var j = 0;
        var found;
  
        var _this$byGroup = this.byGroup(),
            nodes = _this$byGroup.nodes,
            edges = _this$byGroup.edges; // enqueue v
  
  
        for (var i = 0; i < v.length; i++) {
          var vi = v[i];
          var viId = vi.id();
  
          if (vi.isNode()) {
            Q.unshift(vi);
  
            if (params.bfs) {
              V[viId] = true;
              connectedNodes.push(vi);
            }
  
            id2depth[viId] = 0;
          }
        }
  
        var _loop2 = function _loop2() {
          var v = params.bfs ? Q.shift() : Q.pop();
          var vId = v.id();
  
          if (params.dfs) {
            if (V[vId]) {
              return "continue";
            }
  
            V[vId] = true;
            connectedNodes.push(v);
          }
  
          var depth = id2depth[vId];
          var prevEdge = connectedBy[vId];
          var src = prevEdge != null ? prevEdge.source() : null;
          var tgt = prevEdge != null ? prevEdge.target() : null;
          var prevNode = prevEdge == null ? undefined : v.same(src) ? tgt[0] : src[0];
          var ret = void 0;
          ret = fn$1(v, prevEdge, prevNode, j++, depth);
  
          if (ret === true) {
            found = v;
            return "break";
          }
  
          if (ret === false) {
            return "break";
          }
  
          var vwEdges = v.connectedEdges().filter(function (e) {
            return (!directed || e.source().same(v)) && edges.has(e);
          });
  
          for (var _i2 = 0; _i2 < vwEdges.length; _i2++) {
            var e = vwEdges[_i2];
            var w = e.connectedNodes().filter(function (n) {
              return !n.same(v) && nodes.has(n);
            });
            var wId = w.id();
  
            if (w.length !== 0 && !V[wId]) {
              w = w[0];
              Q.push(w);
  
              if (params.bfs) {
                V[wId] = true;
                connectedNodes.push(w);
              }
  
              connectedBy[wId] = e;
              id2depth[wId] = id2depth[vId] + 1;
            }
          }
        };
  
        _loop: while (Q.length !== 0) {
          var _ret = _loop2();
  
          switch (_ret) {
            case "continue":
              continue;
  
            case "break":
              break _loop;
          }
        }
  
        var connectedEles = cy.collection();
  
        for (var _i = 0; _i < connectedNodes.length; _i++) {
          var node = connectedNodes[_i];
          var edge = connectedBy[node.id()];
  
          if (edge != null) {
            connectedEles.merge(edge);
          }
  
          connectedEles.merge(node);
        }
  
        return {
          path: cy.collection(connectedEles),
          found: cy.collection(found)
        };
      };
    }; // search, spanning trees, etc
  
  
    var elesfn = {
      breadthFirstSearch: defineSearch({
        bfs: true
      }),
      depthFirstSearch: defineSearch({
        dfs: true
      })
    }; // nice, short mathemathical alias
  
    elesfn.bfs = elesfn.breadthFirstSearch;
    elesfn.dfs = elesfn.depthFirstSearch;
  
    var heap = createCommonjsModule(function (module, exports) {
    // Generated by CoffeeScript 1.8.0
    (function() {
      var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;
  
      floor = Math.floor, min = Math.min;
  
  
      /*
      Default comparison function to be used
       */
  
      defaultCmp = function(x, y) {
        if (x < y) {
          return -1;
        }
        if (x > y) {
          return 1;
        }
        return 0;
      };
  
  
      /*
      Insert item x in list a, and keep it sorted assuming a is sorted.
      
      If x is already in a, insert it to the right of the rightmost x.
      
      Optional args lo (default 0) and hi (default a.length) bound the slice
      of a to be searched.
       */
  
      insort = function(a, x, lo, hi, cmp) {
        var mid;
        if (lo == null) {
          lo = 0;
        }
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (lo < 0) {
          throw new Error('lo must be non-negative');
        }
        if (hi == null) {
          hi = a.length;
        }
        while (lo < hi) {
          mid = floor((lo + hi) / 2);
          if (cmp(x, a[mid]) < 0) {
            hi = mid;
          } else {
            lo = mid + 1;
          }
        }
        return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
      };
  
  
      /*
      Push item onto heap, maintaining the heap invariant.
       */
  
      heappush = function(array, item, cmp) {
        if (cmp == null) {
          cmp = defaultCmp;
        }
        array.push(item);
        return _siftdown(array, 0, array.length - 1, cmp);
      };
  
  
      /*
      Pop the smallest item off the heap, maintaining the heap invariant.
       */
  
      heappop = function(array, cmp) {
        var lastelt, returnitem;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        lastelt = array.pop();
        if (array.length) {
          returnitem = array[0];
          array[0] = lastelt;
          _siftup(array, 0, cmp);
        } else {
          returnitem = lastelt;
        }
        return returnitem;
      };
  
  
      /*
      Pop and return the current smallest value, and add the new item.
      
      This is more efficient than heappop() followed by heappush(), and can be
      more appropriate when using a fixed size heap. Note that the value
      returned may be larger than item! That constrains reasonable use of
      this routine unless written as part of a conditional replacement:
          if item > array[0]
            item = heapreplace(array, item)
       */
  
      heapreplace = function(array, item, cmp) {
        var returnitem;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        returnitem = array[0];
        array[0] = item;
        _siftup(array, 0, cmp);
        return returnitem;
      };
  
  
      /*
      Fast version of a heappush followed by a heappop.
       */
  
      heappushpop = function(array, item, cmp) {
        var _ref;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (array.length && cmp(array[0], item) < 0) {
          _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
          _siftup(array, 0, cmp);
        }
        return item;
      };
  
  
      /*
      Transform list into a heap, in-place, in O(array.length) time.
       */
  
      heapify = function(array, cmp) {
        var i, _i, _len, _ref1, _results, _results1;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        _ref1 = (function() {
          _results1 = [];
          for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
          return _results1;
        }).apply(this).reverse();
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          i = _ref1[_i];
          _results.push(_siftup(array, i, cmp));
        }
        return _results;
      };
  
  
      /*
      Update the position of the given item in the heap.
      This function should be called every time the item is being modified.
       */
  
      updateItem = function(array, item, cmp) {
        var pos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        pos = array.indexOf(item);
        if (pos === -1) {
          return;
        }
        _siftdown(array, 0, pos, cmp);
        return _siftup(array, pos, cmp);
      };
  
  
      /*
      Find the n largest elements in a dataset.
       */
  
      nlargest = function(array, n, cmp) {
        var elem, result, _i, _len, _ref;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        result = array.slice(0, n);
        if (!result.length) {
          return result;
        }
        heapify(result, cmp);
        _ref = array.slice(n);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elem = _ref[_i];
          heappushpop(result, elem, cmp);
        }
        return result.sort(cmp).reverse();
      };
  
  
      /*
      Find the n smallest elements in a dataset.
       */
  
      nsmallest = function(array, n, cmp) {
        var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (n * 10 <= array.length) {
          result = array.slice(0, n).sort(cmp);
          if (!result.length) {
            return result;
          }
          los = result[result.length - 1];
          _ref = array.slice(n);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            elem = _ref[_i];
            if (cmp(elem, los) < 0) {
              insort(result, elem, 0, null, cmp);
              result.pop();
              los = result[result.length - 1];
            }
          }
          return result;
        }
        heapify(array, cmp);
        _results = [];
        for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          _results.push(heappop(array, cmp));
        }
        return _results;
      };
  
      _siftdown = function(array, startpos, pos, cmp) {
        var newitem, parent, parentpos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        newitem = array[pos];
        while (pos > startpos) {
          parentpos = (pos - 1) >> 1;
          parent = array[parentpos];
          if (cmp(newitem, parent) < 0) {
            array[pos] = parent;
            pos = parentpos;
            continue;
          }
          break;
        }
        return array[pos] = newitem;
      };
  
      _siftup = function(array, pos, cmp) {
        var childpos, endpos, newitem, rightpos, startpos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        endpos = array.length;
        startpos = pos;
        newitem = array[pos];
        childpos = 2 * pos + 1;
        while (childpos < endpos) {
          rightpos = childpos + 1;
          if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
            childpos = rightpos;
          }
          array[pos] = array[childpos];
          pos = childpos;
          childpos = 2 * pos + 1;
        }
        array[pos] = newitem;
        return _siftdown(array, startpos, pos, cmp);
      };
  
      Heap = (function() {
        Heap.push = heappush;
  
        Heap.pop = heappop;
  
        Heap.replace = heapreplace;
  
        Heap.pushpop = heappushpop;
  
        Heap.heapify = heapify;
  
        Heap.updateItem = updateItem;
  
        Heap.nlargest = nlargest;
  
        Heap.nsmallest = nsmallest;
  
        function Heap(cmp) {
          this.cmp = cmp != null ? cmp : defaultCmp;
          this.nodes = [];
        }
  
        Heap.prototype.push = function(x) {
          return heappush(this.nodes, x, this.cmp);
        };
  
        Heap.prototype.pop = function() {
          return heappop(this.nodes, this.cmp);
        };
  
        Heap.prototype.peek = function() {
          return this.nodes[0];
        };
  
        Heap.prototype.contains = function(x) {
          return this.nodes.indexOf(x) !== -1;
        };
  
        Heap.prototype.replace = function(x) {
          return heapreplace(this.nodes, x, this.cmp);
        };
  
        Heap.prototype.pushpop = function(x) {
          return heappushpop(this.nodes, x, this.cmp);
        };
  
        Heap.prototype.heapify = function() {
          return heapify(this.nodes, this.cmp);
        };
  
        Heap.prototype.updateItem = function(x) {
          return updateItem(this.nodes, x, this.cmp);
        };
  
        Heap.prototype.clear = function() {
          return this.nodes = [];
        };
  
        Heap.prototype.empty = function() {
          return this.nodes.length === 0;
        };
  
        Heap.prototype.size = function() {
          return this.nodes.length;
        };
  
        Heap.prototype.clone = function() {
          var heap;
          heap = new Heap();
          heap.nodes = this.nodes.slice(0);
          return heap;
        };
  
        Heap.prototype.toArray = function() {
          return this.nodes.slice(0);
        };
  
        Heap.prototype.insert = Heap.prototype.push;
  
        Heap.prototype.top = Heap.prototype.peek;
  
        Heap.prototype.front = Heap.prototype.peek;
  
        Heap.prototype.has = Heap.prototype.contains;
  
        Heap.prototype.copy = Heap.prototype.clone;
  
        return Heap;
  
      })();
  
      (function(root, factory) {
        {
          return module.exports = factory();
        }
      })(this, function() {
        return Heap;
      });
  
    }).call(commonjsGlobal);
    });
  
    var heap$1 = heap;
  
    var dijkstraDefaults = defaults({
      root: null,
      weight: function weight(edge) {
        return 1;
      },
      directed: false
    });
    var elesfn$1 = {
      dijkstra: function dijkstra(options) {
        if (!plainObject(options)) {
          var args = arguments;
          options = {
            root: args[0],
            weight: args[1],
            directed: args[2]
          };
        }
  
        var _dijkstraDefaults = dijkstraDefaults(options),
            root = _dijkstraDefaults.root,
            weight = _dijkstraDefaults.weight,
            directed = _dijkstraDefaults.directed;
  
        var eles = this;
        var weightFn = weight;
        var source = string(root) ? this.filter(root)[0] : root[0];
        var dist = {};
        var prev = {};
        var knownDist = {};
  
        var _this$byGroup = this.byGroup(),
            nodes = _this$byGroup.nodes,
            edges = _this$byGroup.edges;
  
        edges.unmergeBy(function (ele) {
          return ele.isLoop();
        });
  
        var getDist = function getDist(node) {
          return dist[node.id()];
        };
  
        var setDist = function setDist(node, d) {
          dist[node.id()] = d;
          Q.updateItem(node);
        };
  
        var Q = new heap$1(function (a, b) {
          return getDist(a) - getDist(b);
        });
  
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          dist[node.id()] = node.same(source) ? 0 : Infinity;
          Q.push(node);
        }
  
        var distBetween = function distBetween(u, v) {
          var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);
          var smallestDistance = Infinity;
          var smallestEdge;
  
          for (var _i = 0; _i < uvs.length; _i++) {
            var edge = uvs[_i];
  
            var _weight = weightFn(edge);
  
            if (_weight < smallestDistance || !smallestEdge) {
              smallestDistance = _weight;
              smallestEdge = edge;
            }
          }
  
          return {
            edge: smallestEdge,
            dist: smallestDistance
          };
        };
  
        while (Q.size() > 0) {
          var u = Q.pop();
          var smalletsDist = getDist(u);
          var uid = u.id();
          knownDist[uid] = smalletsDist;
  
          if (smalletsDist === Infinity) {
            continue;
          }
  
          var neighbors = u.neighborhood().intersect(nodes);
  
          for (var _i2 = 0; _i2 < neighbors.length; _i2++) {
            var v = neighbors[_i2];
            var vid = v.id();
            var vDist = distBetween(u, v);
            var alt = smalletsDist + vDist.dist;
  
            if (alt < getDist(v)) {
              setDist(v, alt);
              prev[vid] = {
                node: u,
                edge: vDist.edge
              };
            }
          } // for
  
        } // while
  
  
        return {
          distanceTo: function distanceTo(node) {
            var target = string(node) ? nodes.filter(node)[0] : node[0];
            return knownDist[target.id()];
          },
          pathTo: function pathTo(node) {
            var target = string(node) ? nodes.filter(node)[0] : node[0];
            var S = [];
            var u = target;
            var uid = u.id();
  
            if (target.length > 0) {
              S.unshift(target);
  
              while (prev[uid]) {
                var p = prev[uid];
                S.unshift(p.edge);
                S.unshift(p.node);
                u = p.node;
                uid = u.id();
              }
            }
  
            return eles.spawn(S);
          }
        };
      }
    };
  
    var elesfn$2 = {
      // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
      // implemented from pseudocode from wikipedia
      kruskal: function kruskal(weightFn) {
        weightFn = weightFn || function (edge) {
          return 1;
        };
  
        var _this$byGroup = this.byGroup(),
            nodes = _this$byGroup.nodes,
            edges = _this$byGroup.edges;
  
        var numNodes = nodes.length;
        var forest = new Array(numNodes);
        var A = nodes; // assumes byGroup() creates new collections that can be safely mutated
  
        var findSetIndex = function findSetIndex(ele) {
          for (var i = 0; i < forest.length; i++) {
            var eles = forest[i];
  
            if (eles.has(ele)) {
              return i;
            }
          }
        }; // start with one forest per node
  
  
        for (var i = 0; i < numNodes; i++) {
          forest[i] = this.spawn(nodes[i]);
        }
  
        var S = edges.sort(function (a, b) {
          return weightFn(a) - weightFn(b);
        });
  
        for (var _i = 0; _i < S.length; _i++) {
          var edge = S[_i];
          var u = edge.source()[0];
          var v = edge.target()[0];
          var setUIndex = findSetIndex(u);
          var setVIndex = findSetIndex(v);
          var setU = forest[setUIndex];
          var setV = forest[setVIndex];
  
          if (setUIndex !== setVIndex) {
            A.merge(edge); // combine forests for u and v
  
            setU.merge(setV);
            forest.splice(setVIndex, 1);
          }
        }
  
        return A;
      }
    };
  
    var aStarDefaults = defaults({
      root: null,
      goal: null,
      weight: function weight(edge) {
        return 1;
      },
      heuristic: function heuristic(edge) {
        return 0;
      },
      directed: false
    });
    var elesfn$3 = {
      // Implemented from pseudocode from wikipedia
      aStar: function aStar(options) {
        var cy = this.cy();
  
        var _aStarDefaults = aStarDefaults(options),
            root = _aStarDefaults.root,
            goal = _aStarDefaults.goal,
            heuristic = _aStarDefaults.heuristic,
            directed = _aStarDefaults.directed,
            weight = _aStarDefaults.weight;
  
        root = cy.collection(root)[0];
        goal = cy.collection(goal)[0];
        var sid = root.id();
        var tid = goal.id();
        var gScore = {};
        var fScore = {};
        var closedSetIds = {};
        var openSet = new heap$1(function (a, b) {
          return fScore[a.id()] - fScore[b.id()];
        });
        var openSetIds = new Set$1();
        var cameFrom = {};
        var cameFromEdge = {};
  
        var addToOpenSet = function addToOpenSet(ele, id) {
          openSet.push(ele);
          openSetIds.add(id);
        };
  
        var cMin, cMinId;
  
        var popFromOpenSet = function popFromOpenSet() {
          cMin = openSet.pop();
          cMinId = cMin.id();
          openSetIds["delete"](cMinId);
        };
  
        var isInOpenSet = function isInOpenSet(id) {
          return openSetIds.has(id);
        };
  
        addToOpenSet(root, sid);
        gScore[sid] = 0;
        fScore[sid] = heuristic(root); // Counter
  
        var steps = 0; // Main loop
  
        while (openSet.size() > 0) {
          popFromOpenSet();
          steps++; // If we've found our goal, then we are done
  
          if (cMinId === tid) {
            var path = [];
            var pathNode = goal;
            var pathNodeId = tid;
            var pathEdge = cameFromEdge[pathNodeId];
  
            for (;;) {
              path.unshift(pathNode);
  
              if (pathEdge != null) {
                path.unshift(pathEdge);
              }
  
              pathNode = cameFrom[pathNodeId];
  
              if (pathNode == null) {
                break;
              }
  
              pathNodeId = pathNode.id();
              pathEdge = cameFromEdge[pathNodeId];
            }
  
            return {
              found: true,
              distance: gScore[cMinId],
              path: this.spawn(path),
              steps: steps
            };
          } // Add cMin to processed nodes
  
  
          closedSetIds[cMinId] = true; // Update scores for neighbors of cMin
          // Take into account if graph is directed or not
  
          var vwEdges = cMin._private.edges;
  
          for (var i = 0; i < vwEdges.length; i++) {
            var e = vwEdges[i]; // edge must be in set of calling eles
  
            if (!this.hasElementWithId(e.id())) {
              continue;
            } // cMin must be the source of edge if directed
  
  
            if (directed && e.data('source') !== cMinId) {
              continue;
            }
  
            var wSrc = e.source();
            var wTgt = e.target();
            var w = wSrc.id() !== cMinId ? wSrc : wTgt;
            var wid = w.id(); // node must be in set of calling eles
  
            if (!this.hasElementWithId(wid)) {
              continue;
            } // if node is in closedSet, ignore it
  
  
            if (closedSetIds[wid]) {
              continue;
            } // New tentative score for node w
  
  
            var tempScore = gScore[cMinId] + weight(e); // Update gScore for node w if:
            //   w not present in openSet
            // OR
            //   tentative gScore is less than previous value
            // w not in openSet
  
            if (!isInOpenSet(wid)) {
              gScore[wid] = tempScore;
              fScore[wid] = tempScore + heuristic(w);
              addToOpenSet(w, wid);
              cameFrom[wid] = cMin;
              cameFromEdge[wid] = e;
              continue;
            } // w already in openSet, but with greater gScore
  
  
            if (tempScore < gScore[wid]) {
              gScore[wid] = tempScore;
              fScore[wid] = tempScore + heuristic(w);
              cameFrom[wid] = cMin;
            }
          } // End of neighbors update
  
        } // End of main loop
        // If we've reached here, then we've not reached our goal
  
  
        return {
          found: false,
          distance: undefined,
          path: undefined,
          steps: steps
        };
      }
    }; // elesfn
  
    var floydWarshallDefaults = defaults({
      weight: function weight(edge) {
        return 1;
      },
      directed: false
    });
    var elesfn$4 = {
      // Implemented from pseudocode from wikipedia
      floydWarshall: function floydWarshall(options) {
        var cy = this.cy();
  
        var _floydWarshallDefault = floydWarshallDefaults(options),
            weight = _floydWarshallDefault.weight,
            directed = _floydWarshallDefault.directed;
  
        var weightFn = weight;
  
        var _this$byGroup = this.byGroup(),
            nodes = _this$byGroup.nodes,
            edges = _this$byGroup.edges;
  
        var N = nodes.length;
        var Nsq = N * N;
  
        var indexOf = function indexOf(node) {
          return nodes.indexOf(node);
        };
  
        var atIndex = function atIndex(i) {
          return nodes[i];
        }; // Initialize distance matrix
  
  
        var dist = new Array(Nsq);
  
        for (var n = 0; n < Nsq; n++) {
          var j = n % N;
          var i = (n - j) / N;
  
          if (i === j) {
            dist[n] = 0;
          } else {
            dist[n] = Infinity;
          }
        } // Initialize matrix used for path reconstruction
        // Initialize distance matrix
  
  
        var next = new Array(Nsq);
        var edgeNext = new Array(Nsq); // Process edges
  
        for (var _i = 0; _i < edges.length; _i++) {
          var edge = edges[_i];
          var src = edge.source()[0];
          var tgt = edge.target()[0];
  
          if (src === tgt) {
            continue;
          } // exclude loops
  
  
          var s = indexOf(src);
          var t = indexOf(tgt);
          var st = s * N + t; // source to target index
  
          var _weight = weightFn(edge); // Check if already process another edge between same 2 nodes
  
  
          if (dist[st] > _weight) {
            dist[st] = _weight;
            next[st] = t;
            edgeNext[st] = edge;
          } // If undirected graph, process 'reversed' edge
  
  
          if (!directed) {
            var ts = t * N + s; // target to source index
  
            if (!directed && dist[ts] > _weight) {
              dist[ts] = _weight;
              next[ts] = s;
              edgeNext[ts] = edge;
            }
          }
        } // Main loop
  
  
        for (var k = 0; k < N; k++) {
          for (var _i2 = 0; _i2 < N; _i2++) {
            var ik = _i2 * N + k;
  
            for (var _j = 0; _j < N; _j++) {
              var ij = _i2 * N + _j;
              var kj = k * N + _j;
  
              if (dist[ik] + dist[kj] < dist[ij]) {
                dist[ij] = dist[ik] + dist[kj];
                next[ij] = next[ik];
              }
            }
          }
        }
  
        var getArgEle = function getArgEle(ele) {
          return (string(ele) ? cy.filter(ele) : ele)[0];
        };
  
        var indexOfArgEle = function indexOfArgEle(ele) {
          return indexOf(getArgEle(ele));
        };
  
        var res = {
          distance: function distance(from, to) {
            var i = indexOfArgEle(from);
            var j = indexOfArgEle(to);
            return dist[i * N + j];
          },
          path: function path(from, to) {
            var i = indexOfArgEle(from);
            var j = indexOfArgEle(to);
            var fromNode = atIndex(i);
  
            if (i === j) {
              return fromNode.collection();
            }
  
            if (next[i * N + j] == null) {
              return cy.collection();
            }
  
            var path = cy.collection();
            var prev = i;
            var edge;
            path.merge(fromNode);
  
            while (i !== j) {
              prev = i;
              i = next[i * N + j];
              edge = edgeNext[prev * N + i];
              path.merge(edge);
              path.merge(atIndex(i));
            }
  
            return path;
          }
        };
        return res;
      } // floydWarshall
  
    }; // elesfn
  
    var bellmanFordDefaults = defaults({
      weight: function weight(edge) {
        return 1;
      },
      directed: false,
      root: null
    });
    var elesfn$5 = {
      // Implemented from pseudocode from wikipedia
      bellmanFord: function bellmanFord(options) {
        var _this = this;
  
        var _bellmanFordDefaults = bellmanFordDefaults(options),
            weight = _bellmanFordDefaults.weight,
            directed = _bellmanFordDefaults.directed,
            root = _bellmanFordDefaults.root;
  
        var weightFn = weight;
        var eles = this;
        var cy = this.cy();
  
        var _this$byGroup = this.byGroup(),
            edges = _this$byGroup.edges,
            nodes = _this$byGroup.nodes;
  
        var numNodes = nodes.length;
        var infoMap = new Map$1();
        var hasNegativeWeightCycle = false;
        var negativeWeightCycles = [];
        root = cy.collection(root)[0]; // in case selector passed
  
        edges.unmergeBy(function (edge) {
          return edge.isLoop();
        });
        var numEdges = edges.length;
  
        var getInfo = function getInfo(node) {
          var obj = infoMap.get(node.id());
  
          if (!obj) {
            obj = {};
            infoMap.set(node.id(), obj);
          }
  
          return obj;
        };
  
        var getNodeFromTo = function getNodeFromTo(to) {
          return (string(to) ? cy.$(to) : to)[0];
        };
  
        var distanceTo = function distanceTo(to) {
          return getInfo(getNodeFromTo(to)).dist;
        };
  
        var pathTo = function pathTo(to) {
          var thisStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : root;
          var end = getNodeFromTo(to);
          var path = [];
          var node = end;
  
          for (;;) {
            if (node == null) {
              return _this.spawn();
            }
  
            var _getInfo = getInfo(node),
                edge = _getInfo.edge,
                pred = _getInfo.pred;
  
            path.unshift(node[0]);
  
            if (node.same(thisStart) && path.length > 0) {
              break;
            }
  
            if (edge != null) {
              path.unshift(edge);
            }
  
            node = pred;
          }
  
          return eles.spawn(path);
        }; // Initializations { dist, pred, edge }
  
  
        for (var i = 0; i < numNodes; i++) {
          var node = nodes[i];
          var info = getInfo(node);
  
          if (node.same(root)) {
            info.dist = 0;
          } else {
            info.dist = Infinity;
          }
  
          info.pred = null;
          info.edge = null;
        } // Edges relaxation
  
  
        var replacedEdge = false;
  
        var checkForEdgeReplacement = function checkForEdgeReplacement(node1, node2, edge, info1, info2, weight) {
          var dist = info1.dist + weight;
  
          if (dist < info2.dist && !edge.same(info1.edge)) {
            info2.dist = dist;
            info2.pred = node1;
            info2.edge = edge;
            replacedEdge = true;
          }
        };
  
        for (var _i = 1; _i < numNodes; _i++) {
          replacedEdge = false;
  
          for (var e = 0; e < numEdges; e++) {
            var edge = edges[e];
            var src = edge.source();
            var tgt = edge.target();
  
            var _weight = weightFn(edge);
  
            var srcInfo = getInfo(src);
            var tgtInfo = getInfo(tgt);
            checkForEdgeReplacement(src, tgt, edge, srcInfo, tgtInfo, _weight); // If undirected graph, we need to take into account the 'reverse' edge
  
            if (!directed) {
              checkForEdgeReplacement(tgt, src, edge, tgtInfo, srcInfo, _weight);
            }
          }
  
          if (!replacedEdge) {
            break;
          }
        }
  
        if (replacedEdge) {
          // Check for negative weight cycles
          for (var _e = 0; _e < numEdges; _e++) {
            var _edge = edges[_e];
  
            var _src = _edge.source();
  
            var _tgt = _edge.target();
  
            var _weight2 = weightFn(_edge);
  
            var srcDist = getInfo(_src).dist;
            var tgtDist = getInfo(_tgt).dist;
  
            if (srcDist + _weight2 < tgtDist || !directed && tgtDist + _weight2 < srcDist) {
              warn('Graph contains a negative weight cycle for Bellman-Ford');
              hasNegativeWeightCycle = true;
              break;
            }
          }
        }
  
        return {
          distanceTo: distanceTo,
          pathTo: pathTo,
          hasNegativeWeightCycle: hasNegativeWeightCycle,
          negativeWeightCycles: negativeWeightCycles
        };
      } // bellmanFord
  
    }; // elesfn
  
    var sqrt2 = Math.sqrt(2); // Function which colapses 2 (meta) nodes into one
    // Updates the remaining edge lists
    // Receives as a paramater the edge which causes the collapse
  
    var collapse = function collapse(edgeIndex, nodeMap, remainingEdges) {
      if (remainingEdges.length === 0) {
        error("Karger-Stein must be run on a connected (sub)graph");
      }
  
      var edgeInfo = remainingEdges[edgeIndex];
      var sourceIn = edgeInfo[1];
      var targetIn = edgeInfo[2];
      var partition1 = nodeMap[sourceIn];
      var partition2 = nodeMap[targetIn];
      var newEdges = remainingEdges; // re-use array
      // Delete all edges between partition1 and partition2
  
      for (var i = newEdges.length - 1; i >= 0; i--) {
        var edge = newEdges[i];
        var src = edge[1];
        var tgt = edge[2];
  
        if (nodeMap[src] === partition1 && nodeMap[tgt] === partition2 || nodeMap[src] === partition2 && nodeMap[tgt] === partition1) {
          newEdges.splice(i, 1);
        }
      } // All edges pointing to partition2 should now point to partition1
  
  
      for (var _i = 0; _i < newEdges.length; _i++) {
        var _edge = newEdges[_i];
  
        if (_edge[1] === partition2) {
          // Check source
          newEdges[_i] = _edge.slice(); // copy
  
          newEdges[_i][1] = partition1;
        } else if (_edge[2] === partition2) {
          // Check target
          newEdges[_i] = _edge.slice(); // copy
  
          newEdges[_i][2] = partition1;
        }
      } // Move all nodes from partition2 to partition1
  
  
      for (var _i2 = 0; _i2 < nodeMap.length; _i2++) {
        if (nodeMap[_i2] === partition2) {
          nodeMap[_i2] = partition1;
        }
      }
  
      return newEdges;
    }; // Contracts a graph until we reach a certain number of meta nodes
  
  
    var contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {
      while (size > sizeLimit) {
        // Choose an edge randomly
        var edgeIndex = Math.floor(Math.random() * remainingEdges.length); // Collapse graph based on edge
  
        remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);
        size--;
      }
  
      return remainingEdges;
    };
  
    var elesfn$6 = {
      // Computes the minimum cut of an undirected graph
      // Returns the correct answer with high probability
      kargerStein: function kargerStein() {
        var _this = this;
  
        var _this$byGroup = this.byGroup(),
            nodes = _this$byGroup.nodes,
            edges = _this$byGroup.edges;
  
        edges.unmergeBy(function (edge) {
          return edge.isLoop();
        });
        var numNodes = nodes.length;
        var numEdges = edges.length;
        var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
        var stopSize = Math.floor(numNodes / sqrt2);
  
        if (numNodes < 2) {
          error('At least 2 nodes are required for Karger-Stein algorithm');
          return undefined;
        } // Now store edge destination as indexes
        // Format for each edge (edge index, source node index, target node index)
  
  
        var edgeIndexes = [];
  
        for (var i = 0; i < numEdges; i++) {
          var e = edges[i];
          edgeIndexes.push([i, nodes.indexOf(e.source()), nodes.indexOf(e.target())]);
        } // We will store the best cut found here
  
  
        var minCutSize = Infinity;
        var minCutEdgeIndexes = [];
        var minCutNodeMap = new Array(numNodes); // Initial meta node partition
  
        var metaNodeMap = new Array(numNodes);
        var metaNodeMap2 = new Array(numNodes);
  
        var copyNodesMap = function copyNodesMap(from, to) {
          for (var _i3 = 0; _i3 < numNodes; _i3++) {
            to[_i3] = from[_i3];
          }
        }; // Main loop
  
  
        for (var iter = 0; iter <= numIter; iter++) {
          // Reset meta node partition
          for (var _i4 = 0; _i4 < numNodes; _i4++) {
            metaNodeMap[_i4] = _i4;
          } // Contract until stop point (stopSize nodes)
  
  
          var edgesState = contractUntil(metaNodeMap, edgeIndexes.slice(), numNodes, stopSize);
          var edgesState2 = edgesState.slice(); // copy
          // Create a copy of the colapsed nodes state
  
          copyNodesMap(metaNodeMap, metaNodeMap2); // Run 2 iterations starting in the stop state
  
          var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
          var res2 = contractUntil(metaNodeMap2, edgesState2, stopSize, 2); // Is any of the 2 results the best cut so far?
  
          if (res1.length <= res2.length && res1.length < minCutSize) {
            minCutSize = res1.length;
            minCutEdgeIndexes = res1;
            copyNodesMap(metaNodeMap, minCutNodeMap);
          } else if (res2.length <= res1.length && res2.length < minCutSize) {
            minCutSize = res2.length;
            minCutEdgeIndexes = res2;
            copyNodesMap(metaNodeMap2, minCutNodeMap);
          }
        } // end of main loop
        // Construct result
  
  
        var cut = this.spawn(minCutEdgeIndexes.map(function (e) {
          return edges[e[0]];
        }));
        var partition1 = this.spawn();
        var partition2 = this.spawn(); // traverse metaNodeMap for best cut
  
        var witnessNodePartition = minCutNodeMap[0];
  
        for (var _i5 = 0; _i5 < minCutNodeMap.length; _i5++) {
          var partitionId = minCutNodeMap[_i5];
          var node = nodes[_i5];
  
          if (partitionId === witnessNodePartition) {
            partition1.merge(node);
          } else {
            partition2.merge(node);
          }
        } // construct components corresponding to each disjoint subset of nodes
  
  
        var constructComponent = function constructComponent(subset) {
          var component = _this.spawn();
  
          subset.forEach(function (node) {
            component.merge(node);
            node.connectedEdges().forEach(function (edge) {
              // ensure edge is within calling collection and edge is not in cut
              if (_this.contains(edge) && !cut.contains(edge)) {
                component.merge(edge);
              }
            });
          });
          return component;
        };
  
        var components = [constructComponent(partition1), constructComponent(partition2)];
        var ret = {
          cut: cut,
          components: components,
          // n.b. partitions are included to be compatible with the old api spec
          // (could be removed in a future major version)
          partition1: partition1,
          partition2: partition2
        };
        return ret;
      }
    }; // elesfn
  
    var copyPosition = function copyPosition(p) {
      return {
        x: p.x,
        y: p.y
      };
    };
    var modelToRenderedPosition = function modelToRenderedPosition(p, zoom, pan) {
      return {
        x: p.x * zoom + pan.x,
        y: p.y * zoom + pan.y
      };
    };
    var renderedToModelPosition = function renderedToModelPosition(p, zoom, pan) {
      return {
        x: (p.x - pan.x) / zoom,
        y: (p.y - pan.y) / zoom
      };
    };
    var array2point = function array2point(arr) {
      return {
        x: arr[0],
        y: arr[1]
      };
    };
    var min = function min(arr) {
      var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
      var min = Infinity;
  
      for (var i = begin; i < end; i++) {
        var val = arr[i];
  
        if (isFinite(val)) {
          min = Math.min(val, min);
        }
      }
  
      return min;
    };
    var max = function max(arr) {
      var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
      var max = -Infinity;
  
      for (var i = begin; i < end; i++) {
        var val = arr[i];
  
        if (isFinite(val)) {
          max = Math.max(val, max);
        }
      }
  
      return max;
    };
    var mean = function mean(arr) {
      var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
      var total = 0;
      var n = 0;
  
      for (var i = begin; i < end; i++) {
        var val = arr[i];
  
        if (isFinite(val)) {
          total += val;
          n++;
        }
      }
  
      return total / n;
    };
    var median = function median(arr) {
      var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
      var copy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var sort = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      var includeHoles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
  
      if (copy) {
        arr = arr.slice(begin, end);
      } else {
        if (end < arr.length) {
          arr.splice(end, arr.length - end);
        }
  
        if (begin > 0) {
          arr.splice(0, begin);
        }
      } // all non finite (e.g. Infinity, NaN) elements must be -Infinity so they go to the start
  
  
      var off = 0; // offset from non-finite values
  
      for (var i = arr.length - 1; i >= 0; i--) {
        var v = arr[i];
  
        if (includeHoles) {
          if (!isFinite(v)) {
            arr[i] = -Infinity;
            off++;
          }
        } else {
          // just remove it if we don't want to consider holes
          arr.splice(i, 1);
        }
      }
  
      if (sort) {
        arr.sort(function (a, b) {
          return a - b;
        }); // requires copy = true if you don't want to change the orig
      }
  
      var len = arr.length;
      var mid = Math.floor(len / 2);
  
      if (len % 2 !== 0) {
        return arr[mid + 1 + off];
      } else {
        return (arr[mid - 1 + off] + arr[mid + off]) / 2;
      }
    };
    var deg2rad = function deg2rad(deg) {
      return Math.PI * deg / 180;
    };
    var getAngleFromDisp = function getAngleFromDisp(dispX, dispY) {
      return Math.atan2(dispY, dispX) - Math.PI / 2;
    };
    var log2 = Math.log2 || function (n) {
      return Math.log(n) / Math.log(2);
    };
    var signum = function signum(x) {
      if (x > 0) {
        return 1;
      } else if (x < 0) {
        return -1;
      } else {
        return 0;
      }
    };
    var dist = function dist(p1, p2) {
      return Math.sqrt(sqdist(p1, p2));
    };
    var sqdist = function sqdist(p1, p2) {
      var dx = p2.x - p1.x;
      var dy = p2.y - p1.y;
      return dx * dx + dy * dy;
    };
    var inPlaceSumNormalize = function inPlaceSumNormalize(v) {
      var length = v.length; // First, get sum of all elements
  
      var total = 0;
  
      for (var i = 0; i < length; i++) {
        total += v[i];
      } // Now, divide each by the sum of all elements
  
  
      for (var _i = 0; _i < length; _i++) {
        v[_i] = v[_i] / total;
      }
  
      return v;
    };
  
    var qbezierAt = function qbezierAt(p0, p1, p2, t) {
      return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
    };
    var qbezierPtAt = function qbezierPtAt(p0, p1, p2, t) {
      return {
        x: qbezierAt(p0.x, p1.x, p2.x, t),
        y: qbezierAt(p0.y, p1.y, p2.y, t)
      };
    };
    var lineAt = function lineAt(p0, p1, t, d) {
      var vec = {
        x: p1.x - p0.x,
        y: p1.y - p0.y
      };
      var vecDist = dist(p0, p1);
      var normVec = {
        x: vec.x / vecDist,
        y: vec.y / vecDist
      };
      t = t == null ? 0 : t;
      d = d != null ? d : t * vecDist;
      return {
        x: p0.x + normVec.x * d,
        y: p0.y + normVec.y * d
      };
    };
    var bound = function bound(min, val, max) {
      return Math.max(min, Math.min(max, val));
    }; // makes a full bb (x1, y1, x2, y2, w, h) from implicit params
  
    var makeBoundingBox = function makeBoundingBox(bb) {
      if (bb == null) {
        return {
          x1: Infinity,
          y1: Infinity,
          x2: -Infinity,
          y2: -Infinity,
          w: 0,
          h: 0
        };
      } else if (bb.x1 != null && bb.y1 != null) {
        if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {
          return {
            x1: bb.x1,
            y1: bb.y1,
            x2: bb.x2,
            y2: bb.y2,
            w: bb.x2 - bb.x1,
            h: bb.y2 - bb.y1
          };
        } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {
          return {
            x1: bb.x1,
            y1: bb.y1,
            x2: bb.x1 + bb.w,
            y2: bb.y1 + bb.h,
            w: bb.w,
            h: bb.h
          };
        }
      }
    };
    var copyBoundingBox = function copyBoundingBox(bb) {
      return {
        x1: bb.x1,
        x2: bb.x2,
        w: bb.w,
        y1: bb.y1,
        y2: bb.y2,
        h: bb.h
      };
    };
    var clearBoundingBox = function clearBoundingBox(bb) {
      bb.x1 = Infinity;
      bb.y1 = Infinity;
      bb.x2 = -Infinity;
      bb.y2 = -Infinity;
      bb.w = 0;
      bb.h = 0;
    };
    var updateBoundingBox = function updateBoundingBox(bb1, bb2) {
      // update bb1 with bb2 bounds
      bb1.x1 = Math.min(bb1.x1, bb2.x1);
      bb1.x2 = Math.max(bb1.x2, bb2.x2);
      bb1.w = bb1.x2 - bb1.x1;
      bb1.y1 = Math.min(bb1.y1, bb2.y1);
      bb1.y2 = Math.max(bb1.y2, bb2.y2);
      bb1.h = bb1.y2 - bb1.y1;
    };
    var expandBoundingBoxByPoint = function expandBoundingBoxByPoint(bb, x, y) {
      bb.x1 = Math.min(bb.x1, x);
      bb.x2 = Math.max(bb.x2, x);
      bb.w = bb.x2 - bb.x1;
      bb.y1 = Math.min(bb.y1, y);
      bb.y2 = Math.max(bb.y2, y);
      bb.h = bb.y2 - bb.y1;
    };
    var expandBoundingBox = function expandBoundingBox(bb) {
      var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      bb.x1 -= padding;
      bb.x2 += padding;
      bb.y1 -= padding;
      bb.y2 += padding;
      bb.w = bb.x2 - bb.x1;
      bb.h = bb.y2 - bb.y1;
      return bb;
    };
    var expandBoundingBoxSides = function expandBoundingBoxSides(bb) {
      var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0];
      var top, right, bottom, left;
  
      if (padding.length === 1) {
        top = right = bottom = left = padding[0];
      } else if (padding.length === 2) {
        top = bottom = padding[0];
        left = right = padding[1];
      } else if (padding.length === 4) {
        var _padding = _slicedToArray(padding, 4);
  
        top = _padding[0];
        right = _padding[1];
        bottom = _padding[2];
        left = _padding[3];
      }
  
      bb.x1 -= left;
      bb.x2 += right;
      bb.y1 -= top;
      bb.y2 += bottom;
      bb.w = bb.x2 - bb.x1;
      bb.h = bb.y2 - bb.y1;
      return bb;
    };
  
    var assignBoundingBox = function assignBoundingBox(bb1, bb2) {
      bb1.x1 = bb2.x1;
      bb1.y1 = bb2.y1;
      bb1.x2 = bb2.x2;
      bb1.y2 = bb2.y2;
      bb1.w = bb1.x2 - bb1.x1;
      bb1.h = bb1.y2 - bb1.y1;
    };
    var assignShiftToBoundingBox = function assignShiftToBoundingBox(bb, delta) {
      bb.x1 += delta.x;
      bb.x2 += delta.x;
      bb.y1 += delta.y;
      bb.y2 += delta.y;
    };
    var boundingBoxesIntersect = function boundingBoxesIntersect(bb1, bb2) {
      // case: one bb to right of other
      if (bb1.x1 > bb2.x2) {
        return false;
      }
  
      if (bb2.x1 > bb1.x2) {
        return false;
      } // case: one bb to left of other
  
  
      if (bb1.x2 < bb2.x1) {
        return false;
      }
  
      if (bb2.x2 < bb1.x1) {
        return false;
      } // case: one bb above other
  
  
      if (bb1.y2 < bb2.y1) {
        return false;
      }
  
      if (bb2.y2 < bb1.y1) {
        return false;
      } // case: one bb below other
  
  
      if (bb1.y1 > bb2.y2) {
        return false;
      }
  
      if (bb2.y1 > bb1.y2) {
        return false;
      } // otherwise, must have some overlap
  
  
      return true;
    };
    var inBoundingBox = function inBoundingBox(bb, x, y) {
      return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
    };
    var pointInBoundingBox = function pointInBoundingBox(bb, pt) {
      return inBoundingBox(bb, pt.x, pt.y);
    };
    var boundingBoxInBoundingBox = function boundingBoxInBoundingBox(bb1, bb2) {
      return inBoundingBox(bb1, bb2.x1, bb2.y1) && inBoundingBox(bb1, bb2.x2, bb2.y2);
    };
    var roundRectangleIntersectLine = function roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding) {
      var cornerRadius = getRoundRectangleRadius(width, height);
      var halfWidth = width / 2;
      var halfHeight = height / 2; // Check intersections with straight line segments
  
      var straightLineIntersections; // Top segment, left to right
  
      {
        var topStartX = nodeX - halfWidth + cornerRadius - padding;
        var topStartY = nodeY - halfHeight - padding;
        var topEndX = nodeX + halfWidth - cornerRadius + padding;
        var topEndY = topStartY;
        straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);
  
        if (straightLineIntersections.length > 0) {
          return straightLineIntersections;
        }
      } // Right segment, top to bottom
  
      {
        var rightStartX = nodeX + halfWidth + padding;
        var rightStartY = nodeY - halfHeight + cornerRadius - padding;
        var rightEndX = rightStartX;
        var rightEndY = nodeY + halfHeight - cornerRadius + padding;
        straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);
  
        if (straightLineIntersections.length > 0) {
          return straightLineIntersections;
        }
      } // Bottom segment, left to right
  
      {
        var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
        var bottomStartY = nodeY + halfHeight + padding;
        var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
        var bottomEndY = bottomStartY;
        straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);
  
        if (straightLineIntersections.length > 0) {
          return straightLineIntersections;
        }
      } // Left segment, top to bottom
  
      {
        var leftStartX = nodeX - halfWidth - padding;
        var leftStartY = nodeY - halfHeight + cornerRadius - padding;
        var leftEndX = leftStartX;
        var leftEndY = nodeY + halfHeight - cornerRadius + padding;
        straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);
  
        if (straightLineIntersections.length > 0) {
          return straightLineIntersections;
        }
      } // Check intersections with arc segments
  
      var arcIntersections; // Top Left
  
      {
        var topLeftCenterX = nodeX - halfWidth + cornerRadius;
        var topLeftCenterY = nodeY - halfHeight + cornerRadius;
        arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle
  
        if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {
          return [arcIntersections[0], arcIntersections[1]];
        }
      } // Top Right
  
      {
        var topRightCenterX = nodeX + halfWidth - cornerRadius;
        var topRightCenterY = nodeY - halfHeight + cornerRadius;
        arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle
  
        if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {
          return [arcIntersections[0], arcIntersections[1]];
        }
      } // Bottom Right
  
      {
        var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
        var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
        arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle
  
        if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {
          return [arcIntersections[0], arcIntersections[1]];
        }
      } // Bottom Left
  
      {
        var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
        var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
        arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle
  
        if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {
          return [arcIntersections[0], arcIntersections[1]];
        }
      }
      return []; // if nothing
    };
    var inLineVicinity = function inLineVicinity(x, y, lx1, ly1, lx2, ly2, tolerance) {
      var t = tolerance;
      var x1 = Math.min(lx1, lx2);
      var x2 = Math.max(lx1, lx2);
      var y1 = Math.min(ly1, ly2);
      var y2 = Math.max(ly1, ly2);
      return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;
    };
    var inBezierVicinity = function inBezierVicinity(x, y, x1, y1, x2, y2, x3, y3, tolerance) {
      var bb = {
        x1: Math.min(x1, x3, x2) - tolerance,
        x2: Math.max(x1, x3, x2) + tolerance,
        y1: Math.min(y1, y3, y2) - tolerance,
        y2: Math.max(y1, y3, y2) + tolerance
      }; // if outside the rough bounding box for the bezier, then it can't be a hit
  
      if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {
        // console.log('bezier out of rough bb')
        return false;
      } else {
        // console.log('do more expensive check');
        return true;
      }
    };
    var solveQuadratic = function solveQuadratic(a, b, c, val) {
      c -= val;
      var r = b * b - 4 * a * c;
  
      if (r < 0) {
        return [];
      }
  
      var sqrtR = Math.sqrt(r);
      var denom = 2 * a;
      var root1 = (-b + sqrtR) / denom;
      var root2 = (-b - sqrtR) / denom;
      return [root1, root2];
    };
    var solveCubic = function solveCubic(a, b, c, d, result) {
      // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
      // r is the real component, i is the imaginary component
      // An implementation of the Cardano method from the year 1545
      // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots
      var epsilon = 0.00001; // avoid division by zero while keeping the overall expression close in value
  
      if (a === 0) {
        a = epsilon;
      }
  
      b /= a;
      c /= a;
      d /= a;
      var discriminant, q, r, dum1, s, t, term1, r13;
      q = (3.0 * c - b * b) / 9.0;
      r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
      r /= 54.0;
      discriminant = q * q * q + r * r;
      result[1] = 0;
      term1 = b / 3.0;
  
      if (discriminant > 0) {
        s = r + Math.sqrt(discriminant);
        s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);
        t = r - Math.sqrt(discriminant);
        t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);
        result[0] = -term1 + s + t;
        term1 += (s + t) / 2.0;
        result[4] = result[2] = -term1;
        term1 = Math.sqrt(3.0) * (-t + s) / 2;
        result[3] = term1;
        result[5] = -term1;
        return;
      }
  
      result[5] = result[3] = 0;
  
      if (discriminant === 0) {
        r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);
        result[0] = -term1 + 2.0 * r13;
        result[4] = result[2] = -(r13 + term1);
        return;
      }
  
      q = -q;
      dum1 = q * q * q;
      dum1 = Math.acos(r / Math.sqrt(dum1));
      r13 = 2.0 * Math.sqrt(q);
      result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
      result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
      result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);
      return;
    };
    var sqdistToQuadraticBezier = function sqdistToQuadraticBezier(x, y, x1, y1, x2, y2, x3, y3) {
      // Find minimum distance by using the minimum of the distance
      // function between the given point and the curve
      // This gives the coefficients of the resulting cubic equation
      // whose roots tell us where a possible minimum is
      // (Coefficients are divided by 4)
      var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;
      var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;
      var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;
      var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y; // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);
  
      var roots = []; // Use the cubic solving algorithm
  
      solveCubic(a, b, c, d, roots);
      var zeroThreshold = 0.0000001;
      var params = [];
  
      for (var index = 0; index < 6; index += 2) {
        if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {
          params.push(roots[index]);
        }
      }
  
      params.push(1.0);
      params.push(0.0);
      var minDistanceSquared = -1;
      var curX, curY, distSquared;
  
      for (var i = 0; i < params.length; i++) {
        curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;
        curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;
        distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2); // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));
  
        if (minDistanceSquared >= 0) {
          if (distSquared < minDistanceSquared) {
            minDistanceSquared = distSquared;
          }
        } else {
          minDistanceSquared = distSquared;
        }
      }
  
      return minDistanceSquared;
    };
    var sqdistToFiniteLine = function sqdistToFiniteLine(x, y, x1, y1, x2, y2) {
      var offset = [x - x1, y - y1];
      var line = [x2 - x1, y2 - y1];
      var lineSq = line[0] * line[0] + line[1] * line[1];
      var hypSq = offset[0] * offset[0] + offset[1] * offset[1];
      var dotProduct = offset[0] * line[0] + offset[1] * line[1];
      var adjSq = dotProduct * dotProduct / lineSq;
  
      if (dotProduct < 0) {
        return hypSq;
      }
  
      if (adjSq > lineSq) {
        return (x - x2) * (x - x2) + (y - y2) * (y - y2);
      }
  
      return hypSq - adjSq;
    };
    var pointInsidePolygonPoints = function pointInsidePolygonPoints(x, y, points) {
      var x1, y1, x2, y2;
      var y3; // Intersect with vertical line through (x, y)
  
      var up = 0; // let down = 0;
  
      for (var i = 0; i < points.length / 2; i++) {
        x1 = points[i * 2];
        y1 = points[i * 2 + 1];
  
        if (i + 1 < points.length / 2) {
          x2 = points[(i + 1) * 2];
          y2 = points[(i + 1) * 2 + 1];
        } else {
          x2 = points[(i + 1 - points.length / 2) * 2];
          y2 = points[(i + 1 - points.length / 2) * 2 + 1];
        }
  
        if (x1 == x && x2 == x) ; else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {
          y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;
  
          if (y3 > y) {
            up++;
          } // if( y3 < y ){
          // down++;
          // }
  
        } else {
          continue;
        }
      }
  
      if (up % 2 === 0) {
        return false;
      } else {
        return true;
      }
    };
    var pointInsidePolygon = function pointInsidePolygon(x, y, basePoints, centerX, centerY, width, height, direction, padding) {
      var transformedPoints = new Array(basePoints.length); // Gives negative angle
  
      var angle;
  
      if (direction[0] != null) {
        angle = Math.atan(direction[1] / direction[0]);
  
        if (direction[0] < 0) {
          angle = angle + Math.PI / 2;
        } else {
          angle = -angle - Math.PI / 2;
        }
      } else {
        angle = direction;
      }
  
      var cos = Math.cos(-angle);
      var sin = Math.sin(-angle); //    console.log("base: " + basePoints);
  
      for (var i = 0; i < transformedPoints.length / 2; i++) {
        transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);
        transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);
        transformedPoints[i * 2] += centerX;
        transformedPoints[i * 2 + 1] += centerY;
      }
  
      var points;
  
      if (padding > 0) {
        var expandedLineSet = expandPolygon(transformedPoints, -padding);
        points = joinLines(expandedLineSet);
      } else {
        points = transformedPoints;
      }
  
      return pointInsidePolygonPoints(x, y, points);
    };
    var pointInsideRoundPolygon = function pointInsideRoundPolygon(x, y, basePoints, centerX, centerY, width, height) {
      var cutPolygonPoints = new Array(basePoints.length);
      var halfW = width / 2;
      var halfH = height / 2;
      var cornerRadius = getRoundPolygonRadius(width, height);
      var squaredCornerRadius = cornerRadius * cornerRadius;
  
      for (var i = 0; i < basePoints.length / 4; i++) {
        var sourceUv = void 0,
            destUv = void 0;
  
        if (i === 0) {
          sourceUv = basePoints.length - 2;
        } else {
          sourceUv = i * 4 - 2;
        }
  
        destUv = i * 4 + 2;
        var px = centerX + halfW * basePoints[i * 4];
        var py = centerY + halfH * basePoints[i * 4 + 1];
        var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];
        var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
        var cp0x = px - offset * basePoints[sourceUv];
        var cp0y = py - offset * basePoints[sourceUv + 1];
        var cp1x = px + offset * basePoints[destUv];
        var cp1y = py + offset * basePoints[destUv + 1];
        cutPolygonPoints[i * 4] = cp0x;
        cutPolygonPoints[i * 4 + 1] = cp0y;
        cutPolygonPoints[i * 4 + 2] = cp1x;
        cutPolygonPoints[i * 4 + 3] = cp1y;
        var orthx = basePoints[sourceUv + 1];
        var orthy = -basePoints[sourceUv];
        var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];
  
        if (cosAlpha < 0) {
          orthx *= -1;
          orthy *= -1;
        }
  
        var cx = cp0x + orthx * cornerRadius;
        var cy = cp0y + orthy * cornerRadius;
        var squaredDistance = Math.pow(cx - x, 2) + Math.pow(cy - y, 2);
  
        if (squaredDistance <= squaredCornerRadius) {
          return true;
        }
      }
  
      return pointInsidePolygonPoints(x, y, cutPolygonPoints);
    };
    var joinLines = function joinLines(lineSet) {
      var vertices = new Array(lineSet.length / 2);
      var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
      var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;
  
      for (var i = 0; i < lineSet.length / 4; i++) {
        currentLineStartX = lineSet[i * 4];
        currentLineStartY = lineSet[i * 4 + 1];
        currentLineEndX = lineSet[i * 4 + 2];
        currentLineEndY = lineSet[i * 4 + 3];
  
        if (i < lineSet.length / 4 - 1) {
          nextLineStartX = lineSet[(i + 1) * 4];
          nextLineStartY = lineSet[(i + 1) * 4 + 1];
          nextLineEndX = lineSet[(i + 1) * 4 + 2];
          nextLineEndY = lineSet[(i + 1) * 4 + 3];
        } else {
          nextLineStartX = lineSet[0];
          nextLineStartY = lineSet[1];
          nextLineEndX = lineSet[2];
          nextLineEndY = lineSet[3];
        }
  
        var intersection = finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);
        vertices[i * 2] = intersection[0];
        vertices[i * 2 + 1] = intersection[1];
      }
  
      return vertices;
    };
    var expandPolygon = function expandPolygon(points, pad) {
      var expandedLineSet = new Array(points.length * 2);
      var currentPointX, currentPointY, nextPointX, nextPointY;
  
      for (var i = 0; i < points.length / 2; i++) {
        currentPointX = points[i * 2];
        currentPointY = points[i * 2 + 1];
  
        if (i < points.length / 2 - 1) {
          nextPointX = points[(i + 1) * 2];
          nextPointY = points[(i + 1) * 2 + 1];
        } else {
          nextPointX = points[0];
          nextPointY = points[1];
        } // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]
        // Assume CCW polygon winding
  
  
        var offsetX = nextPointY - currentPointY;
        var offsetY = -(nextPointX - currentPointX); // Normalize
  
        var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
        var normalizedOffsetX = offsetX / offsetLength;
        var normalizedOffsetY = offsetY / offsetLength;
        expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
        expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
        expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
        expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
      }
  
      return expandedLineSet;
    };
    var intersectLineEllipse = function intersectLineEllipse(x, y, centerX, centerY, ellipseWradius, ellipseHradius) {
      var dispX = centerX - x;
      var dispY = centerY - y;
      dispX /= ellipseWradius;
      dispY /= ellipseHradius;
      var len = Math.sqrt(dispX * dispX + dispY * dispY);
      var newLength = len - 1;
  
      if (newLength < 0) {
        return [];
      }
  
      var lenProportion = newLength / len;
      return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
    };
    var checkInEllipse = function checkInEllipse(x, y, width, height, centerX, centerY, padding) {
      x -= centerX;
      y -= centerY;
      x /= width / 2 + padding;
      y /= height / 2 + padding;
      return x * x + y * y <= 1;
    }; // Returns intersections of increasing distance from line's start point
  
    var intersectLineCircle = function intersectLineCircle(x1, y1, x2, y2, centerX, centerY, radius) {
      // Calculate d, direction vector of line
      var d = [x2 - x1, y2 - y1]; // Direction vector of line
  
      var f = [x1 - centerX, y1 - centerY];
      var a = d[0] * d[0] + d[1] * d[1];
      var b = 2 * (f[0] * d[0] + f[1] * d[1]);
      var c = f[0] * f[0] + f[1] * f[1] - radius * radius;
      var discriminant = b * b - 4 * a * c;
  
      if (discriminant < 0) {
        return [];
      }
  
      var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
      var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
      var tMin = Math.min(t1, t2);
      var tMax = Math.max(t1, t2);
      var inRangeParams = [];
  
      if (tMin >= 0 && tMin <= 1) {
        inRangeParams.push(tMin);
      }
  
      if (tMax >= 0 && tMax <= 1) {
        inRangeParams.push(tMax);
      }
  
      if (inRangeParams.length === 0) {
        return [];
      }
  
      var nearIntersectionX = inRangeParams[0] * d[0] + x1;
      var nearIntersectionY = inRangeParams[0] * d[1] + y1;
  
      if (inRangeParams.length > 1) {
        if (inRangeParams[0] == inRangeParams[1]) {
          return [nearIntersectionX, nearIntersectionY];
        } else {
          var farIntersectionX = inRangeParams[1] * d[0] + x1;
          var farIntersectionY = inRangeParams[1] * d[1] + y1;
          return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
        }
      } else {
        return [nearIntersectionX, nearIntersectionY];
      }
    };
    var midOfThree = function midOfThree(a, b, c) {
      if (b <= a && a <= c || c <= a && a <= b) {
        return a;
      } else if (a <= b && b <= c || c <= b && b <= a) {
        return b;
      } else {
        return c;
      }
    }; // (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)
  
    var finiteLinesIntersect = function finiteLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {
      var dx13 = x1 - x3;
      var dx21 = x2 - x1;
      var dx43 = x4 - x3;
      var dy13 = y1 - y3;
      var dy21 = y2 - y1;
      var dy43 = y4 - y3;
      var ua_t = dx43 * dy13 - dy43 * dx13;
      var ub_t = dx21 * dy13 - dy21 * dx13;
      var u_b = dy43 * dx21 - dx43 * dy21;
  
      if (u_b !== 0) {
        var ua = ua_t / u_b;
        var ub = ub_t / u_b;
        var flptThreshold = 0.001;
  
        var _min = 0 - flptThreshold;
  
        var _max = 1 + flptThreshold;
  
        if (_min <= ua && ua <= _max && _min <= ub && ub <= _max) {
          return [x1 + ua * dx21, y1 + ua * dy21];
        } else {
          if (!infiniteLines) {
            return [];
          } else {
            return [x1 + ua * dx21, y1 + ua * dy21];
          }
        }
      } else {
        if (ua_t === 0 || ub_t === 0) {
          // Parallel, coincident lines. Check if overlap
          // Check endpoint of second line
          if (midOfThree(x1, x2, x4) === x4) {
            return [x4, y4];
          } // Check start point of second line
  
  
          if (midOfThree(x1, x2, x3) === x3) {
            return [x3, y3];
          } // Endpoint of first line
  
  
          if (midOfThree(x3, x4, x2) === x2) {
            return [x2, y2];
          }
  
          return [];
        } else {
          // Parallel, non-coincident
          return [];
        }
      }
    }; // math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )
    // intersect a node polygon (pts transformed)
    //
    // math.polygonIntersectLine( x, y, basePoints, centerX, centerY )
    // intersect the points (no transform)
  
    var polygonIntersectLine = function polygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {
      var intersections = [];
      var intersection;
      var transformedPoints = new Array(basePoints.length);
      var doTransform = true;
  
      if (width == null) {
        doTransform = false;
      }
  
      var points;
  
      if (doTransform) {
        for (var i = 0; i < transformedPoints.length / 2; i++) {
          transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
          transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
        }
  
        if (padding > 0) {
          var expandedLineSet = expandPolygon(transformedPoints, -padding);
          points = joinLines(expandedLineSet);
        } else {
          points = transformedPoints;
        }
      } else {
        points = basePoints;
      }
  
      var currentX, currentY, nextX, nextY;
  
      for (var _i2 = 0; _i2 < points.length / 2; _i2++) {
        currentX = points[_i2 * 2];
        currentY = points[_i2 * 2 + 1];
  
        if (_i2 < points.length / 2 - 1) {
          nextX = points[(_i2 + 1) * 2];
          nextY = points[(_i2 + 1) * 2 + 1];
        } else {
          nextX = points[0];
          nextY = points[1];
        }
  
        intersection = finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);
  
        if (intersection.length !== 0) {
          intersections.push(intersection[0], intersection[1]);
        }
      }
  
      return intersections;
    };
    var roundPolygonIntersectLine = function roundPolygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {
      var intersections = [];
      var intersection;
      var lines = new Array(basePoints.length);
      var halfW = width / 2;
      var halfH = height / 2;
      var cornerRadius = getRoundPolygonRadius(width, height);
  
      for (var i = 0; i < basePoints.length / 4; i++) {
        var sourceUv = void 0,
            destUv = void 0;
  
        if (i === 0) {
          sourceUv = basePoints.length - 2;
        } else {
          sourceUv = i * 4 - 2;
        }
  
        destUv = i * 4 + 2;
        var px = centerX + halfW * basePoints[i * 4];
        var py = centerY + halfH * basePoints[i * 4 + 1];
        var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];
        var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
        var cp0x = px - offset * basePoints[sourceUv];
        var cp0y = py - offset * basePoints[sourceUv + 1];
        var cp1x = px + offset * basePoints[destUv];
        var cp1y = py + offset * basePoints[destUv + 1];
  
        if (i === 0) {
          lines[basePoints.length - 2] = cp0x;
          lines[basePoints.length - 1] = cp0y;
        } else {
          lines[i * 4 - 2] = cp0x;
          lines[i * 4 - 1] = cp0y;
        }
  
        lines[i * 4] = cp1x;
        lines[i * 4 + 1] = cp1y;
        var orthx = basePoints[sourceUv + 1];
        var orthy = -basePoints[sourceUv];
        var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];
  
        if (cosAlpha < 0) {
          orthx *= -1;
          orthy *= -1;
        }
  
        var cx = cp0x + orthx * cornerRadius;
        var cy = cp0y + orthy * cornerRadius;
        intersection = intersectLineCircle(x, y, centerX, centerY, cx, cy, cornerRadius);
  
        if (intersection.length !== 0) {
          intersections.push(intersection[0], intersection[1]);
        }
      }
  
      for (var _i3 = 0; _i3 < lines.length / 4; _i3++) {
        intersection = finiteLinesIntersect(x, y, centerX, centerY, lines[_i3 * 4], lines[_i3 * 4 + 1], lines[_i3 * 4 + 2], lines[_i3 * 4 + 3], false);
  
        if (intersection.length !== 0) {
          intersections.push(intersection[0], intersection[1]);
        }
      }
  
      if (intersections.length > 2) {
        var lowestIntersection = [intersections[0], intersections[1]];
        var lowestSquaredDistance = Math.pow(lowestIntersection[0] - x, 2) + Math.pow(lowestIntersection[1] - y, 2);
  
        for (var _i4 = 1; _i4 < intersections.length / 2; _i4++) {
          var squaredDistance = Math.pow(intersections[_i4 * 2] - x, 2) + Math.pow(intersections[_i4 * 2 + 1] - y, 2);
  
          if (squaredDistance <= lowestSquaredDistance) {
            lowestIntersection[0] = intersections[_i4 * 2];
            lowestIntersection[1] = intersections[_i4 * 2 + 1];
            lowestSquaredDistance = squaredDistance;
          }
        }
  
        return lowestIntersection;
      }
  
      return intersections;
    };
    var shortenIntersection = function shortenIntersection(intersection, offset, amount) {
      var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];
      var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);
      var lenRatio = (length - amount) / length;
  
      if (lenRatio < 0) {
        lenRatio = 0.00001;
      }
  
      return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
    };
    var generateUnitNgonPointsFitToSquare = function generateUnitNgonPointsFitToSquare(sides, rotationRadians) {
      var points = generateUnitNgonPoints(sides, rotationRadians);
      points = fitPolygonToSquare(points);
      return points;
    };
    var fitPolygonToSquare = function fitPolygonToSquare(points) {
      var x, y;
      var sides = points.length / 2;
      var minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity;
  
      for (var i = 0; i < sides; i++) {
        x = points[2 * i];
        y = points[2 * i + 1];
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      } // stretch factors
  
  
      var sx = 2 / (maxX - minX);
      var sy = 2 / (maxY - minY);
  
      for (var _i5 = 0; _i5 < sides; _i5++) {
        x = points[2 * _i5] = points[2 * _i5] * sx;
        y = points[2 * _i5 + 1] = points[2 * _i5 + 1] * sy;
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
  
      if (minY < -1) {
        for (var _i6 = 0; _i6 < sides; _i6++) {
          y = points[2 * _i6 + 1] = points[2 * _i6 + 1] + (-1 - minY);
        }
      }
  
      return points;
    };
    var generateUnitNgonPoints = function generateUnitNgonPoints(sides, rotationRadians) {
      var increment = 1.0 / sides * 2 * Math.PI;
      var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;
      startAngle += rotationRadians;
      var points = new Array(sides * 2);
      var currentAngle;
  
      for (var i = 0; i < sides; i++) {
        currentAngle = i * increment + startAngle;
        points[2 * i] = Math.cos(currentAngle); // x
  
        points[2 * i + 1] = Math.sin(-currentAngle); // y
      }
  
      return points;
    }; // Set the default radius, unless half of width or height is smaller than default
  
    var getRoundRectangleRadius = function getRoundRectangleRadius(width, height) {
      return Math.min(width / 4, height / 4, 8);
    }; // Set the default radius
  
    var getRoundPolygonRadius = function getRoundPolygonRadius(width, height) {
      return Math.min(width / 10, height / 10, 8);
    };
    var getCutRectangleCornerLength = function getCutRectangleCornerLength() {
      return 8;
    };
    var bezierPtsToQuadCoeff = function bezierPtsToQuadCoeff(p0, p1, p2) {
      return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];
    }; // get curve width, height, and control point position offsets as a percentage of node height / width
  
    var getBarrelCurveConstants = function getBarrelCurveConstants(width, height) {
      return {
        heightOffset: Math.min(15, 0.05 * height),
        widthOffset: Math.min(100, 0.25 * width),
        ctrlPtOffsetPct: 0.05
      };
    };
  
    var pageRankDefaults = defaults({
      dampingFactor: 0.8,
      precision: 0.000001,
      iterations: 200,
      weight: function weight(edge) {
        return 1;
      }
    });
    var elesfn$7 = {
      pageRank: function pageRank(options) {
        var _pageRankDefaults = pageRankDefaults(options),
            dampingFactor = _pageRankDefaults.dampingFactor,
            precision = _pageRankDefaults.precision,
            iterations = _pageRankDefaults.iterations,
            weight = _pageRankDefaults.weight;
  
        var cy = this._private.cy;
  
        var _this$byGroup = this.byGroup(),
            nodes = _this$byGroup.nodes,
            edges = _this$byGroup.edges;
  
        var numNodes = nodes.length;
        var numNodesSqd = numNodes * numNodes;
        var numEdges = edges.length; // Construct transposed adjacency matrix
        // First lets have a zeroed matrix of the right size
        // We'll also keep track of the sum of each column
  
        var matrix = new Array(numNodesSqd);
        var columnSum = new Array(numNodes);
        var additionalProb = (1 - dampingFactor) / numNodes; // Create null matrix
  
        for (var i = 0; i < numNodes; i++) {
          for (var j = 0; j < numNodes; j++) {
            var n = i * numNodes + j;
            matrix[n] = 0;
          }
  
          columnSum[i] = 0;
        } // Now, process edges
  
  
        for (var _i = 0; _i < numEdges; _i++) {
          var edge = edges[_i];
          var srcId = edge.data('source');
          var tgtId = edge.data('target'); // Don't include loops in the matrix
  
          if (srcId === tgtId) {
            continue;
          }
  
          var s = nodes.indexOfId(srcId);
          var t = nodes.indexOfId(tgtId);
          var w = weight(edge);
  
          var _n = t * numNodes + s; // Update matrix
  
  
          matrix[_n] += w; // Update column sum
  
          columnSum[s] += w;
        } // Add additional probability based on damping factor
        // Also, take into account columns that have sum = 0
  
  
        var p = 1.0 / numNodes + additionalProb; // Shorthand
        // Traverse matrix, column by column
  
        for (var _j = 0; _j < numNodes; _j++) {
          if (columnSum[_j] === 0) {
            // No 'links' out from node jth, assume equal probability for each possible node
            for (var _i2 = 0; _i2 < numNodes; _i2++) {
              var _n2 = _i2 * numNodes + _j;
  
              matrix[_n2] = p;
            }
          } else {
            // Node jth has outgoing link, compute normalized probabilities
            for (var _i3 = 0; _i3 < numNodes; _i3++) {
              var _n3 = _i3 * numNodes + _j;
  
              matrix[_n3] = matrix[_n3] / columnSum[_j] + additionalProb;
            }
          }
        } // Compute dominant eigenvector using power method
  
  
        var eigenvector = new Array(numNodes);
        var temp = new Array(numNodes);
        var previous; // Start with a vector of all 1's
        // Also, initialize a null vector which will be used as shorthand
  
        for (var _i4 = 0; _i4 < numNodes; _i4++) {
          eigenvector[_i4] = 1;
        }
  
        for (var iter = 0; iter < iterations; iter++) {
          // Temp array with all 0's
          for (var _i5 = 0; _i5 < numNodes; _i5++) {
            temp[_i5] = 0;
          } // Multiply matrix with previous result
  
  
          for (var _i6 = 0; _i6 < numNodes; _i6++) {
            for (var _j2 = 0; _j2 < numNodes; _j2++) {
              var _n4 = _i6 * numNodes + _j2;
  
              temp[_i6] += matrix[_n4] * eigenvector[_j2];
            }
          }
  
          inPlaceSumNormalize(temp);
          previous = eigenvector;
          eigenvector = temp;
          temp = previous;
          var diff = 0; // Compute difference (squared module) of both vectors
  
          for (var _i7 = 0; _i7 < numNodes; _i7++) {
            var delta = previous[_i7] - eigenvector[_i7];
            diff += delta * delta;
          } // If difference is less than the desired threshold, stop iterating
  
  
          if (diff < precision) {
            break;
          }
        } // Construct result
  
  
        var res = {
          rank: function rank(node) {
            node = cy.collection(node)[0];
            return eigenvector[nodes.indexOf(node)];
          }
        };
        return res;
      } // pageRank
  
    }; // elesfn
  
    var defaults$1 = defaults({
      root: null,
      weight: function weight(edge) {
        return 1;
      },
      directed: false,
      alpha: 0
    });
    var elesfn$8 = {
      degreeCentralityNormalized: function degreeCentralityNormalized(options) {
        options = defaults$1(options);
        var cy = this.cy();
        var nodes = this.nodes();
        var numNodes = nodes.length;
  
        if (!options.directed) {
          var degrees = {};
          var maxDegree = 0;
  
          for (var i = 0; i < numNodes; i++) {
            var node = nodes[i]; // add current node to the current options object and call degreeCentrality
  
            options.root = node;
            var currDegree = this.degreeCentrality(options);
  
            if (maxDegree < currDegree.degree) {
              maxDegree = currDegree.degree;
            }
  
            degrees[node.id()] = currDegree.degree;
          }
  
          return {
            degree: function degree(node) {
              if (maxDegree === 0) {
                return 0;
              }
  
              if (string(node)) {
                // from is a selector string
                node = cy.filter(node);
              }
  
              return degrees[node.id()] / maxDegree;
            }
          };
        } else {
          var indegrees = {};
          var outdegrees = {};
          var maxIndegree = 0;
          var maxOutdegree = 0;
  
          for (var _i = 0; _i < numNodes; _i++) {
            var _node = nodes[_i];
  
            var id = _node.id(); // add current node to the current options object and call degreeCentrality
  
  
            options.root = _node;
  
            var _currDegree = this.degreeCentrality(options);
  
            if (maxIndegree < _currDegree.indegree) maxIndegree = _currDegree.indegree;
            if (maxOutdegree < _currDegree.outdegree) maxOutdegree = _currDegree.outdegree;
            indegrees[id] = _currDegree.indegree;
            outdegrees[id] = _currDegree.outdegree;
          }
  
          return {
            indegree: function indegree(node) {
              if (maxIndegree == 0) {
                return 0;
              }
  
              if (string(node)) {
                // from is a selector string
                node = cy.filter(node);
              }
  
              return indegrees[node.id()] / maxIndegree;
            },
            outdegree: function outdegree(node) {
              if (maxOutdegree === 0) {
                return 0;
              }
  
              if (string(node)) {
                // from is a selector string
                node = cy.filter(node);
              }
  
              return outdegrees[node.id()] / maxOutdegree;
            }
          };
        }
      },
      // degreeCentralityNormalized
      // Implemented from the algorithm in Opsahl's paper
      // "Node centrality in weighted networks: Generalizing degree and shortest paths"
      // check the heading 2 "Degree"
      degreeCentrality: function degreeCentrality(options) {
        options = defaults$1(options);
        var cy = this.cy();
        var callingEles = this;
        var _options = options,
            root = _options.root,
            weight = _options.weight,
            directed = _options.directed,
            alpha = _options.alpha;
        root = cy.collection(root)[0];
  
        if (!directed) {
          var connEdges = root.connectedEdges().intersection(callingEles);
          var k = connEdges.length;
          var s = 0; // Now, sum edge weights
  
          for (var i = 0; i < connEdges.length; i++) {
            s += weight(connEdges[i]);
          }
  
          return {
            degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
          };
        } else {
          var edges = root.connectedEdges();
          var incoming = edges.filter(function (edge) {
            return edge.target().same(root) && callingEles.has(edge);
          });
          var outgoing = edges.filter(function (edge) {
            return edge.source().same(root) && callingEles.has(edge);
          });
          var k_in = incoming.length;
          var k_out = outgoing.length;
          var s_in = 0;
          var s_out = 0; // Now, sum incoming edge weights
  
          for (var _i2 = 0; _i2 < incoming.length; _i2++) {
            s_in += weight(incoming[_i2]);
          } // Now, sum outgoing edge weights
  
  
          for (var _i3 = 0; _i3 < outgoing.length; _i3++) {
            s_out += weight(outgoing[_i3]);
          }
  
          return {
            indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
            outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
          };
        }
      } // degreeCentrality
  
    }; // elesfn
    // nice, short mathemathical alias
  
    elesfn$8.dc = elesfn$8.degreeCentrality;
    elesfn$8.dcn = elesfn$8.degreeCentralityNormalised = elesfn$8.degreeCentralityNormalized;
  
    var defaults$2 = defaults({
      harmonic: true,
      weight: function weight() {
        return 1;
      },
      directed: false,
      root: null
    });
    var elesfn$9 = {
      closenessCentralityNormalized: function closenessCentralityNormalized(options) {
        var _defaults = defaults$2(options),
            harmonic = _defaults.harmonic,
            weight = _defaults.weight,
            directed = _defaults.directed;
  
        var cy = this.cy();
        var closenesses = {};
        var maxCloseness = 0;
        var nodes = this.nodes();
        var fw = this.floydWarshall({
          weight: weight,
          directed: directed
        }); // Compute closeness for every node and find the maximum closeness
  
        for (var i = 0; i < nodes.length; i++) {
          var currCloseness = 0;
          var node_i = nodes[i];
  
          for (var j = 0; j < nodes.length; j++) {
            if (i !== j) {
              var d = fw.distance(node_i, nodes[j]);
  
              if (harmonic) {
                currCloseness += 1 / d;
              } else {
                currCloseness += d;
              }
            }
          }
  
          if (!harmonic) {
            currCloseness = 1 / currCloseness;
          }
  
          if (maxCloseness < currCloseness) {
            maxCloseness = currCloseness;
          }
  
          closenesses[node_i.id()] = currCloseness;
        }
  
        return {
          closeness: function closeness(node) {
            if (maxCloseness == 0) {
              return 0;
            }
  
            if (string(node)) {
              // from is a selector string
              node = cy.filter(node)[0].id();
            } else {
              // from is a node
              node = node.id();
            }
  
            return closenesses[node] / maxCloseness;
          }
        };
      },
      // Implemented from pseudocode from wikipedia
      closenessCentrality: function closenessCentrality(options) {
        var _defaults2 = defaults$2(options),
            root = _defaults2.root,
            weight = _defaults2.weight,
            directed = _defaults2.directed,
            harmonic = _defaults2.harmonic;
  
        root = this.filter(root)[0]; // we need distance from this node to every other node
  
        var dijkstra = this.dijkstra({
          root: root,
          weight: weight,
          directed: directed
        });
        var totalDistance = 0;
        var nodes = this.nodes();
  
        for (var i = 0; i < nodes.length; i++) {
          var n = nodes[i];
  
          if (!n.same(root)) {
            var d = dijkstra.distanceTo(n);
  
            if (harmonic) {
              totalDistance += 1 / d;
            } else {
              totalDistance += d;
            }
          }
        }
  
        return harmonic ? totalDistance : 1 / totalDistance;
      } // closenessCentrality
  
    }; // elesfn
    // nice, short mathemathical alias
  
    elesfn$9.cc = elesfn$9.closenessCentrality;
    elesfn$9.ccn = elesfn$9.closenessCentralityNormalised = elesfn$9.closenessCentralityNormalized;
  
    var defaults$3 = defaults({
      weight: null,
      directed: false
    });
    var elesfn$a = {
      // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
      betweennessCentrality: function betweennessCentrality(options) {
        var _defaults = defaults$3(options),
            directed = _defaults.directed,
            weight = _defaults.weight;
  
        var weighted = weight != null;
        var cy = this.cy(); // starting
  
        var V = this.nodes();
        var A = {};
        var _C = {};
        var max = 0;
        var C = {
          set: function set(key, val) {
            _C[key] = val;
  
            if (val > max) {
              max = val;
            }
          },
          get: function get(key) {
            return _C[key];
          }
        }; // A contains the neighborhoods of every node
  
        for (var i = 0; i < V.length; i++) {
          var v = V[i];
          var vid = v.id();
  
          if (directed) {
            A[vid] = v.outgoers().nodes(); // get outgoers of every node
          } else {
            A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node
          }
  
          C.set(vid, 0);
        }
  
        var _loop = function _loop(s) {
          var sid = V[s].id();
          var S = []; // stack
  
          var P = {};
          var g = {};
          var d = {};
          var Q = new heap$1(function (a, b) {
            return d[a] - d[b];
          }); // queue
          // init dictionaries
  
          for (var _i = 0; _i < V.length; _i++) {
            var _vid = V[_i].id();
  
            P[_vid] = [];
            g[_vid] = 0;
            d[_vid] = Infinity;
          }
  
          g[sid] = 1; // sigma
  
          d[sid] = 0; // distance to s
  
          Q.push(sid);
  
          while (!Q.empty()) {
            var _v = Q.pop();
  
            S.push(_v);
  
            if (weighted) {
              for (var j = 0; j < A[_v].length; j++) {
                var w = A[_v][j];
                var vEle = cy.getElementById(_v);
                var edge = void 0;
  
                if (vEle.edgesTo(w).length > 0) {
                  edge = vEle.edgesTo(w)[0];
                } else {
                  edge = w.edgesTo(vEle)[0];
                }
  
                var edgeWeight = weight(edge);
                w = w.id();
  
                if (d[w] > d[_v] + edgeWeight) {
                  d[w] = d[_v] + edgeWeight;
  
                  if (Q.nodes.indexOf(w) < 0) {
                    //if w is not in Q
                    Q.push(w);
                  } else {
                    // update position if w is in Q
                    Q.updateItem(w);
                  }
  
                  g[w] = 0;
                  P[w] = [];
                }
  
                if (d[w] == d[_v] + edgeWeight) {
                  g[w] = g[w] + g[_v];
                  P[w].push(_v);
                }
              }
            } else {
              for (var _j = 0; _j < A[_v].length; _j++) {
                var _w = A[_v][_j].id();
  
                if (d[_w] == Infinity) {
                  Q.push(_w);
                  d[_w] = d[_v] + 1;
                }
  
                if (d[_w] == d[_v] + 1) {
                  g[_w] = g[_w] + g[_v];
  
                  P[_w].push(_v);
                }
              }
            }
          }
  
          var e = {};
  
          for (var _i2 = 0; _i2 < V.length; _i2++) {
            e[V[_i2].id()] = 0;
          }
  
          while (S.length > 0) {
            var _w2 = S.pop();
  
            for (var _j2 = 0; _j2 < P[_w2].length; _j2++) {
              var _v2 = P[_w2][_j2];
              e[_v2] = e[_v2] + g[_v2] / g[_w2] * (1 + e[_w2]);
  
              if (_w2 != V[s].id()) {
                C.set(_w2, C.get(_w2) + e[_w2]);
              }
            }
          }
        };
  
        for (var s = 0; s < V.length; s++) {
          _loop(s);
        }
  
        var ret = {
          betweenness: function betweenness(node) {
            var id = cy.collection(node).id();
            return C.get(id);
          },
          betweennessNormalized: function betweennessNormalized(node) {
            if (max == 0) {
              return 0;
            }
  
            var id = cy.collection(node).id();
            return C.get(id) / max;
          }
        }; // alias
  
        ret.betweennessNormalised = ret.betweennessNormalized;
        return ret;
      } // betweennessCentrality
  
    }; // elesfn
    // nice, short mathemathical alias
  
    elesfn$a.bc = elesfn$a.betweennessCentrality;
  
    // Implemented by Zoe Xi @zoexi for GSOC 2016
    /* eslint-disable no-unused-vars */
  
    var defaults$4 = defaults({
      expandFactor: 2,
      // affects time of computation and cluster granularity to some extent: M * M
      inflateFactor: 2,
      // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)
      multFactor: 1,
      // optional self loops for each node. Use a neutral value to improve cluster computations.
      maxIterations: 20,
      // maximum number of iterations of the MCL algorithm in a single run
      attributes: [// attributes/features used to group nodes, ie. similarity values between nodes
      function (edge) {
        return 1;
      }]
    });
    /* eslint-enable */
  
    var setOptions = function setOptions(options) {
      return defaults$4(options);
    };
    /* eslint-enable */
  
  
    var getSimilarity = function getSimilarity(edge, attributes) {
      var total = 0;
  
      for (var i = 0; i < attributes.length; i++) {
        total += attributes[i](edge);
      }
  
      return total;
    };
  
    var addLoops = function addLoops(M, n, val) {
      for (var i = 0; i < n; i++) {
        M[i * n + i] = val;
      }
    };
  
    var normalize = function normalize(M, n) {
      var sum;
  
      for (var col = 0; col < n; col++) {
        sum = 0;
  
        for (var row = 0; row < n; row++) {
          sum += M[row * n + col];
        }
  
        for (var _row = 0; _row < n; _row++) {
          M[_row * n + col] = M[_row * n + col] / sum;
        }
      }
    }; // TODO: blocked matrix multiplication?
  
  
    var mmult = function mmult(A, B, n) {
      var C = new Array(n * n);
  
      for (var i = 0; i < n; i++) {
        for (var j = 0; j < n; j++) {
          C[i * n + j] = 0;
        }
  
        for (var k = 0; k < n; k++) {
          for (var _j = 0; _j < n; _j++) {
            C[i * n + _j] += A[i * n + k] * B[k * n + _j];
          }
        }
      }
  
      return C;
    };
  
    var expand = function expand(M, n, expandFactor
    /** power **/
    ) {
      var _M = M.slice(0);
  
      for (var p = 1; p < expandFactor; p++) {
        M = mmult(M, _M, n);
      }
  
      return M;
    };
  
    var inflate = function inflate(M, n, inflateFactor
    /** r **/
    ) {
      var _M = new Array(n * n); // M(i,j) ^ inflatePower
  
  
      for (var i = 0; i < n * n; i++) {
        _M[i] = Math.pow(M[i], inflateFactor);
      }
  
      normalize(_M, n);
      return _M;
    };
  
    var hasConverged = function hasConverged(M, _M, n2, roundFactor) {
      // Check that both matrices have the same elements (i,j)
      for (var i = 0; i < n2; i++) {
        var v1 = Math.round(M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor); // truncate to 'roundFactor' decimal places
  
        var v2 = Math.round(_M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);
  
        if (v1 !== v2) {
          return false;
        }
      }
  
      return true;
    };
  
    var assign = function assign(M, n, nodes, cy) {
      var clusters = [];
  
      for (var i = 0; i < n; i++) {
        var cluster = [];
  
        for (var j = 0; j < n; j++) {
          // Row-wise attractors and elements that they attract belong in same cluster
          if (Math.round(M[i * n + j] * 1000) / 1000 > 0) {
            cluster.push(nodes[j]);
          }
        }
  
        if (cluster.length !== 0) {
          clusters.push(cy.collection(cluster));
        }
      }
  
      return clusters;
    };
  
    var isDuplicate = function isDuplicate(c1, c2) {
      for (var i = 0; i < c1.length; i++) {
        if (!c2[i] || c1[i].id() !== c2[i].id()) {
          return false;
        }
      }
  
      return true;
    };
  
    var removeDuplicates = function removeDuplicates(clusters) {
      for (var i = 0; i < clusters.length; i++) {
        for (var j = 0; j < clusters.length; j++) {
          if (i != j && isDuplicate(clusters[i], clusters[j])) {
            clusters.splice(j, 1);
          }
        }
      }
  
      return clusters;
    };
  
    var markovClustering = function markovClustering(options) {
      var nodes = this.nodes();
      var edges = this.edges();
      var cy = this.cy(); // Set parameters of algorithm:
  
      var opts = setOptions(options); // Map each node to its position in node array
  
      var id2position = {};
  
      for (var i = 0; i < nodes.length; i++) {
        id2position[nodes[i].id()] = i;
      } // Generate stochastic matrix M from input graph G (should be symmetric/undirected)
  
  
      var n = nodes.length,
          n2 = n * n;
  
      var M = new Array(n2),
          _M;
  
      for (var _i = 0; _i < n2; _i++) {
        M[_i] = 0;
      }
  
      for (var e = 0; e < edges.length; e++) {
        var edge = edges[e];
        var _i2 = id2position[edge.source().id()];
        var j = id2position[edge.target().id()];
        var sim = getSimilarity(edge, opts.attributes);
        M[_i2 * n + j] += sim; // G should be symmetric and undirected
  
        M[j * n + _i2] += sim;
      } // Begin Markov cluster algorithm
      // Step 1: Add self loops to each node, ie. add multFactor to matrix diagonal
  
  
      addLoops(M, n, opts.multFactor); // Step 2: M = normalize( M );
  
      normalize(M, n);
      var isStillMoving = true;
      var iterations = 0;
  
      while (isStillMoving && iterations < opts.maxIterations) {
        isStillMoving = false; // Step 3:
  
        _M = expand(M, n, opts.expandFactor); // Step 4:
  
        M = inflate(_M, n, opts.inflateFactor); // Step 5: check to see if ~steady state has been reached
  
        if (!hasConverged(M, _M, n2, 4)) {
          isStillMoving = true;
        }
  
        iterations++;
      } // Build clusters from matrix
  
  
      var clusters = assign(M, n, nodes, cy); // Remove duplicate clusters due to symmetry of graph and M matrix
  
      clusters = removeDuplicates(clusters);
      return clusters;
    };
  
    var markovClustering$1 = {
      markovClustering: markovClustering,
      mcl: markovClustering
    };
  
    // Common distance metrics for clustering algorithms
  
    var identity = function identity(x) {
      return x;
    };
  
    var absDiff = function absDiff(p, q) {
      return Math.abs(q - p);
    };
  
    var addAbsDiff = function addAbsDiff(total, p, q) {
      return total + absDiff(p, q);
    };
  
    var addSquaredDiff = function addSquaredDiff(total, p, q) {
      return total + Math.pow(q - p, 2);
    };
  
    var sqrt = function sqrt(x) {
      return Math.sqrt(x);
    };
  
    var maxAbsDiff = function maxAbsDiff(currentMax, p, q) {
      return Math.max(currentMax, absDiff(p, q));
    };
  
    var getDistance = function getDistance(length, getP, getQ, init, visit) {
      var post = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : identity;
      var ret = init;
      var p, q;
  
      for (var dim = 0; dim < length; dim++) {
        p = getP(dim);
        q = getQ(dim);
        ret = visit(ret, p, q);
      }
  
      return post(ret);
    };
  
    var distances = {
      euclidean: function euclidean(length, getP, getQ) {
        if (length >= 2) {
          return getDistance(length, getP, getQ, 0, addSquaredDiff, sqrt);
        } else {
          // for single attr case, more efficient to avoid sqrt
          return getDistance(length, getP, getQ, 0, addAbsDiff);
        }
      },
      squaredEuclidean: function squaredEuclidean(length, getP, getQ) {
        return getDistance(length, getP, getQ, 0, addSquaredDiff);
      },
      manhattan: function manhattan(length, getP, getQ) {
        return getDistance(length, getP, getQ, 0, addAbsDiff);
      },
      max: function max(length, getP, getQ) {
        return getDistance(length, getP, getQ, -Infinity, maxAbsDiff);
      }
    }; // in case the user accidentally doesn't use camel case
  
    distances['squared-euclidean'] = distances['squaredEuclidean'];
    distances['squaredeuclidean'] = distances['squaredEuclidean'];
    function clusteringDistance (method, length, getP, getQ, nodeP, nodeQ) {
      var impl;
  
      if (fn(method)) {
        impl = method;
      } else {
        impl = distances[method] || distances.euclidean;
      }
  
      if (length === 0 && fn(method)) {
        return impl(nodeP, nodeQ);
      } else {
        return impl(length, getP, getQ, nodeP, nodeQ);
      }
    }
  
    var defaults$5 = defaults({
      k: 2,
      m: 2,
      sensitivityThreshold: 0.0001,
      distance: 'euclidean',
      maxIterations: 10,
      attributes: [],
      testMode: false,
      testCentroids: null
    });
  
    var setOptions$1 = function setOptions(options) {
      return defaults$5(options);
    };
    /* eslint-enable */
  
  
    var getDist = function getDist(type, node, centroid, attributes, mode) {
      var noNodeP = mode !== 'kMedoids';
      var getP = noNodeP ? function (i) {
        return centroid[i];
      } : function (i) {
        return attributes[i](centroid);
      };
  
      var getQ = function getQ(i) {
        return attributes[i](node);
      };
  
      var nodeP = centroid;
      var nodeQ = node;
      return clusteringDistance(type, attributes.length, getP, getQ, nodeP, nodeQ);
    };
  
    var randomCentroids = function randomCentroids(nodes, k, attributes) {
      var ndim = attributes.length;
      var min = new Array(ndim);
      var max = new Array(ndim);
      var centroids = new Array(k);
      var centroid = null; // Find min, max values for each attribute dimension
  
      for (var i = 0; i < ndim; i++) {
        min[i] = nodes.min(attributes[i]).value;
        max[i] = nodes.max(attributes[i]).value;
      } // Build k centroids, each represented as an n-dim feature vector
  
  
      for (var c = 0; c < k; c++) {
        centroid = [];
  
        for (var _i = 0; _i < ndim; _i++) {
          centroid[_i] = Math.random() * (max[_i] - min[_i]) + min[_i]; // random initial value
        }
  
        centroids[c] = centroid;
      }
  
      return centroids;
    };
  
    var classify = function classify(node, centroids, distance, attributes, type) {
      var min = Infinity;
      var index = 0;
  
      for (var i = 0; i < centroids.length; i++) {
        var dist = getDist(distance, node, centroids[i], attributes, type);
  
        if (dist < min) {
          min = dist;
          index = i;
        }
      }
  
      return index;
    };
  
    var buildCluster = function buildCluster(centroid, nodes, assignment) {
      var cluster = [];
      var node = null;
  
      for (var n = 0; n < nodes.length; n++) {
        node = nodes[n];
  
        if (assignment[node.id()] === centroid) {
          //console.log("Node " + node.id() + " is associated with medoid #: " + m);
          cluster.push(node);
        }
      }
  
      return cluster;
    };
  
    var haveValuesConverged = function haveValuesConverged(v1, v2, sensitivityThreshold) {
      return Math.abs(v2 - v1) <= sensitivityThreshold;
    };
  
    var haveMatricesConverged = function haveMatricesConverged(v1, v2, sensitivityThreshold) {
      for (var i = 0; i < v1.length; i++) {
        for (var j = 0; j < v1[i].length; j++) {
          var diff = Math.abs(v1[i][j] - v2[i][j]);
  
          if (diff > sensitivityThreshold) {
            return false;
          }
        }
      }
  
      return true;
    };
  
    var seenBefore = function seenBefore(node, medoids, n) {
      for (var i = 0; i < n; i++) {
        if (node === medoids[i]) return true;
      }
  
      return false;
    };
  
    var randomMedoids = function randomMedoids(nodes, k) {
      var medoids = new Array(k); // For small data sets, the probability of medoid conflict is greater,
      // so we need to check to see if we've already seen or chose this node before.
  
      if (nodes.length < 50) {
        // Randomly select k medoids from the n nodes
        for (var i = 0; i < k; i++) {
          var node = nodes[Math.floor(Math.random() * nodes.length)]; // If we've already chosen this node to be a medoid, don't choose it again (for small data sets).
          // Instead choose a different random node.
  
          while (seenBefore(node, medoids, i)) {
            node = nodes[Math.floor(Math.random() * nodes.length)];
          }
  
          medoids[i] = node;
        }
      } else {
        // Relatively large data set, so pretty safe to not check and just select random nodes
        for (var _i2 = 0; _i2 < k; _i2++) {
          medoids[_i2] = nodes[Math.floor(Math.random() * nodes.length)];
        }
      }
  
      return medoids;
    };
  
    var findCost = function findCost(potentialNewMedoid, cluster, attributes) {
      var cost = 0;
  
      for (var n = 0; n < cluster.length; n++) {
        cost += getDist('manhattan', cluster[n], potentialNewMedoid, attributes, 'kMedoids');
      }
  
      return cost;
    };
  
    var kMeans = function kMeans(options) {
      var cy = this.cy();
      var nodes = this.nodes();
      var node = null; // Set parameters of algorithm: # of clusters, distance metric, etc.
  
      var opts = setOptions$1(options); // Begin k-means algorithm
  
      var clusters = new Array(opts.k);
      var assignment = {};
      var centroids; // Step 1: Initialize centroid positions
  
      if (opts.testMode) {
        if (typeof opts.testCentroids === 'number') {
          centroids = randomCentroids(nodes, opts.k, opts.attributes);
        } else if (_typeof(opts.testCentroids) === 'object') {
          centroids = opts.testCentroids;
        } else {
          centroids = randomCentroids(nodes, opts.k, opts.attributes);
        }
      } else {
        centroids = randomCentroids(nodes, opts.k, opts.attributes);
      }
  
      var isStillMoving = true;
      var iterations = 0;
  
      while (isStillMoving && iterations < opts.maxIterations) {
        // Step 2: Assign nodes to the nearest centroid
        for (var n = 0; n < nodes.length; n++) {
          node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #
  
          assignment[node.id()] = classify(node, centroids, opts.distance, opts.attributes, 'kMeans');
        } // Step 3: For each of the k clusters, update its centroid
  
  
        isStillMoving = false;
  
        for (var c = 0; c < opts.k; c++) {
          // Get all nodes that belong to this cluster
          var cluster = buildCluster(c, nodes, assignment);
  
          if (cluster.length === 0) {
            // If cluster is empty, break out early & move to next cluster
            continue;
          } // Update centroids by calculating avg of all nodes within the cluster.
  
  
          var ndim = opts.attributes.length;
          var centroid = centroids[c]; // [ dim_1, dim_2, dim_3, ... , dim_n ]
  
          var newCentroid = new Array(ndim);
          var sum = new Array(ndim);
  
          for (var d = 0; d < ndim; d++) {
            sum[d] = 0.0;
  
            for (var i = 0; i < cluster.length; i++) {
              node = cluster[i];
              sum[d] += opts.attributes[d](node);
            }
  
            newCentroid[d] = sum[d] / cluster.length; // Check to see if algorithm has converged, i.e. when centroids no longer change
  
            if (!haveValuesConverged(newCentroid[d], centroid[d], opts.sensitivityThreshold)) {
              isStillMoving = true;
            }
          }
  
          centroids[c] = newCentroid;
          clusters[c] = cy.collection(cluster);
        }
  
        iterations++;
      }
  
      return clusters;
    };
  
    var kMedoids = function kMedoids(options) {
      var cy = this.cy();
      var nodes = this.nodes();
      var node = null;
      var opts = setOptions$1(options); // Begin k-medoids algorithm
  
      var clusters = new Array(opts.k);
      var medoids;
      var assignment = {};
      var curCost;
      var minCosts = new Array(opts.k); // minimum cost configuration for each cluster
      // Step 1: Initialize k medoids
  
      if (opts.testMode) {
        if (typeof opts.testCentroids === 'number') ; else if (_typeof(opts.testCentroids) === 'object') {
          medoids = opts.testCentroids;
        } else {
          medoids = randomMedoids(nodes, opts.k);
        }
      } else {
        medoids = randomMedoids(nodes, opts.k);
      }
  
      var isStillMoving = true;
      var iterations = 0;
  
      while (isStillMoving && iterations < opts.maxIterations) {
        // Step 2: Assign nodes to the nearest medoid
        for (var n = 0; n < nodes.length; n++) {
          node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #
  
          assignment[node.id()] = classify(node, medoids, opts.distance, opts.attributes, 'kMedoids');
        }
  
        isStillMoving = false; // Step 3: For each medoid m, and for each node assciated with mediod m,
        // select the node with the lowest configuration cost as new medoid.
  
        for (var m = 0; m < medoids.length; m++) {
          // Get all nodes that belong to this medoid
          var cluster = buildCluster(m, nodes, assignment);
  
          if (cluster.length === 0) {
            // If cluster is empty, break out early & move to next cluster
            continue;
          }
  
          minCosts[m] = findCost(medoids[m], cluster, opts.attributes); // original cost
          // Select different medoid if its configuration has the lowest cost
  
          for (var _n = 0; _n < cluster.length; _n++) {
            curCost = findCost(cluster[_n], cluster, opts.attributes);
  
            if (curCost < minCosts[m]) {
              minCosts[m] = curCost;
              medoids[m] = cluster[_n];
              isStillMoving = true;
            }
          }
  
          clusters[m] = cy.collection(cluster);
        }
  
        iterations++;
      }
  
      return clusters;
    };
  
    var updateCentroids = function updateCentroids(centroids, nodes, U, weight, opts) {
      var numerator, denominator;
  
      for (var n = 0; n < nodes.length; n++) {
        for (var c = 0; c < centroids.length; c++) {
          weight[n][c] = Math.pow(U[n][c], opts.m);
        }
      }
  
      for (var _c = 0; _c < centroids.length; _c++) {
        for (var dim = 0; dim < opts.attributes.length; dim++) {
          numerator = 0;
          denominator = 0;
  
          for (var _n2 = 0; _n2 < nodes.length; _n2++) {
            numerator += weight[_n2][_c] * opts.attributes[dim](nodes[_n2]);
            denominator += weight[_n2][_c];
          }
  
          centroids[_c][dim] = numerator / denominator;
        }
      }
    };
  
    var updateMembership = function updateMembership(U, _U, centroids, nodes, opts) {
      // Save previous step
      for (var i = 0; i < U.length; i++) {
        _U[i] = U[i].slice();
      }
  
      var sum, numerator, denominator;
      var pow = 2 / (opts.m - 1);
  
      for (var c = 0; c < centroids.length; c++) {
        for (var n = 0; n < nodes.length; n++) {
          sum = 0;
  
          for (var k = 0; k < centroids.length; k++) {
            // against all other centroids
            numerator = getDist(opts.distance, nodes[n], centroids[c], opts.attributes, 'cmeans');
            denominator = getDist(opts.distance, nodes[n], centroids[k], opts.attributes, 'cmeans');
            sum += Math.pow(numerator / denominator, pow);
          }
  
          U[n][c] = 1 / sum;
        }
      }
    };
  
    var assign$1 = function assign(nodes, U, opts, cy) {
      var clusters = new Array(opts.k);
  
      for (var c = 0; c < clusters.length; c++) {
        clusters[c] = [];
      }
  
      var max;
      var index;
  
      for (var n = 0; n < U.length; n++) {
        // for each node (U is N x C matrix)
        max = -Infinity;
        index = -1; // Determine which cluster the node is most likely to belong in
  
        for (var _c2 = 0; _c2 < U[0].length; _c2++) {
          if (U[n][_c2] > max) {
            max = U[n][_c2];
            index = _c2;
          }
        }
  
        clusters[index].push(nodes[n]);
      } // Turn every array into a collection of nodes
  
  
      for (var _c3 = 0; _c3 < clusters.length; _c3++) {
        clusters[_c3] = cy.collection(clusters[_c3]);
      }
  
      return clusters;
    };
  
    var fuzzyCMeans = function fuzzyCMeans(options) {
      var cy = this.cy();
      var nodes = this.nodes();
      var opts = setOptions$1(options); // Begin fuzzy c-means algorithm
  
      var clusters;
      var centroids;
      var U;
  
      var _U;
  
      var weight; // Step 1: Initialize letiables.
  
      _U = new Array(nodes.length);
  
      for (var i = 0; i < nodes.length; i++) {
        // N x C matrix
        _U[i] = new Array(opts.k);
      }
  
      U = new Array(nodes.length);
  
      for (var _i3 = 0; _i3 < nodes.length; _i3++) {
        // N x C matrix
        U[_i3] = new Array(opts.k);
      }
  
      for (var _i4 = 0; _i4 < nodes.length; _i4++) {
        var total = 0;
  
        for (var j = 0; j < opts.k; j++) {
          U[_i4][j] = Math.random();
          total += U[_i4][j];
        }
  
        for (var _j = 0; _j < opts.k; _j++) {
          U[_i4][_j] = U[_i4][_j] / total;
        }
      }
  
      centroids = new Array(opts.k);
  
      for (var _i5 = 0; _i5 < opts.k; _i5++) {
        centroids[_i5] = new Array(opts.attributes.length);
      }
  
      weight = new Array(nodes.length);
  
      for (var _i6 = 0; _i6 < nodes.length; _i6++) {
        // N x C matrix
        weight[_i6] = new Array(opts.k);
      } // end init FCM
  
  
      var isStillMoving = true;
      var iterations = 0;
  
      while (isStillMoving && iterations < opts.maxIterations) {
        isStillMoving = false; // Step 2: Calculate the centroids for each step.
  
        updateCentroids(centroids, nodes, U, weight, opts); // Step 3: Update the partition matrix U.
  
        updateMembership(U, _U, centroids, nodes, opts); // Step 4: Check for convergence.
  
        if (!haveMatricesConverged(U, _U, opts.sensitivityThreshold)) {
          isStillMoving = true;
        }
  
        iterations++;
      } // Assign nodes to clusters with highest probability.
  
  
      clusters = assign$1(nodes, U, opts, cy);
      return {
        clusters: clusters,
        degreeOfMembership: U
      };
    };
  
    var kClustering = {
      kMeans: kMeans,
      kMedoids: kMedoids,
      fuzzyCMeans: fuzzyCMeans,
      fcm: fuzzyCMeans
    };
  
    // Implemented by Zoe Xi @zoexi for GSOC 2016
    var defaults$6 = defaults({
      distance: 'euclidean',
      // distance metric to compare nodes
      linkage: 'min',
      // linkage criterion : how to determine the distance between clusters of nodes
      mode: 'threshold',
      // mode:'threshold' => clusters must be threshold distance apart
      threshold: Infinity,
      // the distance threshold
      // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters
      addDendrogram: false,
      // whether to add the dendrogram to the graph for viz
      dendrogramDepth: 0,
      // depth at which dendrogram branches are merged into the returned clusters
      attributes: [] // array of attr functions
  
    });
    var linkageAliases = {
      'single': 'min',
      'complete': 'max'
    };
  
    var setOptions$2 = function setOptions(options) {
      var opts = defaults$6(options);
      var preferredAlias = linkageAliases[opts.linkage];
  
      if (preferredAlias != null) {
        opts.linkage = preferredAlias;
      }
  
      return opts;
    };
  
    var mergeClosest = function mergeClosest(clusters, index, dists, mins, opts) {
      // Find two closest clusters from cached mins
      var minKey = 0;
      var min = Infinity;
      var dist;
      var attrs = opts.attributes;
  
      var getDist = function getDist(n1, n2) {
        return clusteringDistance(opts.distance, attrs.length, function (i) {
          return attrs[i](n1);
        }, function (i) {
          return attrs[i](n2);
        }, n1, n2);
      };
  
      for (var i = 0; i < clusters.length; i++) {
        var key = clusters[i].key;
        var _dist = dists[key][mins[key]];
  
        if (_dist < min) {
          minKey = key;
          min = _dist;
        }
      }
  
      if (opts.mode === 'threshold' && min >= opts.threshold || opts.mode === 'dendrogram' && clusters.length === 1) {
        return false;
      }
  
      var c1 = index[minKey];
      var c2 = index[mins[minKey]];
      var merged; // Merge two closest clusters
  
      if (opts.mode === 'dendrogram') {
        merged = {
          left: c1,
          right: c2,
          key: c1.key
        };
      } else {
        merged = {
          value: c1.value.concat(c2.value),
          key: c1.key
        };
      }
  
      clusters[c1.index] = merged;
      clusters.splice(c2.index, 1);
      index[c1.key] = merged; // Update distances with new merged cluster
  
      for (var _i = 0; _i < clusters.length; _i++) {
        var cur = clusters[_i];
  
        if (c1.key === cur.key) {
          dist = Infinity;
        } else if (opts.linkage === 'min') {
          dist = dists[c1.key][cur.key];
  
          if (dists[c1.key][cur.key] > dists[c2.key][cur.key]) {
            dist = dists[c2.key][cur.key];
          }
        } else if (opts.linkage === 'max') {
          dist = dists[c1.key][cur.key];
  
          if (dists[c1.key][cur.key] < dists[c2.key][cur.key]) {
            dist = dists[c2.key][cur.key];
          }
        } else if (opts.linkage === 'mean') {
          dist = (dists[c1.key][cur.key] * c1.size + dists[c2.key][cur.key] * c2.size) / (c1.size + c2.size);
        } else {
          if (opts.mode === 'dendrogram') dist = getDist(cur.value, c1.value);else dist = getDist(cur.value[0], c1.value[0]);
        }
  
        dists[c1.key][cur.key] = dists[cur.key][c1.key] = dist; // distance matrix is symmetric
      } // Update cached mins
  
  
      for (var _i2 = 0; _i2 < clusters.length; _i2++) {
        var key1 = clusters[_i2].key;
  
        if (mins[key1] === c1.key || mins[key1] === c2.key) {
          var _min = key1;
  
          for (var j = 0; j < clusters.length; j++) {
            var key2 = clusters[j].key;
  
            if (dists[key1][key2] < dists[key1][_min]) {
              _min = key2;
            }
          }
  
          mins[key1] = _min;
        }
  
        clusters[_i2].index = _i2;
      } // Clean up meta data used for clustering
  
  
      c1.key = c2.key = c1.index = c2.index = null;
      return true;
    };
  
    var getAllChildren = function getAllChildren(root, arr, cy) {
      if (!root) return;
  
      if (root.value) {
        arr.push(root.value);
      } else {
        if (root.left) getAllChildren(root.left, arr);
        if (root.right) getAllChildren(root.right, arr);
      }
    };
  
    var buildDendrogram = function buildDendrogram(root, cy) {
      if (!root) return '';
  
      if (root.left && root.right) {
        var leftStr = buildDendrogram(root.left, cy);
        var rightStr = buildDendrogram(root.right, cy);
        var node = cy.add({
          group: 'nodes',
          data: {
            id: leftStr + ',' + rightStr
          }
        });
        cy.add({
          group: 'edges',
          data: {
            source: leftStr,
            target: node.id()
          }
        });
        cy.add({
          group: 'edges',
          data: {
            source: rightStr,
            target: node.id()
          }
        });
        return node.id();
      } else if (root.value) {
        return root.value.id();
      }
    };
  
    var buildClustersFromTree = function buildClustersFromTree(root, k, cy) {
      if (!root) return [];
      var left = [],
          right = [],
          leaves = [];
  
      if (k === 0) {
        // don't cut tree, simply return all nodes as 1 single cluster
        if (root.left) getAllChildren(root.left, left);
        if (root.right) getAllChildren(root.right, right);
        leaves = left.concat(right);
        return [cy.collection(leaves)];
      } else if (k === 1) {
        // cut at root
        if (root.value) {
          // leaf node
          return [cy.collection(root.value)];
        } else {
          if (root.left) getAllChildren(root.left, left);
          if (root.right) getAllChildren(root.right, right);
          return [cy.collection(left), cy.collection(right)];
        }
      } else {
        if (root.value) {
          return [cy.collection(root.value)];
        } else {
          if (root.left) left = buildClustersFromTree(root.left, k - 1, cy);
          if (root.right) right = buildClustersFromTree(root.right, k - 1, cy);
          return left.concat(right);
        }
      }
    };
    /* eslint-enable */
  
  
    var hierarchicalClustering = function hierarchicalClustering(options) {
      var cy = this.cy();
      var nodes = this.nodes(); // Set parameters of algorithm: linkage type, distance metric, etc.
  
      var opts = setOptions$2(options);
      var attrs = opts.attributes;
  
      var getDist = function getDist(n1, n2) {
        return clusteringDistance(opts.distance, attrs.length, function (i) {
          return attrs[i](n1);
        }, function (i) {
          return attrs[i](n2);
        }, n1, n2);
      }; // Begin hierarchical algorithm
  
  
      var clusters = [];
      var dists = []; // distances between each pair of clusters
  
      var mins = []; // closest cluster for each cluster
  
      var index = []; // hash of all clusters by key
      // In agglomerative (bottom-up) clustering, each node starts as its own cluster
  
      for (var n = 0; n < nodes.length; n++) {
        var cluster = {
          value: opts.mode === 'dendrogram' ? nodes[n] : [nodes[n]],
          key: n,
          index: n
        };
        clusters[n] = cluster;
        index[n] = cluster;
        dists[n] = [];
        mins[n] = 0;
      } // Calculate the distance between each pair of clusters
  
  
      for (var i = 0; i < clusters.length; i++) {
        for (var j = 0; j <= i; j++) {
          var dist = void 0;
  
          if (opts.mode === 'dendrogram') {
            // modes store cluster values differently
            dist = i === j ? Infinity : getDist(clusters[i].value, clusters[j].value);
          } else {
            dist = i === j ? Infinity : getDist(clusters[i].value[0], clusters[j].value[0]);
          }
  
          dists[i][j] = dist;
          dists[j][i] = dist;
  
          if (dist < dists[i][mins[i]]) {
            mins[i] = j; // Cache mins: closest cluster to cluster i is cluster j
          }
        }
      } // Find the closest pair of clusters and merge them into a single cluster.
      // Update distances between new cluster and each of the old clusters, and loop until threshold reached.
  
  
      var merged = mergeClosest(clusters, index, dists, mins, opts);
  
      while (merged) {
        merged = mergeClosest(clusters, index, dists, mins, opts);
      }
  
      var retClusters; // Dendrogram mode builds the hierarchy and adds intermediary nodes + edges
      // in addition to returning the clusters.
  
      if (opts.mode === 'dendrogram') {
        retClusters = buildClustersFromTree(clusters[0], opts.dendrogramDepth, cy);
        if (opts.addDendrogram) buildDendrogram(clusters[0], cy);
      } else {
        // Regular mode simply returns the clusters
        retClusters = new Array(clusters.length);
        clusters.forEach(function (cluster, i) {
          // Clean up meta data used for clustering
          cluster.key = cluster.index = null;
          retClusters[i] = cy.collection(cluster.value);
        });
      }
  
      return retClusters;
    };
  
    var hierarchicalClustering$1 = {
      hierarchicalClustering: hierarchicalClustering,
      hca: hierarchicalClustering
    };
  
    // Implemented by Zoe Xi @zoexi for GSOC 2016
    var defaults$7 = defaults({
      distance: 'euclidean',
      // distance metric to compare attributes between two nodes
      preference: 'median',
      // suitability of a data point to serve as an exemplar
      damping: 0.8,
      // damping factor between [0.5, 1)
      maxIterations: 1000,
      // max number of iterations to run
      minIterations: 100,
      // min number of iterations to run in order for clustering to stop
      attributes: [// functions to quantify the similarity between any two points
        // e.g. node => node.data('weight')
      ]
    });
  
    var setOptions$3 = function setOptions(options) {
      var dmp = options.damping;
      var pref = options.preference;
  
      if (!(0.5 <= dmp && dmp < 1)) {
        error("Damping must range on [0.5, 1).  Got: ".concat(dmp));
      }
  
      var validPrefs = ['median', 'mean', 'min', 'max'];
  
      if (!(validPrefs.some(function (v) {
        return v === pref;
      }) || number(pref))) {
        error("Preference must be one of [".concat(validPrefs.map(function (p) {
          return "'".concat(p, "'");
        }).join(', '), "] or a number.  Got: ").concat(pref));
      }
  
      return defaults$7(options);
    };
    /* eslint-enable */
  
  
    var getSimilarity$1 = function getSimilarity(type, n1, n2, attributes) {
      var attr = function attr(n, i) {
        return attributes[i](n);
      }; // nb negative because similarity should have an inverse relationship to distance
  
  
      return -clusteringDistance(type, attributes.length, function (i) {
        return attr(n1, i);
      }, function (i) {
        return attr(n2, i);
      }, n1, n2);
    };
  
    var getPreference = function getPreference(S, preference) {
      // larger preference = greater # of clusters
      var p = null;
  
      if (preference === 'median') {
        p = median(S);
      } else if (preference === 'mean') {
        p = mean(S);
      } else if (preference === 'min') {
        p = min(S);
      } else if (preference === 'max') {
        p = max(S);
      } else {
        // Custom preference number, as set by user
        p = preference;
      }
  
      return p;
    };
  
    var findExemplars = function findExemplars(n, R, A) {
      var indices = [];
  
      for (var i = 0; i < n; i++) {
        if (R[i * n + i] + A[i * n + i] > 0) {
          indices.push(i);
        }
      }
  
      return indices;
    };
  
    var assignClusters = function assignClusters(n, S, exemplars) {
      var clusters = [];
  
      for (var i = 0; i < n; i++) {
        var index = -1;
        var max = -Infinity;
  
        for (var ei = 0; ei < exemplars.length; ei++) {
          var e = exemplars[ei];
  
          if (S[i * n + e] > max) {
            index = e;
            max = S[i * n + e];
          }
        }
  
        if (index > 0) {
          clusters.push(index);
        }
      }
  
      for (var _ei = 0; _ei < exemplars.length; _ei++) {
        clusters[exemplars[_ei]] = exemplars[_ei];
      }
  
      return clusters;
    };
  
    var assign$2 = function assign(n, S, exemplars) {
      var clusters = assignClusters(n, S, exemplars);
  
      for (var ei = 0; ei < exemplars.length; ei++) {
        var ii = [];
  
        for (var c = 0; c < clusters.length; c++) {
          if (clusters[c] === exemplars[ei]) {
            ii.push(c);
          }
        }
  
        var maxI = -1;
        var maxSum = -Infinity;
  
        for (var i = 0; i < ii.length; i++) {
          var sum = 0;
  
          for (var j = 0; j < ii.length; j++) {
            sum += S[ii[j] * n + ii[i]];
          }
  
          if (sum > maxSum) {
            maxI = i;
            maxSum = sum;
          }
        }
  
        exemplars[ei] = ii[maxI];
      }
  
      clusters = assignClusters(n, S, exemplars);
      return clusters;
    };
  
    var affinityPropagation = function affinityPropagation(options) {
      var cy = this.cy();
      var nodes = this.nodes();
      var opts = setOptions$3(options); // Map each node to its position in node array
  
      var id2position = {};
  
      for (var i = 0; i < nodes.length; i++) {
        id2position[nodes[i].id()] = i;
      } // Begin affinity propagation algorithm
  
  
      var n; // number of data points
  
      var n2; // size of matrices
  
      var S; // similarity matrix (1D array)
  
      var p; // preference/suitability of a data point to serve as an exemplar
  
      var R; // responsibility matrix (1D array)
  
      var A; // availability matrix (1D array)
  
      n = nodes.length;
      n2 = n * n; // Initialize and build S similarity matrix
  
      S = new Array(n2);
  
      for (var _i = 0; _i < n2; _i++) {
        S[_i] = -Infinity; // for cases where two data points shouldn't be linked together
      }
  
      for (var _i2 = 0; _i2 < n; _i2++) {
        for (var j = 0; j < n; j++) {
          if (_i2 !== j) {
            S[_i2 * n + j] = getSimilarity$1(opts.distance, nodes[_i2], nodes[j], opts.attributes);
          }
        }
      } // Place preferences on the diagonal of S
  
  
      p = getPreference(S, opts.preference);
  
      for (var _i3 = 0; _i3 < n; _i3++) {
        S[_i3 * n + _i3] = p;
      } // Initialize R responsibility matrix
  
  
      R = new Array(n2);
  
      for (var _i4 = 0; _i4 < n2; _i4++) {
        R[_i4] = 0.0;
      } // Initialize A availability matrix
  
  
      A = new Array(n2);
  
      for (var _i5 = 0; _i5 < n2; _i5++) {
        A[_i5] = 0.0;
      }
  
      var old = new Array(n);
      var Rp = new Array(n);
      var se = new Array(n);
  
      for (var _i6 = 0; _i6 < n; _i6++) {
        old[_i6] = 0.0;
        Rp[_i6] = 0.0;
        se[_i6] = 0;
      }
  
      var e = new Array(n * opts.minIterations);
  
      for (var _i7 = 0; _i7 < e.length; _i7++) {
        e[_i7] = 0;
      }
  
      var iter;
  
      for (iter = 0; iter < opts.maxIterations; iter++) {
        // main algorithmic loop
        // Update R responsibility matrix
        for (var _i8 = 0; _i8 < n; _i8++) {
          var max = -Infinity,
              max2 = -Infinity,
              maxI = -1,
              AS = 0.0;
  
          for (var _j = 0; _j < n; _j++) {
            old[_j] = R[_i8 * n + _j];
            AS = A[_i8 * n + _j] + S[_i8 * n + _j];
  
            if (AS >= max) {
              max2 = max;
              max = AS;
              maxI = _j;
            } else if (AS > max2) {
              max2 = AS;
            }
          }
  
          for (var _j2 = 0; _j2 < n; _j2++) {
            R[_i8 * n + _j2] = (1 - opts.damping) * (S[_i8 * n + _j2] - max) + opts.damping * old[_j2];
          }
  
          R[_i8 * n + maxI] = (1 - opts.damping) * (S[_i8 * n + maxI] - max2) + opts.damping * old[maxI];
        } // Update A availability matrix
  
  
        for (var _i9 = 0; _i9 < n; _i9++) {
          var sum = 0;
  
          for (var _j3 = 0; _j3 < n; _j3++) {
            old[_j3] = A[_j3 * n + _i9];
            Rp[_j3] = Math.max(0, R[_j3 * n + _i9]);
            sum += Rp[_j3];
          }
  
          sum -= Rp[_i9];
          Rp[_i9] = R[_i9 * n + _i9];
          sum += Rp[_i9];
  
          for (var _j4 = 0; _j4 < n; _j4++) {
            A[_j4 * n + _i9] = (1 - opts.damping) * Math.min(0, sum - Rp[_j4]) + opts.damping * old[_j4];
          }
  
          A[_i9 * n + _i9] = (1 - opts.damping) * (sum - Rp[_i9]) + opts.damping * old[_i9];
        } // Check for convergence
  
  
        var K = 0;
  
        for (var _i10 = 0; _i10 < n; _i10++) {
          var E = A[_i10 * n + _i10] + R[_i10 * n + _i10] > 0 ? 1 : 0;
          e[iter % opts.minIterations * n + _i10] = E;
          K += E;
        }
  
        if (K > 0 && (iter >= opts.minIterations - 1 || iter == opts.maxIterations - 1)) {
          var _sum = 0;
  
          for (var _i11 = 0; _i11 < n; _i11++) {
            se[_i11] = 0;
  
            for (var _j5 = 0; _j5 < opts.minIterations; _j5++) {
              se[_i11] += e[_j5 * n + _i11];
            }
  
            if (se[_i11] === 0 || se[_i11] === opts.minIterations) {
              _sum++;
            }
          }
  
          if (_sum === n) {
            // then we have convergence
            break;
          }
        }
      } // Identify exemplars (cluster centers)
  
  
      var exemplarsIndices = findExemplars(n, R, A); // Assign nodes to clusters
  
      var clusterIndices = assign$2(n, S, exemplarsIndices);
      var clusters = {};
  
      for (var c = 0; c < exemplarsIndices.length; c++) {
        clusters[exemplarsIndices[c]] = [];
      }
  
      for (var _i12 = 0; _i12 < nodes.length; _i12++) {
        var pos = id2position[nodes[_i12].id()];
  
        var clusterIndex = clusterIndices[pos];
  
        if (clusterIndex != null) {
          // the node may have not been assigned a cluster if no valid attributes were specified
          clusters[clusterIndex].push(nodes[_i12]);
        }
      }
  
      var retClusters = new Array(exemplarsIndices.length);
  
      for (var _c = 0; _c < exemplarsIndices.length; _c++) {
        retClusters[_c] = cy.collection(clusters[exemplarsIndices[_c]]);
      }
  
      return retClusters;
    };
  
    var affinityPropagation$1 = {
      affinityPropagation: affinityPropagation,
      ap: affinityPropagation
    };
  
    var hierholzerDefaults = defaults({
      root: undefined,
      directed: false
    });
    var elesfn$b = {
      hierholzer: function hierholzer(options) {
        if (!plainObject(options)) {
          var args = arguments;
          options = {
            root: args[0],
            directed: args[1]
          };
        }
  
        var _hierholzerDefaults = hierholzerDefaults(options),
            root = _hierholzerDefaults.root,
            directed = _hierholzerDefaults.directed;
  
        var eles = this;
        var dflag = false;
        var oddIn;
        var oddOut;
        var startVertex;
        if (root) startVertex = string(root) ? this.filter(root)[0].id() : root[0].id();
        var nodes = {};
        var edges = {};
  
        if (directed) {
          eles.forEach(function (ele) {
            var id = ele.id();
  
            if (ele.isNode()) {
              var ind = ele.indegree(true);
              var outd = ele.outdegree(true);
              var d1 = ind - outd;
              var d2 = outd - ind;
  
              if (d1 == 1) {
                if (oddIn) dflag = true;else oddIn = id;
              } else if (d2 == 1) {
                if (oddOut) dflag = true;else oddOut = id;
              } else if (d2 > 1 || d1 > 1) {
                dflag = true;
              }
  
              nodes[id] = [];
              ele.outgoers().forEach(function (e) {
                if (e.isEdge()) nodes[id].push(e.id());
              });
            } else {
              edges[id] = [undefined, ele.target().id()];
            }
          });
        } else {
          eles.forEach(function (ele) {
            var id = ele.id();
  
            if (ele.isNode()) {
              var d = ele.degree(true);
  
              if (d % 2) {
                if (!oddIn) oddIn = id;else if (!oddOut) oddOut = id;else dflag = true;
              }
  
              nodes[id] = [];
              ele.connectedEdges().forEach(function (e) {
                return nodes[id].push(e.id());
              });
            } else {
              edges[id] = [ele.source().id(), ele.target().id()];
            }
          });
        }
  
        var result = {
          found: false,
          trail: undefined
        };
        if (dflag) return result;else if (oddOut && oddIn) {
          if (directed) {
            if (startVertex && oddOut != startVertex) {
              return result;
            }
  
            startVertex = oddOut;
          } else {
            if (startVertex && oddOut != startVertex && oddIn != startVertex) {
              return result;
            } else if (!startVertex) {
              startVertex = oddOut;
            }
          }
        } else {
          if (!startVertex) startVertex = eles[0].id();
        }
  
        var walk = function walk(v) {
          var currentNode = v;
          var subtour = [v];
          var adj, adjTail, adjHead;
  
          while (nodes[currentNode].length) {
            adj = nodes[currentNode].shift();
            adjTail = edges[adj][0];
            adjHead = edges[adj][1];
  
            if (currentNode != adjHead) {
              nodes[adjHead] = nodes[adjHead].filter(function (e) {
                return e != adj;
              });
              currentNode = adjHead;
            } else if (!directed && currentNode != adjTail) {
              nodes[adjTail] = nodes[adjTail].filter(function (e) {
                return e != adj;
              });
              currentNode = adjTail;
            }
  
            subtour.unshift(adj);
            subtour.unshift(currentNode);
          }
  
          return subtour;
        };
  
        var trail = [];
        var subtour = [];
        subtour = walk(startVertex);
  
        while (subtour.length != 1) {
          if (nodes[subtour[0]].length == 0) {
            trail.unshift(eles.getElementById(subtour.shift()));
            trail.unshift(eles.getElementById(subtour.shift()));
          } else {
            subtour = walk(subtour.shift()).concat(subtour);
          }
        }
  
        trail.unshift(eles.getElementById(subtour.shift())); // final node
  
        for (var d in nodes) {
          if (nodes[d].length) {
            return result;
          }
        }
  
        result.found = true;
        result.trail = this.spawn(trail);
        return result;
      }
    };
  
    var hopcroftTarjanBiconnected = function hopcroftTarjanBiconnected() {
      var eles = this;
      var nodes = {};
      var id = 0;
      var edgeCount = 0;
      var components = [];
      var stack = [];
      var visitedEdges = {};
  
      var buildComponent = function buildComponent(x, y) {
        var i = stack.length - 1;
        var cutset = [];
        var component = eles.spawn();
  
        while (stack[i].x != x || stack[i].y != y) {
          cutset.push(stack.pop().edge);
          i--;
        }
  
        cutset.push(stack.pop().edge);
        cutset.forEach(function (edge) {
          var connectedNodes = edge.connectedNodes().intersection(eles);
          component.merge(edge);
          connectedNodes.forEach(function (node) {
            var nodeId = node.id();
            var connectedEdges = node.connectedEdges().intersection(eles);
            component.merge(node);
  
            if (!nodes[nodeId].cutVertex) {
              component.merge(connectedEdges);
            } else {
              component.merge(connectedEdges.filter(function (edge) {
                return edge.isLoop();
              }));
            }
          });
        });
        components.push(component);
      };
  
      var biconnectedSearch = function biconnectedSearch(root, currentNode, parent) {
        if (root === parent) edgeCount += 1;
        nodes[currentNode] = {
          id: id,
          low: id++,
          cutVertex: false
        };
        var edges = eles.getElementById(currentNode).connectedEdges().intersection(eles);
  
        if (edges.size() === 0) {
          components.push(eles.spawn(eles.getElementById(currentNode)));
        } else {
          var sourceId, targetId, otherNodeId, edgeId;
          edges.forEach(function (edge) {
            sourceId = edge.source().id();
            targetId = edge.target().id();
            otherNodeId = sourceId === currentNode ? targetId : sourceId;
  
            if (otherNodeId !== parent) {
              edgeId = edge.id();
  
              if (!visitedEdges[edgeId]) {
                visitedEdges[edgeId] = true;
                stack.push({
                  x: currentNode,
                  y: otherNodeId,
                  edge: edge
                });
              }
  
              if (!(otherNodeId in nodes)) {
                biconnectedSearch(root, otherNodeId, currentNode);
                nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].low);
  
                if (nodes[currentNode].id <= nodes[otherNodeId].low) {
                  nodes[currentNode].cutVertex = true;
                  buildComponent(currentNode, otherNodeId);
                }
              } else {
                nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].id);
              }
            }
          });
        }
      };
  
      eles.forEach(function (ele) {
        if (ele.isNode()) {
          var nodeId = ele.id();
  
          if (!(nodeId in nodes)) {
            edgeCount = 0;
            biconnectedSearch(nodeId, nodeId);
            nodes[nodeId].cutVertex = edgeCount > 1;
          }
        }
      });
      var cutVertices = Object.keys(nodes).filter(function (id) {
        return nodes[id].cutVertex;
      }).map(function (id) {
        return eles.getElementById(id);
      });
      return {
        cut: eles.spawn(cutVertices),
        components: components
      };
    };
  
    var hopcroftTarjanBiconnected$1 = {
      hopcroftTarjanBiconnected: hopcroftTarjanBiconnected,
      htbc: hopcroftTarjanBiconnected,
      htb: hopcroftTarjanBiconnected,
      hopcroftTarjanBiconnectedComponents: hopcroftTarjanBiconnected
    };
  
    var tarjanStronglyConnected = function tarjanStronglyConnected() {
      var eles = this;
      var nodes = {};
      var index = 0;
      var components = [];
      var stack = [];
      var cut = eles.spawn(eles);
  
      var stronglyConnectedSearch = function stronglyConnectedSearch(sourceNodeId) {
        stack.push(sourceNodeId);
        nodes[sourceNodeId] = {
          index: index,
          low: index++,
          explored: false
        };
        var connectedEdges = eles.getElementById(sourceNodeId).connectedEdges().intersection(eles);
        connectedEdges.forEach(function (edge) {
          var targetNodeId = edge.target().id();
  
          if (targetNodeId !== sourceNodeId) {
            if (!(targetNodeId in nodes)) {
              stronglyConnectedSearch(targetNodeId);
            }
  
            if (!nodes[targetNodeId].explored) {
              nodes[sourceNodeId].low = Math.min(nodes[sourceNodeId].low, nodes[targetNodeId].low);
            }
          }
        });
  
        if (nodes[sourceNodeId].index === nodes[sourceNodeId].low) {
          var componentNodes = eles.spawn();
  
          for (;;) {
            var nodeId = stack.pop();
            componentNodes.merge(eles.getElementById(nodeId));
            nodes[nodeId].low = nodes[sourceNodeId].index;
            nodes[nodeId].explored = true;
  
            if (nodeId === sourceNodeId) {
              break;
            }
          }
  
          var componentEdges = componentNodes.edgesWith(componentNodes);
          var component = componentNodes.merge(componentEdges);
          components.push(component);
          cut = cut.difference(component);
        }
      };
  
      eles.forEach(function (ele) {
        if (ele.isNode()) {
          var nodeId = ele.id();
  
          if (!(nodeId in nodes)) {
            stronglyConnectedSearch(nodeId);
          }
        }
      });
      return {
        cut: cut,
        components: components
      };
    };
  
    var tarjanStronglyConnected$1 = {
      tarjanStronglyConnected: tarjanStronglyConnected,
      tsc: tarjanStronglyConnected,
      tscc: tarjanStronglyConnected,
      tarjanStronglyConnectedComponents: tarjanStronglyConnected
    };
  
    var elesfn$c = {};
    [elesfn, elesfn$1, elesfn$2, elesfn$3, elesfn$4, elesfn$5, elesfn$6, elesfn$7, elesfn$8, elesfn$9, elesfn$a, markovClustering$1, kClustering, hierarchicalClustering$1, affinityPropagation$1, elesfn$b, hopcroftTarjanBiconnected$1, tarjanStronglyConnected$1].forEach(function (props) {
      extend(elesfn$c, props);
    });
  
    /*!
    Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
    Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
    Licensed under The MIT License (http://opensource.org/licenses/MIT)
    */
  
    /*  promise states [Promises/A+ 2.1]  */
    var STATE_PENDING = 0;
    /*  [Promises/A+ 2.1.1]  */
  
    var STATE_FULFILLED = 1;
    /*  [Promises/A+ 2.1.2]  */
  
    var STATE_REJECTED = 2;
    /*  [Promises/A+ 2.1.3]  */
  
    /*  promise object constructor  */
  
    var api = function api(executor) {
      /*  optionally support non-constructor/plain-function call  */
      if (!(this instanceof api)) return new api(executor);
      /*  initialize object  */
  
      this.id = 'Thenable/1.0.7';
      this.state = STATE_PENDING;
      /*  initial state  */
  
      this.fulfillValue = undefined;
      /*  initial value  */
  
      /*  [Promises/A+ 1.3, 2.1.2.2]  */
  
      this.rejectReason = undefined;
      /*  initial reason */
  
      /*  [Promises/A+ 1.5, 2.1.3.2]  */
  
      this.onFulfilled = [];
      /*  initial handlers  */
  
      this.onRejected = [];
      /*  initial handlers  */
  
      /*  provide optional information-hiding proxy  */
  
      this.proxy = {
        then: this.then.bind(this)
      };
      /*  support optional executor function  */
  
      if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
    };
    /*  promise API methods  */
  
  
    api.prototype = {
      /*  promise resolving methods  */
      fulfill: function fulfill(value) {
        return deliver(this, STATE_FULFILLED, 'fulfillValue', value);
      },
      reject: function reject(value) {
        return deliver(this, STATE_REJECTED, 'rejectReason', value);
      },
  
      /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
      then: function then(onFulfilled, onRejected) {
        var curr = this;
        var next = new api();
        /*  [Promises/A+ 2.2.7]  */
  
        curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill'));
        /*  [Promises/A+ 2.2.2/2.2.6]  */
  
        curr.onRejected.push(resolver(onRejected, next, 'reject'));
        /*  [Promises/A+ 2.2.3/2.2.6]  */
  
        execute(curr);
        return next.proxy;
        /*  [Promises/A+ 2.2.7, 3.3]  */
      }
    };
    /*  deliver an action  */
  
    var deliver = function deliver(curr, state, name, value) {
      if (curr.state === STATE_PENDING) {
        curr.state = state;
        /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
  
        curr[name] = value;
        /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
  
        execute(curr);
      }
  
      return curr;
    };
    /*  execute all handlers  */
  
  
    var execute = function execute(curr) {
      if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);
    };
    /*  execute particular set of handlers  */
  
  
    var execute_handlers = function execute_handlers(curr, name, value) {
      /* global setImmediate: true */
  
      /* global setTimeout: true */
  
      /*  short-circuit processing  */
      if (curr[name].length === 0) return;
      /*  iterate over all handlers, exactly once  */
  
      var handlers = curr[name];
      curr[name] = [];
      /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
  
      var func = function func() {
        for (var i = 0; i < handlers.length; i++) {
          handlers[i](value);
        }
        /*  [Promises/A+ 2.2.5]  */
  
      };
      /*  execute procedure asynchronously  */
  
      /*  [Promises/A+ 2.2.4, 3.1]  */
  
  
      if (typeof setImmediate === 'function') setImmediate(func);else setTimeout(func, 0);
    };
    /*  generate a resolver function  */
  
  
    var resolver = function resolver(cb, next, method) {
      return function (value) {
        if (typeof cb !== 'function')
          /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
          next[method].call(next, value);
          /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
        else {
            var result;
  
            try {
              result = cb(value);
            }
            /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
            catch (e) {
              next.reject(e);
              /*  [Promises/A+ 2.2.7.2]  */
  
              return;
            }
  
            resolve(next, result);
            /*  [Promises/A+ 2.2.7.1]  */
          }
      };
    };
    /*  "Promise Resolution Procedure"  */
  
    /*  [Promises/A+ 2.3]  */
  
  
    var resolve = function resolve(promise, x) {
      /*  sanity check arguments  */
  
      /*  [Promises/A+ 2.3.1]  */
      if (promise === x || promise.proxy === x) {
        promise.reject(new TypeError('cannot resolve promise with itself'));
        return;
      }
      /*  surgically check for a "then" method
        (mainly to just call the "getter" of "then" only once)  */
  
  
      var then;
  
      if (_typeof(x) === 'object' && x !== null || typeof x === 'function') {
        try {
          then = x.then;
        }
        /*  [Promises/A+ 2.3.3.1, 3.5]  */
        catch (e) {
          promise.reject(e);
          /*  [Promises/A+ 2.3.3.2]  */
  
          return;
        }
      }
      /*  handle own Thenables    [Promises/A+ 2.3.2]
        and similar "thenables" [Promises/A+ 2.3.3]  */
  
  
      if (typeof then === 'function') {
        var resolved = false;
  
        try {
          /*  call retrieved "then" method */
  
          /*  [Promises/A+ 2.3.3.3]  */
          then.call(x,
          /*  resolvePromise  */
  
          /*  [Promises/A+ 2.3.3.3.1]  */
          function (y) {
            if (resolved) return;
            resolved = true;
            /*  [Promises/A+ 2.3.3.3.3]  */
  
            if (y === x)
              /*  [Promises/A+ 3.6]  */
              promise.reject(new TypeError('circular thenable chain'));else resolve(promise, y);
          },
          /*  rejectPromise  */
  
          /*  [Promises/A+ 2.3.3.3.2]  */
          function (r) {
            if (resolved) return;
            resolved = true;
            /*  [Promises/A+ 2.3.3.3.3]  */
  
            promise.reject(r);
          });
        } catch (e) {
          if (!resolved)
            /*  [Promises/A+ 2.3.3.3.3]  */
            promise.reject(e);
          /*  [Promises/A+ 2.3.3.3.4]  */
        }
  
        return;
      }
      /*  handle other values  */
  
  
      promise.fulfill(x);
      /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
    }; // so we always have Promise.all()
  
  
    api.all = function (ps) {
      return new api(function (resolveAll, rejectAll) {
        var vals = new Array(ps.length);
        var doneCount = 0;
  
        var fulfill = function fulfill(i, val) {
          vals[i] = val;
          doneCount++;
  
          if (doneCount === ps.length) {
            resolveAll(vals);
          }
        };
  
        for (var i = 0; i < ps.length; i++) {
          (function (i) {
            var p = ps[i];
            var isPromise = p != null && p.then != null;
  
            if (isPromise) {
              p.then(function (val) {
                fulfill(i, val);
              }, function (err) {
                rejectAll(err);
              });
            } else {
              var val = p;
              fulfill(i, val);
            }
          })(i);
        }
      });
    };
  
    api.resolve = function (val) {
      return new api(function (resolve, reject) {
        resolve(val);
      });
    };
  
    api.reject = function (val) {
      return new api(function (resolve, reject) {
        reject(val);
      });
    };
  
    var Promise$1 = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef
  
    var Animation = function Animation(target, opts, opts2) {
      var isCore = core(target);
      var isEle = !isCore;
  
      var _p = this._private = extend({
        duration: 1000
      }, opts, opts2);
  
      _p.target = target;
      _p.style = _p.style || _p.css;
      _p.started = false;
      _p.playing = false;
      _p.hooked = false;
      _p.applying = false;
      _p.progress = 0;
      _p.completes = [];
      _p.frames = [];
  
      if (_p.complete && fn(_p.complete)) {
        _p.completes.push(_p.complete);
      }
  
      if (isEle) {
        var pos = target.position();
        _p.startPosition = _p.startPosition || {
          x: pos.x,
          y: pos.y
        };
        _p.startStyle = _p.startStyle || target.cy().style().getAnimationStartStyle(target, _p.style);
      }
  
      if (isCore) {
        var pan = target.pan();
        _p.startPan = {
          x: pan.x,
          y: pan.y
        };
        _p.startZoom = target.zoom();
      } // for future timeline/animations impl
  
  
      this.length = 1;
      this[0] = this;
    };
  
    var anifn = Animation.prototype;
    extend(anifn, {
      instanceString: function instanceString() {
        return 'animation';
      },
      hook: function hook() {
        var _p = this._private;
  
        if (!_p.hooked) {
          // add to target's animation queue
          var q;
          var tAni = _p.target._private.animation;
  
          if (_p.queue) {
            q = tAni.queue;
          } else {
            q = tAni.current;
          }
  
          q.push(this); // add to the animation loop pool
  
          if (elementOrCollection(_p.target)) {
            _p.target.cy().addToAnimationPool(_p.target);
          }
  
          _p.hooked = true;
        }
  
        return this;
      },
      play: function play() {
        var _p = this._private; // autorewind
  
        if (_p.progress === 1) {
          _p.progress = 0;
        }
  
        _p.playing = true;
        _p.started = false; // needs to be started by animation loop
  
        _p.stopped = false;
        this.hook(); // the animation loop will start the animation...
  
        return this;
      },
      playing: function playing() {
        return this._private.playing;
      },
      apply: function apply() {
        var _p = this._private;
        _p.applying = true;
        _p.started = false; // needs to be started by animation loop
  
        _p.stopped = false;
        this.hook(); // the animation loop will apply the animation at this progress
  
        return this;
      },
      applying: function applying() {
        return this._private.applying;
      },
      pause: function pause() {
        var _p = this._private;
        _p.playing = false;
        _p.started = false;
        return this;
      },
      stop: function stop() {
        var _p = this._private;
        _p.playing = false;
        _p.started = false;
        _p.stopped = true; // to be removed from animation queues
  
        return this;
      },
      rewind: function rewind() {
        return this.progress(0);
      },
      fastforward: function fastforward() {
        return this.progress(1);
      },
      time: function time(t) {
        var _p = this._private;
  
        if (t === undefined) {
          return _p.progress * _p.duration;
        } else {
          return this.progress(t / _p.duration);
        }
      },
      progress: function progress(p) {
        var _p = this._private;
        var wasPlaying = _p.playing;
  
        if (p === undefined) {
          return _p.progress;
        } else {
          if (wasPlaying) {
            this.pause();
          }
  
          _p.progress = p;
          _p.started = false;
  
          if (wasPlaying) {
            this.play();
          }
        }
  
        return this;
      },
      completed: function completed() {
        return this._private.progress === 1;
      },
      reverse: function reverse() {
        var _p = this._private;
        var wasPlaying = _p.playing;
  
        if (wasPlaying) {
          this.pause();
        }
  
        _p.progress = 1 - _p.progress;
        _p.started = false;
  
        var swap = function swap(a, b) {
          var _pa = _p[a];
  
          if (_pa == null) {
            return;
          }
  
          _p[a] = _p[b];
          _p[b] = _pa;
        };
  
        swap('zoom', 'startZoom');
        swap('pan', 'startPan');
        swap('position', 'startPosition'); // swap styles
  
        if (_p.style) {
          for (var i = 0; i < _p.style.length; i++) {
            var prop = _p.style[i];
            var name = prop.name;
            var startStyleProp = _p.startStyle[name];
            _p.startStyle[name] = prop;
            _p.style[i] = startStyleProp;
          }
        }
  
        if (wasPlaying) {
          this.play();
        }
  
        return this;
      },
      promise: function promise(type) {
        var _p = this._private;
        var arr;
  
        switch (type) {
          case 'frame':
            arr = _p.frames;
            break;
  
          default:
          case 'complete':
          case 'completed':
            arr = _p.completes;
        }
  
        return new Promise$1(function (resolve, reject) {
          arr.push(function () {
            resolve();
          });
        });
      }
    });
    anifn.complete = anifn.completed;
    anifn.run = anifn.play;
    anifn.running = anifn.playing;
  
    var define = {
      animated: function animated() {
        return function animatedImpl() {
          var self = this;
          var selfIsArrayLike = self.length !== undefined;
          var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
  
          var cy = this._private.cy || this;
  
          if (!cy.styleEnabled()) {
            return false;
          }
  
          var ele = all[0];
  
          if (ele) {
            return ele._private.animation.current.length > 0;
          }
        };
      },
      // animated
      clearQueue: function clearQueue() {
        return function clearQueueImpl() {
          var self = this;
          var selfIsArrayLike = self.length !== undefined;
          var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
  
          var cy = this._private.cy || this;
  
          if (!cy.styleEnabled()) {
            return this;
          }
  
          for (var i = 0; i < all.length; i++) {
            var ele = all[i];
            ele._private.animation.queue = [];
          }
  
          return this;
        };
      },
      // clearQueue
      delay: function delay() {
        return function delayImpl(time, complete) {
          var cy = this._private.cy || this;
  
          if (!cy.styleEnabled()) {
            return this;
          }
  
          return this.animate({
            delay: time,
            duration: time,
            complete: complete
          });
        };
      },
      // delay
      delayAnimation: function delayAnimation() {
        return function delayAnimationImpl(time, complete) {
          var cy = this._private.cy || this;
  
          if (!cy.styleEnabled()) {
            return this;
          }
  
          return this.animation({
            delay: time,
            duration: time,
            complete: complete
          });
        };
      },
      // delay
      animation: function animation() {
        return function animationImpl(properties, params) {
          var self = this;
          var selfIsArrayLike = self.length !== undefined;
          var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
  
          var cy = this._private.cy || this;
          var isCore = !selfIsArrayLike;
          var isEles = !isCore;
  
          if (!cy.styleEnabled()) {
            return this;
          }
  
          var style = cy.style();
          properties = extend({}, properties, params);
          var propertiesEmpty = Object.keys(properties).length === 0;
  
          if (propertiesEmpty) {
            return new Animation(all[0], properties); // nothing to animate
          }
  
          if (properties.duration === undefined) {
            properties.duration = 400;
          }
  
          switch (properties.duration) {
            case 'slow':
              properties.duration = 600;
              break;
  
            case 'fast':
              properties.duration = 200;
              break;
          }
  
          if (isEles) {
            properties.style = style.getPropsList(properties.style || properties.css);
            properties.css = undefined;
          }
  
          if (isEles && properties.renderedPosition != null) {
            var rpos = properties.renderedPosition;
            var pan = cy.pan();
            var zoom = cy.zoom();
            properties.position = renderedToModelPosition(rpos, zoom, pan);
          } // override pan w/ panBy if set
  
  
          if (isCore && properties.panBy != null) {
            var panBy = properties.panBy;
            var cyPan = cy.pan();
            properties.pan = {
              x: cyPan.x + panBy.x,
              y: cyPan.y + panBy.y
            };
          } // override pan w/ center if set
  
  
          var center = properties.center || properties.centre;
  
          if (isCore && center != null) {
            var centerPan = cy.getCenterPan(center.eles, properties.zoom);
  
            if (centerPan != null) {
              properties.pan = centerPan;
            }
          } // override pan & zoom w/ fit if set
  
  
          if (isCore && properties.fit != null) {
            var fit = properties.fit;
            var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);
  
            if (fitVp != null) {
              properties.pan = fitVp.pan;
              properties.zoom = fitVp.zoom;
            }
          } // override zoom (& potentially pan) w/ zoom obj if set
  
  
          if (isCore && plainObject(properties.zoom)) {
            var vp = cy.getZoomedViewport(properties.zoom);
  
            if (vp != null) {
              if (vp.zoomed) {
                properties.zoom = vp.zoom;
              }
  
              if (vp.panned) {
                properties.pan = vp.pan;
              }
            } else {
              properties.zoom = null; // an inavalid zoom (e.g. no delta) gets automatically destroyed
            }
          }
  
          return new Animation(all[0], properties);
        };
      },
      // animate
      animate: function animate() {
        return function animateImpl(properties, params) {
          var self = this;
          var selfIsArrayLike = self.length !== undefined;
          var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
  
          var cy = this._private.cy || this;
  
          if (!cy.styleEnabled()) {
            return this;
          }
  
          if (params) {
            properties = extend({}, properties, params);
          } // manually hook and run the animation
  
  
          for (var i = 0; i < all.length; i++) {
            var ele = all[i];
            var queue = ele.animated() && (properties.queue === undefined || properties.queue);
            var ani = ele.animation(properties, queue ? {
              queue: true
            } : undefined);
            ani.play();
          }
  
          return this; // chaining
        };
      },
      // animate
      stop: function stop() {
        return function stopImpl(clearQueue, jumpToEnd) {
          var self = this;
          var selfIsArrayLike = self.length !== undefined;
          var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
  
          var cy = this._private.cy || this;
  
          if (!cy.styleEnabled()) {
            return this;
          }
  
          for (var i = 0; i < all.length; i++) {
            var ele = all[i];
            var _p = ele._private;
            var anis = _p.animation.current;
  
            for (var j = 0; j < anis.length; j++) {
              var ani = anis[j];
              var ani_p = ani._private;
  
              if (jumpToEnd) {
                // next iteration of the animation loop, the animation
                // will go straight to the end and be removed
                ani_p.duration = 0;
              }
            } // clear the queue of future animations
  
  
            if (clearQueue) {
              _p.animation.queue = [];
            }
  
            if (!jumpToEnd) {
              _p.animation.current = [];
            }
          } // we have to notify (the animation loop doesn't do it for us on `stop`)
  
  
          cy.notify('draw');
          return this;
        };
      } // stop
  
    }; // define
  
    var define$1 = {
      // access data field
      data: function data(params) {
        var defaults = {
          field: 'data',
          bindingEvent: 'data',
          allowBinding: false,
          allowSetting: false,
          allowGetting: false,
          settingEvent: 'data',
          settingTriggersEvent: false,
          triggerFnName: 'trigger',
          immutableKeys: {},
          // key => true if immutable
          updateStyle: false,
          beforeGet: function beforeGet(self) {},
          beforeSet: function beforeSet(self, obj) {},
          onSet: function onSet(self) {},
          canSet: function canSet(self) {
            return true;
          }
        };
        params = extend({}, defaults, params);
        return function dataImpl(name, value) {
          var p = params;
          var self = this;
          var selfIsArrayLike = self.length !== undefined;
          var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
  
          var single = selfIsArrayLike ? self[0] : self; // .data('foo', ...)
  
          if (string(name)) {
            // set or get property
            // .data('foo')
            if (p.allowGetting && value === undefined) {
              // get
              var ret;
  
              if (single) {
                p.beforeGet(single);
                ret = single._private[p.field][name];
              }
  
              return ret; // .data('foo', 'bar')
            } else if (p.allowSetting && value !== undefined) {
              // set
              var valid = !p.immutableKeys[name];
  
              if (valid) {
                var change = _defineProperty({}, name, value);
  
                p.beforeSet(self, change);
  
                for (var i = 0, l = all.length; i < l; i++) {
                  var ele = all[i];
  
                  if (p.canSet(ele)) {
                    ele._private[p.field][name] = value;
                  }
                } // update mappers if asked
  
  
                if (p.updateStyle) {
                  self.updateStyle();
                } // call onSet callback
  
  
                p.onSet(self);
  
                if (p.settingTriggersEvent) {
                  self[p.triggerFnName](p.settingEvent);
                }
              }
            } // .data({ 'foo': 'bar' })
  
          } else if (p.allowSetting && plainObject(name)) {
            // extend
            var obj = name;
            var k, v;
            var keys = Object.keys(obj);
            p.beforeSet(self, obj);
  
            for (var _i = 0; _i < keys.length; _i++) {
              k = keys[_i];
              v = obj[k];
  
              var _valid = !p.immutableKeys[k];
  
              if (_valid) {
                for (var j = 0; j < all.length; j++) {
                  var _ele = all[j];
  
                  if (p.canSet(_ele)) {
                    _ele._private[p.field][k] = v;
                  }
                }
              }
            } // update mappers if asked
  
  
            if (p.updateStyle) {
              self.updateStyle();
            } // call onSet callback
  
  
            p.onSet(self);
  
            if (p.settingTriggersEvent) {
              self[p.triggerFnName](p.settingEvent);
            } // .data(function(){ ... })
  
          } else if (p.allowBinding && fn(name)) {
            // bind to event
            var fn$1 = name;
            self.on(p.bindingEvent, fn$1); // .data()
          } else if (p.allowGetting && name === undefined) {
            // get whole object
            var _ret;
  
            if (single) {
              p.beforeGet(single);
              _ret = single._private[p.field];
            }
  
            return _ret;
          }
  
          return self; // maintain chainability
        }; // function
      },
      // data
      // remove data field
      removeData: function removeData(params) {
        var defaults = {
          field: 'data',
          event: 'data',
          triggerFnName: 'trigger',
          triggerEvent: false,
          immutableKeys: {} // key => true if immutable
  
        };
        params = extend({}, defaults, params);
        return function removeDataImpl(names) {
          var p = params;
          var self = this;
          var selfIsArrayLike = self.length !== undefined;
          var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
          // .removeData('foo bar')
  
          if (string(names)) {
            // then get the list of keys, and delete them
            var keys = names.split(/\s+/);
            var l = keys.length;
  
            for (var i = 0; i < l; i++) {
              // delete each non-empty key
              var key = keys[i];
  
              if (emptyString(key)) {
                continue;
              }
  
              var valid = !p.immutableKeys[key]; // not valid if immutable
  
              if (valid) {
                for (var i_a = 0, l_a = all.length; i_a < l_a; i_a++) {
                  all[i_a]._private[p.field][key] = undefined;
                }
              }
            }
  
            if (p.triggerEvent) {
              self[p.triggerFnName](p.event);
            } // .removeData()
  
          } else if (names === undefined) {
            // then delete all keys
            for (var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++) {
              var _privateFields = all[_i_a]._private[p.field];
  
              var _keys = Object.keys(_privateFields);
  
              for (var _i2 = 0; _i2 < _keys.length; _i2++) {
                var _key = _keys[_i2];
                var validKeyToDelete = !p.immutableKeys[_key];
  
                if (validKeyToDelete) {
                  _privateFields[_key] = undefined;
                }
              }
            }
  
            if (p.triggerEvent) {
              self[p.triggerFnName](p.event);
            }
          }
  
          return self; // maintain chaining
        }; // function
      } // removeData
  
    }; // define
  
    var define$2 = {
      eventAliasesOn: function eventAliasesOn(proto) {
        var p = proto;
        p.addListener = p.listen = p.bind = p.on;
        p.unlisten = p.unbind = p.off = p.removeListener;
        p.trigger = p.emit; // this is just a wrapper alias of .on()
  
        p.pon = p.promiseOn = function (events, selector) {
          var self = this;
          var args = Array.prototype.slice.call(arguments, 0);
          return new Promise$1(function (resolve, reject) {
            var callback = function callback(e) {
              self.off.apply(self, offArgs);
              resolve(e);
            };
  
            var onArgs = args.concat([callback]);
            var offArgs = onArgs.concat([]);
            self.on.apply(self, onArgs);
          });
        };
      }
    }; // define
  
    // use this module to cherry pick functions into your prototype
    var define$3 = {};
    [define, define$1, define$2].forEach(function (m) {
      extend(define$3, m);
    });
  
    var elesfn$d = {
      animate: define$3.animate(),
      animation: define$3.animation(),
      animated: define$3.animated(),
      clearQueue: define$3.clearQueue(),
      delay: define$3.delay(),
      delayAnimation: define$3.delayAnimation(),
      stop: define$3.stop()
    };
  
    var elesfn$e = {
      classes: function classes(_classes) {
        var self = this;
  
        if (_classes === undefined) {
          var ret = [];
  
          self[0]._private.classes.forEach(function (cls) {
            return ret.push(cls);
          });
  
          return ret;
        } else if (!array(_classes)) {
          // extract classes from string
          _classes = (_classes || '').match(/\S+/g) || [];
        }
  
        var changed = [];
        var classesSet = new Set$1(_classes); // check and update each ele
  
        for (var j = 0; j < self.length; j++) {
          var ele = self[j];
          var _p = ele._private;
          var eleClasses = _p.classes;
          var changedEle = false; // check if ele has all of the passed classes
  
          for (var i = 0; i < _classes.length; i++) {
            var cls = _classes[i];
            var eleHasClass = eleClasses.has(cls);
  
            if (!eleHasClass) {
              changedEle = true;
              break;
            }
          } // check if ele has classes outside of those passed
  
  
          if (!changedEle) {
            changedEle = eleClasses.size !== _classes.length;
          }
  
          if (changedEle) {
            _p.classes = classesSet;
            changed.push(ele);
          }
        } // trigger update style on those eles that had class changes
  
  
        if (changed.length > 0) {
          this.spawn(changed).updateStyle().emit('class');
        }
  
        return self;
      },
      addClass: function addClass(classes) {
        return this.toggleClass(classes, true);
      },
      hasClass: function hasClass(className) {
        var ele = this[0];
        return ele != null && ele._private.classes.has(className);
      },
      toggleClass: function toggleClass(classes, toggle) {
        if (!array(classes)) {
          // extract classes from string
          classes = classes.match(/\S+/g) || [];
        }
  
        var self = this;
        var toggleUndefd = toggle === undefined;
        var changed = []; // eles who had classes changed
  
        for (var i = 0, il = self.length; i < il; i++) {
          var ele = self[i];
          var eleClasses = ele._private.classes;
          var changedEle = false;
  
          for (var j = 0; j < classes.length; j++) {
            var cls = classes[j];
            var hasClass = eleClasses.has(cls);
            var changedNow = false;
  
            if (toggle || toggleUndefd && !hasClass) {
              eleClasses.add(cls);
              changedNow = true;
            } else if (!toggle || toggleUndefd && hasClass) {
              eleClasses["delete"](cls);
              changedNow = true;
            }
  
            if (!changedEle && changedNow) {
              changed.push(ele);
              changedEle = true;
            }
          } // for j classes
  
        } // for i eles
        // trigger update style on those eles that had class changes
  
  
        if (changed.length > 0) {
          this.spawn(changed).updateStyle().emit('class');
        }
  
        return self;
      },
      removeClass: function removeClass(classes) {
        return this.toggleClass(classes, false);
      },
      flashClass: function flashClass(classes, duration) {
        var self = this;
  
        if (duration == null) {
          duration = 250;
        } else if (duration === 0) {
          return self; // nothing to do really
        }
  
        self.addClass(classes);
        setTimeout(function () {
          self.removeClass(classes);
        }, duration);
        return self;
      }
    };
    elesfn$e.className = elesfn$e.classNames = elesfn$e.classes;
  
    var tokens = {
      metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]',
      // chars we need to escape in let names, etc
      comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=',
      // binary comparison op (used in data selectors)
      boolOp: '\\?|\\!|\\^',
      // boolean (unary) operators (used in data selectors)
      string: '"(?:\\\\"|[^"])*"' + '|' + "'(?:\\\\'|[^'])*'",
      // string literals (used in data selectors) -- doublequotes | singlequotes
      number: number$1,
      // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
      meta: 'degree|indegree|outdegree',
      // allowed metadata fields (i.e. allowed functions to use from Collection)
      separator: '\\s*,\\s*',
      // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
      descendant: '\\s+',
      child: '\\s+>\\s+',
      subject: '\\$',
      group: 'node|edge|\\*',
      directedEdge: '\\s+->\\s+',
      undirectedEdge: '\\s+<->\\s+'
    };
    tokens.variable = '(?:[\\w-]|(?:\\\\' + tokens.metaChar + '))+'; // a variable name
  
    tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number
  
    tokens.className = tokens.variable; // a class name (follows variable conventions)
  
    tokens.id = tokens.variable; // an element id (follows variable conventions)
  
    (function () {
      var ops, op, i; // add @ variants to comparatorOp
  
      ops = tokens.comparatorOp.split('|');
  
      for (i = 0; i < ops.length; i++) {
        op = ops[i];
        tokens.comparatorOp += '|@' + op;
      } // add ! variants to comparatorOp
  
  
      ops = tokens.comparatorOp.split('|');
  
      for (i = 0; i < ops.length; i++) {
        op = ops[i];
  
        if (op.indexOf('!') >= 0) {
          continue;
        } // skip ops that explicitly contain !
  
  
        if (op === '=') {
          continue;
        } // skip = b/c != is explicitly defined
  
  
        tokens.comparatorOp += '|\\!' + op;
      }
    })();
  
    /**
     * Make a new query object
     *
     * @prop type {Type} The type enum (int) of the query
     * @prop checks List of checks to make against an ele to test for a match
     */
    var newQuery = function newQuery() {
      return {
        checks: []
      };
    };
  
    /**
     * A check type enum-like object.  Uses integer values for fast match() lookup.
     * The ordering does not matter as long as the ints are unique.
     */
    var Type = {
      /** E.g. node */
      GROUP: 0,
  
      /** A collection of elements */
      COLLECTION: 1,
  
      /** A filter(ele) function */
      FILTER: 2,
  
      /** E.g. [foo > 1] */
      DATA_COMPARE: 3,
  
      /** E.g. [foo] */
      DATA_EXIST: 4,
  
      /** E.g. [?foo] */
      DATA_BOOL: 5,
  
      /** E.g. [[degree > 2]] */
      META_COMPARE: 6,
  
      /** E.g. :selected */
      STATE: 7,
  
      /** E.g. #foo */
      ID: 8,
  
      /** E.g. .foo */
      CLASS: 9,
  
      /** E.g. #foo <-> #bar */
      UNDIRECTED_EDGE: 10,
  
      /** E.g. #foo -> #bar */
      DIRECTED_EDGE: 11,
  
      /** E.g. $#foo -> #bar */
      NODE_SOURCE: 12,
  
      /** E.g. #foo -> $#bar */
      NODE_TARGET: 13,
  
      /** E.g. $#foo <-> #bar */
      NODE_NEIGHBOR: 14,
  
      /** E.g. #foo > #bar */
      CHILD: 15,
  
      /** E.g. #foo #bar */
      DESCENDANT: 16,
  
      /** E.g. $#foo > #bar */
      PARENT: 17,
  
      /** E.g. $#foo #bar */
      ANCESTOR: 18,
  
      /** E.g. #foo > $bar > #baz */
      COMPOUND_SPLIT: 19,
  
      /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */
      TRUE: 20
    };
  
    var stateSelectors = [{
      selector: ':selected',
      matches: function matches(ele) {
        return ele.selected();
      }
    }, {
      selector: ':unselected',
      matches: function matches(ele) {
        return !ele.selected();
      }
    }, {
      selector: ':selectable',
      matches: function matches(ele) {
        return ele.selectable();
      }
    }, {
      selector: ':unselectable',
      matches: function matches(ele) {
        return !ele.selectable();
      }
    }, {
      selector: ':locked',
      matches: function matches(ele) {
        return ele.locked();
      }
    }, {
      selector: ':unlocked',
      matches: function matches(ele) {
        return !ele.locked();
      }
    }, {
      selector: ':visible',
      matches: function matches(ele) {
        return ele.visible();
      }
    }, {
      selector: ':hidden',
      matches: function matches(ele) {
        return !ele.visible();
      }
    }, {
      selector: ':transparent',
      matches: function matches(ele) {
        return ele.transparent();
      }
    }, {
      selector: ':grabbed',
      matches: function matches(ele) {
        return ele.grabbed();
      }
    }, {
      selector: ':free',
      matches: function matches(ele) {
        return !ele.grabbed();
      }
    }, {
      selector: ':removed',
      matches: function matches(ele) {
        return ele.removed();
      }
    }, {
      selector: ':inside',
      matches: function matches(ele) {
        return !ele.removed();
      }
    }, {
      selector: ':grabbable',
      matches: function matches(ele) {
        return ele.grabbable();
      }
    }, {
      selector: ':ungrabbable',
      matches: function matches(ele) {
        return !ele.grabbable();
      }
    }, {
      selector: ':animated',
      matches: function matches(ele) {
        return ele.animated();
      }
    }, {
      selector: ':unanimated',
      matches: function matches(ele) {
        return !ele.animated();
      }
    }, {
      selector: ':parent',
      matches: function matches(ele) {
        return ele.isParent();
      }
    }, {
      selector: ':childless',
      matches: function matches(ele) {
        return ele.isChildless();
      }
    }, {
      selector: ':child',
      matches: function matches(ele) {
        return ele.isChild();
      }
    }, {
      selector: ':orphan',
      matches: function matches(ele) {
        return ele.isOrphan();
      }
    }, {
      selector: ':nonorphan',
      matches: function matches(ele) {
        return ele.isChild();
      }
    }, {
      selector: ':compound',
      matches: function matches(ele) {
        if (ele.isNode()) {
          return ele.isParent();
        } else {
          return ele.source().isParent() || ele.target().isParent();
        }
      }
    }, {
      selector: ':loop',
      matches: function matches(ele) {
        return ele.isLoop();
      }
    }, {
      selector: ':simple',
      matches: function matches(ele) {
        return ele.isSimple();
      }
    }, {
      selector: ':active',
      matches: function matches(ele) {
        return ele.active();
      }
    }, {
      selector: ':inactive',
      matches: function matches(ele) {
        return !ele.active();
      }
    }, {
      selector: ':backgrounding',
      matches: function matches(ele) {
        return ele.backgrounding();
      }
    }, {
      selector: ':nonbackgrounding',
      matches: function matches(ele) {
        return !ele.backgrounding();
      }
    }].sort(function (a, b) {
      // n.b. selectors that are starting substrings of others must have the longer ones first
      return descending(a.selector, b.selector);
    });
  
    var lookup = function () {
      var selToFn = {};
      var s;
  
      for (var i = 0; i < stateSelectors.length; i++) {
        s = stateSelectors[i];
        selToFn[s.selector] = s.matches;
      }
  
      return selToFn;
    }();
  
    var stateSelectorMatches = function stateSelectorMatches(sel, ele) {
      return lookup[sel](ele);
    };
    var stateSelectorRegex = '(' + stateSelectors.map(function (s) {
      return s.selector;
    }).join('|') + ')';
  
    // so that values get compared properly in Selector.filter()
  
    var cleanMetaChars = function cleanMetaChars(str) {
      return str.replace(new RegExp('\\\\(' + tokens.metaChar + ')', 'g'), function (match, $1) {
        return $1;
      });
    };
  
    var replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {
      selector[selector.length - 1] = replacementQuery;
    }; // NOTE: add new expression syntax here to have it recognised by the parser;
    // - a query contains all adjacent (i.e. no separator in between) expressions;
    // - the current query is stored in selector[i]
    // - you need to check the query objects in match() for it actually filter properly, but that's pretty straight forward
  
  
    var exprs = [{
      name: 'group',
      // just used for identifying when debugging
      query: true,
      regex: '(' + tokens.group + ')',
      populate: function populate(selector, query, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            group = _ref2[0];
  
        query.checks.push({
          type: Type.GROUP,
          value: group === '*' ? group : group + 's'
        });
      }
    }, {
      name: 'state',
      query: true,
      regex: stateSelectorRegex,
      populate: function populate(selector, query, _ref3) {
        var _ref4 = _slicedToArray(_ref3, 1),
            state = _ref4[0];
  
        query.checks.push({
          type: Type.STATE,
          value: state
        });
      }
    }, {
      name: 'id',
      query: true,
      regex: '\\#(' + tokens.id + ')',
      populate: function populate(selector, query, _ref5) {
        var _ref6 = _slicedToArray(_ref5, 1),
            id = _ref6[0];
  
        query.checks.push({
          type: Type.ID,
          value: cleanMetaChars(id)
        });
      }
    }, {
      name: 'className',
      query: true,
      regex: '\\.(' + tokens.className + ')',
      populate: function populate(selector, query, _ref7) {
        var _ref8 = _slicedToArray(_ref7, 1),
            className = _ref8[0];
  
        query.checks.push({
          type: Type.CLASS,
          value: cleanMetaChars(className)
        });
      }
    }, {
      name: 'dataExists',
      query: true,
      regex: '\\[\\s*(' + tokens.variable + ')\\s*\\]',
      populate: function populate(selector, query, _ref9) {
        var _ref10 = _slicedToArray(_ref9, 1),
            variable = _ref10[0];
  
        query.checks.push({
          type: Type.DATA_EXIST,
          field: cleanMetaChars(variable)
        });
      }
    }, {
      name: 'dataCompare',
      query: true,
      regex: '\\[\\s*(' + tokens.variable + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.value + ')\\s*\\]',
      populate: function populate(selector, query, _ref11) {
        var _ref12 = _slicedToArray(_ref11, 3),
            variable = _ref12[0],
            comparatorOp = _ref12[1],
            value = _ref12[2];
  
        var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;
  
        if (valueIsString) {
          value = value.substring(1, value.length - 1);
        } else {
          value = parseFloat(value);
        }
  
        query.checks.push({
          type: Type.DATA_COMPARE,
          field: cleanMetaChars(variable),
          operator: comparatorOp,
          value: value
        });
      }
    }, {
      name: 'dataBool',
      query: true,
      regex: '\\[\\s*(' + tokens.boolOp + ')\\s*(' + tokens.variable + ')\\s*\\]',
      populate: function populate(selector, query, _ref13) {
        var _ref14 = _slicedToArray(_ref13, 2),
            boolOp = _ref14[0],
            variable = _ref14[1];
  
        query.checks.push({
          type: Type.DATA_BOOL,
          field: cleanMetaChars(variable),
          operator: boolOp
        });
      }
    }, {
      name: 'metaCompare',
      query: true,
      regex: '\\[\\[\\s*(' + tokens.meta + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.number + ')\\s*\\]\\]',
      populate: function populate(selector, query, _ref15) {
        var _ref16 = _slicedToArray(_ref15, 3),
            meta = _ref16[0],
            comparatorOp = _ref16[1],
            number = _ref16[2];
  
        query.checks.push({
          type: Type.META_COMPARE,
          field: cleanMetaChars(meta),
          operator: comparatorOp,
          value: parseFloat(number)
        });
      }
    }, {
      name: 'nextQuery',
      separator: true,
      regex: tokens.separator,
      populate: function populate(selector, query) {
        var currentSubject = selector.currentSubject;
        var edgeCount = selector.edgeCount;
        var compoundCount = selector.compoundCount;
        var lastQ = selector[selector.length - 1];
  
        if (currentSubject != null) {
          lastQ.subject = currentSubject;
          selector.currentSubject = null;
        }
  
        lastQ.edgeCount = edgeCount;
        lastQ.compoundCount = compoundCount;
        selector.edgeCount = 0;
        selector.compoundCount = 0; // go on to next query
  
        var nextQuery = selector[selector.length++] = newQuery();
        return nextQuery; // this is the new query to be filled by the following exprs
      }
    }, {
      name: 'directedEdge',
      separator: true,
      regex: tokens.directedEdge,
      populate: function populate(selector, query) {
        if (selector.currentSubject == null) {
          // undirected edge
          var edgeQuery = newQuery();
          var source = query;
          var target = newQuery();
          edgeQuery.checks.push({
            type: Type.DIRECTED_EDGE,
            source: source,
            target: target
          }); // the query in the selector should be the edge rather than the source
  
          replaceLastQuery(selector, query, edgeQuery);
          selector.edgeCount++; // we're now populating the target query with expressions that follow
  
          return target;
        } else {
          // source/target
          var srcTgtQ = newQuery();
          var _source = query;
  
          var _target = newQuery();
  
          srcTgtQ.checks.push({
            type: Type.NODE_SOURCE,
            source: _source,
            target: _target
          }); // the query in the selector should be the neighbourhood rather than the node
  
          replaceLastQuery(selector, query, srcTgtQ);
          selector.edgeCount++;
          return _target; // now populating the target with the following expressions
        }
      }
    }, {
      name: 'undirectedEdge',
      separator: true,
      regex: tokens.undirectedEdge,
      populate: function populate(selector, query) {
        if (selector.currentSubject == null) {
          // undirected edge
          var edgeQuery = newQuery();
          var source = query;
          var target = newQuery();
          edgeQuery.checks.push({
            type: Type.UNDIRECTED_EDGE,
            nodes: [source, target]
          }); // the query in the selector should be the edge rather than the source
  
          replaceLastQuery(selector, query, edgeQuery);
          selector.edgeCount++; // we're now populating the target query with expressions that follow
  
          return target;
        } else {
          // neighbourhood
          var nhoodQ = newQuery();
          var node = query;
          var neighbor = newQuery();
          nhoodQ.checks.push({
            type: Type.NODE_NEIGHBOR,
            node: node,
            neighbor: neighbor
          }); // the query in the selector should be the neighbourhood rather than the node
  
          replaceLastQuery(selector, query, nhoodQ);
          return neighbor; // now populating the neighbor with following expressions
        }
      }
    }, {
      name: 'child',
      separator: true,
      regex: tokens.child,
      populate: function populate(selector, query) {
        if (selector.currentSubject == null) {
          // default: child query
          var parentChildQuery = newQuery();
          var child = newQuery();
          var parent = selector[selector.length - 1];
          parentChildQuery.checks.push({
            type: Type.CHILD,
            parent: parent,
            child: child
          }); // the query in the selector should be the '>' itself
  
          replaceLastQuery(selector, query, parentChildQuery);
          selector.compoundCount++; // we're now populating the child query with expressions that follow
  
          return child;
        } else if (selector.currentSubject === query) {
          // compound split query
          var compound = newQuery();
          var left = selector[selector.length - 1];
          var right = newQuery();
          var subject = newQuery();
  
          var _child = newQuery();
  
          var _parent = newQuery(); // set up the root compound q
  
  
          compound.checks.push({
            type: Type.COMPOUND_SPLIT,
            left: left,
            right: right,
            subject: subject
          }); // populate the subject and replace the q at the old spot (within left) with TRUE
  
          subject.checks = query.checks; // take the checks from the left
  
          query.checks = [{
            type: Type.TRUE
          }]; // checks under left refs the subject implicitly
          // set up the right q
  
          _parent.checks.push({
            type: Type.TRUE
          }); // parent implicitly refs the subject
  
  
          right.checks.push({
            type: Type.PARENT,
            // type is swapped on right side queries
            parent: _parent,
            child: _child // empty for now
  
          });
          replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`
  
          selector.currentSubject = subject;
          selector.compoundCount++;
          return _child; // now populating the right side's child
        } else {
          // parent query
          // info for parent query
          var _parent2 = newQuery();
  
          var _child2 = newQuery();
  
          var pcQChecks = [{
            type: Type.PARENT,
            parent: _parent2,
            child: _child2
          }]; // the parent-child query takes the place of the query previously being populated
  
          _parent2.checks = query.checks; // the previous query contains the checks for the parent
  
          query.checks = pcQChecks; // pc query takes over
  
          selector.compoundCount++;
          return _child2; // we're now populating the child
        }
      }
    }, {
      name: 'descendant',
      separator: true,
      regex: tokens.descendant,
      populate: function populate(selector, query) {
        if (selector.currentSubject == null) {
          // default: descendant query
          var ancChQuery = newQuery();
          var descendant = newQuery();
          var ancestor = selector[selector.length - 1];
          ancChQuery.checks.push({
            type: Type.DESCENDANT,
            ancestor: ancestor,
            descendant: descendant
          }); // the query in the selector should be the '>' itself
  
          replaceLastQuery(selector, query, ancChQuery);
          selector.compoundCount++; // we're now populating the descendant query with expressions that follow
  
          return descendant;
        } else if (selector.currentSubject === query) {
          // compound split query
          var compound = newQuery();
          var left = selector[selector.length - 1];
          var right = newQuery();
          var subject = newQuery();
  
          var _descendant = newQuery();
  
          var _ancestor = newQuery(); // set up the root compound q
  
  
          compound.checks.push({
            type: Type.COMPOUND_SPLIT,
            left: left,
            right: right,
            subject: subject
          }); // populate the subject and replace the q at the old spot (within left) with TRUE
  
          subject.checks = query.checks; // take the checks from the left
  
          query.checks = [{
            type: Type.TRUE
          }]; // checks under left refs the subject implicitly
          // set up the right q
  
          _ancestor.checks.push({
            type: Type.TRUE
          }); // ancestor implicitly refs the subject
  
  
          right.checks.push({
            type: Type.ANCESTOR,
            // type is swapped on right side queries
            ancestor: _ancestor,
            descendant: _descendant // empty for now
  
          });
          replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`
  
          selector.currentSubject = subject;
          selector.compoundCount++;
          return _descendant; // now populating the right side's descendant
        } else {
          // ancestor query
          // info for parent query
          var _ancestor2 = newQuery();
  
          var _descendant2 = newQuery();
  
          var adQChecks = [{
            type: Type.ANCESTOR,
            ancestor: _ancestor2,
            descendant: _descendant2
          }]; // the parent-child query takes the place of the query previously being populated
  
          _ancestor2.checks = query.checks; // the previous query contains the checks for the parent
  
          query.checks = adQChecks; // pc query takes over
  
          selector.compoundCount++;
          return _descendant2; // we're now populating the child
        }
      }
    }, {
      name: 'subject',
      modifier: true,
      regex: tokens.subject,
      populate: function populate(selector, query) {
        if (selector.currentSubject != null && selector.currentSubject !== query) {
          warn('Redefinition of subject in selector `' + selector.toString() + '`');
          return false;
        }
  
        selector.currentSubject = query;
        var topQ = selector[selector.length - 1];
        var topChk = topQ.checks[0];
        var topType = topChk == null ? null : topChk.type;
  
        if (topType === Type.DIRECTED_EDGE) {
          // directed edge with subject on the target
          // change to target node check
          topChk.type = Type.NODE_TARGET;
        } else if (topType === Type.UNDIRECTED_EDGE) {
          // undirected edge with subject on the second node
          // change to neighbor check
          topChk.type = Type.NODE_NEIGHBOR;
          topChk.node = topChk.nodes[1]; // second node is subject
  
          topChk.neighbor = topChk.nodes[0]; // clean up unused fields for new type
  
          topChk.nodes = null;
        }
      }
    }];
    exprs.forEach(function (e) {
      return e.regexObj = new RegExp('^' + e.regex);
    });
  
    /**
     * Of all the expressions, find the first match in the remaining text.
     * @param {string} remaining The remaining text to parse
     * @returns The matched expression and the newly remaining text `{ expr, match, name, remaining }`
     */
  
    var consumeExpr = function consumeExpr(remaining) {
      var expr;
      var match;
      var name;
  
      for (var j = 0; j < exprs.length; j++) {
        var e = exprs[j];
        var n = e.name;
        var m = remaining.match(e.regexObj);
  
        if (m != null) {
          match = m;
          expr = e;
          name = n;
          var consumed = m[0];
          remaining = remaining.substring(consumed.length);
          break; // we've consumed one expr, so we can return now
        }
      }
  
      return {
        expr: expr,
        match: match,
        name: name,
        remaining: remaining
      };
    };
    /**
     * Consume all the leading whitespace
     * @param {string} remaining The text to consume
     * @returns The text with the leading whitespace removed
     */
  
  
    var consumeWhitespace = function consumeWhitespace(remaining) {
      var match = remaining.match(/^\s+/);
  
      if (match) {
        var consumed = match[0];
        remaining = remaining.substring(consumed.length);
      }
  
      return remaining;
    };
    /**
     * Parse the string and store the parsed representation in the Selector.
     * @param {string} selector The selector string
     * @returns `true` if the selector was successfully parsed, `false` otherwise
     */
  
  
    var parse = function parse(selector) {
      var self = this;
      var remaining = self.inputText = selector;
      var currentQuery = self[0] = newQuery();
      self.length = 1;
      remaining = consumeWhitespace(remaining); // get rid of leading whitespace
  
      for (;;) {
        var exprInfo = consumeExpr(remaining);
  
        if (exprInfo.expr == null) {
          warn('The selector `' + selector + '`is invalid');
          return false;
        } else {
          var args = exprInfo.match.slice(1); // let the token populate the selector object in currentQuery
  
          var ret = exprInfo.expr.populate(self, currentQuery, args);
  
          if (ret === false) {
            return false; // exit if population failed
          } else if (ret != null) {
            currentQuery = ret; // change the current query to be filled if the expr specifies
          }
        }
  
        remaining = exprInfo.remaining; // we're done when there's nothing left to parse
  
        if (remaining.match(/^\s*$/)) {
          break;
        }
      }
  
      var lastQ = self[self.length - 1];
  
      if (self.currentSubject != null) {
        lastQ.subject = self.currentSubject;
      }
  
      lastQ.edgeCount = self.edgeCount;
      lastQ.compoundCount = self.compoundCount;
  
      for (var i = 0; i < self.length; i++) {
        var q = self[i]; // in future, this could potentially be allowed if there were operator precedence and detection of invalid combinations
  
        if (q.compoundCount > 0 && q.edgeCount > 0) {
          warn('The selector `' + selector + '` is invalid because it uses both a compound selector and an edge selector');
          return false;
        }
  
        if (q.edgeCount > 1) {
          warn('The selector `' + selector + '` is invalid because it uses multiple edge selectors');
          return false;
        } else if (q.edgeCount === 1) {
          warn('The selector `' + selector + '` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.');
        }
      }
  
      return true; // success
    };
    /**
     * Get the selector represented as a string.  This value uses default formatting,
     * so things like spacing may differ from the input text passed to the constructor.
     * @returns {string} The selector string
     */
  
  
    var toString = function toString() {
      if (this.toStringCache != null) {
        return this.toStringCache;
      }
  
      var clean = function clean(obj) {
        if (obj == null) {
          return '';
        } else {
          return obj;
        }
      };
  
      var cleanVal = function cleanVal(val) {
        if (string(val)) {
          return '"' + val + '"';
        } else {
          return clean(val);
        }
      };
  
      var space = function space(val) {
        return ' ' + val + ' ';
      };
  
      var checkToString = function checkToString(check, subject) {
        var type = check.type,
            value = check.value;
  
        switch (type) {
          case Type.GROUP:
            {
              var group = clean(value);
              return group.substring(0, group.length - 1);
            }
  
          case Type.DATA_COMPARE:
            {
              var field = check.field,
                  operator = check.operator;
              return '[' + field + space(clean(operator)) + cleanVal(value) + ']';
            }
  
          case Type.DATA_BOOL:
            {
              var _operator = check.operator,
                  _field = check.field;
              return '[' + clean(_operator) + _field + ']';
            }
  
          case Type.DATA_EXIST:
            {
              var _field2 = check.field;
              return '[' + _field2 + ']';
            }
  
          case Type.META_COMPARE:
            {
              var _operator2 = check.operator,
                  _field3 = check.field;
              return '[[' + _field3 + space(clean(_operator2)) + cleanVal(value) + ']]';
            }
  
          case Type.STATE:
            {
              return value;
            }
  
          case Type.ID:
            {
              return '#' + value;
            }
  
          case Type.CLASS:
            {
              return '.' + value;
            }
  
          case Type.PARENT:
          case Type.CHILD:
            {
              return queryToString(check.parent, subject) + space('>') + queryToString(check.child, subject);
            }
  
          case Type.ANCESTOR:
          case Type.DESCENDANT:
            {
              return queryToString(check.ancestor, subject) + ' ' + queryToString(check.descendant, subject);
            }
  
          case Type.COMPOUND_SPLIT:
            {
              var lhs = queryToString(check.left, subject);
              var sub = queryToString(check.subject, subject);
              var rhs = queryToString(check.right, subject);
              return lhs + (lhs.length > 0 ? ' ' : '') + sub + rhs;
            }
  
          case Type.TRUE:
            {
              return '';
            }
        }
      };
  
      var queryToString = function queryToString(query, subject) {
        return query.checks.reduce(function (str, chk, i) {
          return str + (subject === query && i === 0 ? '$' : '') + checkToString(chk, subject);
        }, '');
      };
  
      var str = '';
  
      for (var i = 0; i < this.length; i++) {
        var query = this[i];
        str += queryToString(query, query.subject);
  
        if (this.length > 1 && i < this.length - 1) {
          str += ', ';
        }
      }
  
      this.toStringCache = str;
      return str;
    };
    var parse$1 = {
      parse: parse,
      toString: toString
    };
  
    var valCmp = function valCmp(fieldVal, operator, value) {
      var matches;
      var isFieldStr = string(fieldVal);
      var isFieldNum = number(fieldVal);
      var isValStr = string(value);
      var fieldStr, valStr;
      var caseInsensitive = false;
      var notExpr = false;
      var isIneqCmp = false;
  
      if (operator.indexOf('!') >= 0) {
        operator = operator.replace('!', '');
        notExpr = true;
      }
  
      if (operator.indexOf('@') >= 0) {
        operator = operator.replace('@', '');
        caseInsensitive = true;
      }
  
      if (isFieldStr || isValStr || caseInsensitive) {
        fieldStr = !isFieldStr && !isFieldNum ? '' : '' + fieldVal;
        valStr = '' + value;
      } // if we're doing a case insensitive comparison, then we're using a STRING comparison
      // even if we're comparing numbers
  
  
      if (caseInsensitive) {
        fieldVal = fieldStr = fieldStr.toLowerCase();
        value = valStr = valStr.toLowerCase();
      }
  
      switch (operator) {
        case '*=':
          matches = fieldStr.indexOf(valStr) >= 0;
          break;
  
        case '$=':
          matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;
          break;
  
        case '^=':
          matches = fieldStr.indexOf(valStr) === 0;
          break;
  
        case '=':
          matches = fieldVal === value;
          break;
  
        case '>':
          isIneqCmp = true;
          matches = fieldVal > value;
          break;
  
        case '>=':
          isIneqCmp = true;
          matches = fieldVal >= value;
          break;
  
        case '<':
          isIneqCmp = true;
          matches = fieldVal < value;
          break;
  
        case '<=':
          isIneqCmp = true;
          matches = fieldVal <= value;
          break;
  
        default:
          matches = false;
          break;
      } // apply the not op, but null vals for inequalities should always stay non-matching
  
  
      if (notExpr && (fieldVal != null || !isIneqCmp)) {
        matches = !matches;
      }
  
      return matches;
    };
    var boolCmp = function boolCmp(fieldVal, operator) {
      switch (operator) {
        case '?':
          return fieldVal ? true : false;
  
        case '!':
          return fieldVal ? false : true;
  
        case '^':
          return fieldVal === undefined;
      }
    };
    var existCmp = function existCmp(fieldVal) {
      return fieldVal !== undefined;
    };
    var data = function data(ele, field) {
      return ele.data(field);
    };
    var meta = function meta(ele, field) {
      return ele[field]();
    };
  
    /** A lookup of `match(check, ele)` functions by `Type` int */
  
    var match = [];
    /**
     * Returns whether the query matches for the element
     * @param query The `{ type, value, ... }` query object
     * @param ele The element to compare against
    */
  
    var matches = function matches(query, ele) {
      return query.checks.every(function (chk) {
        return match[chk.type](chk, ele);
      });
    };
  
    match[Type.GROUP] = function (check, ele) {
      var group = check.value;
      return group === '*' || group === ele.group();
    };
  
    match[Type.STATE] = function (check, ele) {
      var stateSelector = check.value;
      return stateSelectorMatches(stateSelector, ele);
    };
  
    match[Type.ID] = function (check, ele) {
      var id = check.value;
      return ele.id() === id;
    };
  
    match[Type.CLASS] = function (check, ele) {
      var cls = check.value;
      return ele.hasClass(cls);
    };
  
    match[Type.META_COMPARE] = function (check, ele) {
      var field = check.field,
          operator = check.operator,
          value = check.value;
      return valCmp(meta(ele, field), operator, value);
    };
  
    match[Type.DATA_COMPARE] = function (check, ele) {
      var field = check.field,
          operator = check.operator,
          value = check.value;
      return valCmp(data(ele, field), operator, value);
    };
  
    match[Type.DATA_BOOL] = function (check, ele) {
      var field = check.field,
          operator = check.operator;
      return boolCmp(data(ele, field), operator);
    };
  
    match[Type.DATA_EXIST] = function (check, ele) {
      var field = check.field,
          operator = check.operator;
      return existCmp(data(ele, field));
    };
  
    match[Type.UNDIRECTED_EDGE] = function (check, ele) {
      var qA = check.nodes[0];
      var qB = check.nodes[1];
      var src = ele.source();
      var tgt = ele.target();
      return matches(qA, src) && matches(qB, tgt) || matches(qB, src) && matches(qA, tgt);
    };
  
    match[Type.NODE_NEIGHBOR] = function (check, ele) {
      return matches(check.node, ele) && ele.neighborhood().some(function (n) {
        return n.isNode() && matches(check.neighbor, n);
      });
    };
  
    match[Type.DIRECTED_EDGE] = function (check, ele) {
      return matches(check.source, ele.source()) && matches(check.target, ele.target());
    };
  
    match[Type.NODE_SOURCE] = function (check, ele) {
      return matches(check.source, ele) && ele.outgoers().some(function (n) {
        return n.isNode() && matches(check.target, n);
      });
    };
  
    match[Type.NODE_TARGET] = function (check, ele) {
      return matches(check.target, ele) && ele.incomers().some(function (n) {
        return n.isNode() && matches(check.source, n);
      });
    };
  
    match[Type.CHILD] = function (check, ele) {
      return matches(check.child, ele) && matches(check.parent, ele.parent());
    };
  
    match[Type.PARENT] = function (check, ele) {
      return matches(check.parent, ele) && ele.children().some(function (c) {
        return matches(check.child, c);
      });
    };
  
    match[Type.DESCENDANT] = function (check, ele) {
      return matches(check.descendant, ele) && ele.ancestors().some(function (a) {
        return matches(check.ancestor, a);
      });
    };
  
    match[Type.ANCESTOR] = function (check, ele) {
      return matches(check.ancestor, ele) && ele.descendants().some(function (d) {
        return matches(check.descendant, d);
      });
    };
  
    match[Type.COMPOUND_SPLIT] = function (check, ele) {
      return matches(check.subject, ele) && matches(check.left, ele) && matches(check.right, ele);
    };
  
    match[Type.TRUE] = function () {
      return true;
    };
  
    match[Type.COLLECTION] = function (check, ele) {
      var collection = check.value;
      return collection.has(ele);
    };
  
    match[Type.FILTER] = function (check, ele) {
      var filter = check.value;
      return filter(ele);
    };
  
    var filter = function filter(collection) {
      var self = this; // for 1 id #foo queries, just get the element
  
      if (self.length === 1 && self[0].checks.length === 1 && self[0].checks[0].type === Type.ID) {
        return collection.getElementById(self[0].checks[0].value).collection();
      }
  
      var selectorFunction = function selectorFunction(element) {
        for (var j = 0; j < self.length; j++) {
          var query = self[j];
  
          if (matches(query, element)) {
            return true;
          }
        }
  
        return false;
      };
  
      if (self.text() == null) {
        selectorFunction = function selectorFunction() {
          return true;
        };
      }
  
      return collection.filter(selectorFunction);
    }; // filter
    // does selector match a single element?
  
  
    var matches$1 = function matches$1(ele) {
      var self = this;
  
      for (var j = 0; j < self.length; j++) {
        var query = self[j];
  
        if (matches(query, ele)) {
          return true;
        }
      }
  
      return false;
    }; // matches
  
  
    var matching = {
      matches: matches$1,
      filter: filter
    };
  
    var Selector = function Selector(selector) {
      this.inputText = selector;
      this.currentSubject = null;
      this.compoundCount = 0;
      this.edgeCount = 0;
      this.length = 0;
  
      if (selector == null || string(selector) && selector.match(/^\s*$/)) ; else if (elementOrCollection(selector)) {
        this.addQuery({
          checks: [{
            type: Type.COLLECTION,
            value: selector.collection()
          }]
        });
      } else if (fn(selector)) {
        this.addQuery({
          checks: [{
            type: Type.FILTER,
            value: selector
          }]
        });
      } else if (string(selector)) {
        if (!this.parse(selector)) {
          this.invalid = true;
        }
      } else {
        error('A selector must be created from a string; found ');
      }
    };
  
    var selfn = Selector.prototype;
    [parse$1, matching].forEach(function (p) {
      return extend(selfn, p);
    });
  
    selfn.text = function () {
      return this.inputText;
    };
  
    selfn.size = function () {
      return this.length;
    };
  
    selfn.eq = function (i) {
      return this[i];
    };
  
    selfn.sameText = function (otherSel) {
      return !this.invalid && !otherSel.invalid && this.text() === otherSel.text();
    };
  
    selfn.addQuery = function (q) {
      this[this.length++] = q;
    };
  
    selfn.selector = selfn.toString;
  
    var elesfn$f = {
      allAre: function allAre(selector) {
        var selObj = new Selector(selector);
        return this.every(function (ele) {
          return selObj.matches(ele);
        });
      },
      is: function is(selector) {
        var selObj = new Selector(selector);
        return this.some(function (ele) {
          return selObj.matches(ele);
        });
      },
      some: function some(fn, thisArg) {
        for (var i = 0; i < this.length; i++) {
          var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);
  
          if (ret) {
            return true;
          }
        }
  
        return false;
      },
      every: function every(fn, thisArg) {
        for (var i = 0; i < this.length; i++) {
          var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);
  
          if (!ret) {
            return false;
          }
        }
  
        return true;
      },
      same: function same(collection) {
        // cheap collection ref check
        if (this === collection) {
          return true;
        }
  
        collection = this.cy().collection(collection);
        var thisLength = this.length;
        var collectionLength = collection.length; // cheap length check
  
        if (thisLength !== collectionLength) {
          return false;
        } // cheap element ref check
  
  
        if (thisLength === 1) {
          return this[0] === collection[0];
        }
  
        return this.every(function (ele) {
          return collection.hasElementWithId(ele.id());
        });
      },
      anySame: function anySame(collection) {
        collection = this.cy().collection(collection);
        return this.some(function (ele) {
          return collection.hasElementWithId(ele.id());
        });
      },
      allAreNeighbors: function allAreNeighbors(collection) {
        collection = this.cy().collection(collection);
        var nhood = this.neighborhood();
        return collection.every(function (ele) {
          return nhood.hasElementWithId(ele.id());
        });
      },
      contains: function contains(collection) {
        collection = this.cy().collection(collection);
        var self = this;
        return collection.every(function (ele) {
          return self.hasElementWithId(ele.id());
        });
      }
    };
    elesfn$f.allAreNeighbours = elesfn$f.allAreNeighbors;
    elesfn$f.has = elesfn$f.contains;
    elesfn$f.equal = elesfn$f.equals = elesfn$f.same;
  
    var cache = function cache(fn, name) {
      return function traversalCache(arg1, arg2, arg3, arg4) {
        var selectorOrEles = arg1;
        var eles = this;
        var key;
  
        if (selectorOrEles == null) {
          key = '';
        } else if (elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {
          key = selectorOrEles.id();
        }
  
        if (eles.length === 1 && key) {
          var _p = eles[0]._private;
          var tch = _p.traversalCache = _p.traversalCache || {};
          var ch = tch[name] = tch[name] || [];
          var hash = hashString(key);
          var cacheHit = ch[hash];
  
          if (cacheHit) {
            return cacheHit;
          } else {
            return ch[hash] = fn.call(eles, arg1, arg2, arg3, arg4);
          }
        } else {
          return fn.call(eles, arg1, arg2, arg3, arg4);
        }
      };
    };
  
    var elesfn$g = {
      parent: function parent(selector) {
        var parents = []; // optimisation for single ele call
  
        if (this.length === 1) {
          var parent = this[0]._private.parent;
  
          if (parent) {
            return parent;
          }
        }
  
        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
          var _parent = ele._private.parent;
  
          if (_parent) {
            parents.push(_parent);
          }
        }
  
        return this.spawn(parents, {
          unique: true
        }).filter(selector);
      },
      parents: function parents(selector) {
        var parents = [];
        var eles = this.parent();
  
        while (eles.nonempty()) {
          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            parents.push(ele);
          }
  
          eles = eles.parent();
        }
  
        return this.spawn(parents, {
          unique: true
        }).filter(selector);
      },
      commonAncestors: function commonAncestors(selector) {
        var ancestors;
  
        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
          var parents = ele.parents();
          ancestors = ancestors || parents;
          ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set
        }
  
        return ancestors.filter(selector);
      },
      orphans: function orphans(selector) {
        return this.stdFilter(function (ele) {
          return ele.isOrphan();
        }).filter(selector);
      },
      nonorphans: function nonorphans(selector) {
        return this.stdFilter(function (ele) {
          return ele.isChild();
        }).filter(selector);
      },
      children: cache(function (selector) {
        var children = [];
  
        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
          var eleChildren = ele._private.children;
  
          for (var j = 0; j < eleChildren.length; j++) {
            children.push(eleChildren[j]);
          }
        }
  
        return this.spawn(children, {
          unique: true
        }).filter(selector);
      }, 'children'),
      siblings: function siblings(selector) {
        return this.parent().children().not(this).filter(selector);
      },
      isParent: function isParent() {
        var ele = this[0];
  
        if (ele) {
          return ele.isNode() && ele._private.children.length !== 0;
        }
      },
      isChildless: function isChildless() {
        var ele = this[0];
  
        if (ele) {
          return ele.isNode() && ele._private.children.length === 0;
        }
      },
      isChild: function isChild() {
        var ele = this[0];
  
        if (ele) {
          return ele.isNode() && ele._private.parent != null;
        }
      },
      isOrphan: function isOrphan() {
        var ele = this[0];
  
        if (ele) {
          return ele.isNode() && ele._private.parent == null;
        }
      },
      descendants: function descendants(selector) {
        var elements = [];
  
        function add(eles) {
          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            elements.push(ele);
  
            if (ele.children().nonempty()) {
              add(ele.children());
            }
          }
        }
  
        add(this.children());
        return this.spawn(elements, {
          unique: true
        }).filter(selector);
      }
    };
  
    function forEachCompound(eles, fn, includeSelf, recursiveStep) {
      var q = [];
      var did = new Set$1();
      var cy = eles.cy();
      var hasCompounds = cy.hasCompoundNodes();
  
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
  
        if (includeSelf) {
          q.push(ele);
        } else if (hasCompounds) {
          recursiveStep(q, did, ele);
        }
      }
  
      while (q.length > 0) {
        var _ele = q.shift();
  
        fn(_ele);
        did.add(_ele.id());
  
        if (hasCompounds) {
          recursiveStep(q, did, _ele);
        }
      }
  
      return eles;
    }
  
    function addChildren(q, did, ele) {
      if (ele.isParent()) {
        var children = ele._private.children;
  
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
  
          if (!did.has(child.id())) {
            q.push(child);
          }
        }
      }
    } // very efficient version of eles.add( eles.descendants() ).forEach()
    // for internal use
  
  
    elesfn$g.forEachDown = function (fn) {
      var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return forEachCompound(this, fn, includeSelf, addChildren);
    };
  
    function addParent(q, did, ele) {
      if (ele.isChild()) {
        var parent = ele._private.parent;
  
        if (!did.has(parent.id())) {
          q.push(parent);
        }
      }
    }
  
    elesfn$g.forEachUp = function (fn) {
      var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return forEachCompound(this, fn, includeSelf, addParent);
    };
  
    function addParentAndChildren(q, did, ele) {
      addParent(q, did, ele);
      addChildren(q, did, ele);
    }
  
    elesfn$g.forEachUpAndDown = function (fn) {
      var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return forEachCompound(this, fn, includeSelf, addParentAndChildren);
    }; // aliases
  
  
    elesfn$g.ancestors = elesfn$g.parents;
  
    var fn$1, elesfn$h;
    fn$1 = elesfn$h = {
      data: define$3.data({
        field: 'data',
        bindingEvent: 'data',
        allowBinding: true,
        allowSetting: true,
        settingEvent: 'data',
        settingTriggersEvent: true,
        triggerFnName: 'trigger',
        allowGetting: true,
        immutableKeys: {
          'id': true,
          'source': true,
          'target': true,
          'parent': true
        },
        updateStyle: true
      }),
      removeData: define$3.removeData({
        field: 'data',
        event: 'data',
        triggerFnName: 'trigger',
        triggerEvent: true,
        immutableKeys: {
          'id': true,
          'source': true,
          'target': true,
          'parent': true
        },
        updateStyle: true
      }),
      scratch: define$3.data({
        field: 'scratch',
        bindingEvent: 'scratch',
        allowBinding: true,
        allowSetting: true,
        settingEvent: 'scratch',
        settingTriggersEvent: true,
        triggerFnName: 'trigger',
        allowGetting: true,
        updateStyle: true
      }),
      removeScratch: define$3.removeData({
        field: 'scratch',
        event: 'scratch',
        triggerFnName: 'trigger',
        triggerEvent: true,
        updateStyle: true
      }),
      rscratch: define$3.data({
        field: 'rscratch',
        allowBinding: false,
        allowSetting: true,
        settingTriggersEvent: false,
        allowGetting: true
      }),
      removeRscratch: define$3.removeData({
        field: 'rscratch',
        triggerEvent: false
      }),
      id: function id() {
        var ele = this[0];
  
        if (ele) {
          return ele._private.data.id;
        }
      }
    }; // aliases
  
    fn$1.attr = fn$1.data;
    fn$1.removeAttr = fn$1.removeData;
    var data$1 = elesfn$h;
  
    var elesfn$i = {};
  
    function defineDegreeFunction(callback) {
      return function (includeLoops) {
        var self = this;
  
        if (includeLoops === undefined) {
          includeLoops = true;
        }
  
        if (self.length === 0) {
          return;
        }
  
        if (self.isNode() && !self.removed()) {
          var degree = 0;
          var node = self[0];
          var connectedEdges = node._private.edges;
  
          for (var i = 0; i < connectedEdges.length; i++) {
            var edge = connectedEdges[i];
  
            if (!includeLoops && edge.isLoop()) {
              continue;
            }
  
            degree += callback(node, edge);
          }
  
          return degree;
        } else {
          return;
        }
      };
    }
  
    extend(elesfn$i, {
      degree: defineDegreeFunction(function (node, edge) {
        if (edge.source().same(edge.target())) {
          return 2;
        } else {
          return 1;
        }
      }),
      indegree: defineDegreeFunction(function (node, edge) {
        if (edge.target().same(node)) {
          return 1;
        } else {
          return 0;
        }
      }),
      outdegree: defineDegreeFunction(function (node, edge) {
        if (edge.source().same(node)) {
          return 1;
        } else {
          return 0;
        }
      })
    });
  
    function defineDegreeBoundsFunction(degreeFn, callback) {
      return function (includeLoops) {
        var ret;
        var nodes = this.nodes();
  
        for (var i = 0; i < nodes.length; i++) {
          var ele = nodes[i];
          var degree = ele[degreeFn](includeLoops);
  
          if (degree !== undefined && (ret === undefined || callback(degree, ret))) {
            ret = degree;
          }
        }
  
        return ret;
      };
    }
  
    extend(elesfn$i, {
      minDegree: defineDegreeBoundsFunction('degree', function (degree, min) {
        return degree < min;
      }),
      maxDegree: defineDegreeBoundsFunction('degree', function (degree, max) {
        return degree > max;
      }),
      minIndegree: defineDegreeBoundsFunction('indegree', function (degree, min) {
        return degree < min;
      }),
      maxIndegree: defineDegreeBoundsFunction('indegree', function (degree, max) {
        return degree > max;
      }),
      minOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, min) {
        return degree < min;
      }),
      maxOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, max) {
        return degree > max;
      })
    });
    extend(elesfn$i, {
      totalDegree: function totalDegree(includeLoops) {
        var total = 0;
        var nodes = this.nodes();
  
        for (var i = 0; i < nodes.length; i++) {
          total += nodes[i].degree(includeLoops);
        }
  
        return total;
      }
    });
  
    var fn$2, elesfn$j;
  
    var beforePositionSet = function beforePositionSet(eles, newPos, silent) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
  
        if (!ele.locked()) {
          var oldPos = ele._private.position;
          var delta = {
            x: newPos.x != null ? newPos.x - oldPos.x : 0,
            y: newPos.y != null ? newPos.y - oldPos.y : 0
          };
  
          if (ele.isParent() && !(delta.x === 0 && delta.y === 0)) {
            ele.children().shift(delta, silent);
          }
  
          ele.shiftCachedBoundingBox(delta);
        }
      }
    };
  
    var positionDef = {
      field: 'position',
      bindingEvent: 'position',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'position',
      settingTriggersEvent: true,
      triggerFnName: 'emitAndNotify',
      allowGetting: true,
      validKeys: ['x', 'y'],
      beforeGet: function beforeGet(ele) {
        ele.updateCompoundBounds();
      },
      beforeSet: function beforeSet(eles, newPos) {
        beforePositionSet(eles, newPos, false);
      },
      onSet: function onSet(eles) {
        eles.dirtyCompoundBoundsCache();
      },
      canSet: function canSet(ele) {
        return !ele.locked();
      }
    };
    fn$2 = elesfn$j = {
      position: define$3.data(positionDef),
      // position but no notification to renderer
      silentPosition: define$3.data(extend({}, positionDef, {
        allowBinding: false,
        allowSetting: true,
        settingTriggersEvent: false,
        allowGetting: false,
        beforeSet: function beforeSet(eles, newPos) {
          beforePositionSet(eles, newPos, true);
        }
      })),
      positions: function positions(pos, silent) {
        if (plainObject(pos)) {
          if (silent) {
            this.silentPosition(pos);
          } else {
            this.position(pos);
          }
        } else if (fn(pos)) {
          var _fn = pos;
          var cy = this.cy();
          cy.startBatch();
  
          for (var i = 0; i < this.length; i++) {
            var ele = this[i];
  
            var _pos = void 0;
  
            if (_pos = _fn(ele, i)) {
              if (silent) {
                ele.silentPosition(_pos);
              } else {
                ele.position(_pos);
              }
            }
          }
  
          cy.endBatch();
        }
  
        return this; // chaining
      },
      silentPositions: function silentPositions(pos) {
        return this.positions(pos, true);
      },
      shift: function shift(dim, val, silent) {
        var delta;
  
        if (plainObject(dim)) {
          delta = {
            x: number(dim.x) ? dim.x : 0,
            y: number(dim.y) ? dim.y : 0
          };
          silent = val;
        } else if (string(dim) && number(val)) {
          delta = {
            x: 0,
            y: 0
          };
          delta[dim] = val;
        }
  
        if (delta != null) {
          var cy = this.cy();
          cy.startBatch();
  
          for (var i = 0; i < this.length; i++) {
            var ele = this[i];
            var pos = ele.position();
            var newPos = {
              x: pos.x + delta.x,
              y: pos.y + delta.y
            };
  
            if (silent) {
              ele.silentPosition(newPos);
            } else {
              ele.position(newPos);
            }
          }
  
          cy.endBatch();
        }
  
        return this;
      },
      silentShift: function silentShift(dim, val) {
        if (plainObject(dim)) {
          this.shift(dim, true);
        } else if (string(dim) && number(val)) {
          this.shift(dim, val, true);
        }
  
        return this;
      },
      // get/set the rendered (i.e. on screen) positon of the element
      renderedPosition: function renderedPosition(dim, val) {
        var ele = this[0];
        var cy = this.cy();
        var zoom = cy.zoom();
        var pan = cy.pan();
        var rpos = plainObject(dim) ? dim : undefined;
        var setting = rpos !== undefined || val !== undefined && string(dim);
  
        if (ele && ele.isNode()) {
          // must have an element and must be a node to return position
          if (setting) {
            for (var i = 0; i < this.length; i++) {
              var _ele = this[i];
  
              if (val !== undefined) {
                // set one dimension
                _ele.position(dim, (val - pan[dim]) / zoom);
              } else if (rpos !== undefined) {
                // set whole position
                _ele.position(renderedToModelPosition(rpos, zoom, pan));
              }
            }
          } else {
            // getting
            var pos = ele.position();
            rpos = modelToRenderedPosition(pos, zoom, pan);
  
            if (dim === undefined) {
              // then return the whole rendered position
              return rpos;
            } else {
              // then return the specified dimension
              return rpos[dim];
            }
          }
        } else if (!setting) {
          return undefined; // for empty collection case
        }
  
        return this; // chaining
      },
      // get/set the position relative to the parent
      relativePosition: function relativePosition(dim, val) {
        var ele = this[0];
        var cy = this.cy();
        var ppos = plainObject(dim) ? dim : undefined;
        var setting = ppos !== undefined || val !== undefined && string(dim);
        var hasCompoundNodes = cy.hasCompoundNodes();
  
        if (ele && ele.isNode()) {
          // must have an element and must be a node to return position
          if (setting) {
            for (var i = 0; i < this.length; i++) {
              var _ele2 = this[i];
              var parent = hasCompoundNodes ? _ele2.parent() : null;
              var hasParent = parent && parent.length > 0;
              var relativeToParent = hasParent;
  
              if (hasParent) {
                parent = parent[0];
              }
  
              var origin = relativeToParent ? parent.position() : {
                x: 0,
                y: 0
              };
  
              if (val !== undefined) {
                // set one dimension
                _ele2.position(dim, val + origin[dim]);
              } else if (ppos !== undefined) {
                // set whole position
                _ele2.position({
                  x: ppos.x + origin.x,
                  y: ppos.y + origin.y
                });
              }
            }
          } else {
            // getting
            var pos = ele.position();
  
            var _parent = hasCompoundNodes ? ele.parent() : null;
  
            var _hasParent = _parent && _parent.length > 0;
  
            var _relativeToParent = _hasParent;
  
            if (_hasParent) {
              _parent = _parent[0];
            }
  
            var _origin = _relativeToParent ? _parent.position() : {
              x: 0,
              y: 0
            };
  
            ppos = {
              x: pos.x - _origin.x,
              y: pos.y - _origin.y
            };
  
            if (dim === undefined) {
              // then return the whole rendered position
              return ppos;
            } else {
              // then return the specified dimension
              return ppos[dim];
            }
          }
        } else if (!setting) {
          return undefined; // for empty collection case
        }
  
        return this; // chaining
      }
    }; // aliases
  
    fn$2.modelPosition = fn$2.point = fn$2.position;
    fn$2.modelPositions = fn$2.points = fn$2.positions;
    fn$2.renderedPoint = fn$2.renderedPosition;
    fn$2.relativePoint = fn$2.relativePosition;
    var position = elesfn$j;
  
    var fn$3, elesfn$k;
    fn$3 = elesfn$k = {};
  
    elesfn$k.renderedBoundingBox = function (options) {
      var bb = this.boundingBox(options);
      var cy = this.cy();
      var zoom = cy.zoom();
      var pan = cy.pan();
      var x1 = bb.x1 * zoom + pan.x;
      var x2 = bb.x2 * zoom + pan.x;
      var y1 = bb.y1 * zoom + pan.y;
      var y2 = bb.y2 * zoom + pan.y;
      return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2,
        w: x2 - x1,
        h: y2 - y1
      };
    };
  
    elesfn$k.dirtyCompoundBoundsCache = function () {
      var cy = this.cy();
  
      if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
        return this;
      }
  
      this.forEachUp(function (ele) {
        if (ele.isParent()) {
          var _p = ele._private;
          _p.compoundBoundsClean = false;
          _p.bbCache = null;
          ele.emitAndNotify('bounds');
        }
      });
      return this;
    };
  
    elesfn$k.updateCompoundBounds = function () {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var cy = this.cy(); // not possible to do on non-compound graphs or with the style disabled
  
      if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
        return this;
      } // save cycles when batching -- but bounds will be stale (or not exist yet)
  
  
      if (!force && cy.batching()) {
        return this;
      }
  
      function update(parent) {
        if (!parent.isParent()) {
          return;
        }
  
        var _p = parent._private;
        var children = parent.children();
        var includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';
        var min = {
          width: {
            val: parent.pstyle('min-width').pfValue,
            left: parent.pstyle('min-width-bias-left'),
            right: parent.pstyle('min-width-bias-right')
          },
          height: {
            val: parent.pstyle('min-height').pfValue,
            top: parent.pstyle('min-height-bias-top'),
            bottom: parent.pstyle('min-height-bias-bottom')
          }
        };
        var bb = children.boundingBox({
          includeLabels: includeLabels,
          includeOverlays: false,
          // updating the compound bounds happens outside of the regular
          // cache cycle (i.e. before fired events)
          useCache: false
        });
        var pos = _p.position; // if children take up zero area then keep position and fall back on stylesheet w/h
  
        if (bb.w === 0 || bb.h === 0) {
          bb = {
            w: parent.pstyle('width').pfValue,
            h: parent.pstyle('height').pfValue
          };
          bb.x1 = pos.x - bb.w / 2;
          bb.x2 = pos.x + bb.w / 2;
          bb.y1 = pos.y - bb.h / 2;
          bb.y2 = pos.y + bb.h / 2;
        }
  
        function computeBiasValues(propDiff, propBias, propBiasComplement) {
          var biasDiff = 0;
          var biasComplementDiff = 0;
          var biasTotal = propBias + propBiasComplement;
  
          if (propDiff > 0 && biasTotal > 0) {
            biasDiff = propBias / biasTotal * propDiff;
            biasComplementDiff = propBiasComplement / biasTotal * propDiff;
          }
  
          return {
            biasDiff: biasDiff,
            biasComplementDiff: biasComplementDiff
          };
        }
  
        function computePaddingValues(width, height, paddingObject, relativeTo) {
          // Assuming percentage is number from 0 to 1
          if (paddingObject.units === '%') {
            switch (relativeTo) {
              case 'width':
                return width > 0 ? paddingObject.pfValue * width : 0;
  
              case 'height':
                return height > 0 ? paddingObject.pfValue * height : 0;
  
              case 'average':
                return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;
  
              case 'min':
                return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;
  
              case 'max':
                return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;
  
              default:
                return 0;
            }
          } else if (paddingObject.units === 'px') {
            return paddingObject.pfValue;
          } else {
            return 0;
          }
        }
  
        var leftVal = min.width.left.value;
  
        if (min.width.left.units === 'px' && min.width.val > 0) {
          leftVal = leftVal * 100 / min.width.val;
        }
  
        var rightVal = min.width.right.value;
  
        if (min.width.right.units === 'px' && min.width.val > 0) {
          rightVal = rightVal * 100 / min.width.val;
        }
  
        var topVal = min.height.top.value;
  
        if (min.height.top.units === 'px' && min.height.val > 0) {
          topVal = topVal * 100 / min.height.val;
        }
  
        var bottomVal = min.height.bottom.value;
  
        if (min.height.bottom.units === 'px' && min.height.val > 0) {
          bottomVal = bottomVal * 100 / min.height.val;
        }
  
        var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);
        var diffLeft = widthBiasDiffs.biasDiff;
        var diffRight = widthBiasDiffs.biasComplementDiff;
        var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);
        var diffTop = heightBiasDiffs.biasDiff;
        var diffBottom = heightBiasDiffs.biasComplementDiff;
        _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);
        _p.autoWidth = Math.max(bb.w, min.width.val);
        pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;
        _p.autoHeight = Math.max(bb.h, min.height.val);
        pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;
      }
  
      for (var i = 0; i < this.length; i++) {
        var ele = this[i];
        var _p = ele._private;
  
        if (!_p.compoundBoundsClean) {
          update(ele);
  
          if (!cy.batching()) {
            _p.compoundBoundsClean = true;
          }
        }
      }
  
      return this;
    };
  
    var noninf = function noninf(x) {
      if (x === Infinity || x === -Infinity) {
        return 0;
      }
  
      return x;
    };
  
    var updateBounds = function updateBounds(b, x1, y1, x2, y2) {
      // don't update with zero area boxes
      if (x2 - x1 === 0 || y2 - y1 === 0) {
        return;
      } // don't update with null dim
  
  
      if (x1 == null || y1 == null || x2 == null || y2 == null) {
        return;
      }
  
      b.x1 = x1 < b.x1 ? x1 : b.x1;
      b.x2 = x2 > b.x2 ? x2 : b.x2;
      b.y1 = y1 < b.y1 ? y1 : b.y1;
      b.y2 = y2 > b.y2 ? y2 : b.y2;
      b.w = b.x2 - b.x1;
      b.h = b.y2 - b.y1;
    };
  
    var updateBoundsFromBox = function updateBoundsFromBox(b, b2) {
      if (b2 == null) {
        return b;
      }
  
      return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);
    };
  
    var prefixedProperty = function prefixedProperty(obj, field, prefix) {
      return getPrefixedProperty(obj, field, prefix);
    };
  
    var updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {
      if (ele.cy().headless()) {
        return;
      }
  
      var _p = ele._private;
      var rstyle = _p.rstyle;
      var halfArW = rstyle.arrowWidth / 2;
      var arrowType = ele.pstyle(prefix + '-arrow-shape').value;
      var x;
      var y;
  
      if (arrowType !== 'none') {
        if (prefix === 'source') {
          x = rstyle.srcX;
          y = rstyle.srcY;
        } else if (prefix === 'target') {
          x = rstyle.tgtX;
          y = rstyle.tgtY;
        } else {
          x = rstyle.midX;
          y = rstyle.midY;
        } // always store the individual arrow bounds
  
  
        var bbs = _p.arrowBounds = _p.arrowBounds || {};
        var bb = bbs[prefix] = bbs[prefix] || {};
        bb.x1 = x - halfArW;
        bb.y1 = y - halfArW;
        bb.x2 = x + halfArW;
        bb.y2 = y + halfArW;
        bb.w = bb.x2 - bb.x1;
        bb.h = bb.y2 - bb.y1;
        expandBoundingBox(bb, 1);
        updateBounds(bounds, bb.x1, bb.y1, bb.x2, bb.y2);
      }
    };
  
    var updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {
      if (ele.cy().headless()) {
        return;
      }
  
      var prefixDash;
  
      if (prefix) {
        prefixDash = prefix + '-';
      } else {
        prefixDash = '';
      }
  
      var _p = ele._private;
      var rstyle = _p.rstyle;
      var label = ele.pstyle(prefixDash + 'label').strValue;
  
      if (label) {
        var halign = ele.pstyle('text-halign');
        var valign = ele.pstyle('text-valign');
        var labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);
        var labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);
        var labelX = prefixedProperty(rstyle, 'labelX', prefix);
        var labelY = prefixedProperty(rstyle, 'labelY', prefix);
        var marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;
        var marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;
        var isEdge = ele.isEdge();
        var rotation = ele.pstyle(prefixDash + 'text-rotation');
        var outlineWidth = ele.pstyle('text-outline-width').pfValue;
        var borderWidth = ele.pstyle('text-border-width').pfValue;
        var halfBorderWidth = borderWidth / 2;
        var padding = ele.pstyle('text-background-padding').pfValue;
        var lh = labelHeight;
        var lw = labelWidth;
        var lw_2 = lw / 2;
        var lh_2 = lh / 2;
        var lx1, lx2, ly1, ly2;
  
        if (isEdge) {
          lx1 = labelX - lw_2;
          lx2 = labelX + lw_2;
          ly1 = labelY - lh_2;
          ly2 = labelY + lh_2;
        } else {
          switch (halign.value) {
            case 'left':
              lx1 = labelX - lw;
              lx2 = labelX;
              break;
  
            case 'center':
              lx1 = labelX - lw_2;
              lx2 = labelX + lw_2;
              break;
  
            case 'right':
              lx1 = labelX;
              lx2 = labelX + lw;
              break;
          }
  
          switch (valign.value) {
            case 'top':
              ly1 = labelY - lh;
              ly2 = labelY;
              break;
  
            case 'center':
              ly1 = labelY - lh_2;
              ly2 = labelY + lh_2;
              break;
  
            case 'bottom':
              ly1 = labelY;
              ly2 = labelY + lh;
              break;
          }
        } // shift by margin and expand by outline and border
  
  
        lx1 += marginX - Math.max(outlineWidth, halfBorderWidth) - padding;
        lx2 += marginX + Math.max(outlineWidth, halfBorderWidth) + padding;
        ly1 += marginY - Math.max(outlineWidth, halfBorderWidth) - padding;
        ly2 += marginY + Math.max(outlineWidth, halfBorderWidth) + padding; // always store the unrotated label bounds separately
  
        var bbPrefix = prefix || 'main';
        var bbs = _p.labelBounds;
        var bb = bbs[bbPrefix] = bbs[bbPrefix] || {};
        bb.x1 = lx1;
        bb.y1 = ly1;
        bb.x2 = lx2;
        bb.y2 = ly2;
        bb.w = lx2 - lx1;
        bb.h = ly2 - ly1;
        expandBoundingBox(bb, 1); // expand to work around browser dimension inaccuracies
  
        var isAutorotate = isEdge && rotation.strValue === 'autorotate';
        var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;
  
        if (isAutorotate || isPfValue) {
          var theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;
          var cos = Math.cos(theta);
          var sin = Math.sin(theta); // rotation point (default value for center-center)
  
          var xo = (lx1 + lx2) / 2;
          var yo = (ly1 + ly2) / 2;
  
          if (!isEdge) {
            switch (halign.value) {
              case 'left':
                xo = lx2;
                break;
  
              case 'right':
                xo = lx1;
                break;
            }
  
            switch (valign.value) {
              case 'top':
                yo = ly2;
                break;
  
              case 'bottom':
                yo = ly1;
                break;
            }
          }
  
          var rotate = function rotate(x, y) {
            x = x - xo;
            y = y - yo;
            return {
              x: x * cos - y * sin + xo,
              y: x * sin + y * cos + yo
            };
          };
  
          var px1y1 = rotate(lx1, ly1);
          var px1y2 = rotate(lx1, ly2);
          var px2y1 = rotate(lx2, ly1);
          var px2y2 = rotate(lx2, ly2);
          lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
          lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
          ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
          ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
        }
  
        var bbPrefixRot = bbPrefix + 'Rot';
        var bbRot = bbs[bbPrefixRot] = bbs[bbPrefixRot] || {};
        bbRot.x1 = lx1;
        bbRot.y1 = ly1;
        bbRot.x2 = lx2;
        bbRot.y2 = ly2;
        bbRot.w = lx2 - lx1;
        bbRot.h = ly2 - ly1;
        updateBounds(bounds, lx1, ly1, lx2, ly2);
        updateBounds(_p.labelBounds.all, lx1, ly1, lx2, ly2);
      }
  
      return bounds;
    }; // get the bounding box of the elements (in raw model position)
  
  
    var boundingBoxImpl = function boundingBoxImpl(ele, options) {
      var cy = ele._private.cy;
      var styleEnabled = cy.styleEnabled();
      var headless = cy.headless();
      var bounds = makeBoundingBox();
      var _p = ele._private;
      var isNode = ele.isNode();
      var isEdge = ele.isEdge();
      var ex1, ex2, ey1, ey2; // extrema of body / lines
  
      var x, y; // node pos
  
      var rstyle = _p.rstyle;
      var manualExpansion = isNode && styleEnabled ? ele.pstyle('bounds-expansion').pfValue : [0]; // must use `display` prop only, as reading `compound.width()` causes recursion
      // (other factors like width values will be considered later in this function anyway)
  
      var isDisplayed = function isDisplayed(ele) {
        return ele.pstyle('display').value !== 'none';
      };
  
      var displayed = !styleEnabled || isDisplayed(ele) // must take into account connected nodes b/c of implicit edge hiding on display:none node
      && (!isEdge || isDisplayed(ele.source()) && isDisplayed(ele.target()));
  
      if (displayed) {
        // displayed suffices, since we will find zero area eles anyway
        var overlayOpacity = 0;
        var overlayPadding = 0;
  
        if (styleEnabled && options.includeOverlays) {
          overlayOpacity = ele.pstyle('overlay-opacity').value;
  
          if (overlayOpacity !== 0) {
            overlayPadding = ele.pstyle('overlay-padding').value;
          }
        }
  
        var w = 0;
        var wHalf = 0;
  
        if (styleEnabled) {
          w = ele.pstyle('width').pfValue;
          wHalf = w / 2;
        }
  
        if (isNode && options.includeNodes) {
          var pos = ele.position();
          x = pos.x;
          y = pos.y;
  
          var _w = ele.outerWidth();
  
          var halfW = _w / 2;
          var h = ele.outerHeight();
          var halfH = h / 2; // handle node dimensions
          /////////////////////////
  
          ex1 = x - halfW;
          ex2 = x + halfW;
          ey1 = y - halfH;
          ey2 = y + halfH;
          updateBounds(bounds, ex1, ey1, ex2, ey2);
        } else if (isEdge && options.includeEdges) {
          if (styleEnabled && !headless) {
            var curveStyle = ele.pstyle('curve-style').strValue; // handle edge dimensions (rough box estimate)
            //////////////////////////////////////////////
  
            ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);
            ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);
            ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);
            ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY); // take into account edge width
  
            ex1 -= wHalf;
            ex2 += wHalf;
            ey1 -= wHalf;
            ey2 += wHalf;
            updateBounds(bounds, ex1, ey1, ex2, ey2); // precise edges
            ////////////////
  
            if (curveStyle === 'haystack') {
              var hpts = rstyle.haystackPts;
  
              if (hpts && hpts.length === 2) {
                ex1 = hpts[0].x;
                ey1 = hpts[0].y;
                ex2 = hpts[1].x;
                ey2 = hpts[1].y;
  
                if (ex1 > ex2) {
                  var temp = ex1;
                  ex1 = ex2;
                  ex2 = temp;
                }
  
                if (ey1 > ey2) {
                  var _temp = ey1;
                  ey1 = ey2;
                  ey2 = _temp;
                }
  
                updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);
              }
            } else if (curveStyle === 'bezier' || curveStyle === 'unbundled-bezier' || curveStyle === 'segments' || curveStyle === 'taxi') {
              var pts;
  
              switch (curveStyle) {
                case 'bezier':
                case 'unbundled-bezier':
                  pts = rstyle.bezierPts;
                  break;
  
                case 'segments':
                case 'taxi':
                  pts = rstyle.linePts;
                  break;
              }
  
              if (pts != null) {
                for (var j = 0; j < pts.length; j++) {
                  var pt = pts[j];
                  ex1 = pt.x - wHalf;
                  ex2 = pt.x + wHalf;
                  ey1 = pt.y - wHalf;
                  ey2 = pt.y + wHalf;
                  updateBounds(bounds, ex1, ey1, ex2, ey2);
                }
              }
            } // bezier-like or segment-like edge
  
          } else {
            // headless or style disabled
            // fallback on source and target positions
            //////////////////////////////////////////
            var n1 = ele.source();
            var n1pos = n1.position();
            var n2 = ele.target();
            var n2pos = n2.position();
            ex1 = n1pos.x;
            ex2 = n2pos.x;
            ey1 = n1pos.y;
            ey2 = n2pos.y;
  
            if (ex1 > ex2) {
              var _temp2 = ex1;
              ex1 = ex2;
              ex2 = _temp2;
            }
  
            if (ey1 > ey2) {
              var _temp3 = ey1;
              ey1 = ey2;
              ey2 = _temp3;
            } // take into account edge width
  
  
            ex1 -= wHalf;
            ex2 += wHalf;
            ey1 -= wHalf;
            ey2 += wHalf;
            updateBounds(bounds, ex1, ey1, ex2, ey2);
          } // headless or style disabled
  
        } // edges
        // handle edge arrow size
        /////////////////////////
  
  
        if (styleEnabled && options.includeEdges && isEdge) {
          updateBoundsFromArrow(bounds, ele, 'mid-source');
          updateBoundsFromArrow(bounds, ele, 'mid-target');
          updateBoundsFromArrow(bounds, ele, 'source');
          updateBoundsFromArrow(bounds, ele, 'target');
        } // ghost
        ////////
  
  
        if (styleEnabled) {
          var ghost = ele.pstyle('ghost').value === 'yes';
  
          if (ghost) {
            var gx = ele.pstyle('ghost-offset-x').pfValue;
            var gy = ele.pstyle('ghost-offset-y').pfValue;
            updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);
          }
        } // always store the body bounds separately from the labels
  
  
        var bbBody = _p.bodyBounds = _p.bodyBounds || {};
        assignBoundingBox(bbBody, bounds);
        expandBoundingBoxSides(bbBody, manualExpansion);
        expandBoundingBox(bbBody, 1); // expand to work around browser dimension inaccuracies
        // overlay
        //////////
  
        if (styleEnabled) {
          ex1 = bounds.x1;
          ex2 = bounds.x2;
          ey1 = bounds.y1;
          ey2 = bounds.y2;
          updateBounds(bounds, ex1 - overlayPadding, ey1 - overlayPadding, ex2 + overlayPadding, ey2 + overlayPadding);
        } // always store the body bounds separately from the labels
  
  
        var bbOverlay = _p.overlayBounds = _p.overlayBounds || {};
        assignBoundingBox(bbOverlay, bounds);
        expandBoundingBoxSides(bbOverlay, manualExpansion);
        expandBoundingBox(bbOverlay, 1); // expand to work around browser dimension inaccuracies
        // handle label dimensions
        //////////////////////////
  
        var bbLabels = _p.labelBounds = _p.labelBounds || {};
  
        if (bbLabels.all != null) {
          clearBoundingBox(bbLabels.all);
        } else {
          bbLabels.all = makeBoundingBox();
        }
  
        if (styleEnabled && options.includeLabels) {
          if (options.includeMainLabels) {
            updateBoundsFromLabel(bounds, ele, null);
          }
  
          if (isEdge) {
            if (options.includeSourceLabels) {
              updateBoundsFromLabel(bounds, ele, 'source');
            }
  
            if (options.includeTargetLabels) {
              updateBoundsFromLabel(bounds, ele, 'target');
            }
          }
        } // style enabled for labels
  
      } // if displayed
  
  
      bounds.x1 = noninf(bounds.x1);
      bounds.y1 = noninf(bounds.y1);
      bounds.x2 = noninf(bounds.x2);
      bounds.y2 = noninf(bounds.y2);
      bounds.w = noninf(bounds.x2 - bounds.x1);
      bounds.h = noninf(bounds.y2 - bounds.y1);
  
      if (bounds.w > 0 && bounds.h > 0 && displayed) {
        expandBoundingBoxSides(bounds, manualExpansion); // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides
  
        expandBoundingBox(bounds, 1);
      }
  
      return bounds;
    };
  
    var getKey = function getKey(opts) {
      var i = 0;
  
      var tf = function tf(val) {
        return (val ? 1 : 0) << i++;
      };
  
      var key = 0;
      key += tf(opts.incudeNodes);
      key += tf(opts.includeEdges);
      key += tf(opts.includeLabels);
      key += tf(opts.includeMainLabels);
      key += tf(opts.includeSourceLabels);
      key += tf(opts.includeTargetLabels);
      key += tf(opts.includeOverlays);
      return key;
    };
  
    var getBoundingBoxPosKey = function getBoundingBoxPosKey(ele) {
      if (ele.isEdge()) {
        var p1 = ele.source().position();
        var p2 = ele.target().position();
  
        var r = function r(x) {
          return Math.round(x);
        };
  
        return hashIntsArray([r(p1.x), r(p1.y), r(p2.x), r(p2.y)]);
      } else {
        return 0;
      }
    };
  
    var cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {
      var _p = ele._private;
      var bb;
      var isEdge = ele.isEdge();
      var key = opts == null ? defBbOptsKey : getKey(opts);
      var usingDefOpts = key === defBbOptsKey;
      var currPosKey = getBoundingBoxPosKey(ele);
      var isPosKeySame = _p.bbCachePosKey === currPosKey;
      var useCache = opts.useCache && isPosKeySame;
  
      var isDirty = function isDirty(ele) {
        return ele._private.bbCache == null;
      };
  
      var needRecalc = !useCache || isDirty(ele) || isEdge && isDirty(ele.source()) || isDirty(ele.target());
  
      if (needRecalc) {
        if (!isPosKeySame) {
          ele.recalculateRenderedStyle();
        }
  
        bb = boundingBoxImpl(ele, defBbOpts);
        _p.bbCache = bb;
        _p.bbCacheShift.x = _p.bbCacheShift.y = 0;
        _p.bbCachePosKey = currPosKey;
      } else {
        bb = _p.bbCache;
      }
  
      if (!needRecalc && (_p.bbCacheShift.x !== 0 || _p.bbCacheShift.y !== 0)) {
        var shift = assignShiftToBoundingBox;
        var delta = _p.bbCacheShift;
  
        var safeShift = function safeShift(bb, delta) {
          if (bb != null) {
            shift(bb, delta);
          }
        };
  
        shift(bb, delta);
        var bodyBounds = _p.bodyBounds,
            overlayBounds = _p.overlayBounds,
            labelBounds = _p.labelBounds,
            arrowBounds = _p.arrowBounds;
        safeShift(bodyBounds, delta);
        safeShift(overlayBounds, delta);
  
        if (arrowBounds != null) {
          safeShift(arrowBounds.source, delta);
          safeShift(arrowBounds.target, delta);
          safeShift(arrowBounds['mid-source'], delta);
          safeShift(arrowBounds['mid-target'], delta);
        }
  
        if (labelBounds != null) {
          safeShift(labelBounds.main, delta);
          safeShift(labelBounds.all, delta);
          safeShift(labelBounds.source, delta);
          safeShift(labelBounds.target, delta);
        }
      } // always reset the shift, because we either applied the shift or cleared it by doing a fresh recalc
  
  
      _p.bbCacheShift.x = _p.bbCacheShift.y = 0; // not using def opts => need to build up bb from combination of sub bbs
  
      if (!usingDefOpts) {
        var isNode = ele.isNode();
        bb = makeBoundingBox();
  
        if (opts.includeNodes && isNode || opts.includeEdges && !isNode) {
          if (opts.includeOverlays) {
            updateBoundsFromBox(bb, _p.overlayBounds);
          } else {
            updateBoundsFromBox(bb, _p.bodyBounds);
          }
        }
  
        if (opts.includeLabels) {
          if (opts.includeMainLabels && (!isEdge || opts.includeSourceLabels && opts.includeTargetLabels)) {
            updateBoundsFromBox(bb, _p.labelBounds.all);
          } else {
            if (opts.includeMainLabels) {
              updateBoundsFromBox(bb, _p.labelBounds.mainRot);
            }
  
            if (opts.includeSourceLabels) {
              updateBoundsFromBox(bb, _p.labelBounds.sourceRot);
            }
  
            if (opts.includeTargetLabels) {
              updateBoundsFromBox(bb, _p.labelBounds.targetRot);
            }
          }
        }
  
        bb.w = bb.x2 - bb.x1;
        bb.h = bb.y2 - bb.y1;
      }
  
      return bb;
    };
  
    var defBbOpts = {
      includeNodes: true,
      includeEdges: true,
      includeLabels: true,
      includeMainLabels: true,
      includeSourceLabels: true,
      includeTargetLabels: true,
      includeOverlays: true,
      useCache: true
    };
    var defBbOptsKey = getKey(defBbOpts);
    var filledBbOpts = defaults(defBbOpts);
  
    elesfn$k.boundingBox = function (options) {
      var bounds; // the main usecase is ele.boundingBox() for a single element with no/def options
      // specified s.t. the cache is used, so check for this case to make it faster by
      // avoiding the overhead of the rest of the function
  
      if (this.length === 1 && this[0]._private.bbCache != null && (options === undefined || options.useCache === undefined || options.useCache === true)) {
        if (options === undefined) {
          options = defBbOpts;
        } else {
          options = filledBbOpts(options);
        }
  
        bounds = cachedBoundingBoxImpl(this[0], options);
      } else {
        bounds = makeBoundingBox();
        options = options || defBbOpts;
        var opts = filledBbOpts(options);
        var eles = this;
        var cy = eles.cy();
        var styleEnabled = cy.styleEnabled();
  
        if (styleEnabled) {
          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            var _p = ele._private;
            var currPosKey = getBoundingBoxPosKey(ele);
            var isPosKeySame = _p.bbCachePosKey === currPosKey;
            var useCache = opts.useCache && isPosKeySame;
            ele.recalculateRenderedStyle(useCache);
          }
        }
  
        this.updateCompoundBounds();
  
        for (var _i = 0; _i < eles.length; _i++) {
          var _ele = eles[_i];
          updateBoundsFromBox(bounds, cachedBoundingBoxImpl(_ele, opts));
        }
      }
  
      bounds.x1 = noninf(bounds.x1);
      bounds.y1 = noninf(bounds.y1);
      bounds.x2 = noninf(bounds.x2);
      bounds.y2 = noninf(bounds.y2);
      bounds.w = noninf(bounds.x2 - bounds.x1);
      bounds.h = noninf(bounds.y2 - bounds.y1);
      return bounds;
    };
  
    elesfn$k.dirtyBoundingBoxCache = function () {
      for (var i = 0; i < this.length; i++) {
        var _p = this[i]._private;
        _p.bbCache = null;
        _p.bbCacheShift.x = _p.bbCacheShift.y = 0;
        _p.bbCachePosKey = null;
        _p.bodyBounds = null;
        _p.overlayBounds = null;
        _p.labelBounds.all = null;
        _p.labelBounds.source = null;
        _p.labelBounds.target = null;
        _p.labelBounds.main = null;
        _p.labelBounds.sourceRot = null;
        _p.labelBounds.targetRot = null;
        _p.labelBounds.mainRot = null;
        _p.arrowBounds.source = null;
        _p.arrowBounds.target = null;
        _p.arrowBounds['mid-source'] = null;
        _p.arrowBounds['mid-target'] = null;
      }
  
      this.emitAndNotify('bounds');
      return this;
    };
  
    elesfn$k.shiftCachedBoundingBox = function (delta) {
      for (var i = 0; i < this.length; i++) {
        var ele = this[i];
        var _p = ele._private;
        var bb = _p.bbCache;
  
        if (bb != null) {
          _p.bbCacheShift.x += delta.x;
          _p.bbCacheShift.y += delta.y;
        }
      }
  
      this.emitAndNotify('bounds');
      return this;
    }; // private helper to get bounding box for custom node positions
    // - good for perf in certain cases but currently requires dirtying the rendered style
    // - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...
    // - try to use for only things like discrete layouts where the node position would change anyway
  
  
    elesfn$k.boundingBoxAt = function (fn) {
      var nodes = this.nodes();
      var cy = this.cy();
      var hasCompoundNodes = cy.hasCompoundNodes();
  
      if (hasCompoundNodes) {
        nodes = nodes.filter(function (node) {
          return !node.isParent();
        });
      }
  
      if (plainObject(fn)) {
        var obj = fn;
  
        fn = function fn() {
          return obj;
        };
      }
  
      var storeOldPos = function storeOldPos(node, i) {
        return node._private.bbAtOldPos = fn(node, i);
      };
  
      var getOldPos = function getOldPos(node) {
        return node._private.bbAtOldPos;
      };
  
      cy.startBatch();
      nodes.forEach(storeOldPos).silentPositions(fn);
  
      if (hasCompoundNodes) {
        this.updateCompoundBounds(true); // force update b/c we're inside a batch cycle
      }
  
      var bb = copyBoundingBox(this.boundingBox({
        useCache: false
      }));
      nodes.silentPositions(getOldPos);
      cy.endBatch();
      return bb;
    };
  
    fn$3.boundingbox = fn$3.bb = fn$3.boundingBox;
    fn$3.renderedBoundingbox = fn$3.renderedBoundingBox;
    var bounds = elesfn$k;
  
    var fn$4, elesfn$l;
    fn$4 = elesfn$l = {};
  
    var defineDimFns = function defineDimFns(opts) {
      opts.uppercaseName = capitalize(opts.name);
      opts.autoName = 'auto' + opts.uppercaseName;
      opts.labelName = 'label' + opts.uppercaseName;
      opts.outerName = 'outer' + opts.uppercaseName;
      opts.uppercaseOuterName = capitalize(opts.outerName);
  
      fn$4[opts.name] = function dimImpl() {
        var ele = this[0];
        var _p = ele._private;
        var cy = _p.cy;
        var styleEnabled = cy._private.styleEnabled;
  
        if (ele) {
          if (styleEnabled) {
            if (ele.isParent()) {
              ele.updateCompoundBounds();
              return _p[opts.autoName] || 0;
            }
  
            var d = ele.pstyle(opts.name);
  
            switch (d.strValue) {
              case 'label':
                ele.recalculateRenderedStyle();
                return _p.rstyle[opts.labelName] || 0;
  
              default:
                return d.pfValue;
            }
          } else {
            return 1;
          }
        }
      };
  
      fn$4['outer' + opts.uppercaseName] = function outerDimImpl() {
        var ele = this[0];
        var _p = ele._private;
        var cy = _p.cy;
        var styleEnabled = cy._private.styleEnabled;
  
        if (ele) {
          if (styleEnabled) {
            var dim = ele[opts.name]();
            var border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side
  
            var padding = 2 * ele.padding();
            return dim + border + padding;
          } else {
            return 1;
          }
        }
      };
  
      fn$4['rendered' + opts.uppercaseName] = function renderedDimImpl() {
        var ele = this[0];
  
        if (ele) {
          var d = ele[opts.name]();
          return d * this.cy().zoom();
        }
      };
  
      fn$4['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {
        var ele = this[0];
  
        if (ele) {
          var od = ele[opts.outerName]();
          return od * this.cy().zoom();
        }
      };
    };
  
    defineDimFns({
      name: 'width'
    });
    defineDimFns({
      name: 'height'
    });
  
    elesfn$l.padding = function () {
      var ele = this[0];
      var _p = ele._private;
  
      if (ele.isParent()) {
        ele.updateCompoundBounds();
  
        if (_p.autoPadding !== undefined) {
          return _p.autoPadding;
        } else {
          return ele.pstyle('padding').pfValue;
        }
      } else {
        return ele.pstyle('padding').pfValue;
      }
    };
  
    elesfn$l.paddedHeight = function () {
      var ele = this[0];
      return ele.height() + 2 * ele.padding();
    };
  
    elesfn$l.paddedWidth = function () {
      var ele = this[0];
      return ele.width() + 2 * ele.padding();
    };
  
    var widthHeight = elesfn$l;
  
    var ifEdge = function ifEdge(ele, getValue) {
      if (ele.isEdge()) {
        return getValue(ele);
      }
    };
  
    var ifEdgeRenderedPosition = function ifEdgeRenderedPosition(ele, getPoint) {
      if (ele.isEdge()) {
        var cy = ele.cy();
        return modelToRenderedPosition(getPoint(ele), cy.zoom(), cy.pan());
      }
    };
  
    var ifEdgeRenderedPositions = function ifEdgeRenderedPositions(ele, getPoints) {
      if (ele.isEdge()) {
        var cy = ele.cy();
        var pan = cy.pan();
        var zoom = cy.zoom();
        return getPoints(ele).map(function (p) {
          return modelToRenderedPosition(p, zoom, pan);
        });
      }
    };
  
    var controlPoints = function controlPoints(ele) {
      return ele.renderer().getControlPoints(ele);
    };
  
    var segmentPoints = function segmentPoints(ele) {
      return ele.renderer().getSegmentPoints(ele);
    };
  
    var sourceEndpoint = function sourceEndpoint(ele) {
      return ele.renderer().getSourceEndpoint(ele);
    };
  
    var targetEndpoint = function targetEndpoint(ele) {
      return ele.renderer().getTargetEndpoint(ele);
    };
  
    var midpoint = function midpoint(ele) {
      return ele.renderer().getEdgeMidpoint(ele);
    };
  
    var pts = {
      controlPoints: {
        get: controlPoints,
        mult: true
      },
      segmentPoints: {
        get: segmentPoints,
        mult: true
      },
      sourceEndpoint: {
        get: sourceEndpoint
      },
      targetEndpoint: {
        get: targetEndpoint
      },
      midpoint: {
        get: midpoint
      }
    };
  
    var renderedName = function renderedName(name) {
      return 'rendered' + name[0].toUpperCase() + name.substr(1);
    };
  
    var edgePoints = Object.keys(pts).reduce(function (obj, name) {
      var spec = pts[name];
      var rName = renderedName(name);
  
      obj[name] = function () {
        return ifEdge(this, spec.get);
      };
  
      if (spec.mult) {
        obj[rName] = function () {
          return ifEdgeRenderedPositions(this, spec.get);
        };
      } else {
        obj[rName] = function () {
          return ifEdgeRenderedPosition(this, spec.get);
        };
      }
  
      return obj;
    }, {});
  
    var dimensions = extend({}, position, bounds, widthHeight, edgePoints);
  
    /*!
    Event object based on jQuery events, MIT license
  
    https://jquery.org/license/
    https://tldrlegal.com/license/mit-license
    https://github.com/jquery/jquery/blob/master/src/event.js
    */
    var Event = function Event(src, props) {
      this.recycle(src, props);
    };
  
    function returnFalse() {
      return false;
    }
  
    function returnTrue() {
      return true;
    } // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  
  
    Event.prototype = {
      instanceString: function instanceString() {
        return 'event';
      },
      recycle: function recycle(src, props) {
        this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;
  
        if (src != null && src.preventDefault) {
          // Browser Event object
          this.type = src.type; // Events bubbling up the document may have been marked as prevented
          // by a handler lower down the tree; reflect the correct value.
  
          this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;
        } else if (src != null && src.type) {
          // Plain object containing all event details
          props = src;
        } else {
          // Event string
          this.type = src;
        } // Put explicitly provided properties onto the event object
  
  
        if (props != null) {
          // more efficient to manually copy fields we use
          this.originalEvent = props.originalEvent;
          this.type = props.type != null ? props.type : this.type;
          this.cy = props.cy;
          this.target = props.target;
          this.position = props.position;
          this.renderedPosition = props.renderedPosition;
          this.namespace = props.namespace;
          this.layout = props.layout;
        }
  
        if (this.cy != null && this.position != null && this.renderedPosition == null) {
          // create a rendered position based on the passed position
          var pos = this.position;
          var zoom = this.cy.zoom();
          var pan = this.cy.pan();
          this.renderedPosition = {
            x: pos.x * zoom + pan.x,
            y: pos.y * zoom + pan.y
          };
        } // Create a timestamp if incoming event doesn't have one
  
  
        this.timeStamp = src && src.timeStamp || Date.now();
      },
      preventDefault: function preventDefault() {
        this.isDefaultPrevented = returnTrue;
        var e = this.originalEvent;
  
        if (!e) {
          return;
        } // if preventDefault exists run it on the original event
  
  
        if (e.preventDefault) {
          e.preventDefault();
        }
      },
      stopPropagation: function stopPropagation() {
        this.isPropagationStopped = returnTrue;
        var e = this.originalEvent;
  
        if (!e) {
          return;
        } // if stopPropagation exists run it on the original event
  
  
        if (e.stopPropagation) {
          e.stopPropagation();
        }
      },
      stopImmediatePropagation: function stopImmediatePropagation() {
        this.isImmediatePropagationStopped = returnTrue;
        this.stopPropagation();
      },
      isDefaultPrevented: returnFalse,
      isPropagationStopped: returnFalse,
      isImmediatePropagationStopped: returnFalse
    };
  
    var eventRegex = /^([^.]+)(\.(?:[^.]+))?$/; // regex for matching event strings (e.g. "click.namespace")
  
    var universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally
  
    var defaults$8 = {
      qualifierCompare: function qualifierCompare(q1, q2) {
        return q1 === q2;
      },
      eventMatches: function eventMatches()
      /*context, listener, eventObj*/
      {
        return true;
      },
      addEventFields: function addEventFields()
      /*context, evt*/
      {},
      callbackContext: function callbackContext(context
      /*, listener, eventObj*/
      ) {
        return context;
      },
      beforeEmit: function beforeEmit()
      /* context, listener, eventObj */
      {},
      afterEmit: function afterEmit()
      /* context, listener, eventObj */
      {},
      bubble: function bubble()
      /*context*/
      {
        return false;
      },
      parent: function parent()
      /*context*/
      {
        return null;
      },
      context: null
    };
    var defaultsKeys = Object.keys(defaults$8);
    var emptyOpts = {};
  
    function Emitter() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyOpts;
      var context = arguments.length > 1 ? arguments[1] : undefined;
  
      // micro-optimisation vs Object.assign() -- reduces Element instantiation time
      for (var i = 0; i < defaultsKeys.length; i++) {
        var key = defaultsKeys[i];
        this[key] = opts[key] || defaults$8[key];
      }
  
      this.context = context || this.context;
      this.listeners = [];
      this.emitting = 0;
    }
  
    var p = Emitter.prototype;
  
    var forEachEvent = function forEachEvent(self, handler, events, qualifier, callback, conf, confOverrides) {
      if (fn(qualifier)) {
        callback = qualifier;
        qualifier = null;
      }
  
      if (confOverrides) {
        if (conf == null) {
          conf = confOverrides;
        } else {
          conf = extend({}, conf, confOverrides);
        }
      }
  
      var eventList = array(events) ? events : events.split(/\s+/);
  
      for (var i = 0; i < eventList.length; i++) {
        var evt = eventList[i];
  
        if (emptyString(evt)) {
          continue;
        }
  
        var match = evt.match(eventRegex); // type[.namespace]
  
        if (match) {
          var type = match[1];
          var namespace = match[2] ? match[2] : null;
          var ret = handler(self, evt, type, namespace, qualifier, callback, conf);
  
          if (ret === false) {
            break;
          } // allow exiting early
  
        }
      }
    };
  
    var makeEventObj = function makeEventObj(self, obj) {
      self.addEventFields(self.context, obj);
      return new Event(obj.type, obj);
    };
  
    var forEachEventObj = function forEachEventObj(self, handler, events) {
      if (event(events)) {
        handler(self, events);
        return;
      } else if (plainObject(events)) {
        handler(self, makeEventObj(self, events));
        return;
      }
  
      var eventList = array(events) ? events : events.split(/\s+/);
  
      for (var i = 0; i < eventList.length; i++) {
        var evt = eventList[i];
  
        if (emptyString(evt)) {
          continue;
        }
  
        var match = evt.match(eventRegex); // type[.namespace]
  
        if (match) {
          var type = match[1];
          var namespace = match[2] ? match[2] : null;
          var eventObj = makeEventObj(self, {
            type: type,
            namespace: namespace,
            target: self.context
          });
          handler(self, eventObj);
        }
      }
    };
  
    p.on = p.addListener = function (events, qualifier, callback, conf, confOverrides) {
      forEachEvent(this, function (self, event, type, namespace, qualifier, callback, conf) {
        if (fn(callback)) {
          self.listeners.push({
            event: event,
            // full event string
            callback: callback,
            // callback to run
            type: type,
            // the event type (e.g. 'click')
            namespace: namespace,
            // the event namespace (e.g. ".foo")
            qualifier: qualifier,
            // a restriction on whether to match this emitter
            conf: conf // additional configuration
  
          });
        }
      }, events, qualifier, callback, conf, confOverrides);
      return this;
    };
  
    p.one = function (events, qualifier, callback, conf) {
      return this.on(events, qualifier, callback, conf, {
        one: true
      });
    };
  
    p.removeListener = p.off = function (events, qualifier, callback, conf) {
      var _this = this;
  
      if (this.emitting !== 0) {
        this.listeners = copyArray(this.listeners);
      }
  
      var listeners = this.listeners;
  
      var _loop = function _loop(i) {
        var listener = listeners[i];
        forEachEvent(_this, function (self, event, type, namespace, qualifier, callback
        /*, conf*/
        ) {
          if ((listener.type === type || events === '*') && (!namespace && listener.namespace !== '.*' || listener.namespace === namespace) && (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {
            listeners.splice(i, 1);
            return false;
          }
        }, events, qualifier, callback, conf);
      };
  
      for (var i = listeners.length - 1; i >= 0; i--) {
        _loop(i);
      }
  
      return this;
    };
  
    p.removeAllListeners = function () {
      return this.removeListener('*');
    };
  
    p.emit = p.trigger = function (events, extraParams, manualCallback) {
      var listeners = this.listeners;
      var numListenersBeforeEmit = listeners.length;
      this.emitting++;
  
      if (!array(extraParams)) {
        extraParams = [extraParams];
      }
  
      forEachEventObj(this, function (self, eventObj) {
        if (manualCallback != null) {
          listeners = [{
            event: eventObj.event,
            type: eventObj.type,
            namespace: eventObj.namespace,
            callback: manualCallback
          }];
          numListenersBeforeEmit = listeners.length;
        }
  
        var _loop2 = function _loop2(i) {
          var listener = listeners[i];
  
          if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self.eventMatches(self.context, listener, eventObj)) {
            var args = [eventObj];
  
            if (extraParams != null) {
              push(args, extraParams);
            }
  
            self.beforeEmit(self.context, listener, eventObj);
  
            if (listener.conf && listener.conf.one) {
              self.listeners = self.listeners.filter(function (l) {
                return l !== listener;
              });
            }
  
            var context = self.callbackContext(self.context, listener, eventObj);
            var ret = listener.callback.apply(context, args);
            self.afterEmit(self.context, listener, eventObj);
  
            if (ret === false) {
              eventObj.stopPropagation();
              eventObj.preventDefault();
            }
          } // if listener matches
  
        };
  
        for (var i = 0; i < numListenersBeforeEmit; i++) {
          _loop2(i);
        } // for listener
  
  
        if (self.bubble(self.context) && !eventObj.isPropagationStopped()) {
          self.parent(self.context).emit(eventObj, extraParams);
        }
      }, events);
      this.emitting--;
      return this;
    };
  
    var emitterOptions = {
      qualifierCompare: function qualifierCompare(selector1, selector2) {
        if (selector1 == null || selector2 == null) {
          return selector1 == null && selector2 == null;
        } else {
          return selector1.sameText(selector2);
        }
      },
      eventMatches: function eventMatches(ele, listener, eventObj) {
        var selector = listener.qualifier;
  
        if (selector != null) {
          return ele !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);
        }
  
        return true;
      },
      addEventFields: function addEventFields(ele, evt) {
        evt.cy = ele.cy();
        evt.target = ele;
      },
      callbackContext: function callbackContext(ele, listener, eventObj) {
        return listener.qualifier != null ? eventObj.target : ele;
      },
      beforeEmit: function beforeEmit(context, listener
      /*, eventObj*/
      ) {
        if (listener.conf && listener.conf.once) {
          listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);
        }
      },
      bubble: function bubble() {
        return true;
      },
      parent: function parent(ele) {
        return ele.isChild() ? ele.parent() : ele.cy();
      }
    };
  
    var argSelector = function argSelector(arg) {
      if (string(arg)) {
        return new Selector(arg);
      } else {
        return arg;
      }
    };
  
    var elesfn$m = {
      createEmitter: function createEmitter() {
        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
          var _p = ele._private;
  
          if (!_p.emitter) {
            _p.emitter = new Emitter(emitterOptions, ele);
          }
        }
  
        return this;
      },
      emitter: function emitter() {
        return this._private.emitter;
      },
      on: function on(events, selector, callback) {
        var argSel = argSelector(selector);
  
        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
          ele.emitter().on(events, argSel, callback);
        }
  
        return this;
      },
      removeListener: function removeListener(events, selector, callback) {
        var argSel = argSelector(selector);
  
        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
          ele.emitter().removeListener(events, argSel, callback);
        }
  
        return this;
      },
      removeAllListeners: function removeAllListeners() {
        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
          ele.emitter().removeAllListeners();
        }
  
        return this;
      },
      one: function one(events, selector, callback) {
        var argSel = argSelector(selector);
  
        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
          ele.emitter().one(events, argSel, callback);
        }
  
        return this;
      },
      once: function once(events, selector, callback) {
        var argSel = argSelector(selector);
  
        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
          ele.emitter().on(events, argSel, callback, {
            once: true,
            onceCollection: this
          });
        }
      },
      emit: function emit(events, extraParams) {
        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
          ele.emitter().emit(events, extraParams);
        }
  
        return this;
      },
      emitAndNotify: function emitAndNotify(event, extraParams) {
        // for internal use only
        if (this.length === 0) {
          return;
        } // empty collections don't need to notify anything
        // notify renderer
  
  
        this.cy().notify(event, this);
        this.emit(event, extraParams);
        return this;
      }
    };
    define$3.eventAliasesOn(elesfn$m);
  
    var elesfn$n = {
      nodes: function nodes(selector) {
        return this.filter(function (ele) {
          return ele.isNode();
        }).filter(selector);
      },
      edges: function edges(selector) {
        return this.filter(function (ele) {
          return ele.isEdge();
        }).filter(selector);
      },
      // internal helper to get nodes and edges as separate collections with single iteration over elements
      byGroup: function byGroup() {
        var nodes = this.spawn();
        var edges = this.spawn();
  
        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
  
          if (ele.isNode()) {
            nodes.merge(ele);
          } else {
            edges.merge(ele);
          }
        }
  
        return {
          nodes: nodes,
          edges: edges
        };
      },
      filter: function filter(_filter, thisArg) {
        if (_filter === undefined) {
          // check this first b/c it's the most common/performant case
          return this;
        } else if (string(_filter) || elementOrCollection(_filter)) {
          return new Selector(_filter).filter(this);
        } else if (fn(_filter)) {
          var filterEles = this.spawn();
          var eles = this;
  
          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            var include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);
  
            if (include) {
              filterEles.merge(ele);
            }
          }
  
          return filterEles;
        }
  
        return this.spawn(); // if not handled by above, give 'em an empty collection
      },
      not: function not(toRemove) {
        if (!toRemove) {
          return this;
        } else {
          if (string(toRemove)) {
            toRemove = this.filter(toRemove);
          }
  
          var elements = [];
          var rMap = toRemove._private.map;
  
          for (var i = 0; i < this.length; i++) {
            var element = this[i];
            var remove = rMap.has(element.id());
  
            if (!remove) {
              elements.push(element);
            }
          }
  
          return this.spawn(elements);
        }
      },
      absoluteComplement: function absoluteComplement() {
        var cy = this.cy();
        return cy.mutableElements().not(this);
      },
      intersect: function intersect(other) {
        // if a selector is specified, then filter by it instead
        if (string(other)) {
          var selector = other;
          return this.filter(selector);
        }
  
        var elements = [];
        var col1 = this;
        var col2 = other;
        var col1Smaller = this.length < other.length;
        var map2 = col1Smaller ? col2._private.map : col1._private.map;
        var col = col1Smaller ? col1 : col2;
  
        for (var i = 0; i < col.length; i++) {
          var id = col[i]._private.data.id;
          var entry = map2.get(id);
  
          if (entry) {
            elements.push(entry.ele);
          }
        }
  
        return this.spawn(elements);
      },
      xor: function xor(other) {
        var cy = this._private.cy;
  
        if (string(other)) {
          other = cy.$(other);
        }
  
        var elements = [];
        var col1 = this;
        var col2 = other;
  
        var add = function add(col, other) {
          for (var i = 0; i < col.length; i++) {
            var ele = col[i];
            var id = ele._private.data.id;
            var inOther = other.hasElementWithId(id);
  
            if (!inOther) {
              elements.push(ele);
            }
          }
        };
  
        add(col1, col2);
        add(col2, col1);
        return this.spawn(elements);
      },
      diff: function diff(other) {
        var cy = this._private.cy;
  
        if (string(other)) {
          other = cy.$(other);
        }
  
        var left = [];
        var right = [];
        var both = [];
        var col1 = this;
        var col2 = other;
  
        var add = function add(col, other, retEles) {
          for (var i = 0; i < col.length; i++) {
            var ele = col[i];
            var id = ele._private.data.id;
            var inOther = other.hasElementWithId(id);
  
            if (inOther) {
              both.push(ele);
            } else {
              retEles.push(ele);
            }
          }
        };
  
        add(col1, col2, left);
        add(col2, col1, right);
        return {
          left: this.spawn(left, {
            unique: true
          }),
          right: this.spawn(right, {
            unique: true
          }),
          both: this.spawn(both, {
            unique: true
          })
        };
      },
      add: function add(toAdd) {
        var cy = this._private.cy;
  
        if (!toAdd) {
          return this;
        }
  
        if (string(toAdd)) {
          var selector = toAdd;
          toAdd = cy.mutableElements().filter(selector);
        }
  
        var elements = [];
  
        for (var i = 0; i < this.length; i++) {
          elements.push(this[i]);
        }
  
        var map = this._private.map;
  
        for (var _i = 0; _i < toAdd.length; _i++) {
          var add = !map.has(toAdd[_i].id());
  
          if (add) {
            elements.push(toAdd[_i]);
          }
        }
  
        return this.spawn(elements);
      },
      // in place merge on calling collection
      merge: function merge(toAdd) {
        var _p = this._private;
        var cy = _p.cy;
  
        if (!toAdd) {
          return this;
        }
  
        if (toAdd && string(toAdd)) {
          var selector = toAdd;
          toAdd = cy.mutableElements().filter(selector);
        }
  
        var map = _p.map;
  
        for (var i = 0; i < toAdd.length; i++) {
          var toAddEle = toAdd[i];
          var id = toAddEle._private.data.id;
          var add = !map.has(id);
  
          if (add) {
            var index = this.length++;
            this[index] = toAddEle;
            map.set(id, {
              ele: toAddEle,
              index: index
            });
          } else {
            // replace
            var _index = map.get(id).index;
            this[_index] = toAddEle;
            map.set(id, {
              ele: toAddEle,
              index: _index
            });
          }
        }
  
        return this; // chaining
      },
      unmergeAt: function unmergeAt(i) {
        var ele = this[i];
        var id = ele.id();
        var _p = this._private;
        var map = _p.map; // remove ele
  
        this[i] = undefined;
        map["delete"](id);
        var unmergedLastEle = i === this.length - 1; // replace empty spot with last ele in collection
  
        if (this.length > 1 && !unmergedLastEle) {
          var lastEleI = this.length - 1;
          var lastEle = this[lastEleI];
          var lastEleId = lastEle._private.data.id;
          this[lastEleI] = undefined;
          this[i] = lastEle;
          map.set(lastEleId, {
            ele: lastEle,
            index: i
          });
        } // the collection is now 1 ele smaller
  
  
        this.length--;
        return this;
      },
      // remove single ele in place in calling collection
      unmergeOne: function unmergeOne(ele) {
        ele = ele[0];
        var _p = this._private;
        var id = ele._private.data.id;
        var map = _p.map;
        var entry = map.get(id);
  
        if (!entry) {
          return this; // no need to remove
        }
  
        var i = entry.index;
        this.unmergeAt(i);
        return this;
      },
      // remove eles in place on calling collection
      unmerge: function unmerge(toRemove) {
        var cy = this._private.cy;
  
        if (!toRemove) {
          return this;
        }
  
        if (toRemove && string(toRemove)) {
          var selector = toRemove;
          toRemove = cy.mutableElements().filter(selector);
        }
  
        for (var i = 0; i < toRemove.length; i++) {
          this.unmergeOne(toRemove[i]);
        }
  
        return this; // chaining
      },
      unmergeBy: function unmergeBy(toRmFn) {
        for (var i = this.length - 1; i >= 0; i--) {
          var ele = this[i];
  
          if (toRmFn(ele)) {
            this.unmergeAt(i);
          }
        }
  
        return this;
      },
      map: function map(mapFn, thisArg) {
        var arr = [];
        var eles = this;
  
        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);
          arr.push(ret);
        }
  
        return arr;
      },
      reduce: function reduce(fn, initialValue) {
        var val = initialValue;
        var eles = this;
  
        for (var i = 0; i < eles.length; i++) {
          val = fn(val, eles[i], i, eles);
        }
  
        return val;
      },
      max: function max(valFn, thisArg) {
        var max = -Infinity;
        var maxEle;
        var eles = this;
  
        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);
  
          if (val > max) {
            max = val;
            maxEle = ele;
          }
        }
  
        return {
          value: max,
          ele: maxEle
        };
      },
      min: function min(valFn, thisArg) {
        var min = Infinity;
        var minEle;
        var eles = this;
  
        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);
  
          if (val < min) {
            min = val;
            minEle = ele;
          }
        }
  
        return {
          value: min,
          ele: minEle
        };
      }
    }; // aliases
  
    var fn$5 = elesfn$n;
    fn$5['u'] = fn$5['|'] = fn$5['+'] = fn$5.union = fn$5.or = fn$5.add;
    fn$5['\\'] = fn$5['!'] = fn$5['-'] = fn$5.difference = fn$5.relativeComplement = fn$5.subtract = fn$5.not;
    fn$5['n'] = fn$5['&'] = fn$5['.'] = fn$5.and = fn$5.intersection = fn$5.intersect;
    fn$5['^'] = fn$5['(+)'] = fn$5['(-)'] = fn$5.symmetricDifference = fn$5.symdiff = fn$5.xor;
    fn$5.fnFilter = fn$5.filterFn = fn$5.stdFilter = fn$5.filter;
    fn$5.complement = fn$5.abscomp = fn$5.absoluteComplement;
  
    var elesfn$o = {
      isNode: function isNode() {
        return this.group() === 'nodes';
      },
      isEdge: function isEdge() {
        return this.group() === 'edges';
      },
      isLoop: function isLoop() {
        return this.isEdge() && this.source()[0] === this.target()[0];
      },
      isSimple: function isSimple() {
        return this.isEdge() && this.source()[0] !== this.target()[0];
      },
      group: function group() {
        var ele = this[0];
  
        if (ele) {
          return ele._private.group;
        }
      }
    };
  
    /**
     *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),
     *  and z-index (low to high).  These styles affect how this applies:
     *
     *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the
     *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from
     *      root to leaves of the compound graph.  The last drawn is `top`.
     *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.
     *      `manual` ignores this convention and draws based on the `z-index` value setting.
     *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher
     *      `z-index` will be drawn on top of an element with a lower `z-index`.
     */
  
    var zIndexSort = function zIndexSort(a, b) {
      var cy = a.cy();
      var hasCompoundNodes = cy.hasCompoundNodes();
  
      function getDepth(ele) {
        var style = ele.pstyle('z-compound-depth');
  
        if (style.value === 'auto') {
          return hasCompoundNodes ? ele.zDepth() : 0;
        } else if (style.value === 'bottom') {
          return -1;
        } else if (style.value === 'top') {
          return MAX_INT;
        } // 'orphan'
  
  
        return 0;
      }
  
      var depthDiff = getDepth(a) - getDepth(b);
  
      if (depthDiff !== 0) {
        return depthDiff;
      }
  
      function getEleDepth(ele) {
        var style = ele.pstyle('z-index-compare');
  
        if (style.value === 'auto') {
          return ele.isNode() ? 1 : 0;
        } // 'manual'
  
  
        return 0;
      }
  
      var eleDiff = getEleDepth(a) - getEleDepth(b);
  
      if (eleDiff !== 0) {
        return eleDiff;
      }
  
      var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;
  
      if (zDiff !== 0) {
        return zDiff;
      } // compare indices in the core (order added to graph w/ last on top)
  
  
      return a.poolIndex() - b.poolIndex();
    };
  
    var elesfn$p = {
      forEach: function forEach(fn$1, thisArg) {
        if (fn(fn$1)) {
          var N = this.length;
  
          for (var i = 0; i < N; i++) {
            var ele = this[i];
            var ret = thisArg ? fn$1.apply(thisArg, [ele, i, this]) : fn$1(ele, i, this);
  
            if (ret === false) {
              break;
            } // exit each early on return false
  
          }
        }
  
        return this;
      },
      toArray: function toArray() {
        var array = [];
  
        for (var i = 0; i < this.length; i++) {
          array.push(this[i]);
        }
  
        return array;
      },
      slice: function slice(start, end) {
        var array = [];
        var thisSize = this.length;
  
        if (end == null) {
          end = thisSize;
        }
  
        if (start == null) {
          start = 0;
        }
  
        if (start < 0) {
          start = thisSize + start;
        }
  
        if (end < 0) {
          end = thisSize + end;
        }
  
        for (var i = start; i >= 0 && i < end && i < thisSize; i++) {
          array.push(this[i]);
        }
  
        return this.spawn(array);
      },
      size: function size() {
        return this.length;
      },
      eq: function eq(i) {
        return this[i] || this.spawn();
      },
      first: function first() {
        return this[0] || this.spawn();
      },
      last: function last() {
        return this[this.length - 1] || this.spawn();
      },
      empty: function empty() {
        return this.length === 0;
      },
      nonempty: function nonempty() {
        return !this.empty();
      },
      sort: function sort(sortFn) {
        if (!fn(sortFn)) {
          return this;
        }
  
        var sorted = this.toArray().sort(sortFn);
        return this.spawn(sorted);
      },
      sortByZIndex: function sortByZIndex() {
        return this.sort(zIndexSort);
      },
      zDepth: function zDepth() {
        var ele = this[0];
  
        if (!ele) {
          return undefined;
        } // let cy = ele.cy();
  
  
        var _p = ele._private;
        var group = _p.group;
  
        if (group === 'nodes') {
          var depth = _p.data.parent ? ele.parents().size() : 0;
  
          if (!ele.isParent()) {
            return MAX_INT - 1; // childless nodes always on top
          }
  
          return depth;
        } else {
          var src = _p.source;
          var tgt = _p.target;
          var srcDepth = src.zDepth();
          var tgtDepth = tgt.zDepth();
          return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent
        }
      }
    };
    elesfn$p.each = elesfn$p.forEach;
  
    var defineSymbolIterator = function defineSymbolIterator() {
      var typeofUndef =  "undefined" ;
      var isIteratorSupported = (typeof Symbol === "undefined" ? "undefined" : _typeof(Symbol)) != typeofUndef && _typeof(Symbol.iterator) != typeofUndef; // eslint-disable-line no-undef
  
      if (isIteratorSupported) {
        elesfn$p[Symbol.iterator] = function () {
          var _this = this;
  
          // eslint-disable-line no-undef
          var entry = {
            value: undefined,
            done: false
          };
          var i = 0;
          var length = this.length;
          return _defineProperty({
            next: function next() {
              if (i < length) {
                entry.value = _this[i++];
              } else {
                entry.value = undefined;
                entry.done = true;
              }
  
              return entry;
            }
          }, Symbol.iterator, function () {
            // eslint-disable-line no-undef
            return this;
          });
        };
      }
    };
  
    defineSymbolIterator();
  
    var getLayoutDimensionOptions = defaults({
      nodeDimensionsIncludeLabels: false
    });
    var elesfn$q = {
      // Calculates and returns node dimensions { x, y } based on options given
      layoutDimensions: function layoutDimensions(options) {
        options = getLayoutDimensionOptions(options);
        var dims;
  
        if (!this.takesUpSpace()) {
          dims = {
            w: 0,
            h: 0
          };
        } else if (options.nodeDimensionsIncludeLabels) {
          var bbDim = this.boundingBox();
          dims = {
            w: bbDim.w,
            h: bbDim.h
          };
        } else {
          dims = {
            w: this.outerWidth(),
            h: this.outerHeight()
          };
        } // sanitise the dimensions for external layouts (avoid division by zero)
  
  
        if (dims.w === 0 || dims.h === 0) {
          dims.w = dims.h = 1;
        }
  
        return dims;
      },
      // using standard layout options, apply position function (w/ or w/o animation)
      layoutPositions: function layoutPositions(layout, options, fn) {
        var nodes = this.nodes();
        var cy = this.cy();
        var layoutEles = options.eles; // nodes & edges
  
        var getMemoizeKey = function getMemoizeKey(node) {
          return node.id();
        };
  
        var fnMem = memoize(fn, getMemoizeKey); // memoized version of position function
  
        layout.emit({
          type: 'layoutstart',
          layout: layout
        });
        layout.animations = [];
  
        var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {
          var center = {
            x: nodesBb.x1 + nodesBb.w / 2,
            y: nodesBb.y1 + nodesBb.h / 2
          };
          var spacingVector = {
            // scale from center of bounding box (not necessarily 0,0)
            x: (pos.x - center.x) * spacing,
            y: (pos.y - center.y) * spacing
          };
          return {
            x: center.x + spacingVector.x,
            y: center.y + spacingVector.y
          };
        };
  
        var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;
  
        var spacingBb = function spacingBb() {
          if (!useSpacingFactor) {
            return null;
          }
  
          var bb = makeBoundingBox();
  
          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            var pos = fnMem(node, i);
            expandBoundingBoxByPoint(bb, pos.x, pos.y);
          }
  
          return bb;
        };
  
        var bb = spacingBb();
        var getFinalPos = memoize(function (node, i) {
          var newPos = fnMem(node, i);
  
          if (useSpacingFactor) {
            var spacing = Math.abs(options.spacingFactor);
            newPos = calculateSpacing(spacing, bb, newPos);
          }
  
          if (options.transform != null) {
            newPos = options.transform(node, newPos);
          }
  
          return newPos;
        }, getMemoizeKey);
  
        if (options.animate) {
          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            var newPos = getFinalPos(node, i);
            var animateNode = options.animateFilter == null || options.animateFilter(node, i);
  
            if (animateNode) {
              var ani = node.animation({
                position: newPos,
                duration: options.animationDuration,
                easing: options.animationEasing
              });
              layout.animations.push(ani);
            } else {
              node.position(newPos);
            }
          }
  
          if (options.fit) {
            var fitAni = cy.animation({
              fit: {
                boundingBox: layoutEles.boundingBoxAt(getFinalPos),
                padding: options.padding
              },
              duration: options.animationDuration,
              easing: options.animationEasing
            });
            layout.animations.push(fitAni);
          } else if (options.zoom !== undefined && options.pan !== undefined) {
            var zoomPanAni = cy.animation({
              zoom: options.zoom,
              pan: options.pan,
              duration: options.animationDuration,
              easing: options.animationEasing
            });
            layout.animations.push(zoomPanAni);
          }
  
          layout.animations.forEach(function (ani) {
            return ani.play();
          });
          layout.one('layoutready', options.ready);
          layout.emit({
            type: 'layoutready',
            layout: layout
          });
          Promise$1.all(layout.animations.map(function (ani) {
            return ani.promise();
          })).then(function () {
            layout.one('layoutstop', options.stop);
            layout.emit({
              type: 'layoutstop',
              layout: layout
            });
          });
        } else {
          nodes.positions(getFinalPos);
  
          if (options.fit) {
            cy.fit(options.eles, options.padding);
          }
  
          if (options.zoom != null) {
            cy.zoom(options.zoom);
          }
  
          if (options.pan) {
            cy.pan(options.pan);
          }
  
          layout.one('layoutready', options.ready);
          layout.emit({
            type: 'layoutready',
            layout: layout
          });
          layout.one('layoutstop', options.stop);
          layout.emit({
            type: 'layoutstop',
            layout: layout
          });
        }
  
        return this; // chaining
      },
      layout: function layout(options) {
        var cy = this.cy();
        return cy.makeLayout(extend({}, options, {
          eles: this
        }));
      }
    }; // aliases:
  
    elesfn$q.createLayout = elesfn$q.makeLayout = elesfn$q.layout;
  
    function styleCache(key, fn, ele) {
      var _p = ele._private;
      var cache = _p.styleCache = _p.styleCache || [];
      var val;
  
      if ((val = cache[key]) != null) {
        return val;
      } else {
        val = cache[key] = fn(ele);
        return val;
      }
    }
  
    function cacheStyleFunction(key, fn) {
      key = hashString(key);
      return function cachedStyleFunction(ele) {
        return styleCache(key, fn, ele);
      };
    }
  
    function cachePrototypeStyleFunction(key, fn) {
      key = hashString(key);
  
      var selfFn = function selfFn(ele) {
        return fn.call(ele);
      };
  
      return function cachedPrototypeStyleFunction() {
        var ele = this[0];
  
        if (ele) {
          return styleCache(key, selfFn, ele);
        }
      };
    }
  
    var elesfn$r = {
      recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {
        var cy = this.cy();
        var renderer = cy.renderer();
        var styleEnabled = cy.styleEnabled();
  
        if (renderer && styleEnabled) {
          renderer.recalculateRenderedStyle(this, useCache);
        }
  
        return this;
      },
      dirtyStyleCache: function dirtyStyleCache() {
        var cy = this.cy();
  
        var dirty = function dirty(ele) {
          return ele._private.styleCache = null;
        };
  
        if (cy.hasCompoundNodes()) {
          var eles;
          eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
          eles.merge(eles.connectedEdges());
          eles.forEach(dirty);
        } else {
          this.forEach(function (ele) {
            dirty(ele);
            ele.connectedEdges().forEach(dirty);
          });
        }
  
        return this;
      },
      // fully updates (recalculates) the style for the elements
      updateStyle: function updateStyle(notifyRenderer) {
        var cy = this._private.cy;
  
        if (!cy.styleEnabled()) {
          return this;
        }
  
        if (cy.batching()) {
          var bEles = cy._private.batchStyleEles;
          bEles.merge(this);
          return this; // chaining and exit early when batching
        }
  
        var hasCompounds = cy.hasCompoundNodes();
        var style = cy.style();
        var updatedEles = this;
        notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;
  
        if (hasCompounds) {
          // then add everything up and down for compound selector checks
          updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
        }
  
        var changedEles = style.apply(updatedEles);
  
        if (notifyRenderer) {
          changedEles.emitAndNotify('style'); // let renderer know we changed style
        } else {
          changedEles.emit('style'); // just fire the event
        }
  
        return this; // chaining
      },
      // get the internal parsed style object for the specified property
      parsedStyle: function parsedStyle(property) {
        var includeNonDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var ele = this[0];
        var cy = ele.cy();
  
        if (!cy.styleEnabled()) {
          return;
        }
  
        if (ele) {
          var overriddenStyle = ele._private.style[property];
  
          if (overriddenStyle != null) {
            return overriddenStyle;
          } else if (includeNonDefault) {
            return cy.style().getDefaultProperty(property);
          } else {
            return null;
          }
        }
      },
      numericStyle: function numericStyle(property) {
        var ele = this[0];
  
        if (!ele.cy().styleEnabled()) {
          return;
        }
  
        if (ele) {
          var pstyle = ele.pstyle(property);
          return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;
        }
      },
      numericStyleUnits: function numericStyleUnits(property) {
        var ele = this[0];
  
        if (!ele.cy().styleEnabled()) {
          return;
        }
  
        if (ele) {
          return ele.pstyle(property).units;
        }
      },
      // get the specified css property as a rendered value (i.e. on-screen value)
      // or get the whole rendered style if no property specified (NB doesn't allow setting)
      renderedStyle: function renderedStyle(property) {
        var cy = this.cy();
  
        if (!cy.styleEnabled()) {
          return this;
        }
  
        var ele = this[0];
  
        if (ele) {
          return cy.style().getRenderedStyle(ele, property);
        }
      },
      // read the calculated css style of the element or override the style (via a bypass)
      style: function style(name, value) {
        var cy = this.cy();
  
        if (!cy.styleEnabled()) {
          return this;
        }
  
        var updateTransitions = false;
        var style = cy.style();
  
        if (plainObject(name)) {
          // then extend the bypass
          var props = name;
          style.applyBypass(this, props, updateTransitions);
          this.emitAndNotify('style'); // let the renderer know we've updated style
        } else if (string(name)) {
          if (value === undefined) {
            // then get the property from the style
            var ele = this[0];
  
            if (ele) {
              return style.getStylePropertyValue(ele, name);
            } else {
              // empty collection => can't get any value
              return;
            }
          } else {
            // then set the bypass with the property value
            style.applyBypass(this, name, value, updateTransitions);
            this.emitAndNotify('style'); // let the renderer know we've updated style
          }
        } else if (name === undefined) {
          var _ele = this[0];
  
          if (_ele) {
            return style.getRawStyle(_ele);
          } else {
            // empty collection => can't get any value
            return;
          }
        }
  
        return this; // chaining
      },
      removeStyle: function removeStyle(names) {
        var cy = this.cy();
  
        if (!cy.styleEnabled()) {
          return this;
        }
  
        var updateTransitions = false;
        var style = cy.style();
        var eles = this;
  
        if (names === undefined) {
          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            style.removeAllBypasses(ele, updateTransitions);
          }
        } else {
          names = names.split(/\s+/);
  
          for (var _i = 0; _i < eles.length; _i++) {
            var _ele2 = eles[_i];
            style.removeBypasses(_ele2, names, updateTransitions);
          }
        }
  
        this.emitAndNotify('style'); // let the renderer know we've updated style
  
        return this; // chaining
      },
      show: function show() {
        this.css('display', 'element');
        return this; // chaining
      },
      hide: function hide() {
        this.css('display', 'none');
        return this; // chaining
      },
      effectiveOpacity: function effectiveOpacity() {
        var cy = this.cy();
  
        if (!cy.styleEnabled()) {
          return 1;
        }
  
        var hasCompoundNodes = cy.hasCompoundNodes();
        var ele = this[0];
  
        if (ele) {
          var _p = ele._private;
          var parentOpacity = ele.pstyle('opacity').value;
  
          if (!hasCompoundNodes) {
            return parentOpacity;
          }
  
          var parents = !_p.data.parent ? null : ele.parents();
  
          if (parents) {
            for (var i = 0; i < parents.length; i++) {
              var parent = parents[i];
              var opacity = parent.pstyle('opacity').value;
              parentOpacity = opacity * parentOpacity;
            }
          }
  
          return parentOpacity;
        }
      },
      transparent: function transparent() {
        var cy = this.cy();
  
        if (!cy.styleEnabled()) {
          return false;
        }
  
        var ele = this[0];
        var hasCompoundNodes = ele.cy().hasCompoundNodes();
  
        if (ele) {
          if (!hasCompoundNodes) {
            return ele.pstyle('opacity').value === 0;
          } else {
            return ele.effectiveOpacity() === 0;
          }
        }
      },
      backgrounding: function backgrounding() {
        var cy = this.cy();
  
        if (!cy.styleEnabled()) {
          return false;
        }
  
        var ele = this[0];
        return ele._private.backgrounding ? true : false;
      }
    };
  
    function checkCompound(ele, parentOk) {
      var _p = ele._private;
      var parents = _p.data.parent ? ele.parents() : null;
  
      if (parents) {
        for (var i = 0; i < parents.length; i++) {
          var parent = parents[i];
  
          if (!parentOk(parent)) {
            return false;
          }
        }
      }
  
      return true;
    }
  
    function defineDerivedStateFunction(specs) {
      var ok = specs.ok;
      var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;
      var parentOk = specs.parentOk || specs.ok;
      return function () {
        var cy = this.cy();
  
        if (!cy.styleEnabled()) {
          return true;
        }
  
        var ele = this[0];
        var hasCompoundNodes = cy.hasCompoundNodes();
  
        if (ele) {
          var _p = ele._private;
  
          if (!ok(ele)) {
            return false;
          }
  
          if (ele.isNode()) {
            return !hasCompoundNodes || checkCompound(ele, parentOk);
          } else {
            var src = _p.source;
            var tgt = _p.target;
            return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));
          }
        }
      };
    }
  
    var eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function (ele) {
      return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);
    });
    elesfn$r.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({
      ok: eleTakesUpSpace
    }));
    var eleInteractive = cacheStyleFunction('eleInteractive', function (ele) {
      return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);
    });
    var parentInteractive = cacheStyleFunction('parentInteractive', function (parent) {
      return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);
    });
    elesfn$r.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({
      ok: eleInteractive,
      parentOk: parentInteractive,
      edgeOkViaNode: eleTakesUpSpace
    }));
  
    elesfn$r.noninteractive = function () {
      var ele = this[0];
  
      if (ele) {
        return !ele.interactive();
      }
    };
  
    var eleVisible = cacheStyleFunction('eleVisible', function (ele) {
      return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);
    });
    var edgeVisibleViaNode = eleTakesUpSpace;
    elesfn$r.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({
      ok: eleVisible,
      edgeOkViaNode: edgeVisibleViaNode
    }));
  
    elesfn$r.hidden = function () {
      var ele = this[0];
  
      if (ele) {
        return !ele.visible();
      }
    };
  
    elesfn$r.isBundledBezier = cachePrototypeStyleFunction('isBundledBezier', function () {
      if (!this.cy().styleEnabled()) {
        return false;
      }
  
      return !this.removed() && this.pstyle('curve-style').value === 'bezier' && this.takesUpSpace();
    });
    elesfn$r.bypass = elesfn$r.css = elesfn$r.style;
    elesfn$r.renderedCss = elesfn$r.renderedStyle;
    elesfn$r.removeBypass = elesfn$r.removeCss = elesfn$r.removeStyle;
    elesfn$r.pstyle = elesfn$r.parsedStyle;
  
    var elesfn$s = {};
  
    function defineSwitchFunction(params) {
      return function () {
        var args = arguments;
        var changedEles = []; // e.g. cy.nodes().select( data, handler )
  
        if (args.length === 2) {
          var data = args[0];
          var handler = args[1];
          this.on(params.event, data, handler);
        } // e.g. cy.nodes().select( handler )
        else if (args.length === 1 && fn(args[0])) {
            var _handler = args[0];
            this.on(params.event, _handler);
          } // e.g. cy.nodes().select()
          // e.g. (private) cy.nodes().select(['tapselect'])
          else if (args.length === 0 || args.length === 1 && array(args[0])) {
              var addlEvents = args.length === 1 ? args[0] : null;
  
              for (var i = 0; i < this.length; i++) {
                var ele = this[i];
                var able = !params.ableField || ele._private[params.ableField];
                var changed = ele._private[params.field] != params.value;
  
                if (params.overrideAble) {
                  var overrideAble = params.overrideAble(ele);
  
                  if (overrideAble !== undefined) {
                    able = overrideAble;
  
                    if (!overrideAble) {
                      return this;
                    } // to save cycles assume not able for all on override
  
                  }
                }
  
                if (able) {
                  ele._private[params.field] = params.value;
  
                  if (changed) {
                    changedEles.push(ele);
                  }
                }
              }
  
              var changedColl = this.spawn(changedEles);
              changedColl.updateStyle(); // change of state => possible change of style
  
              changedColl.emit(params.event);
  
              if (addlEvents) {
                changedColl.emit(addlEvents);
              }
            }
  
        return this;
      };
    }
  
    function defineSwitchSet(params) {
      elesfn$s[params.field] = function () {
        var ele = this[0];
  
        if (ele) {
          if (params.overrideField) {
            var val = params.overrideField(ele);
  
            if (val !== undefined) {
              return val;
            }
          }
  
          return ele._private[params.field];
        }
      };
  
      elesfn$s[params.on] = defineSwitchFunction({
        event: params.on,
        field: params.field,
        ableField: params.ableField,
        overrideAble: params.overrideAble,
        value: true
      });
      elesfn$s[params.off] = defineSwitchFunction({
        event: params.off,
        field: params.field,
        ableField: params.ableField,
        overrideAble: params.overrideAble,
        value: false
      });
    }
  
    defineSwitchSet({
      field: 'locked',
      overrideField: function overrideField(ele) {
        return ele.cy().autolock() ? true : undefined;
      },
      on: 'lock',
      off: 'unlock'
    });
    defineSwitchSet({
      field: 'grabbable',
      overrideField: function overrideField(ele) {
        return ele.cy().autoungrabify() || ele.pannable() ? false : undefined;
      },
      on: 'grabify',
      off: 'ungrabify'
    });
    defineSwitchSet({
      field: 'selected',
      ableField: 'selectable',
      overrideAble: function overrideAble(ele) {
        return ele.cy().autounselectify() ? false : undefined;
      },
      on: 'select',
      off: 'unselect'
    });
    defineSwitchSet({
      field: 'selectable',
      overrideField: function overrideField(ele) {
        return ele.cy().autounselectify() ? false : undefined;
      },
      on: 'selectify',
      off: 'unselectify'
    });
    elesfn$s.deselect = elesfn$s.unselect;
  
    elesfn$s.grabbed = function () {
      var ele = this[0];
  
      if (ele) {
        return ele._private.grabbed;
      }
    };
  
    defineSwitchSet({
      field: 'active',
      on: 'activate',
      off: 'unactivate'
    });
    defineSwitchSet({
      field: 'pannable',
      on: 'panify',
      off: 'unpanify'
    });
  
    elesfn$s.inactive = function () {
      var ele = this[0];
  
      if (ele) {
        return !ele._private.active;
      }
    };
  
    var elesfn$t = {}; // DAG functions
    ////////////////
  
    var defineDagExtremity = function defineDagExtremity(params) {
      return function dagExtremityImpl(selector) {
        var eles = this;
        var ret = [];
  
        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
  
          if (!ele.isNode()) {
            continue;
          }
  
          var disqualified = false;
          var edges = ele.connectedEdges();
  
          for (var j = 0; j < edges.length; j++) {
            var edge = edges[j];
            var src = edge.source();
            var tgt = edge.target();
  
            if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {
              disqualified = true;
              break;
            }
          }
  
          if (!disqualified) {
            ret.push(ele);
          }
        }
  
        return this.spawn(ret, {
          unique: true
        }).filter(selector);
      };
    };
  
    var defineDagOneHop = function defineDagOneHop(params) {
      return function (selector) {
        var eles = this;
        var oEles = [];
  
        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
  
          if (!ele.isNode()) {
            continue;
          }
  
          var edges = ele.connectedEdges();
  
          for (var j = 0; j < edges.length; j++) {
            var edge = edges[j];
            var src = edge.source();
            var tgt = edge.target();
  
            if (params.outgoing && src === ele) {
              oEles.push(edge);
              oEles.push(tgt);
            } else if (params.incoming && tgt === ele) {
              oEles.push(edge);
              oEles.push(src);
            }
          }
        }
  
        return this.spawn(oEles, {
          unique: true
        }).filter(selector);
      };
    };
  
    var defineDagAllHops = function defineDagAllHops(params) {
      return function (selector) {
        var eles = this;
        var sEles = [];
        var sElesIds = {};
  
        for (;;) {
          var next = params.outgoing ? eles.outgoers() : eles.incomers();
  
          if (next.length === 0) {
            break;
          } // done if none left
  
  
          var newNext = false;
  
          for (var i = 0; i < next.length; i++) {
            var n = next[i];
            var nid = n.id();
  
            if (!sElesIds[nid]) {
              sElesIds[nid] = true;
              sEles.push(n);
              newNext = true;
            }
          }
  
          if (!newNext) {
            break;
          } // done if touched all outgoers already
  
  
          eles = next;
        }
  
        return this.spawn(sEles, {
          unique: true
        }).filter(selector);
      };
    };
  
    elesfn$t.clearTraversalCache = function () {
      for (var i = 0; i < this.length; i++) {
        this[i]._private.traversalCache = null;
      }
    };
  
    extend(elesfn$t, {
      // get the root nodes in the DAG
      roots: defineDagExtremity({
        noIncomingEdges: true
      }),
      // get the leaf nodes in the DAG
      leaves: defineDagExtremity({
        noOutgoingEdges: true
      }),
      // normally called children in graph theory
      // these nodes =edges=> outgoing nodes
      outgoers: cache(defineDagOneHop({
        outgoing: true
      }), 'outgoers'),
      // aka DAG descendants
      successors: defineDagAllHops({
        outgoing: true
      }),
      // normally called parents in graph theory
      // these nodes <=edges= incoming nodes
      incomers: cache(defineDagOneHop({
        incoming: true
      }), 'incomers'),
      // aka DAG ancestors
      predecessors: defineDagAllHops({
        incoming: true
      })
    }); // Neighbourhood functions
    //////////////////////////
  
    extend(elesfn$t, {
      neighborhood: cache(function (selector) {
        var elements = [];
        var nodes = this.nodes();
  
        for (var i = 0; i < nodes.length; i++) {
          // for all nodes
          var node = nodes[i];
          var connectedEdges = node.connectedEdges(); // for each connected edge, add the edge and the other node
  
          for (var j = 0; j < connectedEdges.length; j++) {
            var edge = connectedEdges[j];
            var src = edge.source();
            var tgt = edge.target();
            var otherNode = node === src ? tgt : src; // need check in case of loop
  
            if (otherNode.length > 0) {
              elements.push(otherNode[0]); // add node 1 hop away
            } // add connected edge
  
  
            elements.push(edge[0]);
          }
        }
  
        return this.spawn(elements, {
          unique: true
        }).filter(selector);
      }, 'neighborhood'),
      closedNeighborhood: function closedNeighborhood(selector) {
        return this.neighborhood().add(this).filter(selector);
      },
      openNeighborhood: function openNeighborhood(selector) {
        return this.neighborhood(selector);
      }
    }); // aliases
  
    elesfn$t.neighbourhood = elesfn$t.neighborhood;
    elesfn$t.closedNeighbourhood = elesfn$t.closedNeighborhood;
    elesfn$t.openNeighbourhood = elesfn$t.openNeighborhood; // Edge functions
    /////////////////
  
    extend(elesfn$t, {
      source: cache(function sourceImpl(selector) {
        var ele = this[0];
        var src;
  
        if (ele) {
          src = ele._private.source || ele.cy().collection();
        }
  
        return src && selector ? src.filter(selector) : src;
      }, 'source'),
      target: cache(function targetImpl(selector) {
        var ele = this[0];
        var tgt;
  
        if (ele) {
          tgt = ele._private.target || ele.cy().collection();
        }
  
        return tgt && selector ? tgt.filter(selector) : tgt;
      }, 'target'),
      sources: defineSourceFunction({
        attr: 'source'
      }),
      targets: defineSourceFunction({
        attr: 'target'
      })
    });
  
    function defineSourceFunction(params) {
      return function sourceImpl(selector) {
        var sources = [];
  
        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
          var src = ele._private[params.attr];
  
          if (src) {
            sources.push(src);
          }
        }
  
        return this.spawn(sources, {
          unique: true
        }).filter(selector);
      };
    }
  
    extend(elesfn$t, {
      edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),
      edgesTo: cache(defineEdgesWithFunction({
        thisIsSrc: true
      }), 'edgesTo')
    });
  
    function defineEdgesWithFunction(params) {
      return function edgesWithImpl(otherNodes) {
        var elements = [];
        var cy = this._private.cy;
        var p = params || {}; // get elements if a selector is specified
  
        if (string(otherNodes)) {
          otherNodes = cy.$(otherNodes);
        }
  
        for (var h = 0; h < otherNodes.length; h++) {
          var edges = otherNodes[h]._private.edges;
  
          for (var i = 0; i < edges.length; i++) {
            var edge = edges[i];
            var edgeData = edge._private.data;
            var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);
            var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);
            var edgeConnectsThisAndOther = thisToOther || otherToThis;
  
            if (!edgeConnectsThisAndOther) {
              continue;
            }
  
            if (p.thisIsSrc || p.thisIsTgt) {
              if (p.thisIsSrc && !thisToOther) {
                continue;
              }
  
              if (p.thisIsTgt && !otherToThis) {
                continue;
              }
            }
  
            elements.push(edge);
          }
        }
  
        return this.spawn(elements, {
          unique: true
        });
      };
    }
  
    extend(elesfn$t, {
      connectedEdges: cache(function (selector) {
        var retEles = [];
        var eles = this;
  
        for (var i = 0; i < eles.length; i++) {
          var node = eles[i];
  
          if (!node.isNode()) {
            continue;
          }
  
          var edges = node._private.edges;
  
          for (var j = 0; j < edges.length; j++) {
            var edge = edges[j];
            retEles.push(edge);
          }
        }
  
        return this.spawn(retEles, {
          unique: true
        }).filter(selector);
      }, 'connectedEdges'),
      connectedNodes: cache(function (selector) {
        var retEles = [];
        var eles = this;
  
        for (var i = 0; i < eles.length; i++) {
          var edge = eles[i];
  
          if (!edge.isEdge()) {
            continue;
          }
  
          retEles.push(edge.source()[0]);
          retEles.push(edge.target()[0]);
        }
  
        return this.spawn(retEles, {
          unique: true
        }).filter(selector);
      }, 'connectedNodes'),
      parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),
      codirectedEdges: cache(defineParallelEdgesFunction({
        codirected: true
      }), 'codirectedEdges')
    });
  
    function defineParallelEdgesFunction(params) {
      var defaults = {
        codirected: false
      };
      params = extend({}, defaults, params);
      return function parallelEdgesImpl(selector) {
        // micro-optimised for renderer
        var elements = [];
        var edges = this.edges();
        var p = params; // look at all the edges in the collection
  
        for (var i = 0; i < edges.length; i++) {
          var edge1 = edges[i];
          var edge1_p = edge1._private;
          var src1 = edge1_p.source;
          var srcid1 = src1._private.data.id;
          var tgtid1 = edge1_p.data.target;
          var srcEdges1 = src1._private.edges; // look at edges connected to the src node of this edge
  
          for (var j = 0; j < srcEdges1.length; j++) {
            var edge2 = srcEdges1[j];
            var edge2data = edge2._private.data;
            var tgtid2 = edge2data.target;
            var srcid2 = edge2data.source;
            var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
            var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;
  
            if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {
              elements.push(edge2);
            }
          }
        }
  
        return this.spawn(elements, {
          unique: true
        }).filter(selector);
      };
    } // Misc functions
    /////////////////
  
  
    extend(elesfn$t, {
      components: function components(root) {
        var self = this;
        var cy = self.cy();
        var visited = cy.collection();
        var unvisited = root == null ? self.nodes() : root.nodes();
        var components = [];
  
        if (root != null && unvisited.empty()) {
          // root may contain only edges
          unvisited = root.sources(); // doesn't matter which node to use (undirected), so just use the source sides
        }
  
        var visitInComponent = function visitInComponent(node, component) {
          visited.merge(node);
          unvisited.unmerge(node);
          component.merge(node);
        };
  
        if (unvisited.empty()) {
          return self.spawn();
        }
  
        var _loop = function _loop() {
          // each iteration yields a component
          var cmpt = cy.collection();
          components.push(cmpt);
          var root = unvisited[0];
          visitInComponent(root, cmpt);
          self.bfs({
            directed: false,
            roots: root,
            visit: function visit(v) {
              return visitInComponent(v, cmpt);
            }
          });
          cmpt.forEach(function (node) {
            node.connectedEdges().forEach(function (e) {
              // connectedEdges() usually cached
              if (self.has(e) && cmpt.has(e.source()) && cmpt.has(e.target())) {
                // has() is cheap
                cmpt.merge(e); // forEach() only considers nodes -- sets N at call time
              }
            });
          });
        };
  
        do {
          _loop();
        } while (unvisited.length > 0);
  
        return components;
      },
      component: function component() {
        var ele = this[0];
        return ele.cy().mutableElements().components(ele)[0];
      }
    });
    elesfn$t.componentsOf = elesfn$t.components;
  
    var idFactory = {
      generate: function generate(cy, element, tryThisId) {
        var id = tryThisId != null ? tryThisId : uuid();
  
        while (cy.hasElementWithId(id)) {
          id = uuid();
        }
  
        return id;
      }
    }; // represents a set of nodes, edges, or both together
  
    var Collection = function Collection(cy, elements, options) {
      if (cy === undefined || !core(cy)) {
        error('A collection must have a reference to the core');
        return;
      }
  
      var map = new Map$1();
      var createdElements = false;
  
      if (!elements) {
        elements = [];
      } else if (elements.length > 0 && plainObject(elements[0]) && !element(elements[0])) {
        createdElements = true; // make elements from json and restore all at once later
  
        var eles = [];
        var elesIds = new Set$1();
  
        for (var i = 0, l = elements.length; i < l; i++) {
          var json = elements[i];
  
          if (json.data == null) {
            json.data = {};
          }
  
          var _data = json.data; // make sure newly created elements have valid ids
  
          if (_data.id == null) {
            _data.id = idFactory.generate(cy, json);
          } else if (cy.hasElementWithId(_data.id) || elesIds.has(_data.id)) {
            continue; // can't create element if prior id already exists
          }
  
          var ele = new Element(cy, json, false);
          eles.push(ele);
          elesIds.add(_data.id);
        }
  
        elements = eles;
      }
  
      this.length = 0;
  
      for (var _i = 0, _l = elements.length; _i < _l; _i++) {
        var element$1 = elements[_i][0]; // [0] in case elements is an array of collections, rather than array of elements
  
        if (element$1 == null) {
          continue;
        }
  
        var id = element$1._private.data.id;
  
        if (options == null || options.unique && !map.has(id)) {
          map.set(id, {
            index: this.length,
            ele: element$1
          });
          this[this.length] = element$1;
          this.length++;
        }
      }
  
      this._private = {
        cy: cy,
        map: map
      }; // restore the elements if we created them from json
  
      if (createdElements) {
        this.restore();
      }
    }; // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    // keep the prototypes in sync (an element has the same functions as a collection)
    // and use elefn and elesfn as shorthands to the prototypes
  
  
    var elesfn$u = Element.prototype = Collection.prototype;
  
    elesfn$u.instanceString = function () {
      return 'collection';
    };
  
    elesfn$u.spawn = function (cy, eles, opts) {
      if (!core(cy)) {
        // cy is optional
        opts = eles;
        eles = cy;
        cy = this.cy();
      }
  
      return new Collection(cy, eles, opts);
    };
  
    elesfn$u.spawnSelf = function () {
      return this.spawn(this);
    };
  
    elesfn$u.cy = function () {
      return this._private.cy;
    };
  
    elesfn$u.renderer = function () {
      return this._private.cy.renderer();
    };
  
    elesfn$u.element = function () {
      return this[0];
    };
  
    elesfn$u.collection = function () {
      if (collection(this)) {
        return this;
      } else {
        // an element
        return new Collection(this._private.cy, [this]);
      }
    };
  
    elesfn$u.unique = function () {
      return new Collection(this._private.cy, this, {
        unique: true
      });
    };
  
    elesfn$u.hasElementWithId = function (id) {
      id = '' + id; // id must be string
  
      return this._private.map.has(id);
    };
  
    elesfn$u.getElementById = function (id) {
      id = '' + id; // id must be string
  
      var cy = this._private.cy;
  
      var entry = this._private.map.get(id);
  
      return entry ? entry.ele : new Collection(cy); // get ele or empty collection
    };
  
    elesfn$u.$id = elesfn$u.getElementById;
  
    elesfn$u.poolIndex = function () {
      var cy = this._private.cy;
      var eles = cy._private.elements;
      var id = this[0]._private.data.id;
      return eles._private.map.get(id).index;
    };
  
    elesfn$u.indexOf = function (ele) {
      var id = ele[0]._private.data.id;
      return this._private.map.get(id).index;
    };
  
    elesfn$u.indexOfId = function (id) {
      id = '' + id; // id must be string
  
      return this._private.map.get(id).index;
    };
  
    elesfn$u.json = function (obj) {
      var ele = this.element();
      var cy = this.cy();
  
      if (ele == null && obj) {
        return this;
      } // can't set to no eles
  
  
      if (ele == null) {
        return undefined;
      } // can't get from no eles
  
  
      var p = ele._private;
  
      if (plainObject(obj)) {
        // set
        cy.startBatch();
  
        if (obj.data) {
          ele.data(obj.data);
          var _data2 = p.data;
  
          if (ele.isEdge()) {
            // source and target are immutable via data()
            var move = false;
            var spec = {};
            var src = obj.data.source;
            var tgt = obj.data.target;
  
            if (src != null && src != _data2.source) {
              spec.source = '' + src; // id must be string
  
              move = true;
            }
  
            if (tgt != null && tgt != _data2.target) {
              spec.target = '' + tgt; // id must be string
  
              move = true;
            }
  
            if (move) {
              ele = ele.move(spec);
            }
          } else {
            // parent is immutable via data()
            var newParentValSpecd = 'parent' in obj.data;
            var parent = obj.data.parent;
  
            if (newParentValSpecd && (parent != null || _data2.parent != null) && parent != _data2.parent) {
              if (parent === undefined) {
                // can't set undefined imperatively, so use null
                parent = null;
              }
  
              if (parent != null) {
                parent = '' + parent; // id must be string
              }
  
              ele = ele.move({
                parent: parent
              });
            }
          }
        }
  
        if (obj.position) {
          ele.position(obj.position);
        } // ignore group -- immutable
  
  
        var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {
          var obj_k = obj[k];
  
          if (obj_k != null && obj_k !== p[k]) {
            if (obj_k) {
              ele[trueFnName]();
            } else {
              ele[falseFnName]();
            }
          }
        };
  
        checkSwitch('removed', 'remove', 'restore');
        checkSwitch('selected', 'select', 'unselect');
        checkSwitch('selectable', 'selectify', 'unselectify');
        checkSwitch('locked', 'lock', 'unlock');
        checkSwitch('grabbable', 'grabify', 'ungrabify');
        checkSwitch('pannable', 'panify', 'unpanify');
  
        if (obj.classes != null) {
          ele.classes(obj.classes);
        }
  
        cy.endBatch();
        return this;
      } else if (obj === undefined) {
        // get
        var json = {
          data: copy(p.data),
          position: copy(p.position),
          group: p.group,
          removed: p.removed,
          selected: p.selected,
          selectable: p.selectable,
          locked: p.locked,
          grabbable: p.grabbable,
          pannable: p.pannable,
          classes: null
        };
        json.classes = '';
        var i = 0;
        p.classes.forEach(function (cls) {
          return json.classes += i++ === 0 ? cls : ' ' + cls;
        });
        return json;
      }
    };
  
    elesfn$u.jsons = function () {
      var jsons = [];
  
      for (var i = 0; i < this.length; i++) {
        var ele = this[i];
        var json = ele.json();
        jsons.push(json);
      }
  
      return jsons;
    };
  
    elesfn$u.clone = function () {
      var cy = this.cy();
      var elesArr = [];
  
      for (var i = 0; i < this.length; i++) {
        var ele = this[i];
        var json = ele.json();
        var clone = new Element(cy, json, false); // NB no restore
  
        elesArr.push(clone);
      }
  
      return new Collection(cy, elesArr);
    };
  
    elesfn$u.copy = elesfn$u.clone;
  
    elesfn$u.restore = function () {
      var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var addToPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var self = this;
      var cy = self.cy();
      var cy_p = cy._private; // create arrays of nodes and edges, since we need to
      // restore the nodes first
  
      var nodes = [];
      var edges = [];
      var elements;
  
      for (var _i2 = 0, l = self.length; _i2 < l; _i2++) {
        var ele = self[_i2];
  
        if (addToPool && !ele.removed()) {
          // don't need to handle this ele
          continue;
        } // keep nodes first in the array and edges after
  
  
        if (ele.isNode()) {
          // put to front of array if node
          nodes.push(ele);
        } else {
          // put to end of array if edge
          edges.push(ele);
        }
      }
  
      elements = nodes.concat(edges);
      var i;
  
      var removeFromElements = function removeFromElements() {
        elements.splice(i, 1);
        i--;
      }; // now, restore each element
  
  
      for (i = 0; i < elements.length; i++) {
        var _ele = elements[i];
        var _private = _ele._private;
        var _data3 = _private.data; // the traversal cache should start fresh when ele is added
  
        _ele.clearTraversalCache(); // set id and validate
  
  
        if (!addToPool && !_private.removed) ; else if (_data3.id === undefined) {
          _data3.id = idFactory.generate(cy, _ele);
        } else if (number(_data3.id)) {
          _data3.id = '' + _data3.id; // now it's a string
        } else if (emptyString(_data3.id) || !string(_data3.id)) {
          error('Can not create element with invalid string ID `' + _data3.id + '`'); // can't create element if it has empty string as id or non-string id
  
          removeFromElements();
          continue;
        } else if (cy.hasElementWithId(_data3.id)) {
          error('Can not create second element with ID `' + _data3.id + '`'); // can't create element if one already has that id
  
          removeFromElements();
          continue;
        }
  
        var id = _data3.id; // id is finalised, now let's keep a ref
  
        if (_ele.isNode()) {
          // extra checks for nodes
          var pos = _private.position; // make sure the nodes have a defined position
  
          if (pos.x == null) {
            pos.x = 0;
          }
  
          if (pos.y == null) {
            pos.y = 0;
          }
        }
  
        if (_ele.isEdge()) {
          // extra checks for edges
          var edge = _ele;
          var fields = ['source', 'target'];
          var fieldsLength = fields.length;
          var badSourceOrTarget = false;
  
          for (var j = 0; j < fieldsLength; j++) {
            var field = fields[j];
            var val = _data3[field];
  
            if (number(val)) {
              val = _data3[field] = '' + _data3[field]; // now string
            }
  
            if (val == null || val === '') {
              // can't create if source or target is not defined properly
              error('Can not create edge `' + id + '` with unspecified ' + field);
              badSourceOrTarget = true;
            } else if (!cy.hasElementWithId(val)) {
              // can't create edge if one of its nodes doesn't exist
              error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');
              badSourceOrTarget = true;
            }
          }
  
          if (badSourceOrTarget) {
            removeFromElements();
            continue;
          } // can't create this
  
  
          var src = cy.getElementById(_data3.source);
          var tgt = cy.getElementById(_data3.target); // only one edge in node if loop
  
          if (src.same(tgt)) {
            src._private.edges.push(edge);
          } else {
            src._private.edges.push(edge);
  
            tgt._private.edges.push(edge);
          }
  
          edge._private.source = src;
          edge._private.target = tgt;
        } // if is edge
        // create mock ids / indexes maps for element so it can be used like collections
  
  
        _private.map = new Map$1();
  
        _private.map.set(id, {
          ele: _ele,
          index: 0
        });
  
        _private.removed = false;
  
        if (addToPool) {
          cy.addToPool(_ele);
        }
      } // for each element
      // do compound node sanity checks
  
  
      for (var _i3 = 0; _i3 < nodes.length; _i3++) {
        // each node
        var node = nodes[_i3];
        var _data4 = node._private.data;
  
        if (number(_data4.parent)) {
          // then automake string
          _data4.parent = '' + _data4.parent;
        }
  
        var parentId = _data4.parent;
        var specifiedParent = parentId != null;
  
        if (specifiedParent) {
          var parent = cy.getElementById(parentId);
  
          if (parent.empty()) {
            // non-existant parent; just remove it
            _data4.parent = undefined;
          } else {
            var selfAsParent = false;
            var ancestor = parent;
  
            while (!ancestor.empty()) {
              if (node.same(ancestor)) {
                // mark self as parent and remove from data
                selfAsParent = true;
                _data4.parent = undefined; // remove parent reference
                // exit or we loop forever
  
                break;
              }
  
              ancestor = ancestor.parent();
            }
  
            if (!selfAsParent) {
              // connect with children
              parent[0]._private.children.push(node);
  
              node._private.parent = parent[0]; // let the core know we have a compound graph
  
              cy_p.hasCompoundNodes = true;
            }
          } // else
  
        } // if specified parent
  
      } // for each node
  
  
      if (elements.length > 0) {
        var restored = new Collection(cy, elements);
  
        for (var _i4 = 0; _i4 < restored.length; _i4++) {
          var _ele2 = restored[_i4];
  
          if (_ele2.isNode()) {
            continue;
          } // adding an edge invalidates the traversal caches for the parallel edges
  
  
          _ele2.parallelEdges().clearTraversalCache(); // adding an edge invalidates the traversal cache for the connected nodes
  
  
          _ele2.source().clearTraversalCache();
  
          _ele2.target().clearTraversalCache();
        }
  
        var toUpdateStyle;
  
        if (cy_p.hasCompoundNodes) {
          toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());
        } else {
          toUpdateStyle = restored;
        }
  
        toUpdateStyle.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(notifyRenderer);
  
        if (notifyRenderer) {
          restored.emitAndNotify('add');
        } else if (addToPool) {
          restored.emit('add');
        }
      }
  
      return self; // chainability
    };
  
    elesfn$u.removed = function () {
      var ele = this[0];
      return ele && ele._private.removed;
    };
  
    elesfn$u.inside = function () {
      var ele = this[0];
      return ele && !ele._private.removed;
    };
  
    elesfn$u.remove = function () {
      var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var removeFromPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var self = this;
      var elesToRemove = [];
      var elesToRemoveIds = {};
      var cy = self._private.cy; // add connected edges
  
      function addConnectedEdges(node) {
        var edges = node._private.edges;
  
        for (var i = 0; i < edges.length; i++) {
          add(edges[i]);
        }
      } // add descendant nodes
  
  
      function addChildren(node) {
        var children = node._private.children;
  
        for (var i = 0; i < children.length; i++) {
          add(children[i]);
        }
      }
  
      function add(ele) {
        var alreadyAdded = elesToRemoveIds[ele.id()];
  
        if (removeFromPool && ele.removed() || alreadyAdded) {
          return;
        } else {
          elesToRemoveIds[ele.id()] = true;
        }
  
        if (ele.isNode()) {
          elesToRemove.push(ele); // nodes are removed last
  
          addConnectedEdges(ele);
          addChildren(ele);
        } else {
          elesToRemove.unshift(ele); // edges are removed first
        }
      } // make the list of elements to remove
      // (may be removing more than specified due to connected edges etc)
  
  
      for (var i = 0, l = self.length; i < l; i++) {
        var ele = self[i];
        add(ele);
      }
  
      function removeEdgeRef(node, edge) {
        var connectedEdges = node._private.edges;
        removeFromArray(connectedEdges, edge); // removing an edges invalidates the traversal cache for its nodes
  
        node.clearTraversalCache();
      }
  
      function removeParallelRef(pllEdge) {
        // removing an edge invalidates the traversal caches for the parallel edges
        pllEdge.clearTraversalCache();
      }
  
      var alteredParents = [];
      alteredParents.ids = {};
  
      function removeChildRef(parent, ele) {
        ele = ele[0];
        parent = parent[0];
        var children = parent._private.children;
        var pid = parent.id();
        removeFromArray(children, ele); // remove parent => child ref
  
        ele._private.parent = null; // remove child => parent ref
  
        if (!alteredParents.ids[pid]) {
          alteredParents.ids[pid] = true;
          alteredParents.push(parent);
        }
      }
  
      self.dirtyCompoundBoundsCache();
  
      if (removeFromPool) {
        cy.removeFromPool(elesToRemove); // remove from core pool
      }
  
      for (var _i5 = 0; _i5 < elesToRemove.length; _i5++) {
        var _ele3 = elesToRemove[_i5];
  
        if (_ele3.isEdge()) {
          // remove references to this edge in its connected nodes
          var src = _ele3.source()[0];
  
          var tgt = _ele3.target()[0];
  
          removeEdgeRef(src, _ele3);
          removeEdgeRef(tgt, _ele3);
  
          var pllEdges = _ele3.parallelEdges();
  
          for (var j = 0; j < pllEdges.length; j++) {
            var pllEdge = pllEdges[j];
            removeParallelRef(pllEdge);
  
            if (pllEdge.isBundledBezier()) {
              pllEdge.dirtyBoundingBoxCache();
            }
          }
        } else {
          // remove reference to parent
          var parent = _ele3.parent();
  
          if (parent.length !== 0) {
            removeChildRef(parent, _ele3);
          }
        }
  
        if (removeFromPool) {
          // mark as removed
          _ele3._private.removed = true;
        }
      } // check to see if we have a compound graph or not
  
  
      var elesStillInside = cy._private.elements;
      cy._private.hasCompoundNodes = false;
  
      for (var _i6 = 0; _i6 < elesStillInside.length; _i6++) {
        var _ele4 = elesStillInside[_i6];
  
        if (_ele4.isParent()) {
          cy._private.hasCompoundNodes = true;
          break;
        }
      }
  
      var removedElements = new Collection(this.cy(), elesToRemove);
  
      if (removedElements.size() > 0) {
        // must manually notify since trigger won't do this automatically once removed
        if (notifyRenderer) {
          removedElements.emitAndNotify('remove');
        } else if (removeFromPool) {
          removedElements.emit('remove');
        }
      } // the parents who were modified by the removal need their style updated
  
  
      for (var _i7 = 0; _i7 < alteredParents.length; _i7++) {
        var _ele5 = alteredParents[_i7];
  
        if (!removeFromPool || !_ele5.removed()) {
          _ele5.updateStyle();
        }
      }
  
      return removedElements;
    };
  
    elesfn$u.move = function (struct) {
      var cy = this._private.cy;
      var eles = this; // just clean up refs, caches, etc. in the same way as when removing and then restoring
      // (our calls to remove/restore do not remove from the graph or make events)
  
      var notifyRenderer = false;
      var modifyPool = false;
  
      var toString = function toString(id) {
        return id == null ? id : '' + id;
      }; // id must be string
  
  
      if (struct.source !== undefined || struct.target !== undefined) {
        var srcId = toString(struct.source);
        var tgtId = toString(struct.target);
        var srcExists = srcId != null && cy.hasElementWithId(srcId);
        var tgtExists = tgtId != null && cy.hasElementWithId(tgtId);
  
        if (srcExists || tgtExists) {
          cy.batch(function () {
            // avoid duplicate style updates
            eles.remove(notifyRenderer, modifyPool); // clean up refs etc.
  
            eles.emitAndNotify('moveout');
  
            for (var i = 0; i < eles.length; i++) {
              var ele = eles[i];
              var _data5 = ele._private.data;
  
              if (ele.isEdge()) {
                if (srcExists) {
                  _data5.source = srcId;
                }
  
                if (tgtExists) {
                  _data5.target = tgtId;
                }
              }
            }
  
            eles.restore(notifyRenderer, modifyPool); // make new refs, style, etc.
          });
          eles.emitAndNotify('move');
        }
      } else if (struct.parent !== undefined) {
        // move node to new parent
        var parentId = toString(struct.parent);
        var parentExists = parentId === null || cy.hasElementWithId(parentId);
  
        if (parentExists) {
          var pidToAssign = parentId === null ? undefined : parentId;
          cy.batch(function () {
            // avoid duplicate style updates
            var updated = eles.remove(notifyRenderer, modifyPool); // clean up refs etc.
  
            updated.emitAndNotify('moveout');
  
            for (var i = 0; i < eles.length; i++) {
              var ele = eles[i];
              var _data6 = ele._private.data;
  
              if (ele.isNode()) {
                _data6.parent = pidToAssign;
              }
            }
  
            updated.restore(notifyRenderer, modifyPool); // make new refs, style, etc.
          });
          eles.emitAndNotify('move');
        }
      }
  
      return this;
    };
  
    [elesfn$c, elesfn$d, elesfn$e, elesfn$f, elesfn$g, data$1, elesfn$i, dimensions, elesfn$m, elesfn$n, elesfn$o, elesfn$p, elesfn$q, elesfn$r, elesfn$s, elesfn$t].forEach(function (props) {
      extend(elesfn$u, props);
    });
  
    var corefn = {
      add: function add(opts) {
        var elements;
        var cy = this; // add the elements
  
        if (elementOrCollection(opts)) {
          var eles = opts;
  
          if (eles._private.cy === cy) {
            // same instance => just restore
            elements = eles.restore();
          } else {
            // otherwise, copy from json
            var jsons = [];
  
            for (var i = 0; i < eles.length; i++) {
              var ele = eles[i];
              jsons.push(ele.json());
            }
  
            elements = new Collection(cy, jsons);
          }
        } // specify an array of options
        else if (array(opts)) {
            var _jsons = opts;
            elements = new Collection(cy, _jsons);
          } // specify via opts.nodes and opts.edges
          else if (plainObject(opts) && (array(opts.nodes) || array(opts.edges))) {
              var elesByGroup = opts;
              var _jsons2 = [];
              var grs = ['nodes', 'edges'];
  
              for (var _i = 0, il = grs.length; _i < il; _i++) {
                var group = grs[_i];
                var elesArray = elesByGroup[group];
  
                if (array(elesArray)) {
                  for (var j = 0, jl = elesArray.length; j < jl; j++) {
                    var json = extend({
                      group: group
                    }, elesArray[j]);
  
                    _jsons2.push(json);
                  }
                }
              }
  
              elements = new Collection(cy, _jsons2);
            } // specify options for one element
            else {
                var _json = opts;
                elements = new Element(cy, _json).collection();
              }
  
        return elements;
      },
      remove: function remove(collection) {
        if (elementOrCollection(collection)) ; else if (string(collection)) {
          var selector = collection;
          collection = this.$(selector);
        }
  
        return collection.remove();
      }
    };
  
    /* global Float32Array */
  
    /*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */
    function generateCubicBezier(mX1, mY1, mX2, mY2) {
      var NEWTON_ITERATIONS = 4,
          NEWTON_MIN_SLOPE = 0.001,
          SUBDIVISION_PRECISION = 0.0000001,
          SUBDIVISION_MAX_ITERATIONS = 10,
          kSplineTableSize = 11,
          kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),
          float32ArraySupported = typeof Float32Array !== 'undefined';
      /* Must contain four arguments. */
  
      if (arguments.length !== 4) {
        return false;
      }
      /* Arguments must be numbers. */
  
  
      for (var i = 0; i < 4; ++i) {
        if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
          return false;
        }
      }
      /* X values must be in the [0, 1] range. */
  
  
      mX1 = Math.min(mX1, 1);
      mX2 = Math.min(mX2, 1);
      mX1 = Math.max(mX1, 0);
      mX2 = Math.max(mX2, 0);
      var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  
      function A(aA1, aA2) {
        return 1.0 - 3.0 * aA2 + 3.0 * aA1;
      }
  
      function B(aA1, aA2) {
        return 3.0 * aA2 - 6.0 * aA1;
      }
  
      function C(aA1) {
        return 3.0 * aA1;
      }
  
      function calcBezier(aT, aA1, aA2) {
        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
      }
  
      function getSlope(aT, aA1, aA2) {
        return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
      }
  
      function newtonRaphsonIterate(aX, aGuessT) {
        for (var _i = 0; _i < NEWTON_ITERATIONS; ++_i) {
          var currentSlope = getSlope(aGuessT, mX1, mX2);
  
          if (currentSlope === 0.0) {
            return aGuessT;
          }
  
          var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
          aGuessT -= currentX / currentSlope;
        }
  
        return aGuessT;
      }
  
      function calcSampleValues() {
        for (var _i2 = 0; _i2 < kSplineTableSize; ++_i2) {
          mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);
        }
      }
  
      function binarySubdivide(aX, aA, aB) {
        var currentX,
            currentT,
            i = 0;
  
        do {
          currentT = aA + (aB - aA) / 2.0;
          currentX = calcBezier(currentT, mX1, mX2) - aX;
  
          if (currentX > 0.0) {
            aB = currentT;
          } else {
            aA = currentT;
          }
        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  
        return currentT;
      }
  
      function getTForX(aX) {
        var intervalStart = 0.0,
            currentSample = 1,
            lastSample = kSplineTableSize - 1;
  
        for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
          intervalStart += kSampleStepSize;
        }
  
        --currentSample;
        var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),
            guessForT = intervalStart + dist * kSampleStepSize,
            initialSlope = getSlope(guessForT, mX1, mX2);
  
        if (initialSlope >= NEWTON_MIN_SLOPE) {
          return newtonRaphsonIterate(aX, guessForT);
        } else if (initialSlope === 0.0) {
          return guessForT;
        } else {
          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
        }
      }
  
      var _precomputed = false;
  
      function precompute() {
        _precomputed = true;
  
        if (mX1 !== mY1 || mX2 !== mY2) {
          calcSampleValues();
        }
      }
  
      var f = function f(aX) {
        if (!_precomputed) {
          precompute();
        }
  
        if (mX1 === mY1 && mX2 === mY2) {
          return aX;
        }
  
        if (aX === 0) {
          return 0;
        }
  
        if (aX === 1) {
          return 1;
        }
  
        return calcBezier(getTForX(aX), mY1, mY2);
      };
  
      f.getControlPoints = function () {
        return [{
          x: mX1,
          y: mY1
        }, {
          x: mX2,
          y: mY2
        }];
      };
  
      var str = "generateBezier(" + [mX1, mY1, mX2, mY2] + ")";
  
      f.toString = function () {
        return str;
      };
  
      return f;
    }
  
    /*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
  
    /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
       then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
    var generateSpringRK4 = function () {
      function springAccelerationForState(state) {
        return -state.tension * state.x - state.friction * state.v;
      }
  
      function springEvaluateStateWithDerivative(initialState, dt, derivative) {
        var state = {
          x: initialState.x + derivative.dx * dt,
          v: initialState.v + derivative.dv * dt,
          tension: initialState.tension,
          friction: initialState.friction
        };
        return {
          dx: state.v,
          dv: springAccelerationForState(state)
        };
      }
  
      function springIntegrateState(state, dt) {
        var a = {
          dx: state.v,
          dv: springAccelerationForState(state)
        },
            b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
            c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
            d = springEvaluateStateWithDerivative(state, dt, c),
            dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
            dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);
        state.x = state.x + dxdt * dt;
        state.v = state.v + dvdt * dt;
        return state;
      }
  
      return function springRK4Factory(tension, friction, duration) {
        var initState = {
          x: -1,
          v: 0,
          tension: null,
          friction: null
        },
            path = [0],
            time_lapsed = 0,
            tolerance = 1 / 10000,
            DT = 16 / 1000,
            have_duration,
            dt,
            last_state;
        tension = parseFloat(tension) || 500;
        friction = parseFloat(friction) || 20;
        duration = duration || null;
        initState.tension = tension;
        initState.friction = friction;
        have_duration = duration !== null;
        /* Calculate the actual time it takes for this animation to complete with the provided conditions. */
  
        if (have_duration) {
          /* Run the simulation without a duration. */
          time_lapsed = springRK4Factory(tension, friction);
          /* Compute the adjusted time delta. */
  
          dt = time_lapsed / duration * DT;
        } else {
          dt = DT;
        }
  
        for (;;) {
          /* Next/step function .*/
          last_state = springIntegrateState(last_state || initState, dt);
          /* Store the position. */
  
          path.push(1 + last_state.x);
          time_lapsed += 16;
          /* If the change threshold is reached, break. */
  
          if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
            break;
          }
        }
        /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
           computed path and returns a snapshot of the position according to a given percentComplete. */
  
  
        return !have_duration ? time_lapsed : function (percentComplete) {
          return path[percentComplete * (path.length - 1) | 0];
        };
      };
    }();
  
    var cubicBezier = function cubicBezier(t1, p1, t2, p2) {
      var bezier = generateCubicBezier(t1, p1, t2, p2);
      return function (start, end, percent) {
        return start + (end - start) * bezier(percent);
      };
    };
  
    var easings = {
      'linear': function linear(start, end, percent) {
        return start + (end - start) * percent;
      },
      // default easings
      'ease': cubicBezier(0.25, 0.1, 0.25, 1),
      'ease-in': cubicBezier(0.42, 0, 1, 1),
      'ease-out': cubicBezier(0, 0, 0.58, 1),
      'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),
      // sine
      'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),
      'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),
      'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),
      // quad
      'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),
      'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),
      'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),
      // cubic
      'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),
      'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),
      'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),
      // quart
      'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),
      'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),
      'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),
      // quint
      'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),
      'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),
      'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),
      // expo
      'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),
      'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),
      'ease-in-out-expo': cubicBezier(1, 0, 0, 1),
      // circ
      'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),
      'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),
      'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),
      // user param easings...
      'spring': function spring(tension, friction, duration) {
        if (duration === 0) {
          // can't get a spring w/ duration 0
          return easings.linear; // duration 0 => jump to end so impl doesn't matter
        }
  
        var spring = generateSpringRK4(tension, friction, duration);
        return function (start, end, percent) {
          return start + (end - start) * spring(percent);
        };
      },
      'cubic-bezier': cubicBezier
    };
  
    function getEasedValue(type, start, end, percent, easingFn) {
      if (percent === 1) {
        return end;
      }
  
      if (start === end) {
        return end;
      }
  
      var val = easingFn(start, end, percent);
  
      if (type == null) {
        return val;
      }
  
      if (type.roundValue || type.color) {
        val = Math.round(val);
      }
  
      if (type.min !== undefined) {
        val = Math.max(val, type.min);
      }
  
      if (type.max !== undefined) {
        val = Math.min(val, type.max);
      }
  
      return val;
    }
  
    function getValue(prop, spec) {
      if (prop.pfValue != null || prop.value != null) {
        if (prop.pfValue != null && (spec == null || spec.type.units !== '%')) {
          return prop.pfValue;
        } else {
          return prop.value;
        }
      } else {
        return prop;
      }
    }
  
    function ease(startProp, endProp, percent, easingFn, propSpec) {
      var type = propSpec != null ? propSpec.type : null;
  
      if (percent < 0) {
        percent = 0;
      } else if (percent > 1) {
        percent = 1;
      }
  
      var start = getValue(startProp, propSpec);
      var end = getValue(endProp, propSpec);
  
      if (number(start) && number(end)) {
        return getEasedValue(type, start, end, percent, easingFn);
      } else if (array(start) && array(end)) {
        var easedArr = [];
  
        for (var i = 0; i < end.length; i++) {
          var si = start[i];
          var ei = end[i];
  
          if (si != null && ei != null) {
            var val = getEasedValue(type, si, ei, percent, easingFn);
            easedArr.push(val);
          } else {
            easedArr.push(ei);
          }
        }
  
        return easedArr;
      }
  
      return undefined;
    }
  
    function step(self, ani, now, isCore) {
      var isEles = !isCore;
      var _p = self._private;
      var ani_p = ani._private;
      var pEasing = ani_p.easing;
      var startTime = ani_p.startTime;
      var cy = isCore ? self : self.cy();
      var style = cy.style();
  
      if (!ani_p.easingImpl) {
        if (pEasing == null) {
          // use default
          ani_p.easingImpl = easings['linear'];
        } else {
          // then define w/ name
          var easingVals;
  
          if (string(pEasing)) {
            var easingProp = style.parse('transition-timing-function', pEasing);
            easingVals = easingProp.value;
          } else {
            // then assume preparsed array
            easingVals = pEasing;
          }
  
          var name, args;
  
          if (string(easingVals)) {
            name = easingVals;
            args = [];
          } else {
            name = easingVals[1];
            args = easingVals.slice(2).map(function (n) {
              return +n;
            });
          }
  
          if (args.length > 0) {
            // create with args
            if (name === 'spring') {
              args.push(ani_p.duration); // need duration to generate spring
            }
  
            ani_p.easingImpl = easings[name].apply(null, args);
          } else {
            // static impl by name
            ani_p.easingImpl = easings[name];
          }
        }
      }
  
      var easing = ani_p.easingImpl;
      var percent;
  
      if (ani_p.duration === 0) {
        percent = 1;
      } else {
        percent = (now - startTime) / ani_p.duration;
      }
  
      if (ani_p.applying) {
        percent = ani_p.progress;
      }
  
      if (percent < 0) {
        percent = 0;
      } else if (percent > 1) {
        percent = 1;
      }
  
      if (ani_p.delay == null) {
        // then update
        var startPos = ani_p.startPosition;
        var endPos = ani_p.position;
  
        if (endPos && isEles && !self.locked()) {
          var newPos = {};
  
          if (valid(startPos.x, endPos.x)) {
            newPos.x = ease(startPos.x, endPos.x, percent, easing);
          }
  
          if (valid(startPos.y, endPos.y)) {
            newPos.y = ease(startPos.y, endPos.y, percent, easing);
          }
  
          self.position(newPos);
        }
  
        var startPan = ani_p.startPan;
        var endPan = ani_p.pan;
        var pan = _p.pan;
        var animatingPan = endPan != null && isCore;
  
        if (animatingPan) {
          if (valid(startPan.x, endPan.x)) {
            pan.x = ease(startPan.x, endPan.x, percent, easing);
          }
  
          if (valid(startPan.y, endPan.y)) {
            pan.y = ease(startPan.y, endPan.y, percent, easing);
          }
  
          self.emit('pan');
        }
  
        var startZoom = ani_p.startZoom;
        var endZoom = ani_p.zoom;
        var animatingZoom = endZoom != null && isCore;
  
        if (animatingZoom) {
          if (valid(startZoom, endZoom)) {
            _p.zoom = bound(_p.minZoom, ease(startZoom, endZoom, percent, easing), _p.maxZoom);
          }
  
          self.emit('zoom');
        }
  
        if (animatingPan || animatingZoom) {
          self.emit('viewport');
        }
  
        var props = ani_p.style;
  
        if (props && props.length > 0 && isEles) {
          for (var i = 0; i < props.length; i++) {
            var prop = props[i];
            var _name = prop.name;
            var end = prop;
            var start = ani_p.startStyle[_name];
            var propSpec = style.properties[start.name];
            var easedVal = ease(start, end, percent, easing, propSpec);
            style.overrideBypass(self, _name, easedVal);
          } // for props
  
  
          self.emit('style');
        } // if
  
      }
  
      ani_p.progress = percent;
      return percent;
    }
  
    function valid(start, end) {
      if (start == null || end == null) {
        return false;
      }
  
      if (number(start) && number(end)) {
        return true;
      } else if (start && end) {
        return true;
      }
  
      return false;
    }
  
    function startAnimation(self, ani, now, isCore) {
      var ani_p = ani._private;
      ani_p.started = true;
      ani_p.startTime = now - ani_p.progress * ani_p.duration;
    }
  
    function stepAll(now, cy) {
      var eles = cy._private.aniEles;
      var doneEles = [];
  
      function stepOne(ele, isCore) {
        var _p = ele._private;
        var current = _p.animation.current;
        var queue = _p.animation.queue;
        var ranAnis = false; // cancel all animations on display:none ele
  
        if (!isCore && ele.pstyle('display').value === 'none') {
          // put all current and queue animations in this tick's current list
          // and empty the lists for the element
          current = current.splice(0, current.length).concat(queue.splice(0, queue.length)); // stop all animations
  
          for (var i = 0; i < current.length; i++) {
            current[i].stop();
          }
        } // if nothing currently animating, get something from the queue
  
  
        if (current.length === 0) {
          var next = queue.shift();
  
          if (next) {
            current.push(next);
          }
        }
  
        var callbacks = function callbacks(_callbacks) {
          for (var j = _callbacks.length - 1; j >= 0; j--) {
            var cb = _callbacks[j];
            cb();
          }
  
          _callbacks.splice(0, _callbacks.length);
        }; // step and remove if done
  
  
        for (var _i = current.length - 1; _i >= 0; _i--) {
          var ani = current[_i];
          var ani_p = ani._private;
  
          if (ani_p.stopped) {
            current.splice(_i, 1);
            ani_p.hooked = false;
            ani_p.playing = false;
            ani_p.started = false;
            callbacks(ani_p.frames);
            continue;
          }
  
          if (!ani_p.playing && !ani_p.applying) {
            continue;
          } // an apply() while playing shouldn't do anything
  
  
          if (ani_p.playing && ani_p.applying) {
            ani_p.applying = false;
          }
  
          if (!ani_p.started) {
            startAnimation(ele, ani, now);
          }
  
          step(ele, ani, now, isCore);
  
          if (ani_p.applying) {
            ani_p.applying = false;
          }
  
          callbacks(ani_p.frames);
  
          if (ani_p.step != null) {
            ani_p.step(now);
          }
  
          if (ani.completed()) {
            current.splice(_i, 1);
            ani_p.hooked = false;
            ani_p.playing = false;
            ani_p.started = false;
            callbacks(ani_p.completes);
          }
  
          ranAnis = true;
        }
  
        if (!isCore && current.length === 0 && queue.length === 0) {
          doneEles.push(ele);
        }
  
        return ranAnis;
      } // stepElement
      // handle all eles
  
  
      var ranEleAni = false;
  
      for (var e = 0; e < eles.length; e++) {
        var ele = eles[e];
        var handledThisEle = stepOne(ele);
        ranEleAni = ranEleAni || handledThisEle;
      } // each element
  
  
      var ranCoreAni = stepOne(cy, true); // notify renderer
  
      if (ranEleAni || ranCoreAni) {
        if (eles.length > 0) {
          cy.notify('draw', eles);
        } else {
          cy.notify('draw');
        }
      } // remove elements from list of currently animating if its queues are empty
  
  
      eles.unmerge(doneEles);
      cy.emit('step');
    } // stepAll
  
    var corefn$1 = {
      // pull in animation functions
      animate: define$3.animate(),
      animation: define$3.animation(),
      animated: define$3.animated(),
      clearQueue: define$3.clearQueue(),
      delay: define$3.delay(),
      delayAnimation: define$3.delayAnimation(),
      stop: define$3.stop(),
      addToAnimationPool: function addToAnimationPool(eles) {
        var cy = this;
  
        if (!cy.styleEnabled()) {
          return;
        } // save cycles when no style used
  
  
        cy._private.aniEles.merge(eles);
      },
      stopAnimationLoop: function stopAnimationLoop() {
        this._private.animationsRunning = false;
      },
      startAnimationLoop: function startAnimationLoop() {
        var cy = this;
        cy._private.animationsRunning = true;
  
        if (!cy.styleEnabled()) {
          return;
        } // save cycles when no style used
        // NB the animation loop will exec in headless environments if style enabled
        // and explicit cy.destroy() is necessary to stop the loop
  
  
        function headlessStep() {
          if (!cy._private.animationsRunning) {
            return;
          }
  
          requestAnimationFrame(function animationStep(now) {
            stepAll(now, cy);
            headlessStep();
          });
        }
  
        var renderer = cy.renderer();
  
        if (renderer && renderer.beforeRender) {
          // let the renderer schedule animations
          renderer.beforeRender(function rendererAnimationStep(willDraw, now) {
            stepAll(now, cy);
          }, renderer.beforeRenderPriorities.animations);
        } else {
          // manage the animation loop ourselves
          headlessStep(); // first call
        }
      }
    };
  
    var emitterOptions$1 = {
      qualifierCompare: function qualifierCompare(selector1, selector2) {
        if (selector1 == null || selector2 == null) {
          return selector1 == null && selector2 == null;
        } else {
          return selector1.sameText(selector2);
        }
      },
      eventMatches: function eventMatches(cy, listener, eventObj) {
        var selector = listener.qualifier;
  
        if (selector != null) {
          return cy !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);
        }
  
        return true;
      },
      addEventFields: function addEventFields(cy, evt) {
        evt.cy = cy;
        evt.target = cy;
      },
      callbackContext: function callbackContext(cy, listener, eventObj) {
        return listener.qualifier != null ? eventObj.target : cy;
      }
    };
  
    var argSelector$1 = function argSelector(arg) {
      if (string(arg)) {
        return new Selector(arg);
      } else {
        return arg;
      }
    };
  
    var elesfn$v = {
      createEmitter: function createEmitter() {
        var _p = this._private;
  
        if (!_p.emitter) {
          _p.emitter = new Emitter(emitterOptions$1, this);
        }
  
        return this;
      },
      emitter: function emitter() {
        return this._private.emitter;
      },
      on: function on(events, selector, callback) {
        this.emitter().on(events, argSelector$1(selector), callback);
        return this;
      },
      removeListener: function removeListener(events, selector, callback) {
        this.emitter().removeListener(events, argSelector$1(selector), callback);
        return this;
      },
      removeAllListeners: function removeAllListeners() {
        this.emitter().removeAllListeners();
        return this;
      },
      one: function one(events, selector, callback) {
        this.emitter().one(events, argSelector$1(selector), callback);
        return this;
      },
      once: function once(events, selector, callback) {
        this.emitter().one(events, argSelector$1(selector), callback);
        return this;
      },
      emit: function emit(events, extraParams) {
        this.emitter().emit(events, extraParams);
        return this;
      },
      emitAndNotify: function emitAndNotify(event, eles) {
        this.emit(event);
        this.notify(event, eles);
        return this;
      }
    };
    define$3.eventAliasesOn(elesfn$v);
  
    var corefn$2 = {
      png: function png(options) {
        var renderer = this._private.renderer;
        options = options || {};
        return renderer.png(options);
      },
      jpg: function jpg(options) {
        var renderer = this._private.renderer;
        options = options || {};
        options.bg = options.bg || '#fff';
        return renderer.jpg(options);
      }
    };
    corefn$2.jpeg = corefn$2.jpg;
  
    var corefn$3 = {
      layout: function layout(options) {
        var cy = this;
  
        if (options == null) {
          error('Layout options must be specified to make a layout');
          return;
        }
  
        if (options.name == null) {
          error('A `name` must be specified to make a layout');
          return;
        }
  
        var name = options.name;
        var Layout = cy.extension('layout', name);
  
        if (Layout == null) {
          error('No such layout `' + name + '` found.  Did you forget to import it and `cytoscape.use()` it?');
          return;
        }
  
        var eles;
  
        if (string(options.eles)) {
          eles = cy.$(options.eles);
        } else {
          eles = options.eles != null ? options.eles : cy.$();
        }
  
        var layout = new Layout(extend({}, options, {
          cy: cy,
          eles: eles
        }));
        return layout;
      }
    };
    corefn$3.createLayout = corefn$3.makeLayout = corefn$3.layout;
  
    var corefn$4 = {
      notify: function notify(eventName, eventEles) {
        var _p = this._private;
  
        if (this.batching()) {
          _p.batchNotifications = _p.batchNotifications || {};
          var eles = _p.batchNotifications[eventName] = _p.batchNotifications[eventName] || this.collection();
  
          if (eventEles != null) {
            eles.merge(eventEles);
          }
  
          return; // notifications are disabled during batching
        }
  
        if (!_p.notificationsEnabled) {
          return;
        } // exit on disabled
  
  
        var renderer = this.renderer(); // exit if destroy() called on core or renderer in between frames #1499 #1528
  
        if (this.destroyed() || !renderer) {
          return;
        }
  
        renderer.notify(eventName, eventEles);
      },
      notifications: function notifications(bool) {
        var p = this._private;
  
        if (bool === undefined) {
          return p.notificationsEnabled;
        } else {
          p.notificationsEnabled = bool ? true : false;
        }
  
        return this;
      },
      noNotifications: function noNotifications(callback) {
        this.notifications(false);
        callback();
        this.notifications(true);
      },
      batching: function batching() {
        return this._private.batchCount > 0;
      },
      startBatch: function startBatch() {
        var _p = this._private;
  
        if (_p.batchCount == null) {
          _p.batchCount = 0;
        }
  
        if (_p.batchCount === 0) {
          _p.batchStyleEles = this.collection();
          _p.batchNotifications = {};
        }
  
        _p.batchCount++;
        return this;
      },
      endBatch: function endBatch() {
        var _p = this._private;
  
        if (_p.batchCount === 0) {
          return this;
        }
  
        _p.batchCount--;
  
        if (_p.batchCount === 0) {
          // update style for dirty eles
          _p.batchStyleEles.updateStyle();
  
          var renderer = this.renderer(); // notify the renderer of queued eles and event types
  
          Object.keys(_p.batchNotifications).forEach(function (eventName) {
            var eles = _p.batchNotifications[eventName];
  
            if (eles.empty()) {
              renderer.notify(eventName);
            } else {
              renderer.notify(eventName, eles);
            }
          });
        }
  
        return this;
      },
      batch: function batch(callback) {
        this.startBatch();
        callback();
        this.endBatch();
        return this;
      },
      // for backwards compatibility
      batchData: function batchData(map) {
        var cy = this;
        return this.batch(function () {
          var ids = Object.keys(map);
  
          for (var i = 0; i < ids.length; i++) {
            var id = ids[i];
            var data = map[id];
            var ele = cy.getElementById(id);
            ele.data(data);
          }
        });
      }
    };
  
    var rendererDefaults = defaults({
      hideEdgesOnViewport: false,
      textureOnViewport: false,
      motionBlur: false,
      motionBlurOpacity: 0.05,
      pixelRatio: undefined,
      desktopTapThreshold: 4,
      touchTapThreshold: 8,
      wheelSensitivity: 1,
      debug: false,
      showFps: false
    });
    var corefn$5 = {
      renderTo: function renderTo(context, zoom, pan, pxRatio) {
        var r = this._private.renderer;
        r.renderTo(context, zoom, pan, pxRatio);
        return this;
      },
      renderer: function renderer() {
        return this._private.renderer;
      },
      forceRender: function forceRender() {
        this.notify('draw');
        return this;
      },
      resize: function resize() {
        this.invalidateSize();
        this.emitAndNotify('resize');
        return this;
      },
      initRenderer: function initRenderer(options) {
        var cy = this;
        var RendererProto = cy.extension('renderer', options.name);
  
        if (RendererProto == null) {
          error("Can not initialise: No such renderer `".concat(options.name, "` found. Did you forget to import it and `cytoscape.use()` it?"));
          return;
        }
  
        if (options.wheelSensitivity !== undefined) {
          warn("You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.");
        }
  
        var rOpts = rendererDefaults(options);
        rOpts.cy = cy;
        cy._private.renderer = new RendererProto(rOpts);
        this.notify('init');
      },
      destroyRenderer: function destroyRenderer() {
        var cy = this;
        cy.notify('destroy'); // destroy the renderer
  
        var domEle = cy.container();
  
        if (domEle) {
          domEle._cyreg = null;
  
          while (domEle.childNodes.length > 0) {
            domEle.removeChild(domEle.childNodes[0]);
          }
        }
  
        cy._private.renderer = null; // to be extra safe, remove the ref
  
        cy.mutableElements().forEach(function (ele) {
          var _p = ele._private;
          _p.rscratch = {};
          _p.rstyle = {};
          _p.animation.current = [];
          _p.animation.queue = [];
        });
      },
      onRender: function onRender(fn) {
        return this.on('render', fn);
      },
      offRender: function offRender(fn) {
        return this.off('render', fn);
      }
    };
    corefn$5.invalidateDimensions = corefn$5.resize;
  
    var corefn$6 = {
      // get a collection
      // - empty collection on no args
      // - collection of elements in the graph on selector arg
      // - guarantee a returned collection when elements or collection specified
      collection: function collection(eles, opts) {
        if (string(eles)) {
          return this.$(eles);
        } else if (elementOrCollection(eles)) {
          return eles.collection();
        } else if (array(eles)) {
          return new Collection(this, eles, opts);
        }
  
        return new Collection(this);
      },
      nodes: function nodes(selector) {
        var nodes = this.$(function (ele) {
          return ele.isNode();
        });
  
        if (selector) {
          return nodes.filter(selector);
        }
  
        return nodes;
      },
      edges: function edges(selector) {
        var edges = this.$(function (ele) {
          return ele.isEdge();
        });
  
        if (selector) {
          return edges.filter(selector);
        }
  
        return edges;
      },
      // search the graph like jQuery
      $: function $(selector) {
        var eles = this._private.elements;
  
        if (selector) {
          return eles.filter(selector);
        } else {
          return eles.spawnSelf();
        }
      },
      mutableElements: function mutableElements() {
        return this._private.elements;
      }
    }; // aliases
  
    corefn$6.elements = corefn$6.filter = corefn$6.$;
  
    var styfn = {}; // keys for style blocks, e.g. ttfftt
  
    var TRUE = 't';
    var FALSE = 'f'; // (potentially expensive calculation)
    // apply the style to the element based on
    // - its bypass
    // - what selectors match it
  
    styfn.apply = function (eles) {
      var self = this;
      var _p = self._private;
      var cy = _p.cy;
      var updatedEles = cy.collection();
  
      if (_p.newStyle) {
        // clear style caches
        _p.contextStyles = {};
        _p.propDiffs = {};
        self.cleanElements(eles, true);
      }
  
      for (var ie = 0; ie < eles.length; ie++) {
        var ele = eles[ie];
        var cxtMeta = self.getContextMeta(ele);
  
        if (cxtMeta.empty) {
          continue;
        }
  
        var cxtStyle = self.getContextStyle(cxtMeta);
        var app = self.applyContextStyle(cxtMeta, cxtStyle, ele);
  
        if (!_p.newStyle) {
          self.updateTransitions(ele, app.diffProps);
        }
  
        var hintsDiff = self.updateStyleHints(ele);
  
        if (hintsDiff) {
          updatedEles.merge(ele);
        }
      } // for elements
  
  
      _p.newStyle = false;
      return updatedEles;
    };
  
    styfn.getPropertiesDiff = function (oldCxtKey, newCxtKey) {
      var self = this;
      var cache = self._private.propDiffs = self._private.propDiffs || {};
      var dualCxtKey = oldCxtKey + '-' + newCxtKey;
      var cachedVal = cache[dualCxtKey];
  
      if (cachedVal) {
        return cachedVal;
      }
  
      var diffProps = [];
      var addedProp = {};
  
      for (var i = 0; i < self.length; i++) {
        var cxt = self[i];
        var oldHasCxt = oldCxtKey[i] === TRUE;
        var newHasCxt = newCxtKey[i] === TRUE;
        var cxtHasDiffed = oldHasCxt !== newHasCxt;
        var cxtHasMappedProps = cxt.mappedProperties.length > 0;
  
        if (cxtHasDiffed || newHasCxt && cxtHasMappedProps) {
          var props = void 0;
  
          if (cxtHasDiffed && cxtHasMappedProps) {
            props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
          } else if (cxtHasDiffed) {
            props = cxt.properties; // need to check them all
          } else if (cxtHasMappedProps) {
            props = cxt.mappedProperties; // only need to check mapped
          }
  
          for (var j = 0; j < props.length; j++) {
            var prop = props[j];
            var name = prop.name; // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
            // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
            // is cached)
  
            var laterCxtOverrides = false;
  
            for (var k = i + 1; k < self.length; k++) {
              var laterCxt = self[k];
              var hasLaterCxt = newCxtKey[k] === TRUE;
  
              if (!hasLaterCxt) {
                continue;
              } // can't override unless the context is active
  
  
              laterCxtOverrides = laterCxt.properties[prop.name] != null;
  
              if (laterCxtOverrides) {
                break;
              } // exit early as long as one later context overrides
  
            }
  
            if (!addedProp[name] && !laterCxtOverrides) {
              addedProp[name] = true;
              diffProps.push(name);
            }
          } // for props
  
        } // if
  
      } // for contexts
  
  
      cache[dualCxtKey] = diffProps;
      return diffProps;
    };
  
    styfn.getContextMeta = function (ele) {
      var self = this;
      var cxtKey = '';
      var diffProps;
      var prevKey = ele._private.styleCxtKey || '';
  
      if (self._private.newStyle) {
        prevKey = ''; // since we need to apply all style if a fresh stylesheet
      } // get the cxt key
  
  
      for (var i = 0; i < self.length; i++) {
        var context = self[i];
        var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'
  
        if (contextSelectorMatches) {
          cxtKey += TRUE;
        } else {
          cxtKey += FALSE;
        }
      } // for context
  
  
      diffProps = self.getPropertiesDiff(prevKey, cxtKey);
      ele._private.styleCxtKey = cxtKey;
      return {
        key: cxtKey,
        diffPropNames: diffProps,
        empty: diffProps.length === 0
      };
    }; // gets a computed ele style object based on matched contexts
  
  
    styfn.getContextStyle = function (cxtMeta) {
      var cxtKey = cxtMeta.key;
      var self = this;
      var cxtStyles = this._private.contextStyles = this._private.contextStyles || {}; // if already computed style, returned cached copy
  
      if (cxtStyles[cxtKey]) {
        return cxtStyles[cxtKey];
      }
  
      var style = {
        _private: {
          key: cxtKey
        }
      };
  
      for (var i = 0; i < self.length; i++) {
        var cxt = self[i];
        var hasCxt = cxtKey[i] === TRUE;
  
        if (!hasCxt) {
          continue;
        }
  
        for (var j = 0; j < cxt.properties.length; j++) {
          var prop = cxt.properties[j];
          style[prop.name] = prop;
        }
      }
  
      cxtStyles[cxtKey] = style;
      return style;
    };
  
    styfn.applyContextStyle = function (cxtMeta, cxtStyle, ele) {
      var self = this;
      var diffProps = cxtMeta.diffPropNames;
      var retDiffProps = {};
      var types = self.types;
  
      for (var i = 0; i < diffProps.length; i++) {
        var diffPropName = diffProps[i];
        var cxtProp = cxtStyle[diffPropName];
        var eleProp = ele.pstyle(diffPropName);
  
        if (!cxtProp) {
          // no context prop means delete
          if (!eleProp) {
            continue; // no existing prop means nothing needs to be removed
            // nb affects initial application on mapped values like control-point-distances
          } else if (eleProp.bypass) {
            cxtProp = {
              name: diffPropName,
              deleteBypassed: true
            };
          } else {
            cxtProp = {
              name: diffPropName,
              "delete": true
            };
          }
        } // save cycles when the context prop doesn't need to be applied
  
  
        if (eleProp === cxtProp) {
          continue;
        } // save cycles when a mapped context prop doesn't need to be applied
  
  
        if (cxtProp.mapped === types.fn // context prop is function mapper
        && eleProp != null // some props can be null even by default (e.g. a prop that overrides another one)
        && eleProp.mapping != null // ele prop is a concrete value from from a mapper
        && eleProp.mapping.value === cxtProp.value // the current prop on the ele is a flat prop value for the function mapper
        ) {
            // NB don't write to cxtProp, as it's shared among eles (stored in stylesheet)
            var mapping = eleProp.mapping; // can write to mapping, as it's a per-ele copy
  
            var fnValue = mapping.fnValue = cxtProp.value(ele); // temporarily cache the value in case of a miss
  
            if (fnValue === mapping.prevFnValue) {
              continue;
            }
          }
  
        var retDiffProp = retDiffProps[diffPropName] = {
          prev: eleProp
        };
        self.applyParsedProperty(ele, cxtProp);
        retDiffProp.next = ele.pstyle(diffPropName);
  
        if (retDiffProp.next && retDiffProp.next.bypass) {
          retDiffProp.next = retDiffProp.next.bypassed;
        }
      }
  
      return {
        diffProps: retDiffProps
      };
    };
  
    styfn.updateStyleHints = function (ele) {
      var _p = ele._private;
      var self = this;
      var propNames = self.propertyGroupNames;
      var propGrKeys = self.propertyGroupKeys;
  
      var propHash = function propHash(ele, propNames, seedKey) {
        return self.getPropertiesHash(ele, propNames, seedKey);
      };
  
      var oldStyleKey = _p.styleKey;
  
      if (ele.removed()) {
        return false;
      }
  
      var isNode = _p.group === 'nodes'; // get the style key hashes per prop group
      // but lazily -- only use non-default prop values to reduce the number of hashes
      //
  
      var overriddenStyles = ele._private.style;
      propNames = Object.keys(overriddenStyles);
  
      for (var i = 0; i < propGrKeys.length; i++) {
        var grKey = propGrKeys[i];
        _p.styleKeys[grKey] = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];
      }
  
      var updateGrKey1 = function updateGrKey1(val, grKey) {
        return _p.styleKeys[grKey][0] = hashInt(val, _p.styleKeys[grKey][0]);
      };
  
      var updateGrKey2 = function updateGrKey2(val, grKey) {
        return _p.styleKeys[grKey][1] = hashIntAlt(val, _p.styleKeys[grKey][1]);
      };
  
      var updateGrKey = function updateGrKey(val, grKey) {
        updateGrKey1(val, grKey);
        updateGrKey2(val, grKey);
      };
  
      var updateGrKeyWStr = function updateGrKeyWStr(strVal, grKey) {
        for (var j = 0; j < strVal.length; j++) {
          var ch = strVal.charCodeAt(j);
          updateGrKey1(ch, grKey);
          updateGrKey2(ch, grKey);
        }
      }; // - hashing works on 32 bit ints b/c we use bitwise ops
      // - small numbers get cut off (e.g. 0.123 is seen as 0 by the hashing function)
      // - raise up small numbers so more significant digits are seen by hashing
      // - make small numbers larger than a normal value to avoid collisions
      // - works in practice and it's relatively cheap
  
  
      var N = 2000000000;
  
      var cleanNum = function cleanNum(val) {
        return -128 < val && val < 128 && Math.floor(val) !== val ? N - (val * 1024 | 0) : val;
      };
  
      for (var _i = 0; _i < propNames.length; _i++) {
        var name = propNames[_i];
        var parsedProp = overriddenStyles[name];
  
        if (parsedProp == null) {
          continue;
        }
  
        var propInfo = this.properties[name];
        var type = propInfo.type;
        var _grKey = propInfo.groupKey;
        var normalizedNumberVal = void 0;
  
        if (propInfo.hashOverride != null) {
          normalizedNumberVal = propInfo.hashOverride(ele, parsedProp);
        } else if (parsedProp.pfValue != null) {
          normalizedNumberVal = parsedProp.pfValue;
        } // might not be a number if it allows enums
  
  
        var numberVal = propInfo.enums == null ? parsedProp.value : null;
        var haveNormNum = normalizedNumberVal != null;
        var haveUnitedNum = numberVal != null;
        var haveNum = haveNormNum || haveUnitedNum;
        var units = parsedProp.units; // numbers are cheaper to hash than strings
        // 1 hash op vs n hash ops (for length n string)
  
        if (type.number && haveNum) {
          var v = haveNormNum ? normalizedNumberVal : numberVal;
  
          if (type.multiple) {
            for (var _i2 = 0; _i2 < v.length; _i2++) {
              updateGrKey(cleanNum(v[_i2]), _grKey);
            }
          } else {
            updateGrKey(cleanNum(v), _grKey);
          }
  
          if (!haveNormNum && units != null) {
            updateGrKeyWStr(units, _grKey);
          }
        } else {
          updateGrKeyWStr(parsedProp.strValue, _grKey);
        }
      } // overall style key
      //
  
  
      var hash = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];
  
      for (var _i3 = 0; _i3 < propGrKeys.length; _i3++) {
        var _grKey2 = propGrKeys[_i3];
        var grHash = _p.styleKeys[_grKey2];
        hash[0] = hashInt(grHash[0], hash[0]);
        hash[1] = hashIntAlt(grHash[1], hash[1]);
      }
  
      _p.styleKey = combineHashes(hash[0], hash[1]); // label dims
      //
  
      var sk = _p.styleKeys;
      _p.labelDimsKey = combineHashesArray(sk.labelDimensions);
      var labelKeys = propHash(ele, ['label'], sk.labelDimensions);
      _p.labelKey = combineHashesArray(labelKeys);
      _p.labelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, labelKeys));
  
      if (!isNode) {
        var sourceLabelKeys = propHash(ele, ['source-label'], sk.labelDimensions);
        _p.sourceLabelKey = combineHashesArray(sourceLabelKeys);
        _p.sourceLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, sourceLabelKeys));
        var targetLabelKeys = propHash(ele, ['target-label'], sk.labelDimensions);
        _p.targetLabelKey = combineHashesArray(targetLabelKeys);
        _p.targetLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, targetLabelKeys));
      } // node
      //
  
  
      if (isNode) {
        var _p$styleKeys = _p.styleKeys,
            nodeBody = _p$styleKeys.nodeBody,
            nodeBorder = _p$styleKeys.nodeBorder,
            backgroundImage = _p$styleKeys.backgroundImage,
            compound = _p$styleKeys.compound,
            pie = _p$styleKeys.pie;
        var nodeKeys = [nodeBorder, backgroundImage, compound, pie].reduce(hashArrays, nodeBody);
        _p.nodeKey = combineHashesArray(nodeKeys);
        _p.hasPie = pie[0] !== DEFAULT_HASH_SEED && pie[1] !== DEFAULT_HASH_SEED_ALT;
      }
  
      return oldStyleKey !== _p.styleKey;
    };
  
    styfn.clearStyleHints = function (ele) {
      var _p = ele._private;
      _p.styleKeys = {};
      _p.styleKey = null;
      _p.labelKey = null;
      _p.labelStyleKey = null;
      _p.sourceLabelKey = null;
      _p.sourceLabelStyleKey = null;
      _p.targetLabelKey = null;
      _p.targetLabelStyleKey = null;
      _p.nodeKey = null;
      _p.hasPie = null;
    }; // apply a property to the style (for internal use)
    // returns whether application was successful
    //
    // now, this function flattens the property, and here's how:
    //
    // for parsedProp:{ bypass: true, deleteBypass: true }
    // no property is generated, instead the bypass property in the
    // element's style is replaced by what's pointed to by the `bypassed`
    // field in the bypass property (i.e. restoring the property the
    // bypass was overriding)
    //
    // for parsedProp:{ mapped: truthy }
    // the generated flattenedProp:{ mapping: prop }
    //
    // for parsedProp:{ bypass: true }
    // the generated flattenedProp:{ bypassed: parsedProp }
  
  
    styfn.applyParsedProperty = function (ele, parsedProp) {
      var self = this;
      var prop = parsedProp;
      var style = ele._private.style;
      var flatProp;
      var types = self.types;
      var type = self.properties[prop.name].type;
      var propIsBypass = prop.bypass;
      var origProp = style[prop.name];
      var origPropIsBypass = origProp && origProp.bypass;
      var _p = ele._private;
      var flatPropMapping = 'mapping';
  
      var getVal = function getVal(p) {
        if (p == null) {
          return null;
        } else if (p.pfValue != null) {
          return p.pfValue;
        } else {
          return p.value;
        }
      };
  
      var checkTriggers = function checkTriggers() {
        var fromVal = getVal(origProp);
        var toVal = getVal(prop);
        self.checkTriggers(ele, prop.name, fromVal, toVal);
      }; // edge sanity checks to prevent the client from making serious mistakes
  
  
      if (parsedProp.name === 'curve-style' && ele.isEdge() && ( // loops must be bundled beziers
      parsedProp.value !== 'bezier' && ele.isLoop() || // edges connected to compound nodes can not be haystacks
      parsedProp.value === 'haystack' && (ele.source().isParent() || ele.target().isParent()))) {
        prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);
      }
  
      if (prop["delete"]) {
        // delete the property and use the default value on falsey value
        style[prop.name] = undefined;
        checkTriggers();
        return true;
      }
  
      if (prop.deleteBypassed) {
        // delete the property that the
        if (!origProp) {
          checkTriggers();
          return true; // can't delete if no prop
        } else if (origProp.bypass) {
          // delete bypassed
          origProp.bypassed = undefined;
          checkTriggers();
          return true;
        } else {
          return false; // we're unsuccessful deleting the bypassed
        }
      } // check if we need to delete the current bypass
  
  
      if (prop.deleteBypass) {
        // then this property is just here to indicate we need to delete
        if (!origProp) {
          checkTriggers();
          return true; // property is already not defined
        } else if (origProp.bypass) {
          // then replace the bypass property with the original
          // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
          style[prop.name] = origProp.bypassed;
          checkTriggers();
          return true;
        } else {
          return false; // we're unsuccessful deleting the bypass
        }
      }
  
      var printMappingErr = function printMappingErr() {
        warn('Do not assign mappings to elements without corresponding data (i.e. ele `' + ele.id() + '` has no mapping for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');
      }; // put the property in the style objects
  
  
      switch (prop.mapped) {
        // flatten the property if mapped
        case types.mapData:
          {
            // flatten the field (e.g. data.foo.bar)
            var fields = prop.field.split('.');
            var fieldVal = _p.data;
  
            for (var i = 0; i < fields.length && fieldVal; i++) {
              var field = fields[i];
              fieldVal = fieldVal[field];
            }
  
            if (fieldVal == null) {
              printMappingErr();
              return false;
            }
  
            var percent;
  
            if (!number(fieldVal)) {
              // then don't apply and fall back on the existing style
              warn('Do not use continuous mappers without specifying numeric data (i.e. `' + prop.field + ': ' + fieldVal + '` for `' + ele.id() + '` is non-numeric)');
              return false;
            } else {
              var fieldWidth = prop.fieldMax - prop.fieldMin;
  
              if (fieldWidth === 0) {
                // safety check -- not strictly necessary as no props of zero range should be passed here
                percent = 0;
              } else {
                percent = (fieldVal - prop.fieldMin) / fieldWidth;
              }
            } // make sure to bound percent value
  
  
            if (percent < 0) {
              percent = 0;
            } else if (percent > 1) {
              percent = 1;
            }
  
            if (type.color) {
              var r1 = prop.valueMin[0];
              var r2 = prop.valueMax[0];
              var g1 = prop.valueMin[1];
              var g2 = prop.valueMax[1];
              var b1 = prop.valueMin[2];
              var b2 = prop.valueMax[2];
              var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
              var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];
              var clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];
              flatProp = {
                // colours are simple, so just create the flat property instead of expensive string parsing
                bypass: prop.bypass,
                // we're a bypass if the mapping property is a bypass
                name: prop.name,
                value: clr,
                strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
              };
            } else if (type.number) {
              var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
              flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);
            } else {
              return false; // can only map to colours and numbers
            }
  
            if (!flatProp) {
              // if we can't flatten the property, then don't apply the property and fall back on the existing style
              printMappingErr();
              return false;
            }
  
            flatProp.mapping = prop; // keep a reference to the mapping
  
            prop = flatProp; // the flattened (mapped) property is the one we want
  
            break;
          }
        // direct mapping
  
        case types.data:
          {
            // flatten the field (e.g. data.foo.bar)
            var _fields = prop.field.split('.');
  
            var _fieldVal = _p.data;
  
            for (var _i4 = 0; _i4 < _fields.length && _fieldVal; _i4++) {
              var _field = _fields[_i4];
              _fieldVal = _fieldVal[_field];
            }
  
            if (_fieldVal != null) {
              flatProp = this.parse(prop.name, _fieldVal, prop.bypass, flatPropMapping);
            }
  
            if (!flatProp) {
              // if we can't flatten the property, then don't apply and fall back on the existing style
              printMappingErr();
              return false;
            }
  
            flatProp.mapping = prop; // keep a reference to the mapping
  
            prop = flatProp; // the flattened (mapped) property is the one we want
  
            break;
          }
  
        case types.fn:
          {
            var fn = prop.value;
            var fnRetVal = prop.fnValue != null ? prop.fnValue : fn(ele); // check for cached value before calling function
  
            prop.prevFnValue = fnRetVal;
  
            if (fnRetVal == null) {
              warn('Custom function mappers may not return null (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is null)');
              return false;
            }
  
            flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);
  
            if (!flatProp) {
              warn('Custom function mappers may not return invalid values for the property type (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is invalid)');
              return false;
            }
  
            flatProp.mapping = copy(prop); // keep a reference to the mapping
  
            prop = flatProp; // the flattened (mapped) property is the one we want
  
            break;
          }
  
        case undefined:
          break;
        // just set the property
  
        default:
          return false;
        // not a valid mapping
      } // if the property is a bypass property, then link the resultant property to the original one
  
  
      if (propIsBypass) {
        if (origPropIsBypass) {
          // then this bypass overrides the existing one
          prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
        } else {
          // then link the orig prop to the new bypass
          prop.bypassed = origProp;
        }
  
        style[prop.name] = prop; // and set
      } else {
        // prop is not bypass
        if (origPropIsBypass) {
          // then keep the orig prop (since it's a bypass) and link to the new prop
          origProp.bypassed = prop;
        } else {
          // then just replace the old prop with the new one
          style[prop.name] = prop;
        }
      }
  
      checkTriggers();
      return true;
    };
  
    styfn.cleanElements = function (eles, keepBypasses) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        this.clearStyleHints(ele);
        ele.dirtyCompoundBoundsCache();
        ele.dirtyBoundingBoxCache();
  
        if (!keepBypasses) {
          ele._private.style = {};
        } else {
          var style = ele._private.style;
          var propNames = Object.keys(style);
  
          for (var j = 0; j < propNames.length; j++) {
            var propName = propNames[j];
            var eleProp = style[propName];
  
            if (eleProp != null) {
              if (eleProp.bypass) {
                eleProp.bypassed = null;
              } else {
                style[propName] = null;
              }
            }
          }
        }
      }
    }; // updates the visual style for all elements (useful for manual style modification after init)
  
  
    styfn.update = function () {
      var cy = this._private.cy;
      var eles = cy.mutableElements();
      eles.updateStyle();
    }; // diffProps : { name => { prev, next } }
  
  
    styfn.updateTransitions = function (ele, diffProps) {
      var self = this;
      var _p = ele._private;
      var props = ele.pstyle('transition-property').value;
      var duration = ele.pstyle('transition-duration').pfValue;
      var delay = ele.pstyle('transition-delay').pfValue;
  
      if (props.length > 0 && duration > 0) {
        var style = {}; // build up the style to animate towards
  
        var anyPrev = false;
  
        for (var i = 0; i < props.length; i++) {
          var prop = props[i];
          var styProp = ele.pstyle(prop);
          var diffProp = diffProps[prop];
  
          if (!diffProp) {
            continue;
          }
  
          var prevProp = diffProp.prev;
          var fromProp = prevProp;
          var toProp = diffProp.next != null ? diffProp.next : styProp;
          var diff = false;
          var initVal = void 0;
          var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)
  
          if (!fromProp) {
            continue;
          } // consider px values
  
  
          if (number(fromProp.pfValue) && number(toProp.pfValue)) {
            diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy
  
            initVal = fromProp.pfValue + initDt * diff; // consider numerical values
          } else if (number(fromProp.value) && number(toProp.value)) {
            diff = toProp.value - fromProp.value; // nonzero is truthy
  
            initVal = fromProp.value + initDt * diff; // consider colour values
          } else if (array(fromProp.value) && array(toProp.value)) {
            diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];
            initVal = fromProp.strValue;
          } // the previous value is good for an animation only if it's different
  
  
          if (diff) {
            style[prop] = toProp.strValue; // to val
  
            this.applyBypass(ele, prop, initVal); // from val
  
            anyPrev = true;
          }
        } // end if props allow ani
        // can't transition if there's nothing previous to transition from
  
  
        if (!anyPrev) {
          return;
        }
  
        _p.transitioning = true;
        new Promise$1(function (resolve) {
          if (delay > 0) {
            ele.delayAnimation(delay).play().promise().then(resolve);
          } else {
            resolve();
          }
        }).then(function () {
          return ele.animation({
            style: style,
            duration: duration,
            easing: ele.pstyle('transition-timing-function').value,
            queue: false
          }).play().promise();
        }).then(function () {
          // if( !isBypass ){
          self.removeBypasses(ele, props);
          ele.emitAndNotify('style'); // }
  
          _p.transitioning = false;
        });
      } else if (_p.transitioning) {
        this.removeBypasses(ele, props);
        ele.emitAndNotify('style');
        _p.transitioning = false;
      }
    };
  
    styfn.checkTrigger = function (ele, name, fromValue, toValue, getTrigger, onTrigger) {
      var prop = this.properties[name];
      var triggerCheck = getTrigger(prop);
  
      if (triggerCheck != null && triggerCheck(fromValue, toValue)) {
        onTrigger(prop);
      }
    };
  
    styfn.checkZOrderTrigger = function (ele, name, fromValue, toValue) {
      var _this = this;
  
      this.checkTrigger(ele, name, fromValue, toValue, function (prop) {
        return prop.triggersZOrder;
      }, function () {
        _this._private.cy.notify('zorder', ele);
      });
    };
  
    styfn.checkBoundsTrigger = function (ele, name, fromValue, toValue) {
      this.checkTrigger(ele, name, fromValue, toValue, function (prop) {
        return prop.triggersBounds;
      }, function (prop) {
        ele.dirtyCompoundBoundsCache();
        ele.dirtyBoundingBoxCache(); // if the prop change makes the bb of pll bezier edges invalid,
        // then dirty the pll edge bb cache as well
  
        if ( // only for beziers -- so performance of other edges isn't affected
        (ele.pstyle('curve-style').value === 'bezier' // already a bezier
        // was just now changed to or from a bezier:
        || name === 'curve-style' && (fromValue === 'bezier' || toValue === 'bezier')) && prop.triggersBoundsOfParallelBeziers) {
          ele.parallelEdges().forEach(function (pllEdge) {
            if (pllEdge.isBundledBezier()) {
              pllEdge.dirtyBoundingBoxCache();
            }
          });
        }
      });
    };
  
    styfn.checkTriggers = function (ele, name, fromValue, toValue) {
      ele.dirtyStyleCache();
      this.checkZOrderTrigger(ele, name, fromValue, toValue);
      this.checkBoundsTrigger(ele, name, fromValue, toValue);
    };
  
    var styfn$1 = {}; // bypasses are applied to an existing style on an element, and just tacked on temporarily
    // returns true iff application was successful for at least 1 specified property
  
    styfn$1.applyBypass = function (eles, name, value, updateTransitions) {
      var self = this;
      var props = [];
      var isBypass = true; // put all the properties (can specify one or many) in an array after parsing them
  
      if (name === '*' || name === '**') {
        // apply to all property names
        if (value !== undefined) {
          for (var i = 0; i < self.properties.length; i++) {
            var prop = self.properties[i];
            var _name = prop.name;
            var parsedProp = this.parse(_name, value, true);
  
            if (parsedProp) {
              props.push(parsedProp);
            }
          }
        }
      } else if (string(name)) {
        // then parse the single property
        var _parsedProp = this.parse(name, value, true);
  
        if (_parsedProp) {
          props.push(_parsedProp);
        }
      } else if (plainObject(name)) {
        // then parse each property
        var specifiedProps = name;
        updateTransitions = value;
        var names = Object.keys(specifiedProps);
  
        for (var _i = 0; _i < names.length; _i++) {
          var _name2 = names[_i];
          var _value = specifiedProps[_name2];
  
          if (_value === undefined) {
            // try camel case name too
            _value = specifiedProps[dash2camel(_name2)];
          }
  
          if (_value !== undefined) {
            var _parsedProp2 = this.parse(_name2, _value, true);
  
            if (_parsedProp2) {
              props.push(_parsedProp2);
            }
          }
        }
      } else {
        // can't do anything without well defined properties
        return false;
      } // we've failed if there are no valid properties
  
  
      if (props.length === 0) {
        return false;
      } // now, apply the bypass properties on the elements
  
  
      var ret = false; // return true if at least one succesful bypass applied
  
      for (var _i2 = 0; _i2 < eles.length; _i2++) {
        // for each ele
        var ele = eles[_i2];
        var diffProps = {};
        var diffProp = void 0;
  
        for (var j = 0; j < props.length; j++) {
          // for each prop
          var _prop = props[j];
  
          if (updateTransitions) {
            var prevProp = ele.pstyle(_prop.name);
            diffProp = diffProps[_prop.name] = {
              prev: prevProp
            };
          }
  
          ret = this.applyParsedProperty(ele, _prop) || ret;
  
          if (updateTransitions) {
            diffProp.next = ele.pstyle(_prop.name);
          }
        } // for props
  
  
        if (ret) {
          this.updateStyleHints(ele);
        }
  
        if (updateTransitions) {
          this.updateTransitions(ele, diffProps, isBypass);
        }
      } // for eles
  
  
      return ret;
    }; // only useful in specific cases like animation
  
  
    styfn$1.overrideBypass = function (eles, name, value) {
      name = camel2dash(name);
  
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        var prop = ele._private.style[name];
        var type = this.properties[name].type;
        var isColor = type.color;
        var isMulti = type.mutiple;
        var oldValue = !prop ? null : prop.pfValue != null ? prop.pfValue : prop.value;
  
        if (!prop || !prop.bypass) {
          // need a bypass if one doesn't exist
          this.applyBypass(ele, name, value);
        } else {
          prop.value = value;
  
          if (prop.pfValue != null) {
            prop.pfValue = value;
          }
  
          if (isColor) {
            prop.strValue = 'rgb(' + value.join(',') + ')';
          } else if (isMulti) {
            prop.strValue = value.join(' ');
          } else {
            prop.strValue = '' + value;
          }
  
          this.updateStyleHints(ele);
        }
  
        this.checkTriggers(ele, name, oldValue, value);
      }
    };
  
    styfn$1.removeAllBypasses = function (eles, updateTransitions) {
      return this.removeBypasses(eles, this.propertyNames, updateTransitions);
    };
  
    styfn$1.removeBypasses = function (eles, props, updateTransitions) {
      var isBypass = true;
  
      for (var j = 0; j < eles.length; j++) {
        var ele = eles[j];
        var diffProps = {};
  
        for (var i = 0; i < props.length; i++) {
          var name = props[i];
          var prop = this.properties[name];
          var prevProp = ele.pstyle(prop.name);
  
          if (!prevProp || !prevProp.bypass) {
            // if a bypass doesn't exist for the prop, nothing needs to be removed
            continue;
          }
  
          var value = ''; // empty => remove bypass
  
          var parsedProp = this.parse(name, value, true);
          var diffProp = diffProps[prop.name] = {
            prev: prevProp
          };
          this.applyParsedProperty(ele, parsedProp);
          diffProp.next = ele.pstyle(prop.name);
        } // for props
  
  
        this.updateStyleHints(ele);
  
        if (updateTransitions) {
          this.updateTransitions(ele, diffProps, isBypass);
        }
      } // for eles
  
    };
  
    var styfn$2 = {}; // gets what an em size corresponds to in pixels relative to a dom element
  
    styfn$2.getEmSizeInPixels = function () {
      var px = this.containerCss('font-size');
  
      if (px != null) {
        return parseFloat(px);
      } else {
        return 1; // for headless
      }
    }; // gets css property from the core container
  
  
    styfn$2.containerCss = function (propName) {
      var cy = this._private.cy;
      var domElement = cy.container();
  
      if (window$1 && domElement && window$1.getComputedStyle) {
        return window$1.getComputedStyle(domElement).getPropertyValue(propName);
      }
    };
  
    var styfn$3 = {}; // gets the rendered style for an element
  
    styfn$3.getRenderedStyle = function (ele, prop) {
      if (prop) {
        return this.getStylePropertyValue(ele, prop, true);
      } else {
        return this.getRawStyle(ele, true);
      }
    }; // gets the raw style for an element
  
  
    styfn$3.getRawStyle = function (ele, isRenderedVal) {
      var self = this;
      ele = ele[0]; // insure it's an element
  
      if (ele) {
        var rstyle = {};
  
        for (var i = 0; i < self.properties.length; i++) {
          var prop = self.properties[i];
          var val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);
  
          if (val != null) {
            rstyle[prop.name] = val;
            rstyle[dash2camel(prop.name)] = val;
          }
        }
  
        return rstyle;
      }
    };
  
    styfn$3.getIndexedStyle = function (ele, property, subproperty, index) {
      var pstyle = ele.pstyle(property)[subproperty][index];
      return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];
    };
  
    styfn$3.getStylePropertyValue = function (ele, propName, isRenderedVal) {
      var self = this;
      ele = ele[0]; // insure it's an element
  
      if (ele) {
        var prop = self.properties[propName];
  
        if (prop.alias) {
          prop = prop.pointsTo;
        }
  
        var type = prop.type;
        var styleProp = ele.pstyle(prop.name);
  
        if (styleProp) {
          var value = styleProp.value,
              units = styleProp.units,
              strValue = styleProp.strValue;
  
          if (isRenderedVal && type.number && value != null && number(value)) {
            var zoom = ele.cy().zoom();
  
            var getRenderedValue = function getRenderedValue(val) {
              return val * zoom;
            };
  
            var getValueStringWithUnits = function getValueStringWithUnits(val, units) {
              return getRenderedValue(val) + units;
            };
  
            var isArrayValue = array(value);
            var haveUnits = isArrayValue ? units.every(function (u) {
              return u != null;
            }) : units != null;
  
            if (haveUnits) {
              if (isArrayValue) {
                return value.map(function (v, i) {
                  return getValueStringWithUnits(v, units[i]);
                }).join(' ');
              } else {
                return getValueStringWithUnits(value, units);
              }
            } else {
              if (isArrayValue) {
                return value.map(function (v) {
                  return string(v) ? v : '' + getRenderedValue(v);
                }).join(' ');
              } else {
                return '' + getRenderedValue(value);
              }
            }
          } else if (strValue != null) {
            return strValue;
          }
        }
  
        return null;
      }
    };
  
    styfn$3.getAnimationStartStyle = function (ele, aniProps) {
      var rstyle = {};
  
      for (var i = 0; i < aniProps.length; i++) {
        var aniProp = aniProps[i];
        var name = aniProp.name;
        var styleProp = ele.pstyle(name);
  
        if (styleProp !== undefined) {
          // then make a prop of it
          if (plainObject(styleProp)) {
            styleProp = this.parse(name, styleProp.strValue);
          } else {
            styleProp = this.parse(name, styleProp);
          }
        }
  
        if (styleProp) {
          rstyle[name] = styleProp;
        }
      }
  
      return rstyle;
    };
  
    styfn$3.getPropsList = function (propsObj) {
      var self = this;
      var rstyle = [];
      var style = propsObj;
      var props = self.properties;
  
      if (style) {
        var names = Object.keys(style);
  
        for (var i = 0; i < names.length; i++) {
          var name = names[i];
          var val = style[name];
          var prop = props[name] || props[camel2dash(name)];
          var styleProp = this.parse(prop.name, val);
  
          if (styleProp) {
            rstyle.push(styleProp);
          }
        }
      }
  
      return rstyle;
    };
  
    styfn$3.getNonDefaultPropertiesHash = function (ele, propNames, seed) {
      var hash = seed.slice();
      var name, val, strVal, chVal;
      var i, j;
  
      for (i = 0; i < propNames.length; i++) {
        name = propNames[i];
        val = ele.pstyle(name, false);
  
        if (val == null) {
          continue;
        } else if (val.pfValue != null) {
          hash[0] = hashInt(chVal, hash[0]);
          hash[1] = hashIntAlt(chVal, hash[1]);
        } else {
          strVal = val.strValue;
  
          for (j = 0; j < strVal.length; j++) {
            chVal = strVal.charCodeAt(j);
            hash[0] = hashInt(chVal, hash[0]);
            hash[1] = hashIntAlt(chVal, hash[1]);
          }
        }
      }
  
      return hash;
    };
  
    styfn$3.getPropertiesHash = styfn$3.getNonDefaultPropertiesHash;
  
    var styfn$4 = {};
  
    styfn$4.appendFromJson = function (json) {
      var style = this;
  
      for (var i = 0; i < json.length; i++) {
        var context = json[i];
        var selector = context.selector;
        var props = context.style || context.css;
        var names = Object.keys(props);
        style.selector(selector); // apply selector
  
        for (var j = 0; j < names.length; j++) {
          var name = names[j];
          var value = props[name];
          style.css(name, value); // apply property
        }
      }
  
      return style;
    }; // accessible cy.style() function
  
  
    styfn$4.fromJson = function (json) {
      var style = this;
      style.resetToDefault();
      style.appendFromJson(json);
      return style;
    }; // get json from cy.style() api
  
  
    styfn$4.json = function () {
      var json = [];
  
      for (var i = this.defaultLength; i < this.length; i++) {
        var cxt = this[i];
        var selector = cxt.selector;
        var props = cxt.properties;
        var css = {};
  
        for (var j = 0; j < props.length; j++) {
          var prop = props[j];
          css[prop.name] = prop.strValue;
        }
  
        json.push({
          selector: !selector ? 'core' : selector.toString(),
          style: css
        });
      }
  
      return json;
    };
  
    var styfn$5 = {};
  
    styfn$5.appendFromString = function (string) {
      var self = this;
      var style = this;
      var remaining = '' + string;
      var selAndBlockStr;
      var blockRem;
      var propAndValStr; // remove comments from the style string
  
      remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, '');
  
      function removeSelAndBlockFromRemaining() {
        // remove the parsed selector and block from the remaining text to parse
        if (remaining.length > selAndBlockStr.length) {
          remaining = remaining.substr(selAndBlockStr.length);
        } else {
          remaining = '';
        }
      }
  
      function removePropAndValFromRem() {
        // remove the parsed property and value from the remaining block text to parse
        if (blockRem.length > propAndValStr.length) {
          blockRem = blockRem.substr(propAndValStr.length);
        } else {
          blockRem = '';
        }
      }
  
      for (;;) {
        var nothingLeftToParse = remaining.match(/^\s*$/);
  
        if (nothingLeftToParse) {
          break;
        }
  
        var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);
  
        if (!selAndBlock) {
          warn('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);
          break;
        }
  
        selAndBlockStr = selAndBlock[0]; // parse the selector
  
        var selectorStr = selAndBlock[1];
  
        if (selectorStr !== 'core') {
          var selector = new Selector(selectorStr);
  
          if (selector.invalid) {
            warn('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr); // skip this selector and block
  
            removeSelAndBlockFromRemaining();
            continue;
          }
        } // parse the block of properties and values
  
  
        var blockStr = selAndBlock[2];
        var invalidBlock = false;
        blockRem = blockStr;
        var props = [];
  
        for (;;) {
          var _nothingLeftToParse = blockRem.match(/^\s*$/);
  
          if (_nothingLeftToParse) {
            break;
          }
  
          var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);
  
          if (!propAndVal) {
            warn('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);
            invalidBlock = true;
            break;
          }
  
          propAndValStr = propAndVal[0];
          var propStr = propAndVal[1];
          var valStr = propAndVal[2];
          var prop = self.properties[propStr];
  
          if (!prop) {
            warn('Skipping property: Invalid property name in: ' + propAndValStr); // skip this property in the block
  
            removePropAndValFromRem();
            continue;
          }
  
          var parsedProp = style.parse(propStr, valStr);
  
          if (!parsedProp) {
            warn('Skipping property: Invalid property definition in: ' + propAndValStr); // skip this property in the block
  
            removePropAndValFromRem();
            continue;
          }
  
          props.push({
            name: propStr,
            val: valStr
          });
          removePropAndValFromRem();
        }
  
        if (invalidBlock) {
          removeSelAndBlockFromRemaining();
          break;
        } // put the parsed block in the style
  
  
        style.selector(selectorStr);
  
        for (var i = 0; i < props.length; i++) {
          var _prop = props[i];
          style.css(_prop.name, _prop.val);
        }
  
        removeSelAndBlockFromRemaining();
      }
  
      return style;
    };
  
    styfn$5.fromString = function (string) {
      var style = this;
      style.resetToDefault();
      style.appendFromString(string);
      return style;
    };
  
    var styfn$6 = {};
  
    (function () {
      var number = number$1;
      var rgba = rgbaNoBackRefs;
      var hsla = hslaNoBackRefs;
      var hex3$1 = hex3;
      var hex6$1 = hex6;
  
      var data = function data(prefix) {
        return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$';
      };
  
      var mapData = function mapData(prefix) {
        var mapArg = number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3$1 + '|' + hex6$1;
        return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + mapArg + ')\\s*\\,\\s*(' + mapArg + ')\\)$';
      };
  
      var urlRegexes = ['^url\\s*\\(\\s*[\'"]?(.+?)[\'"]?\\s*\\)$', '^(none)$', '^(.+)$']; // each visual style property has a type and needs to be validated according to it
  
      styfn$6.types = {
        time: {
          number: true,
          min: 0,
          units: 's|ms',
          implicitUnits: 'ms'
        },
        percent: {
          number: true,
          min: 0,
          max: 100,
          units: '%',
          implicitUnits: '%'
        },
        percentages: {
          number: true,
          min: 0,
          max: 100,
          units: '%',
          implicitUnits: '%',
          multiple: true
        },
        zeroOneNumber: {
          number: true,
          min: 0,
          max: 1,
          unitless: true
        },
        zeroOneNumbers: {
          number: true,
          min: 0,
          max: 1,
          unitless: true,
          multiple: true
        },
        nOneOneNumber: {
          number: true,
          min: -1,
          max: 1,
          unitless: true
        },
        nonNegativeInt: {
          number: true,
          min: 0,
          integer: true,
          unitless: true
        },
        position: {
          enums: ['parent', 'origin']
        },
        nodeSize: {
          number: true,
          min: 0,
          enums: ['label']
        },
        number: {
          number: true,
          unitless: true
        },
        numbers: {
          number: true,
          unitless: true,
          multiple: true
        },
        positiveNumber: {
          number: true,
          unitless: true,
          min: 0,
          strictMin: true
        },
        size: {
          number: true,
          min: 0
        },
        bidirectionalSize: {
          number: true
        },
        // allows negative
        bidirectionalSizeMaybePercent: {
          number: true,
          allowPercent: true
        },
        // allows negative
        bidirectionalSizes: {
          number: true,
          multiple: true
        },
        // allows negative
        sizeMaybePercent: {
          number: true,
          min: 0,
          allowPercent: true
        },
        axisDirection: {
          enums: ['horizontal', 'leftward', 'rightward', 'vertical', 'upward', 'downward', 'auto']
        },
        paddingRelativeTo: {
          enums: ['width', 'height', 'average', 'min', 'max']
        },
        bgWH: {
          number: true,
          min: 0,
          allowPercent: true,
          enums: ['auto'],
          multiple: true
        },
        bgPos: {
          number: true,
          allowPercent: true,
          multiple: true
        },
        bgRelativeTo: {
          enums: ['inner', 'include-padding'],
          multiple: true
        },
        bgRepeat: {
          enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'],
          multiple: true
        },
        bgFit: {
          enums: ['none', 'contain', 'cover'],
          multiple: true
        },
        bgCrossOrigin: {
          enums: ['anonymous', 'use-credentials'],
          multiple: true
        },
        bgClip: {
          enums: ['none', 'node'],
          multiple: true
        },
        color: {
          color: true
        },
        colors: {
          color: true,
          multiple: true
        },
        fill: {
          enums: ['solid', 'linear-gradient', 'radial-gradient']
        },
        bool: {
          enums: ['yes', 'no']
        },
        lineStyle: {
          enums: ['solid', 'dotted', 'dashed']
        },
        lineCap: {
          enums: ['butt', 'round', 'square']
        },
        borderStyle: {
          enums: ['solid', 'dotted', 'dashed', 'double']
        },
        curveStyle: {
          enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments', 'straight', 'taxi']
        },
        fontFamily: {
          regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$'
        },
        fontStyle: {
          enums: ['italic', 'normal', 'oblique']
        },
        fontWeight: {
          enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900]
        },
        textDecoration: {
          enums: ['none', 'underline', 'overline', 'line-through']
        },
        textTransform: {
          enums: ['none', 'uppercase', 'lowercase']
        },
        textWrap: {
          enums: ['none', 'wrap', 'ellipsis']
        },
        textOverflowWrap: {
          enums: ['whitespace', 'anywhere']
        },
        textBackgroundShape: {
          enums: ['rectangle', 'roundrectangle', 'round-rectangle']
        },
        nodeShape: {
          enums: ['rectangle', 'roundrectangle', 'round-rectangle', 'cutrectangle', 'cut-rectangle', 'bottomroundrectangle', 'bottom-round-rectangle', 'barrel', 'ellipse', 'triangle', 'round-triangle', 'square', 'pentagon', 'round-pentagon', 'hexagon', 'round-hexagon', 'concavehexagon', 'concave-hexagon', 'heptagon', 'round-heptagon', 'octagon', 'round-octagon', 'tag', 'round-tag', 'star', 'diamond', 'round-diamond', 'vee', 'rhomboid', 'polygon']
        },
        compoundIncludeLabels: {
          enums: ['include', 'exclude']
        },
        arrowShape: {
          enums: ['tee', 'triangle', 'triangle-tee', 'circle-triangle', 'triangle-cross', 'triangle-backcurve', 'vee', 'square', 'circle', 'diamond', 'chevron', 'none']
        },
        arrowFill: {
          enums: ['filled', 'hollow']
        },
        display: {
          enums: ['element', 'none']
        },
        visibility: {
          enums: ['hidden', 'visible']
        },
        zCompoundDepth: {
          enums: ['bottom', 'orphan', 'auto', 'top']
        },
        zIndexCompare: {
          enums: ['auto', 'manual']
        },
        valign: {
          enums: ['top', 'center', 'bottom']
        },
        halign: {
          enums: ['left', 'center', 'right']
        },
        justification: {
          enums: ['left', 'center', 'right', 'auto']
        },
        text: {
          string: true
        },
        data: {
          mapping: true,
          regex: data('data')
        },
        layoutData: {
          mapping: true,
          regex: data('layoutData')
        },
        scratch: {
          mapping: true,
          regex: data('scratch')
        },
        mapData: {
          mapping: true,
          regex: mapData('mapData')
        },
        mapLayoutData: {
          mapping: true,
          regex: mapData('mapLayoutData')
        },
        mapScratch: {
          mapping: true,
          regex: mapData('mapScratch')
        },
        fn: {
          mapping: true,
          fn: true
        },
        url: {
          regexes: urlRegexes,
          singleRegexMatchValue: true
        },
        urls: {
          regexes: urlRegexes,
          singleRegexMatchValue: true,
          multiple: true
        },
        propList: {
          propList: true
        },
        angle: {
          number: true,
          units: 'deg|rad',
          implicitUnits: 'rad'
        },
        textRotation: {
          number: true,
          units: 'deg|rad',
          implicitUnits: 'rad',
          enums: ['none', 'autorotate']
        },
        polygonPointList: {
          number: true,
          multiple: true,
          evenMultiple: true,
          min: -1,
          max: 1,
          unitless: true
        },
        edgeDistances: {
          enums: ['intersection', 'node-position']
        },
        edgeEndpoint: {
          number: true,
          multiple: true,
          units: '%|px|em|deg|rad',
          implicitUnits: 'px',
          enums: ['inside-to-node', 'outside-to-node', 'outside-to-node-or-label', 'outside-to-line', 'outside-to-line-or-label'],
          singleEnum: true,
          validate: function validate(valArr, unitsArr) {
            switch (valArr.length) {
              case 2:
                // can be % or px only
                return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';
  
              case 1:
                // can be enum, deg, or rad only
                return string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';
  
              default:
                return false;
            }
          }
        },
        easing: {
          regexes: ['^(spring)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$', '^(cubic-bezier)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$'],
          enums: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine', 'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad', 'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic', 'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart', 'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint', 'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo', 'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ']
        },
        gradientDirection: {
          enums: ['to-bottom', 'to-top', 'to-left', 'to-right', 'to-bottom-right', 'to-bottom-left', 'to-top-right', 'to-top-left', 'to-right-bottom', 'to-left-bottom', 'to-right-top', 'to-left-top']
        },
        boundsExpansion: {
          number: true,
          multiple: true,
          min: 0,
          validate: function validate(valArr) {
            var length = valArr.length;
            return length === 1 || length === 2 || length === 4;
          }
        }
      };
      var diff = {
        zeroNonZero: function zeroNonZero(val1, val2) {
          if ((val1 == null || val2 == null) && val1 !== val2) {
            return true; // null cases could represent any value
          }
  
          if (val1 == 0 && val2 != 0) {
            return true;
          } else if (val1 != 0 && val2 == 0) {
            return true;
          } else {
            return false;
          }
        },
        any: function any(val1, val2) {
          return val1 != val2;
        }
      }; // define visual style properties
      //
      // - n.b. adding a new group of props may require updates to updateStyleHints()
      // - adding new props to an existing group gets handled automatically
  
      var t = styfn$6.types;
      var mainLabel = [{
        name: 'label',
        type: t.text,
        triggersBounds: diff.any
      }, {
        name: 'text-rotation',
        type: t.textRotation,
        triggersBounds: diff.any
      }, {
        name: 'text-margin-x',
        type: t.bidirectionalSize,
        triggersBounds: diff.any
      }, {
        name: 'text-margin-y',
        type: t.bidirectionalSize,
        triggersBounds: diff.any
      }];
      var sourceLabel = [{
        name: 'source-label',
        type: t.text,
        triggersBounds: diff.any
      }, {
        name: 'source-text-rotation',
        type: t.textRotation,
        triggersBounds: diff.any
      }, {
        name: 'source-text-margin-x',
        type: t.bidirectionalSize,
        triggersBounds: diff.any
      }, {
        name: 'source-text-margin-y',
        type: t.bidirectionalSize,
        triggersBounds: diff.any
      }, {
        name: 'source-text-offset',
        type: t.size,
        triggersBounds: diff.any
      }];
      var targetLabel = [{
        name: 'target-label',
        type: t.text,
        triggersBounds: diff.any
      }, {
        name: 'target-text-rotation',
        type: t.textRotation,
        triggersBounds: diff.any
      }, {
        name: 'target-text-margin-x',
        type: t.bidirectionalSize,
        triggersBounds: diff.any
      }, {
        name: 'target-text-margin-y',
        type: t.bidirectionalSize,
        triggersBounds: diff.any
      }, {
        name: 'target-text-offset',
        type: t.size,
        triggersBounds: diff.any
      }];
      var labelDimensions = [{
        name: 'font-family',
        type: t.fontFamily,
        triggersBounds: diff.any
      }, {
        name: 'font-style',
        type: t.fontStyle,
        triggersBounds: diff.any
      }, {
        name: 'font-weight',
        type: t.fontWeight,
        triggersBounds: diff.any
      }, {
        name: 'font-size',
        type: t.size,
        triggersBounds: diff.any
      }, {
        name: 'text-transform',
        type: t.textTransform,
        triggersBounds: diff.any
      }, {
        name: 'text-wrap',
        type: t.textWrap,
        triggersBounds: diff.any
      }, {
        name: 'text-overflow-wrap',
        type: t.textOverflowWrap,
        triggersBounds: diff.any
      }, {
        name: 'text-max-width',
        type: t.size,
        triggersBounds: diff.any
      }, {
        name: 'text-outline-width',
        type: t.size,
        triggersBounds: diff.any
      }, {
        name: 'line-height',
        type: t.positiveNumber,
        triggersBounds: diff.any
      }];
      var commonLabel = [{
        name: 'text-valign',
        type: t.valign,
        triggersBounds: diff.any
      }, {
        name: 'text-halign',
        type: t.halign,
        triggersBounds: diff.any
      }, {
        name: 'color',
        type: t.color
      }, {
        name: 'text-outline-color',
        type: t.color
      }, {
        name: 'text-outline-opacity',
        type: t.zeroOneNumber
      }, {
        name: 'text-background-color',
        type: t.color
      }, {
        name: 'text-background-opacity',
        type: t.zeroOneNumber
      }, {
        name: 'text-background-padding',
        type: t.size,
        triggersBounds: diff.any
      }, {
        name: 'text-border-opacity',
        type: t.zeroOneNumber
      }, {
        name: 'text-border-color',
        type: t.color
      }, {
        name: 'text-border-width',
        type: t.size,
        triggersBounds: diff.any
      }, {
        name: 'text-border-style',
        type: t.borderStyle,
        triggersBounds: diff.any
      }, {
        name: 'text-background-shape',
        type: t.textBackgroundShape,
        triggersBounds: diff.any
      }, {
        name: 'text-justification',
        type: t.justification
      }];
      var behavior = [{
        name: 'events',
        type: t.bool
      }, {
        name: 'text-events',
        type: t.bool
      }];
      var visibility = [{
        name: 'display',
        type: t.display,
        triggersZOrder: diff.any,
        triggersBounds: diff.any,
        triggersBoundsOfParallelBeziers: true
      }, {
        name: 'visibility',
        type: t.visibility,
        triggersZOrder: diff.any
      }, {
        name: 'opacity',
        type: t.zeroOneNumber,
        triggersZOrder: diff.zeroNonZero
      }, {
        name: 'text-opacity',
        type: t.zeroOneNumber
      }, {
        name: 'min-zoomed-font-size',
        type: t.size
      }, {
        name: 'z-compound-depth',
        type: t.zCompoundDepth,
        triggersZOrder: diff.any
      }, {
        name: 'z-index-compare',
        type: t.zIndexCompare,
        triggersZOrder: diff.any
      }, {
        name: 'z-index',
        type: t.nonNegativeInt,
        triggersZOrder: diff.any
      }];
      var overlay = [{
        name: 'overlay-padding',
        type: t.size,
        triggersBounds: diff.any
      }, {
        name: 'overlay-color',
        type: t.color
      }, {
        name: 'overlay-opacity',
        type: t.zeroOneNumber,
        triggersBounds: diff.zeroNonZero
      }];
      var transition = [{
        name: 'transition-property',
        type: t.propList
      }, {
        name: 'transition-duration',
        type: t.time
      }, {
        name: 'transition-delay',
        type: t.time
      }, {
        name: 'transition-timing-function',
        type: t.easing
      }];
  
      var nodeSizeHashOverride = function nodeSizeHashOverride(ele, parsedProp) {
        if (parsedProp.value === 'label') {
          return -ele.poolIndex(); // no hash key hits is using label size (hitrate for perf probably low anyway)
        } else {
          return parsedProp.pfValue;
        }
      };
  
      var nodeBody = [{
        name: 'height',
        type: t.nodeSize,
        triggersBounds: diff.any,
        hashOverride: nodeSizeHashOverride
      }, {
        name: 'width',
        type: t.nodeSize,
        triggersBounds: diff.any,
        hashOverride: nodeSizeHashOverride
      }, {
        name: 'shape',
        type: t.nodeShape,
        triggersBounds: diff.any
      }, {
        name: 'shape-polygon-points',
        type: t.polygonPointList,
        triggersBounds: diff.any
      }, {
        name: 'background-color',
        type: t.color
      }, {
        name: 'background-fill',
        type: t.fill
      }, {
        name: 'background-opacity',
        type: t.zeroOneNumber
      }, {
        name: 'background-blacken',
        type: t.nOneOneNumber
      }, {
        name: 'background-gradient-stop-colors',
        type: t.colors
      }, {
        name: 'background-gradient-stop-positions',
        type: t.percentages
      }, {
        name: 'background-gradient-direction',
        type: t.gradientDirection
      }, {
        name: 'padding',
        type: t.sizeMaybePercent,
        triggersBounds: diff.any
      }, {
        name: 'padding-relative-to',
        type: t.paddingRelativeTo,
        triggersBounds: diff.any
      }, {
        name: 'bounds-expansion',
        type: t.boundsExpansion,
        triggersBounds: diff.any
      }];
      var nodeBorder = [{
        name: 'border-color',
        type: t.color
      }, {
        name: 'border-opacity',
        type: t.zeroOneNumber
      }, {
        name: 'border-width',
        type: t.size,
        triggersBounds: diff.any
      }, {
        name: 'border-style',
        type: t.borderStyle
      }];
      var backgroundImage = [{
        name: 'background-image',
        type: t.urls
      }, {
        name: 'background-image-crossorigin',
        type: t.bgCrossOrigin
      }, {
        name: 'background-image-opacity',
        type: t.zeroOneNumbers
      }, {
        name: 'background-position-x',
        type: t.bgPos
      }, {
        name: 'background-position-y',
        type: t.bgPos
      }, {
        name: 'background-width-relative-to',
        type: t.bgRelativeTo
      }, {
        name: 'background-height-relative-to',
        type: t.bgRelativeTo
      }, {
        name: 'background-repeat',
        type: t.bgRepeat
      }, {
        name: 'background-fit',
        type: t.bgFit
      }, {
        name: 'background-clip',
        type: t.bgClip
      }, {
        name: 'background-width',
        type: t.bgWH
      }, {
        name: 'background-height',
        type: t.bgWH
      }, {
        name: 'background-offset-x',
        type: t.bgPos
      }, {
        name: 'background-offset-y',
        type: t.bgPos
      }];
      var compound = [{
        name: 'position',
        type: t.position,
        triggersBounds: diff.any
      }, {
        name: 'compound-sizing-wrt-labels',
        type: t.compoundIncludeLabels,
        triggersBounds: diff.any
      }, {
        name: 'min-width',
        type: t.size,
        triggersBounds: diff.any
      }, {
        name: 'min-width-bias-left',
        type: t.sizeMaybePercent,
        triggersBounds: diff.any
      }, {
        name: 'min-width-bias-right',
        type: t.sizeMaybePercent,
        triggersBounds: diff.any
      }, {
        name: 'min-height',
        type: t.size,
        triggersBounds: diff.any
      }, {
        name: 'min-height-bias-top',
        type: t.sizeMaybePercent,
        triggersBounds: diff.any
      }, {
        name: 'min-height-bias-bottom',
        type: t.sizeMaybePercent,
        triggersBounds: diff.any
      }];
      var edgeLine = [{
        name: 'line-style',
        type: t.lineStyle
      }, {
        name: 'line-color',
        type: t.color
      }, {
        name: 'line-fill',
        type: t.fill
      }, {
        name: 'line-cap',
        type: t.lineCap
      }, {
        name: 'line-dash-pattern',
        type: t.numbers
      }, {
        name: 'line-dash-offset',
        type: t.number
      }, {
        name: 'line-gradient-stop-colors',
        type: t.colors
      }, {
        name: 'line-gradient-stop-positions',
        type: t.percentages
      }, {
        name: 'curve-style',
        type: t.curveStyle,
        triggersBounds: diff.any,
        triggersBoundsOfParallelBeziers: true
      }, {
        name: 'haystack-radius',
        type: t.zeroOneNumber,
        triggersBounds: diff.any
      }, {
        name: 'source-endpoint',
        type: t.edgeEndpoint,
        triggersBounds: diff.any
      }, {
        name: 'target-endpoint',
        type: t.edgeEndpoint,
        triggersBounds: diff.any
      }, {
        name: 'control-point-step-size',
        type: t.size,
        triggersBounds: diff.any
      }, {
        name: 'control-point-distances',
        type: t.bidirectionalSizes,
        triggersBounds: diff.any
      }, {
        name: 'control-point-weights',
        type: t.numbers,
        triggersBounds: diff.any
      }, {
        name: 'segment-distances',
        type: t.bidirectionalSizes,
        triggersBounds: diff.any
      }, {
        name: 'segment-weights',
        type: t.numbers,
        triggersBounds: diff.any
      }, {
        name: 'taxi-turn',
        type: t.bidirectionalSizeMaybePercent,
        triggersBounds: diff.any
      }, {
        name: 'taxi-turn-min-distance',
        type: t.size,
        triggersBounds: diff.any
      }, {
        name: 'taxi-direction',
        type: t.axisDirection,
        triggersBounds: diff.any
      }, {
        name: 'edge-distances',
        type: t.edgeDistances,
        triggersBounds: diff.any
      }, {
        name: 'arrow-scale',
        type: t.positiveNumber,
        triggersBounds: diff.any
      }, {
        name: 'loop-direction',
        type: t.angle,
        triggersBounds: diff.any
      }, {
        name: 'loop-sweep',
        type: t.angle,
        triggersBounds: diff.any
      }, {
        name: 'source-distance-from-node',
        type: t.size,
        triggersBounds: diff.any
      }, {
        name: 'target-distance-from-node',
        type: t.size,
        triggersBounds: diff.any
      }];
      var ghost = [{
        name: 'ghost',
        type: t.bool,
        triggersBounds: diff.any
      }, {
        name: 'ghost-offset-x',
        type: t.bidirectionalSize,
        triggersBounds: diff.any
      }, {
        name: 'ghost-offset-y',
        type: t.bidirectionalSize,
        triggersBounds: diff.any
      }, {
        name: 'ghost-opacity',
        type: t.zeroOneNumber
      }];
      var core = [{
        name: 'selection-box-color',
        type: t.color
      }, {
        name: 'selection-box-opacity',
        type: t.zeroOneNumber
      }, {
        name: 'selection-box-border-color',
        type: t.color
      }, {
        name: 'selection-box-border-width',
        type: t.size
      }, {
        name: 'active-bg-color',
        type: t.color
      }, {
        name: 'active-bg-opacity',
        type: t.zeroOneNumber
      }, {
        name: 'active-bg-size',
        type: t.size
      }, {
        name: 'outside-texture-bg-color',
        type: t.color
      }, {
        name: 'outside-texture-bg-opacity',
        type: t.zeroOneNumber
      }]; // pie backgrounds for nodes
  
      var pie = [];
      styfn$6.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)
  
      pie.push({
        name: 'pie-size',
        type: t.sizeMaybePercent
      });
  
      for (var i = 1; i <= styfn$6.pieBackgroundN; i++) {
        pie.push({
          name: 'pie-' + i + '-background-color',
          type: t.color
        });
        pie.push({
          name: 'pie-' + i + '-background-size',
          type: t.percent
        });
        pie.push({
          name: 'pie-' + i + '-background-opacity',
          type: t.zeroOneNumber
        });
      } // edge arrows
  
  
      var edgeArrow = [];
      var arrowPrefixes = styfn$6.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];
      [{
        name: 'arrow-shape',
        type: t.arrowShape,
        triggersBounds: diff.any
      }, {
        name: 'arrow-color',
        type: t.color
      }, {
        name: 'arrow-fill',
        type: t.arrowFill
      }].forEach(function (prop) {
        arrowPrefixes.forEach(function (prefix) {
          var name = prefix + '-' + prop.name;
          var type = prop.type,
              triggersBounds = prop.triggersBounds;
          edgeArrow.push({
            name: name,
            type: type,
            triggersBounds: triggersBounds
          });
        });
      }, {});
      var props = styfn$6.properties = [].concat(behavior, transition, visibility, overlay, ghost, commonLabel, labelDimensions, mainLabel, sourceLabel, targetLabel, nodeBody, nodeBorder, backgroundImage, pie, compound, edgeLine, edgeArrow, core);
      var propGroups = styfn$6.propertyGroups = {
        // common to all eles
        behavior: behavior,
        transition: transition,
        visibility: visibility,
        overlay: overlay,
        ghost: ghost,
        // labels
        commonLabel: commonLabel,
        labelDimensions: labelDimensions,
        mainLabel: mainLabel,
        sourceLabel: sourceLabel,
        targetLabel: targetLabel,
        // node props
        nodeBody: nodeBody,
        nodeBorder: nodeBorder,
        backgroundImage: backgroundImage,
        pie: pie,
        compound: compound,
        // edge props
        edgeLine: edgeLine,
        edgeArrow: edgeArrow,
        core: core
      };
      var propGroupNames = styfn$6.propertyGroupNames = {};
      var propGroupKeys = styfn$6.propertyGroupKeys = Object.keys(propGroups);
      propGroupKeys.forEach(function (key) {
        propGroupNames[key] = propGroups[key].map(function (prop) {
          return prop.name;
        });
        propGroups[key].forEach(function (prop) {
          return prop.groupKey = key;
        });
      }); // define aliases
  
      var aliases = styfn$6.aliases = [{
        name: 'content',
        pointsTo: 'label'
      }, {
        name: 'control-point-distance',
        pointsTo: 'control-point-distances'
      }, {
        name: 'control-point-weight',
        pointsTo: 'control-point-weights'
      }, {
        name: 'edge-text-rotation',
        pointsTo: 'text-rotation'
      }, {
        name: 'padding-left',
        pointsTo: 'padding'
      }, {
        name: 'padding-right',
        pointsTo: 'padding'
      }, {
        name: 'padding-top',
        pointsTo: 'padding'
      }, {
        name: 'padding-bottom',
        pointsTo: 'padding'
      }]; // list of property names
  
      styfn$6.propertyNames = props.map(function (p) {
        return p.name;
      }); // allow access of properties by name ( e.g. style.properties.height )
  
      for (var _i = 0; _i < props.length; _i++) {
        var prop = props[_i];
        props[prop.name] = prop; // allow lookup by name
      } // map aliases
  
  
      for (var _i2 = 0; _i2 < aliases.length; _i2++) {
        var alias = aliases[_i2];
        var pointsToProp = props[alias.pointsTo];
        var aliasProp = {
          name: alias.name,
          alias: true,
          pointsTo: pointsToProp
        }; // add alias prop for parsing
  
        props.push(aliasProp);
        props[alias.name] = aliasProp; // allow lookup by name
      }
    })();
  
    styfn$6.getDefaultProperty = function (name) {
      return this.getDefaultProperties()[name];
    };
  
    styfn$6.getDefaultProperties = function () {
      var _p = this._private;
  
      if (_p.defaultProperties != null) {
        return _p.defaultProperties;
      }
  
      var rawProps = extend({
        // core props
        'selection-box-color': '#ddd',
        'selection-box-opacity': 0.65,
        'selection-box-border-color': '#aaa',
        'selection-box-border-width': 1,
        'active-bg-color': 'black',
        'active-bg-opacity': 0.15,
        'active-bg-size': 30,
        'outside-texture-bg-color': '#000',
        'outside-texture-bg-opacity': 0.125,
        // common node/edge props
        'events': 'yes',
        'text-events': 'no',
        'text-valign': 'top',
        'text-halign': 'center',
        'text-justification': 'auto',
        'line-height': 1,
        'color': '#000',
        'text-outline-color': '#000',
        'text-outline-width': 0,
        'text-outline-opacity': 1,
        'text-opacity': 1,
        'text-decoration': 'none',
        'text-transform': 'none',
        'text-wrap': 'none',
        'text-overflow-wrap': 'whitespace',
        'text-max-width': 9999,
        'text-background-color': '#000',
        'text-background-opacity': 0,
        'text-background-shape': 'rectangle',
        'text-background-padding': 0,
        'text-border-opacity': 0,
        'text-border-width': 0,
        'text-border-style': 'solid',
        'text-border-color': '#000',
        'font-family': 'Helvetica Neue, Helvetica, sans-serif',
        'font-style': 'normal',
        'font-weight': 'normal',
        'font-size': 16,
        'min-zoomed-font-size': 0,
        'text-rotation': 'none',
        'source-text-rotation': 'none',
        'target-text-rotation': 'none',
        'visibility': 'visible',
        'display': 'element',
        'opacity': 1,
        'z-compound-depth': 'auto',
        'z-index-compare': 'auto',
        'z-index': 0,
        'label': '',
        'text-margin-x': 0,
        'text-margin-y': 0,
        'source-label': '',
        'source-text-offset': 0,
        'source-text-margin-x': 0,
        'source-text-margin-y': 0,
        'target-label': '',
        'target-text-offset': 0,
        'target-text-margin-x': 0,
        'target-text-margin-y': 0,
        'overlay-opacity': 0,
        'overlay-color': '#000',
        'overlay-padding': 10,
        'transition-property': 'none',
        'transition-duration': 0,
        'transition-delay': 0,
        'transition-timing-function': 'linear',
        // node props
        'background-blacken': 0,
        'background-color': '#999',
        'background-fill': 'solid',
        'background-opacity': 1,
        'background-image': 'none',
        'background-image-crossorigin': 'anonymous',
        'background-image-opacity': 1,
        'background-position-x': '50%',
        'background-position-y': '50%',
        'background-offset-x': 0,
        'background-offset-y': 0,
        'background-width-relative-to': 'include-padding',
        'background-height-relative-to': 'include-padding',
        'background-repeat': 'no-repeat',
        'background-fit': 'none',
        'background-clip': 'node',
        'background-width': 'auto',
        'background-height': 'auto',
        'border-color': '#000',
        'border-opacity': 1,
        'border-width': 0,
        'border-style': 'solid',
        'height': 30,
        'width': 30,
        'shape': 'ellipse',
        'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',
        'bounds-expansion': 0,
        // node gradient
        'background-gradient-direction': 'to-bottom',
        'background-gradient-stop-colors': '#999',
        'background-gradient-stop-positions': '0%',
        // ghost props
        'ghost': 'no',
        'ghost-offset-y': 0,
        'ghost-offset-x': 0,
        'ghost-opacity': 0,
        // compound props
        'padding': 0,
        'padding-relative-to': 'width',
        'position': 'origin',
        'compound-sizing-wrt-labels': 'include',
        'min-width': 0,
        'min-width-bias-left': 0,
        'min-width-bias-right': 0,
        'min-height': 0,
        'min-height-bias-top': 0,
        'min-height-bias-bottom': 0
      }, {
        // node pie bg
        'pie-size': '100%'
      }, [{
        name: 'pie-{{i}}-background-color',
        value: 'black'
      }, {
        name: 'pie-{{i}}-background-size',
        value: '0%'
      }, {
        name: 'pie-{{i}}-background-opacity',
        value: 1
      }].reduce(function (css, prop) {
        for (var i = 1; i <= styfn$6.pieBackgroundN; i++) {
          var name = prop.name.replace('{{i}}', i);
          var val = prop.value;
          css[name] = val;
        }
  
        return css;
      }, {}), {
        // edge props
        'line-style': 'solid',
        'line-color': '#999',
        'line-fill': 'solid',
        'line-cap': 'butt',
        'line-gradient-stop-colors': '#999',
        'line-gradient-stop-positions': '0%',
        'control-point-step-size': 40,
        'control-point-weights': 0.5,
        'segment-weights': 0.5,
        'segment-distances': 20,
        'taxi-turn': '50%',
        'taxi-turn-min-distance': 10,
        'taxi-direction': 'auto',
        'edge-distances': 'intersection',
        'curve-style': 'haystack',
        'haystack-radius': 0,
        'arrow-scale': 1,
        'loop-direction': '-45deg',
        'loop-sweep': '-90deg',
        'source-distance-from-node': 0,
        'target-distance-from-node': 0,
        'source-endpoint': 'outside-to-node',
        'target-endpoint': 'outside-to-node',
        'line-dash-pattern': [6, 3],
        'line-dash-offset': 0
      }, [{
        name: 'arrow-shape',
        value: 'none'
      }, {
        name: 'arrow-color',
        value: '#999'
      }, {
        name: 'arrow-fill',
        value: 'filled'
      }].reduce(function (css, prop) {
        styfn$6.arrowPrefixes.forEach(function (prefix) {
          var name = prefix + '-' + prop.name;
          var val = prop.value;
          css[name] = val;
        });
        return css;
      }, {}));
      var parsedProps = {};
  
      for (var i = 0; i < this.properties.length; i++) {
        var prop = this.properties[i];
  
        if (prop.pointsTo) {
          continue;
        }
  
        var name = prop.name;
        var val = rawProps[name];
        var parsedProp = this.parse(name, val);
        parsedProps[name] = parsedProp;
      }
  
      _p.defaultProperties = parsedProps;
      return _p.defaultProperties;
    };
  
    styfn$6.addDefaultStylesheet = function () {
      this.selector(':parent').css({
        'shape': 'rectangle',
        'padding': 10,
        'background-color': '#eee',
        'border-color': '#ccc',
        'border-width': 1
      }).selector('edge').css({
        'width': 3
      }).selector(':loop').css({
        'curve-style': 'bezier'
      }).selector('edge:compound').css({
        'curve-style': 'bezier',
        'source-endpoint': 'outside-to-line',
        'target-endpoint': 'outside-to-line'
      }).selector(':selected').css({
        'background-color': '#0169D9',
        'line-color': '#0169D9',
        'source-arrow-color': '#0169D9',
        'target-arrow-color': '#0169D9',
        'mid-source-arrow-color': '#0169D9',
        'mid-target-arrow-color': '#0169D9'
      }).selector(':parent:selected').css({
        'background-color': '#CCE1F9',
        'border-color': '#aec8e5'
      }).selector(':active').css({
        'overlay-color': 'black',
        'overlay-padding': 10,
        'overlay-opacity': 0.25
      });
      this.defaultLength = this.length;
    };
  
    var styfn$7 = {}; // a caching layer for property parsing
  
    styfn$7.parse = function (name, value, propIsBypass, propIsFlat) {
      var self = this; // function values can't be cached in all cases, and there isn't much benefit of caching them anyway
  
      if (fn(value)) {
        return self.parseImplWarn(name, value, propIsBypass, propIsFlat);
      }
  
      var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;
      var bypassKey = propIsBypass ? 't' : 'f';
      var valueKey = '' + value;
      var argHash = hashStrings(name, valueKey, bypassKey, flatKey);
      var propCache = self.propCache = self.propCache || [];
      var ret;
  
      if (!(ret = propCache[argHash])) {
        ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);
      } // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden
      // - mappings can't be shared b/c mappings are per-element
  
  
      if (propIsBypass || propIsFlat === 'mapping') {
        // need a copy since props are mutated later in their lifecycles
        ret = copy(ret);
  
        if (ret) {
          ret.value = copy(ret.value); // because it could be an array, e.g. colour
        }
      }
  
      return ret;
    };
  
    styfn$7.parseImplWarn = function (name, value, propIsBypass, propIsFlat) {
      var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);
  
      if (!prop && value != null) {
        warn("The style property `".concat(name, ": ").concat(value, "` is invalid"));
      }
  
      return prop;
    }; // parse a property; return null on invalid; return parsed property otherwise
    // fields :
    // - name : the name of the property
    // - value : the parsed, native-typed value of the property
    // - strValue : a string value that represents the property value in valid css
    // - bypass : true iff the property is a bypass property
  
  
    styfn$7.parseImpl = function (name, value, propIsBypass, propIsFlat) {
      var self = this;
      name = camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')
  
      var property = self.properties[name];
      var passedValue = value;
      var types = self.types;
  
      if (!property) {
        return null;
      } // return null on property of unknown name
  
  
      if (value === undefined) {
        return null;
      } // can't assign undefined
      // the property may be an alias
  
  
      if (property.alias) {
        property = property.pointsTo;
        name = property.name;
      }
  
      var valueIsString = string(value);
  
      if (valueIsString) {
        // trim the value to make parsing easier
        value = value.trim();
      }
  
      var type = property.type;
  
      if (!type) {
        return null;
      } // no type, no luck
      // check if bypass is null or empty string (i.e. indication to delete bypass property)
  
  
      if (propIsBypass && (value === '' || value === null)) {
        return {
          name: name,
          value: value,
          bypass: true,
          deleteBypass: true
        };
      } // check if value is a function used as a mapper
  
  
      if (fn(value)) {
        return {
          name: name,
          value: value,
          strValue: 'fn',
          mapped: types.fn,
          bypass: propIsBypass
        };
      } // check if value is mapped
  
  
      var data, mapData;
  
      if (!valueIsString || propIsFlat || value.length < 7 || value[1] !== 'a') ; else if (value.length >= 7 && value[0] === 'd' && (data = new RegExp(types.data.regex).exec(value))) {
        if (propIsBypass) {
          return false;
        } // mappers not allowed in bypass
  
  
        var mapped = types.data;
        return {
          name: name,
          value: data,
          strValue: '' + value,
          mapped: mapped,
          field: data[1],
          bypass: propIsBypass
        };
      } else if (value.length >= 10 && value[0] === 'm' && (mapData = new RegExp(types.mapData.regex).exec(value))) {
        if (propIsBypass) {
          return false;
        } // mappers not allowed in bypass
  
  
        if (type.multiple) {
          return false;
        } // impossible to map to num
  
  
        var _mapped = types.mapData; // we can map only if the type is a colour or a number
  
        if (!(type.color || type.number)) {
          return false;
        }
  
        var valueMin = this.parse(name, mapData[4]); // parse to validate
  
        if (!valueMin || valueMin.mapped) {
          return false;
        } // can't be invalid or mapped
  
  
        var valueMax = this.parse(name, mapData[5]); // parse to validate
  
        if (!valueMax || valueMax.mapped) {
          return false;
        } // can't be invalid or mapped
        // check if valueMin and valueMax are the same
  
  
        if (valueMin.pfValue === valueMax.pfValue || valueMin.strValue === valueMax.strValue) {
          warn('`' + name + ': ' + value + '` is not a valid mapper because the output range is zero; converting to `' + name + ': ' + valueMin.strValue + '`');
          return this.parse(name, valueMin.strValue); // can't make much of a mapper without a range
        } else if (type.color) {
          var c1 = valueMin.value;
          var c2 = valueMax.value;
          var same = c1[0] === c2[0] // red
          && c1[1] === c2[1] // green
          && c1[2] === c2[2] // blue
          && ( // optional alpha
          c1[3] === c2[3] // same alpha outright
          || (c1[3] == null || c1[3] === 1) && ( // full opacity for colour 1?
          c2[3] == null || c2[3] === 1) // full opacity for colour 2?
          );
  
          if (same) {
            return false;
          } // can't make a mapper without a range
  
        }
  
        return {
          name: name,
          value: mapData,
          strValue: '' + value,
          mapped: _mapped,
          field: mapData[1],
          fieldMin: parseFloat(mapData[2]),
          // min & max are numeric
          fieldMax: parseFloat(mapData[3]),
          valueMin: valueMin.value,
          valueMax: valueMax.value,
          bypass: propIsBypass
        };
      }
  
      if (type.multiple && propIsFlat !== 'multiple') {
        var vals;
  
        if (valueIsString) {
          vals = value.split(/\s+/);
        } else if (array(value)) {
          vals = value;
        } else {
          vals = [value];
        }
  
        if (type.evenMultiple && vals.length % 2 !== 0) {
          return null;
        }
  
        var valArr = [];
        var unitsArr = [];
        var pfValArr = [];
        var strVal = '';
        var hasEnum = false;
  
        for (var i = 0; i < vals.length; i++) {
          var p = self.parse(name, vals[i], propIsBypass, 'multiple');
          hasEnum = hasEnum || string(p.value);
          valArr.push(p.value);
          pfValArr.push(p.pfValue != null ? p.pfValue : p.value);
          unitsArr.push(p.units);
          strVal += (i > 0 ? ' ' : '') + p.strValue;
        }
  
        if (type.validate && !type.validate(valArr, unitsArr)) {
          return null;
        }
  
        if (type.singleEnum && hasEnum) {
          if (valArr.length === 1 && string(valArr[0])) {
            return {
              name: name,
              value: valArr[0],
              strValue: valArr[0],
              bypass: propIsBypass
            };
          } else {
            return null;
          }
        }
  
        return {
          name: name,
          value: valArr,
          pfValue: pfValArr,
          strValue: strVal,
          bypass: propIsBypass,
          units: unitsArr
        };
      } // several types also allow enums
  
  
      var checkEnums = function checkEnums() {
        for (var _i = 0; _i < type.enums.length; _i++) {
          var en = type.enums[_i];
  
          if (en === value) {
            return {
              name: name,
              value: value,
              strValue: '' + value,
              bypass: propIsBypass
            };
          }
        }
  
        return null;
      }; // check the type and return the appropriate object
  
  
      if (type.number) {
        var units;
        var implicitUnits = 'px'; // not set => px
  
        if (type.units) {
          // use specified units if set
          units = type.units;
        }
  
        if (type.implicitUnits) {
          implicitUnits = type.implicitUnits;
        }
  
        if (!type.unitless) {
          if (valueIsString) {
            var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');
  
            if (units) {
              unitsRegex = units;
            } // only allow explicit units if so set
  
  
            var match = value.match('^(' + number$1 + ')(' + unitsRegex + ')?' + '$');
  
            if (match) {
              value = match[1];
              units = match[2] || implicitUnits;
            }
          } else if (!units || type.implicitUnits) {
            units = implicitUnits; // implicitly px if unspecified
          }
        }
  
        value = parseFloat(value); // if not a number and enums not allowed, then the value is invalid
  
        if (isNaN(value) && type.enums === undefined) {
          return null;
        } // check if this number type also accepts special keywords in place of numbers
        // (i.e. `left`, `auto`, etc)
  
  
        if (isNaN(value) && type.enums !== undefined) {
          value = passedValue;
          return checkEnums();
        } // check if value must be an integer
  
  
        if (type.integer && !integer(value)) {
          return null;
        } // check value is within range
  
  
        if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {
          return null;
        }
  
        var ret = {
          name: name,
          value: value,
          strValue: '' + value + (units ? units : ''),
          units: units,
          bypass: propIsBypass
        }; // normalise value in pixels
  
        if (type.unitless || units !== 'px' && units !== 'em') {
          ret.pfValue = value;
        } else {
          ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;
        } // normalise value in ms
  
  
        if (units === 'ms' || units === 's') {
          ret.pfValue = units === 'ms' ? value : 1000 * value;
        } // normalise value in rad
  
  
        if (units === 'deg' || units === 'rad') {
          ret.pfValue = units === 'rad' ? value : deg2rad(value);
        } // normalize value in %
  
  
        if (units === '%') {
          ret.pfValue = value / 100;
        }
  
        return ret;
      } else if (type.propList) {
        var props = [];
        var propsStr = '' + value;
  
        if (propsStr === 'none') ; else {
          // go over each prop
          var propsSplit = propsStr.split(/\s*,\s*|\s+/);
  
          for (var _i2 = 0; _i2 < propsSplit.length; _i2++) {
            var propName = propsSplit[_i2].trim();
  
            if (self.properties[propName]) {
              props.push(propName);
            } else {
              warn('`' + propName + '` is not a valid property name');
            }
          }
  
          if (props.length === 0) {
            return null;
          }
        }
  
        return {
          name: name,
          value: props,
          strValue: props.length === 0 ? 'none' : props.join(' '),
          bypass: propIsBypass
        };
      } else if (type.color) {
        var tuple = color2tuple(value);
  
        if (!tuple) {
          return null;
        }
  
        return {
          name: name,
          value: tuple,
          pfValue: tuple,
          strValue: 'rgb(' + tuple[0] + ',' + tuple[1] + ',' + tuple[2] + ')',
          // n.b. no spaces b/c of multiple support
          bypass: propIsBypass
        };
      } else if (type.regex || type.regexes) {
        // first check enums
        if (type.enums) {
          var enumProp = checkEnums();
  
          if (enumProp) {
            return enumProp;
          }
        }
  
        var regexes = type.regexes ? type.regexes : [type.regex];
  
        for (var _i3 = 0; _i3 < regexes.length; _i3++) {
          var regex = new RegExp(regexes[_i3]); // make a regex from the type string
  
          var m = regex.exec(value);
  
          if (m) {
            // regex matches
            return {
              name: name,
              value: type.singleRegexMatchValue ? m[1] : m,
              strValue: '' + value,
              bypass: propIsBypass
            };
          }
        }
  
        return null; // didn't match any
      } else if (type.string) {
        // just return
        return {
          name: name,
          value: '' + value,
          strValue: '' + value,
          bypass: propIsBypass
        };
      } else if (type.enums) {
        // check enums last because it's a combo type in others
        return checkEnums();
      } else {
        return null; // not a type we can handle
      }
    };
  
    var Style = function Style(cy) {
      if (!(this instanceof Style)) {
        return new Style(cy);
      }
  
      if (!core(cy)) {
        error('A style must have a core reference');
        return;
      }
  
      this._private = {
        cy: cy,
        coreStyle: {}
      };
      this.length = 0;
      this.resetToDefault();
    };
  
    var styfn$8 = Style.prototype;
  
    styfn$8.instanceString = function () {
      return 'style';
    }; // remove all contexts
  
  
    styfn$8.clear = function () {
      for (var i = 0; i < this.length; i++) {
        this[i] = undefined;
      }
  
      this.length = 0;
      var _p = this._private;
      _p.newStyle = true;
      return this; // chaining
    };
  
    styfn$8.resetToDefault = function () {
      this.clear();
      this.addDefaultStylesheet();
      return this;
    }; // builds a style object for the 'core' selector
  
  
    styfn$8.core = function (propName) {
      return this._private.coreStyle[propName] || this.getDefaultProperty(propName);
    }; // create a new context from the specified selector string and switch to that context
  
  
    styfn$8.selector = function (selectorStr) {
      // 'core' is a special case and does not need a selector
      var selector = selectorStr === 'core' ? null : new Selector(selectorStr);
      var i = this.length++; // new context means new index
  
      this[i] = {
        selector: selector,
        properties: [],
        mappedProperties: [],
        index: i
      };
      return this; // chaining
    }; // add one or many css rules to the current context
  
  
    styfn$8.css = function () {
      var self = this;
      var args = arguments;
  
      if (args.length === 1) {
        var map = args[0];
  
        for (var i = 0; i < self.properties.length; i++) {
          var prop = self.properties[i];
          var mapVal = map[prop.name];
  
          if (mapVal === undefined) {
            mapVal = map[dash2camel(prop.name)];
          }
  
          if (mapVal !== undefined) {
            this.cssRule(prop.name, mapVal);
          }
        }
      } else if (args.length === 2) {
        this.cssRule(args[0], args[1]);
      } // do nothing if args are invalid
  
  
      return this; // chaining
    };
  
    styfn$8.style = styfn$8.css; // add a single css rule to the current context
  
    styfn$8.cssRule = function (name, value) {
      // name-value pair
      var property = this.parse(name, value); // add property to current context if valid
  
      if (property) {
        var i = this.length - 1;
        this[i].properties.push(property);
        this[i].properties[property.name] = property; // allow access by name as well
  
        if (property.name.match(/pie-(\d+)-background-size/) && property.value) {
          this._private.hasPie = true;
        }
  
        if (property.mapped) {
          this[i].mappedProperties.push(property);
        } // add to core style if necessary
  
  
        var currentSelectorIsCore = !this[i].selector;
  
        if (currentSelectorIsCore) {
          this._private.coreStyle[property.name] = property;
        }
      }
  
      return this; // chaining
    };
  
    styfn$8.append = function (style) {
      if (stylesheet(style)) {
        style.appendToStyle(this);
      } else if (array(style)) {
        this.appendFromJson(style);
      } else if (string(style)) {
        this.appendFromString(style);
      } // you probably wouldn't want to append a Style, since you'd duplicate the default parts
  
  
      return this;
    }; // static function
  
  
    Style.fromJson = function (cy, json) {
      var style = new Style(cy);
      style.fromJson(json);
      return style;
    };
  
    Style.fromString = function (cy, string) {
      return new Style(cy).fromString(string);
    };
  
    [styfn, styfn$1, styfn$2, styfn$3, styfn$4, styfn$5, styfn$6, styfn$7].forEach(function (props) {
      extend(styfn$8, props);
    });
    Style.types = styfn$8.types;
    Style.properties = styfn$8.properties;
    Style.propertyGroups = styfn$8.propertyGroups;
    Style.propertyGroupNames = styfn$8.propertyGroupNames;
    Style.propertyGroupKeys = styfn$8.propertyGroupKeys;
  
    var corefn$7 = {
      style: function style(newStyle) {
        if (newStyle) {
          var s = this.setStyle(newStyle);
          s.update();
        }
  
        return this._private.style;
      },
      setStyle: function setStyle(style) {
        var _p = this._private;
  
        if (stylesheet(style)) {
          _p.style = style.generateStyle(this);
        } else if (array(style)) {
          _p.style = Style.fromJson(this, style);
        } else if (string(style)) {
          _p.style = Style.fromString(this, style);
        } else {
          _p.style = Style(this);
        }
  
        return _p.style;
      }
    };
  
    var defaultSelectionType = 'single';
    var corefn$8 = {
      autolock: function autolock(bool) {
        if (bool !== undefined) {
          this._private.autolock = bool ? true : false;
        } else {
          return this._private.autolock;
        }
  
        return this; // chaining
      },
      autoungrabify: function autoungrabify(bool) {
        if (bool !== undefined) {
          this._private.autoungrabify = bool ? true : false;
        } else {
          return this._private.autoungrabify;
        }
  
        return this; // chaining
      },
      autounselectify: function autounselectify(bool) {
        if (bool !== undefined) {
          this._private.autounselectify = bool ? true : false;
        } else {
          return this._private.autounselectify;
        }
  
        return this; // chaining
      },
      selectionType: function selectionType(selType) {
        var _p = this._private;
  
        if (_p.selectionType == null) {
          _p.selectionType = defaultSelectionType;
        }
  
        if (selType !== undefined) {
          if (selType === 'additive' || selType === 'single') {
            _p.selectionType = selType;
          }
        } else {
          return _p.selectionType;
        }
  
        return this;
      },
      panningEnabled: function panningEnabled(bool) {
        if (bool !== undefined) {
          this._private.panningEnabled = bool ? true : false;
        } else {
          return this._private.panningEnabled;
        }
  
        return this; // chaining
      },
      userPanningEnabled: function userPanningEnabled(bool) {
        if (bool !== undefined) {
          this._private.userPanningEnabled = bool ? true : false;
        } else {
          return this._private.userPanningEnabled;
        }
  
        return this; // chaining
      },
      zoomingEnabled: function zoomingEnabled(bool) {
        if (bool !== undefined) {
          this._private.zoomingEnabled = bool ? true : false;
        } else {
          return this._private.zoomingEnabled;
        }
  
        return this; // chaining
      },
      userZoomingEnabled: function userZoomingEnabled(bool) {
        if (bool !== undefined) {
          this._private.userZoomingEnabled = bool ? true : false;
        } else {
          return this._private.userZoomingEnabled;
        }
  
        return this; // chaining
      },
      boxSelectionEnabled: function boxSelectionEnabled(bool) {
        if (bool !== undefined) {
          this._private.boxSelectionEnabled = bool ? true : false;
        } else {
          return this._private.boxSelectionEnabled;
        }
  
        return this; // chaining
      },
      pan: function pan() {
        var args = arguments;
        var pan = this._private.pan;
        var dim, val, dims, x, y;
  
        switch (args.length) {
          case 0:
            // .pan()
            return pan;
  
          case 1:
            if (string(args[0])) {
              // .pan('x')
              dim = args[0];
              return pan[dim];
            } else if (plainObject(args[0])) {
              // .pan({ x: 0, y: 100 })
              if (!this._private.panningEnabled) {
                return this;
              }
  
              dims = args[0];
              x = dims.x;
              y = dims.y;
  
              if (number(x)) {
                pan.x = x;
              }
  
              if (number(y)) {
                pan.y = y;
              }
  
              this.emit('pan viewport');
            }
  
            break;
  
          case 2:
            // .pan('x', 100)
            if (!this._private.panningEnabled) {
              return this;
            }
  
            dim = args[0];
            val = args[1];
  
            if ((dim === 'x' || dim === 'y') && number(val)) {
              pan[dim] = val;
            }
  
            this.emit('pan viewport');
            break;
          // invalid
        }
  
        this.notify('viewport');
        return this; // chaining
      },
      panBy: function panBy(arg0, arg1) {
        var args = arguments;
        var pan = this._private.pan;
        var dim, val, dims, x, y;
  
        if (!this._private.panningEnabled) {
          return this;
        }
  
        switch (args.length) {
          case 1:
            if (plainObject(arg0)) {
              // .panBy({ x: 0, y: 100 })
              dims = args[0];
              x = dims.x;
              y = dims.y;
  
              if (number(x)) {
                pan.x += x;
              }
  
              if (number(y)) {
                pan.y += y;
              }
  
              this.emit('pan viewport');
            }
  
            break;
  
          case 2:
            // .panBy('x', 100)
            dim = arg0;
            val = arg1;
  
            if ((dim === 'x' || dim === 'y') && number(val)) {
              pan[dim] += val;
            }
  
            this.emit('pan viewport');
            break;
          // invalid
        }
  
        this.notify('viewport');
        return this; // chaining
      },
      fit: function fit(elements, padding) {
        var viewportState = this.getFitViewport(elements, padding);
  
        if (viewportState) {
          var _p = this._private;
          _p.zoom = viewportState.zoom;
          _p.pan = viewportState.pan;
          this.emit('pan zoom viewport');
          this.notify('viewport');
        }
  
        return this; // chaining
      },
      getFitViewport: function getFitViewport(elements, padding) {
        if (number(elements) && padding === undefined) {
          // elements is optional
          padding = elements;
          elements = undefined;
        }
  
        if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
          return;
        }
  
        var bb;
  
        if (string(elements)) {
          var sel = elements;
          elements = this.$(sel);
        } else if (boundingBox(elements)) {
          // assume bb
          var bbe = elements;
          bb = {
            x1: bbe.x1,
            y1: bbe.y1,
            x2: bbe.x2,
            y2: bbe.y2
          };
          bb.w = bb.x2 - bb.x1;
          bb.h = bb.y2 - bb.y1;
        } else if (!elementOrCollection(elements)) {
          elements = this.mutableElements();
        }
  
        if (elementOrCollection(elements) && elements.empty()) {
          return;
        } // can't fit to nothing
  
  
        bb = bb || elements.boundingBox();
        var w = this.width();
        var h = this.height();
        var zoom;
        padding = number(padding) ? padding : 0;
  
        if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {
          zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h); // crop zoom
  
          zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
          zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;
          var pan = {
            // now pan to middle
            x: (w - zoom * (bb.x1 + bb.x2)) / 2,
            y: (h - zoom * (bb.y1 + bb.y2)) / 2
          };
          return {
            zoom: zoom,
            pan: pan
          };
        }
  
        return;
      },
      zoomRange: function zoomRange(min, max) {
        var _p = this._private;
  
        if (max == null) {
          var opts = min;
          min = opts.min;
          max = opts.max;
        }
  
        if (number(min) && number(max) && min <= max) {
          _p.minZoom = min;
          _p.maxZoom = max;
        } else if (number(min) && max === undefined && min <= _p.maxZoom) {
          _p.minZoom = min;
        } else if (number(max) && min === undefined && max >= _p.minZoom) {
          _p.maxZoom = max;
        }
  
        return this;
      },
      minZoom: function minZoom(zoom) {
        if (zoom === undefined) {
          return this._private.minZoom;
        } else {
          return this.zoomRange({
            min: zoom
          });
        }
      },
      maxZoom: function maxZoom(zoom) {
        if (zoom === undefined) {
          return this._private.maxZoom;
        } else {
          return this.zoomRange({
            max: zoom
          });
        }
      },
      getZoomedViewport: function getZoomedViewport(params) {
        var _p = this._private;
        var currentPan = _p.pan;
        var currentZoom = _p.zoom;
        var pos; // in rendered px
  
        var zoom;
        var bail = false;
  
        if (!_p.zoomingEnabled) {
          // zooming disabled
          bail = true;
        }
  
        if (number(params)) {
          // then set the zoom
          zoom = params;
        } else if (plainObject(params)) {
          // then zoom about a point
          zoom = params.level;
  
          if (params.position != null) {
            pos = modelToRenderedPosition(params.position, currentZoom, currentPan);
          } else if (params.renderedPosition != null) {
            pos = params.renderedPosition;
          }
  
          if (pos != null && !_p.panningEnabled) {
            // panning disabled
            bail = true;
          }
        } // crop zoom
  
  
        zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;
        zoom = zoom < _p.minZoom ? _p.minZoom : zoom; // can't zoom with invalid params
  
        if (bail || !number(zoom) || zoom === currentZoom || pos != null && (!number(pos.x) || !number(pos.y))) {
          return null;
        }
  
        if (pos != null) {
          // set zoom about position
          var pan1 = currentPan;
          var zoom1 = currentZoom;
          var zoom2 = zoom;
          var pan2 = {
            x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,
            y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y
          };
          return {
            zoomed: true,
            panned: true,
            zoom: zoom2,
            pan: pan2
          };
        } else {
          // just set the zoom
          return {
            zoomed: true,
            panned: false,
            zoom: zoom,
            pan: currentPan
          };
        }
      },
      zoom: function zoom(params) {
        if (params === undefined) {
          // get
          return this._private.zoom;
        } else {
          // set
          var vp = this.getZoomedViewport(params);
          var _p = this._private;
  
          if (vp == null || !vp.zoomed) {
            return this;
          }
  
          _p.zoom = vp.zoom;
  
          if (vp.panned) {
            _p.pan.x = vp.pan.x;
            _p.pan.y = vp.pan.y;
          }
  
          this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');
          this.notify('viewport');
          return this; // chaining
        }
      },
      viewport: function viewport(opts) {
        var _p = this._private;
        var zoomDefd = true;
        var panDefd = true;
        var events = []; // to trigger
  
        var zoomFailed = false;
        var panFailed = false;
  
        if (!opts) {
          return this;
        }
  
        if (!number(opts.zoom)) {
          zoomDefd = false;
        }
  
        if (!plainObject(opts.pan)) {
          panDefd = false;
        }
  
        if (!zoomDefd && !panDefd) {
          return this;
        }
  
        if (zoomDefd) {
          var z = opts.zoom;
  
          if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {
            zoomFailed = true;
          } else {
            _p.zoom = z;
            events.push('zoom');
          }
        }
  
        if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {
          var p = opts.pan;
  
          if (number(p.x)) {
            _p.pan.x = p.x;
            panFailed = false;
          }
  
          if (number(p.y)) {
            _p.pan.y = p.y;
            panFailed = false;
          }
  
          if (!panFailed) {
            events.push('pan');
          }
        }
  
        if (events.length > 0) {
          events.push('viewport');
          this.emit(events.join(' '));
          this.notify('viewport');
        }
  
        return this; // chaining
      },
      center: function center(elements) {
        var pan = this.getCenterPan(elements);
  
        if (pan) {
          this._private.pan = pan;
          this.emit('pan viewport');
          this.notify('viewport');
        }
  
        return this; // chaining
      },
      getCenterPan: function getCenterPan(elements, zoom) {
        if (!this._private.panningEnabled) {
          return;
        }
  
        if (string(elements)) {
          var selector = elements;
          elements = this.mutableElements().filter(selector);
        } else if (!elementOrCollection(elements)) {
          elements = this.mutableElements();
        }
  
        if (elements.length === 0) {
          return;
        } // can't centre pan to nothing
  
  
        var bb = elements.boundingBox();
        var w = this.width();
        var h = this.height();
        zoom = zoom === undefined ? this._private.zoom : zoom;
        var pan = {
          // middle
          x: (w - zoom * (bb.x1 + bb.x2)) / 2,
          y: (h - zoom * (bb.y1 + bb.y2)) / 2
        };
        return pan;
      },
      reset: function reset() {
        if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
          return this;
        }
  
        this.viewport({
          pan: {
            x: 0,
            y: 0
          },
          zoom: 1
        });
        return this; // chaining
      },
      invalidateSize: function invalidateSize() {
        this._private.sizeCache = null;
      },
      size: function size() {
        var _p = this._private;
        var container = _p.container;
        return _p.sizeCache = _p.sizeCache || (container ? function () {
          var style = window$1.getComputedStyle(container);
  
          var val = function val(name) {
            return parseFloat(style.getPropertyValue(name));
          };
  
          return {
            width: container.clientWidth - val('padding-left') - val('padding-right'),
            height: container.clientHeight - val('padding-top') - val('padding-bottom')
          };
        }() : {
          // fallback if no container (not 0 b/c can be used for dividing etc)
          width: 1,
          height: 1
        });
      },
      width: function width() {
        return this.size().width;
      },
      height: function height() {
        return this.size().height;
      },
      extent: function extent() {
        var pan = this._private.pan;
        var zoom = this._private.zoom;
        var rb = this.renderedExtent();
        var b = {
          x1: (rb.x1 - pan.x) / zoom,
          x2: (rb.x2 - pan.x) / zoom,
          y1: (rb.y1 - pan.y) / zoom,
          y2: (rb.y2 - pan.y) / zoom
        };
        b.w = b.x2 - b.x1;
        b.h = b.y2 - b.y1;
        return b;
      },
      renderedExtent: function renderedExtent() {
        var width = this.width();
        var height = this.height();
        return {
          x1: 0,
          y1: 0,
          x2: width,
          y2: height,
          w: width,
          h: height
        };
      }
    }; // aliases
  
    corefn$8.centre = corefn$8.center; // backwards compatibility
  
    corefn$8.autolockNodes = corefn$8.autolock;
    corefn$8.autoungrabifyNodes = corefn$8.autoungrabify;
  
    var fn$6 = {
      data: define$3.data({
        field: 'data',
        bindingEvent: 'data',
        allowBinding: true,
        allowSetting: true,
        settingEvent: 'data',
        settingTriggersEvent: true,
        triggerFnName: 'trigger',
        allowGetting: true
      }),
      removeData: define$3.removeData({
        field: 'data',
        event: 'data',
        triggerFnName: 'trigger',
        triggerEvent: true
      }),
      scratch: define$3.data({
        field: 'scratch',
        bindingEvent: 'scratch',
        allowBinding: true,
        allowSetting: true,
        settingEvent: 'scratch',
        settingTriggersEvent: true,
        triggerFnName: 'trigger',
        allowGetting: true
      }),
      removeScratch: define$3.removeData({
        field: 'scratch',
        event: 'scratch',
        triggerFnName: 'trigger',
        triggerEvent: true
      })
    }; // aliases
  
    fn$6.attr = fn$6.data;
    fn$6.removeAttr = fn$6.removeData;
  
    var Core = function Core(opts) {
      var cy = this;
      opts = extend({}, opts);
      var container = opts.container; // allow for passing a wrapped jquery object
      // e.g. cytoscape({ container: $('#cy') })
  
      if (container && !htmlElement(container) && htmlElement(container[0])) {
        container = container[0];
      }
  
      var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery
  
      reg = reg || {};
  
      if (reg && reg.cy) {
        reg.cy.destroy();
        reg = {}; // old instance => replace reg completely
      }
  
      var readies = reg.readies = reg.readies || [];
  
      if (container) {
        container._cyreg = reg;
      } // make sure container assoc'd reg points to this cy
  
  
      reg.cy = cy;
      var head = window$1 !== undefined && container !== undefined && !opts.headless;
      var options = opts;
      options.layout = extend({
        name: head ? 'grid' : 'null'
      }, options.layout);
      options.renderer = extend({
        name: head ? 'canvas' : 'null'
      }, options.renderer);
  
      var defVal = function defVal(def, val, altVal) {
        if (val !== undefined) {
          return val;
        } else if (altVal !== undefined) {
          return altVal;
        } else {
          return def;
        }
      };
  
      var _p = this._private = {
        container: container,
        // html dom ele container
        ready: false,
        // whether ready has been triggered
        options: options,
        // cached options
        elements: new Collection(this),
        // elements in the graph
        listeners: [],
        // list of listeners
        aniEles: new Collection(this),
        // elements being animated
        data: {},
        // data for the core
        scratch: {},
        // scratch object for core
        layout: null,
        renderer: null,
        destroyed: false,
        // whether destroy was called
        notificationsEnabled: true,
        // whether notifications are sent to the renderer
        minZoom: 1e-50,
        maxZoom: 1e50,
        zoomingEnabled: defVal(true, options.zoomingEnabled),
        userZoomingEnabled: defVal(true, options.userZoomingEnabled),
        panningEnabled: defVal(true, options.panningEnabled),
        userPanningEnabled: defVal(true, options.userPanningEnabled),
        boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),
        autolock: defVal(false, options.autolock, options.autolockNodes),
        autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
        autounselectify: defVal(false, options.autounselectify),
        styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
        zoom: number(options.zoom) ? options.zoom : 1,
        pan: {
          x: plainObject(options.pan) && number(options.pan.x) ? options.pan.x : 0,
          y: plainObject(options.pan) && number(options.pan.y) ? options.pan.y : 0
        },
        animation: {
          // object for currently-running animations
          current: [],
          queue: []
        },
        hasCompoundNodes: false
      };
  
      this.createEmitter(); // set selection type
  
      this.selectionType(options.selectionType); // init zoom bounds
  
      this.zoomRange({
        min: options.minZoom,
        max: options.maxZoom
      });
  
      var loadExtData = function loadExtData(extData, next) {
        var anyIsPromise = extData.some(promise);
  
        if (anyIsPromise) {
          return Promise$1.all(extData).then(next); // load all data asynchronously, then exec rest of init
        } else {
          next(extData); // exec synchronously for convenience
        }
      }; // start with the default stylesheet so we have something before loading an external stylesheet
  
  
      if (_p.styleEnabled) {
        cy.setStyle([]);
      } // create the renderer
  
  
      var rendererOptions = extend({}, options, options.renderer); // allow rendering hints in top level options
  
      cy.initRenderer(rendererOptions);
  
      var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {
        cy.notifications(false); // remove old elements
  
        var oldEles = cy.mutableElements();
  
        if (oldEles.length > 0) {
          oldEles.remove();
        }
  
        if (elements != null) {
          if (plainObject(elements) || array(elements)) {
            cy.add(elements);
          }
        }
  
        cy.one('layoutready', function (e) {
          cy.notifications(true);
          cy.emit(e); // we missed this event by turning notifications off, so pass it on
  
          cy.one('load', onload);
          cy.emitAndNotify('load');
        }).one('layoutstop', function () {
          cy.one('done', ondone);
          cy.emit('done');
        });
        var layoutOpts = extend({}, cy._private.options.layout);
        layoutOpts.eles = cy.elements();
        cy.layout(layoutOpts).run();
      };
  
      loadExtData([options.style, options.elements], function (thens) {
        var initStyle = thens[0];
        var initEles = thens[1]; // init style
  
        if (_p.styleEnabled) {
          cy.style().append(initStyle);
        } // initial load
  
  
        setElesAndLayout(initEles, function () {
          // onready
          cy.startAnimationLoop();
          _p.ready = true; // if a ready callback is specified as an option, the bind it
  
          if (fn(options.ready)) {
            cy.on('ready', options.ready);
          } // bind all the ready handlers registered before creating this instance
  
  
          for (var i = 0; i < readies.length; i++) {
            var fn$1 = readies[i];
            cy.on('ready', fn$1);
          }
  
          if (reg) {
            reg.readies = [];
          } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc
  
  
          cy.emit('ready');
        }, options.done);
      });
    };
  
    var corefn$9 = Core.prototype; // short alias
  
    extend(corefn$9, {
      instanceString: function instanceString() {
        return 'core';
      },
      isReady: function isReady() {
        return this._private.ready;
      },
      destroyed: function destroyed() {
        return this._private.destroyed;
      },
      ready: function ready(fn) {
        if (this.isReady()) {
          this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event
        } else {
          this.on('ready', fn);
        }
  
        return this;
      },
      destroy: function destroy() {
        var cy = this;
        if (cy.destroyed()) return;
        cy.stopAnimationLoop();
        cy.destroyRenderer();
        this.emit('destroy');
        cy._private.destroyed = true;
        return cy;
      },
      hasElementWithId: function hasElementWithId(id) {
        return this._private.elements.hasElementWithId(id);
      },
      getElementById: function getElementById(id) {
        return this._private.elements.getElementById(id);
      },
      hasCompoundNodes: function hasCompoundNodes() {
        return this._private.hasCompoundNodes;
      },
      headless: function headless() {
        return this._private.renderer.isHeadless();
      },
      styleEnabled: function styleEnabled() {
        return this._private.styleEnabled;
      },
      addToPool: function addToPool(eles) {
        this._private.elements.merge(eles);
  
        return this; // chaining
      },
      removeFromPool: function removeFromPool(eles) {
        this._private.elements.unmerge(eles);
  
        return this;
      },
      container: function container() {
        return this._private.container || null;
      },
      mount: function mount(container) {
        if (container == null) {
          return;
        }
  
        var cy = this;
        var _p = cy._private;
        var options = _p.options;
  
        if (!htmlElement(container) && htmlElement(container[0])) {
          container = container[0];
        }
  
        cy.stopAnimationLoop();
        cy.destroyRenderer();
        _p.container = container;
        _p.styleEnabled = true;
        cy.invalidateSize();
        cy.initRenderer(extend({}, options, options.renderer, {
          // allow custom renderer name to be re-used, otherwise use canvas
          name: options.renderer.name === 'null' ? 'canvas' : options.renderer.name
        }));
        cy.startAnimationLoop();
        cy.style(options.style);
        cy.emit('mount');
        return cy;
      },
      unmount: function unmount() {
        var cy = this;
        cy.stopAnimationLoop();
        cy.destroyRenderer();
        cy.initRenderer({
          name: 'null'
        });
        cy.emit('unmount');
        return cy;
      },
      options: function options() {
        return copy(this._private.options);
      },
      json: function json(obj) {
        var cy = this;
        var _p = cy._private;
        var eles = cy.mutableElements();
  
        var getFreshRef = function getFreshRef(ele) {
          return cy.getElementById(ele.id());
        };
  
        if (plainObject(obj)) {
          // set
          cy.startBatch();
  
          if (obj.elements) {
            var idInJson = {};
  
            var updateEles = function updateEles(jsons, gr) {
              var toAdd = [];
              var toMod = [];
  
              for (var i = 0; i < jsons.length; i++) {
                var json = jsons[i];
                var id = '' + json.data.id; // id must be string
  
                var ele = cy.getElementById(id);
                idInJson[id] = true;
  
                if (ele.length !== 0) {
                  // existing element should be updated
                  toMod.push({
                    ele: ele,
                    json: json
                  });
                } else {
                  // otherwise should be added
                  if (gr) {
                    json.group = gr;
                    toAdd.push(json);
                  } else {
                    toAdd.push(json);
                  }
                }
              }
  
              cy.add(toAdd);
  
              for (var _i = 0; _i < toMod.length; _i++) {
                var _toMod$_i = toMod[_i],
                    _ele = _toMod$_i.ele,
                    _json = _toMod$_i.json;
  
                _ele.json(_json);
              }
            };
  
            if (array(obj.elements)) {
              // elements: []
              updateEles(obj.elements);
            } else {
              // elements: { nodes: [], edges: [] }
              var grs = ['nodes', 'edges'];
  
              for (var i = 0; i < grs.length; i++) {
                var gr = grs[i];
                var elements = obj.elements[gr];
  
                if (array(elements)) {
                  updateEles(elements, gr);
                }
              }
            }
  
            var parentsToRemove = cy.collection();
            eles.filter(function (ele) {
              return !idInJson[ele.id()];
            }).forEach(function (ele) {
              if (ele.isParent()) {
                parentsToRemove.merge(ele);
              } else {
                ele.remove();
              }
            }); // so that children are not removed w/parent
  
            parentsToRemove.forEach(function (ele) {
              return ele.children().move({
                parent: null
              });
            }); // intermediate parents may be moved by prior line, so make sure we remove by fresh refs
  
            parentsToRemove.forEach(function (ele) {
              return getFreshRef(ele).remove();
            });
          }
  
          if (obj.style) {
            cy.style(obj.style);
          }
  
          if (obj.zoom != null && obj.zoom !== _p.zoom) {
            cy.zoom(obj.zoom);
          }
  
          if (obj.pan) {
            if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {
              cy.pan(obj.pan);
            }
          }
  
          if (obj.data) {
            cy.data(obj.data);
          }
  
          var fields = ['minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autolock', 'autoungrabify', 'autounselectify'];
  
          for (var _i2 = 0; _i2 < fields.length; _i2++) {
            var f = fields[_i2];
  
            if (obj[f] != null) {
              cy[f](obj[f]);
            }
          }
  
          cy.endBatch();
          return this; // chaining
        } else {
          // get
          var flat = !!obj;
          var json = {};
  
          if (flat) {
            json.elements = this.elements().map(function (ele) {
              return ele.json();
            });
          } else {
            json.elements = {};
            eles.forEach(function (ele) {
              var group = ele.group();
  
              if (!json.elements[group]) {
                json.elements[group] = [];
              }
  
              json.elements[group].push(ele.json());
            });
          }
  
          if (this._private.styleEnabled) {
            json.style = cy.style().json();
          }
  
          json.data = copy(cy.data());
          var options = _p.options;
          json.zoomingEnabled = _p.zoomingEnabled;
          json.userZoomingEnabled = _p.userZoomingEnabled;
          json.zoom = _p.zoom;
          json.minZoom = _p.minZoom;
          json.maxZoom = _p.maxZoom;
          json.panningEnabled = _p.panningEnabled;
          json.userPanningEnabled = _p.userPanningEnabled;
          json.pan = copy(_p.pan);
          json.boxSelectionEnabled = _p.boxSelectionEnabled;
          json.renderer = copy(options.renderer);
          json.hideEdgesOnViewport = options.hideEdgesOnViewport;
          json.textureOnViewport = options.textureOnViewport;
          json.wheelSensitivity = options.wheelSensitivity;
          json.motionBlur = options.motionBlur;
          return json;
        }
      }
    });
    corefn$9.$id = corefn$9.getElementById;
    [corefn, corefn$1, elesfn$v, corefn$2, corefn$3, corefn$4, corefn$5, corefn$6, corefn$7, corefn$8, fn$6].forEach(function (props) {
      extend(corefn$9, props);
    });
  
    /* eslint-disable no-unused-vars */
  
    var defaults$9 = {
      fit: true,
      // whether to fit the viewport to the graph
      directed: false,
      // whether the tree is directed downwards (or edges can point in any direction if false)
      padding: 30,
      // padding on fit
      circle: false,
      // put depths in concentric circles if true, put depths top down if false
      grid: false,
      // whether to create an even grid into which the DAG is placed (circle:false only)
      spacingFactor: 1.75,
      // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
      boundingBox: undefined,
      // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
      avoidOverlap: true,
      // prevents node overlap, may overflow boundingBox if not enough space
      nodeDimensionsIncludeLabels: false,
      // Excludes the label when calculating node bounding boxes for the layout algorithm
      roots: undefined,
      // the roots of the trees
      maximal: false,
      // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only)
      animate: false,
      // whether to transition the node positions
      animationDuration: 500,
      // duration of animation in ms if enabled
      animationEasing: undefined,
      // easing of animation if enabled,
      animateFilter: function animateFilter(node, i) {
        return true;
      },
      // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
      ready: undefined,
      // callback on layoutready
      stop: undefined,
      // callback on layoutstop
      transform: function transform(node, position) {
        return position;
      } // transform a given node position. Useful for changing flow direction in discrete layouts
  
    };
    /* eslint-enable */
  
    var getInfo = function getInfo(ele) {
      return ele.scratch('breadthfirst');
    };
  
    var setInfo = function setInfo(ele, obj) {
      return ele.scratch('breadthfirst', obj);
    };
  
    function BreadthFirstLayout(options) {
      this.options = extend({}, defaults$9, options);
    }
  
    BreadthFirstLayout.prototype.run = function () {
      var params = this.options;
      var options = params;
      var cy = params.cy;
      var eles = options.eles;
      var nodes = eles.nodes().filter(function (n) {
        return !n.isParent();
      });
      var graph = eles;
      var directed = options.directed;
      var maximal = options.maximal || options.maximalAdjustments > 0; // maximalAdjustments for compat. w/ old code
  
      var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
        x1: 0,
        y1: 0,
        w: cy.width(),
        h: cy.height()
      });
      var roots;
  
      if (elementOrCollection(options.roots)) {
        roots = options.roots;
      } else if (array(options.roots)) {
        var rootsArray = [];
  
        for (var i = 0; i < options.roots.length; i++) {
          var id = options.roots[i];
          var ele = cy.getElementById(id);
          rootsArray.push(ele);
        }
  
        roots = cy.collection(rootsArray);
      } else if (string(options.roots)) {
        roots = cy.$(options.roots);
      } else {
        if (directed) {
          roots = nodes.roots();
        } else {
          var components = eles.components();
          roots = cy.collection();
  
          var _loop = function _loop(_i) {
            var comp = components[_i];
            var maxDegree = comp.maxDegree(false);
            var compRoots = comp.filter(function (ele) {
              return ele.degree(false) === maxDegree;
            });
            roots = roots.add(compRoots);
          };
  
          for (var _i = 0; _i < components.length; _i++) {
            _loop(_i);
          }
        }
      }
  
      var depths = [];
      var foundByBfs = {};
  
      var addToDepth = function addToDepth(ele, d) {
        if (depths[d] == null) {
          depths[d] = [];
        }
  
        var i = depths[d].length;
        depths[d].push(ele);
        setInfo(ele, {
          index: i,
          depth: d
        });
      };
  
      var changeDepth = function changeDepth(ele, newDepth) {
        var _getInfo = getInfo(ele),
            depth = _getInfo.depth,
            index = _getInfo.index;
  
        depths[depth][index] = null;
        addToDepth(ele, newDepth);
      }; // find the depths of the nodes
  
  
      graph.bfs({
        roots: roots,
        directed: options.directed,
        visit: function visit(node, edge, pNode, i, depth) {
          var ele = node[0];
          var id = ele.id();
          addToDepth(ele, depth);
          foundByBfs[id] = true;
        }
      }); // check for nodes not found by bfs
  
      var orphanNodes = [];
  
      for (var _i2 = 0; _i2 < nodes.length; _i2++) {
        var _ele = nodes[_i2];
  
        if (foundByBfs[_ele.id()]) {
          continue;
        } else {
          orphanNodes.push(_ele);
        }
      } // assign the nodes a depth and index
  
  
      var assignDepthsAt = function assignDepthsAt(i) {
        var eles = depths[i];
  
        for (var j = 0; j < eles.length; j++) {
          var _ele2 = eles[j];
  
          if (_ele2 == null) {
            eles.splice(j, 1);
            j--;
            continue;
          }
  
          setInfo(_ele2, {
            depth: i,
            index: j
          });
        }
      };
  
      var assignDepths = function assignDepths() {
        for (var _i3 = 0; _i3 < depths.length; _i3++) {
          assignDepthsAt(_i3);
        }
      };
  
      var adjustMaximally = function adjustMaximally(ele, shifted) {
        var eInfo = getInfo(ele);
        var incomers = ele.incomers().filter(function (el) {
          return el.isNode() && eles.has(el);
        });
        var maxDepth = -1;
        var id = ele.id();
  
        for (var k = 0; k < incomers.length; k++) {
          var incmr = incomers[k];
          var iInfo = getInfo(incmr);
          maxDepth = Math.max(maxDepth, iInfo.depth);
        }
  
        if (eInfo.depth <= maxDepth) {
          if (shifted[id]) {
            return null;
          }
  
          changeDepth(ele, maxDepth + 1);
          shifted[id] = true;
          return true;
        }
  
        return false;
      }; // for the directed case, try to make the edges all go down (i.e. depth i => depth i + 1)
  
  
      if (directed && maximal) {
        var Q = [];
        var shifted = {};
  
        var enqueue = function enqueue(n) {
          return Q.push(n);
        };
  
        var dequeue = function dequeue() {
          return Q.shift();
        };
  
        nodes.forEach(function (n) {
          return Q.push(n);
        });
  
        while (Q.length > 0) {
          var _ele3 = dequeue();
  
          var didShift = adjustMaximally(_ele3, shifted);
  
          if (didShift) {
            _ele3.outgoers().filter(function (el) {
              return el.isNode() && eles.has(el);
            }).forEach(enqueue);
          } else if (didShift === null) {
            warn('Detected double maximal shift for node `' + _ele3.id() + '`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.');
            break; // exit on failure
          }
        }
      }
  
      assignDepths(); // clear holes
      // find min distance we need to leave between nodes
  
      var minDistance = 0;
  
      if (options.avoidOverlap) {
        for (var _i4 = 0; _i4 < nodes.length; _i4++) {
          var n = nodes[_i4];
          var nbb = n.layoutDimensions(options);
          var w = nbb.w;
          var h = nbb.h;
          minDistance = Math.max(minDistance, w, h);
        }
      } // get the weighted percent for an element based on its connectivity to other levels
  
  
      var cachedWeightedPercent = {};
  
      var getWeightedPercent = function getWeightedPercent(ele) {
        if (cachedWeightedPercent[ele.id()]) {
          return cachedWeightedPercent[ele.id()];
        }
  
        var eleDepth = getInfo(ele).depth;
        var neighbors = ele.neighborhood();
        var percent = 0;
        var samples = 0;
  
        for (var _i5 = 0; _i5 < neighbors.length; _i5++) {
          var neighbor = neighbors[_i5];
  
          if (neighbor.isEdge() || neighbor.isParent() || !nodes.has(neighbor)) {
            continue;
          }
  
          var bf = getInfo(neighbor);
          var index = bf.index;
          var depth = bf.depth; // unassigned neighbours shouldn't affect the ordering
  
          if (index == null || depth == null) {
            continue;
          }
  
          var nDepth = depths[depth].length;
  
          if (depth < eleDepth) {
            // only get influenced by elements above
            percent += index / nDepth;
            samples++;
          }
        }
  
        samples = Math.max(1, samples);
        percent = percent / samples;
  
        if (samples === 0) {
          // put lone nodes at the start
          percent = 0;
        }
  
        cachedWeightedPercent[ele.id()] = percent;
        return percent;
      }; // rearrange the indices in each depth level based on connectivity
  
  
      var sortFn = function sortFn(a, b) {
        var apct = getWeightedPercent(a);
        var bpct = getWeightedPercent(b);
        var diff = apct - bpct;
  
        if (diff === 0) {
          return ascending(a.id(), b.id()); // make sure sort doesn't have don't-care comparisons
        } else {
          return diff;
        }
      }; // sort each level to make connected nodes closer
  
  
      for (var _i6 = 0; _i6 < depths.length; _i6++) {
        depths[_i6].sort(sortFn);
  
        assignDepthsAt(_i6);
      } // assign orphan nodes to a new top-level depth
  
  
      var orphanDepth = [];
  
      for (var _i7 = 0; _i7 < orphanNodes.length; _i7++) {
        orphanDepth.push(orphanNodes[_i7]);
      }
  
      depths.unshift(orphanDepth);
      assignDepths();
      var biggestDepthSize = 0;
  
      for (var _i8 = 0; _i8 < depths.length; _i8++) {
        biggestDepthSize = Math.max(depths[_i8].length, biggestDepthSize);
      }
  
      var center = {
        x: bb.x1 + bb.w / 2,
        y: bb.x1 + bb.h / 2
      };
      var maxDepthSize = depths.reduce(function (max, eles) {
        return Math.max(max, eles.length);
      }, 0);
  
      var getPosition = function getPosition(ele) {
        var _getInfo2 = getInfo(ele),
            depth = _getInfo2.depth,
            index = _getInfo2.index;
  
        var depthSize = depths[depth].length;
        var distanceX = Math.max(bb.w / ((options.grid ? maxDepthSize : depthSize) + 1), minDistance);
        var distanceY = Math.max(bb.h / (depths.length + 1), minDistance);
        var radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);
        radiusStepSize = Math.max(radiusStepSize, minDistance);
  
        if (!options.circle) {
          var epos = {
            x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
            y: (depth + 1) * distanceY
          };
          return epos;
        } else {
          var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);
          var theta = 2 * Math.PI / depths[depth].length * index;
  
          if (depth === 0 && depths[0].length === 1) {
            radius = 1;
          }
  
          return {
            x: center.x + radius * Math.cos(theta),
            y: center.y + radius * Math.sin(theta)
          };
        }
      };
  
      nodes.layoutPositions(this, options, getPosition);
      return this; // chaining
    };
  
    var defaults$a = {
      fit: true,
      // whether to fit the viewport to the graph
      padding: 30,
      // the padding on fit
      boundingBox: undefined,
      // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
      avoidOverlap: true,
      // prevents node overlap, may overflow boundingBox and radius if not enough space
      nodeDimensionsIncludeLabels: false,
      // Excludes the label when calculating node bounding boxes for the layout algorithm
      spacingFactor: undefined,
      // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
      radius: undefined,
      // the radius of the circle
      startAngle: 3 / 2 * Math.PI,
      // where nodes start in radians
      sweep: undefined,
      // how many radians should be between the first and last node (defaults to full circle)
      clockwise: true,
      // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
      sort: undefined,
      // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
      animate: false,
      // whether to transition the node positions
      animationDuration: 500,
      // duration of animation in ms if enabled
      animationEasing: undefined,
      // easing of animation if enabled
      animateFilter: function animateFilter(node, i) {
        return true;
      },
      // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
      ready: undefined,
      // callback on layoutready
      stop: undefined,
      // callback on layoutstop
      transform: function transform(node, position) {
        return position;
      } // transform a given node position. Useful for changing flow direction in discrete layouts 
  
    };
  
    function CircleLayout(options) {
      this.options = extend({}, defaults$a, options);
    }
  
    CircleLayout.prototype.run = function () {
      var params = this.options;
      var options = params;
      var cy = params.cy;
      var eles = options.eles;
      var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;
      var nodes = eles.nodes().not(':parent');
  
      if (options.sort) {
        nodes = nodes.sort(options.sort);
      }
  
      var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
        x1: 0,
        y1: 0,
        w: cy.width(),
        h: cy.height()
      });
      var center = {
        x: bb.x1 + bb.w / 2,
        y: bb.y1 + bb.h / 2
      };
      var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;
      var dTheta = sweep / Math.max(1, nodes.length - 1);
      var r;
      var minDistance = 0;
  
      for (var i = 0; i < nodes.length; i++) {
        var n = nodes[i];
        var nbb = n.layoutDimensions(options);
        var w = nbb.w;
        var h = nbb.h;
        minDistance = Math.max(minDistance, w, h);
      }
  
      if (number(options.radius)) {
        r = options.radius;
      } else if (nodes.length <= 1) {
        r = 0;
      } else {
        r = Math.min(bb.h, bb.w) / 2 - minDistance;
      } // calculate the radius
  
  
      if (nodes.length > 1 && options.avoidOverlap) {
        // but only if more than one node (can't overlap)
        minDistance *= 1.75; // just to have some nice spacing
  
        var dcos = Math.cos(dTheta) - Math.cos(0);
        var dsin = Math.sin(dTheta) - Math.sin(0);
        var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping
  
        r = Math.max(rMin, r);
      }
  
      var getPos = function getPos(ele, i) {
        var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);
        var rx = r * Math.cos(theta);
        var ry = r * Math.sin(theta);
        var pos = {
          x: center.x + rx,
          y: center.y + ry
        };
        return pos;
      };
  
      nodes.layoutPositions(this, options, getPos);
      return this; // chaining
    };
  
    var defaults$b = {
      fit: true,
      // whether to fit the viewport to the graph
      padding: 30,
      // the padding on fit
      startAngle: 3 / 2 * Math.PI,
      // where nodes start in radians
      sweep: undefined,
      // how many radians should be between the first and last node (defaults to full circle)
      clockwise: true,
      // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
      equidistant: false,
      // whether levels have an equal radial distance betwen them, may cause bounding box overflow
      minNodeSpacing: 10,
      // min spacing between outside of nodes (used for radius adjustment)
      boundingBox: undefined,
      // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
      avoidOverlap: true,
      // prevents node overlap, may overflow boundingBox if not enough space
      nodeDimensionsIncludeLabels: false,
      // Excludes the label when calculating node bounding boxes for the layout algorithm
      height: undefined,
      // height of layout area (overrides container height)
      width: undefined,
      // width of layout area (overrides container width)
      spacingFactor: undefined,
      // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
      concentric: function concentric(node) {
        // returns numeric value for each node, placing higher nodes in levels towards the centre
        return node.degree();
      },
      levelWidth: function levelWidth(nodes) {
        // the letiation of concentric values in each level
        return nodes.maxDegree() / 4;
      },
      animate: false,
      // whether to transition the node positions
      animationDuration: 500,
      // duration of animation in ms if enabled
      animationEasing: undefined,
      // easing of animation if enabled
      animateFilter: function animateFilter(node, i) {
        return true;
      },
      // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
      ready: undefined,
      // callback on layoutready
      stop: undefined,
      // callback on layoutstop
      transform: function transform(node, position) {
        return position;
      } // transform a given node position. Useful for changing flow direction in discrete layouts
  
    };
  
    function ConcentricLayout(options) {
      this.options = extend({}, defaults$b, options);
    }
  
    ConcentricLayout.prototype.run = function () {
      var params = this.options;
      var options = params;
      var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;
      var cy = params.cy;
      var eles = options.eles;
      var nodes = eles.nodes().not(':parent');
      var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
        x1: 0,
        y1: 0,
        w: cy.width(),
        h: cy.height()
      });
      var center = {
        x: bb.x1 + bb.w / 2,
        y: bb.y1 + bb.h / 2
      };
      var nodeValues = []; // { node, value }
  
      var maxNodeSize = 0;
  
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var value = void 0; // calculate the node value
  
        value = options.concentric(node);
        nodeValues.push({
          value: value,
          node: node
        }); // for style mapping
  
        node._private.scratch.concentric = value;
      } // in case we used the `concentric` in style
  
  
      nodes.updateStyle(); // calculate max size now based on potentially updated mappers
  
      for (var _i = 0; _i < nodes.length; _i++) {
        var _node = nodes[_i];
  
        var nbb = _node.layoutDimensions(options);
  
        maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);
      } // sort node values in descreasing order
  
  
      nodeValues.sort(function (a, b) {
        return b.value - a.value;
      });
      var levelWidth = options.levelWidth(nodes); // put the values into levels
  
      var levels = [[]];
      var currentLevel = levels[0];
  
      for (var _i2 = 0; _i2 < nodeValues.length; _i2++) {
        var val = nodeValues[_i2];
  
        if (currentLevel.length > 0) {
          var diff = Math.abs(currentLevel[0].value - val.value);
  
          if (diff >= levelWidth) {
            currentLevel = [];
            levels.push(currentLevel);
          }
        }
  
        currentLevel.push(val);
      } // create positions from levels
  
  
      var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes
  
      if (!options.avoidOverlap) {
        // then strictly constrain to bb
        var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
        var maxR = Math.min(bb.w, bb.h) / 2 - minDist;
        var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);
        minDist = Math.min(minDist, rStep);
      } // find the metrics for each level
  
  
      var r = 0;
  
      for (var _i3 = 0; _i3 < levels.length; _i3++) {
        var level = levels[_i3];
        var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;
        var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius
  
        if (level.length > 1 && options.avoidOverlap) {
          // but only if more than one node (can't overlap)
          var dcos = Math.cos(dTheta) - Math.cos(0);
          var dsin = Math.sin(dTheta) - Math.sin(0);
          var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping
  
          r = Math.max(rMin, r);
        }
  
        level.r = r;
        r += minDist;
      }
  
      if (options.equidistant) {
        var rDeltaMax = 0;
        var _r = 0;
  
        for (var _i4 = 0; _i4 < levels.length; _i4++) {
          var _level = levels[_i4];
          var rDelta = _level.r - _r;
          rDeltaMax = Math.max(rDeltaMax, rDelta);
        }
  
        _r = 0;
  
        for (var _i5 = 0; _i5 < levels.length; _i5++) {
          var _level2 = levels[_i5];
  
          if (_i5 === 0) {
            _r = _level2.r;
          }
  
          _level2.r = _r;
          _r += rDeltaMax;
        }
      } // calculate the node positions
  
  
      var pos = {}; // id => position
  
      for (var _i6 = 0; _i6 < levels.length; _i6++) {
        var _level3 = levels[_i6];
        var _dTheta = _level3.dTheta;
        var _r2 = _level3.r;
  
        for (var j = 0; j < _level3.length; j++) {
          var _val = _level3[j];
          var theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;
          var p = {
            x: center.x + _r2 * Math.cos(theta),
            y: center.y + _r2 * Math.sin(theta)
          };
          pos[_val.node.id()] = p;
        }
      } // position the nodes
  
  
      nodes.layoutPositions(this, options, function (ele) {
        var id = ele.id();
        return pos[id];
      });
      return this; // chaining
    };
  
    /*
    The CoSE layout was written by Gerardo Huck.
    https://www.linkedin.com/in/gerardohuck/
  
    Based on the following article:
    http://dl.acm.org/citation.cfm?id=1498047
  
    Modifications tracked on Github.
    */
    var DEBUG;
    /**
     * @brief :  default layout options
     */
  
    var defaults$c = {
      // Called on `layoutready`
      ready: function ready() {},
      // Called on `layoutstop`
      stop: function stop() {},
      // Whether to animate while running the layout
      // true : Animate continuously as the layout is running
      // false : Just show the end result
      // 'end' : Animate with the end result, from the initial positions to the end positions
      animate: true,
      // Easing of the animation for animate:'end'
      animationEasing: undefined,
      // The duration of the animation for animate:'end'
      animationDuration: undefined,
      // A function that determines whether the node should be animated
      // All nodes animated by default on animate enabled
      // Non-animated nodes are positioned immediately when the layout starts
      animateFilter: function animateFilter(node, i) {
        return true;
      },
      // The layout animates only after this many milliseconds for animate:true
      // (prevents flashing on fast runs)
      animationThreshold: 250,
      // Number of iterations between consecutive screen positions update
      refresh: 20,
      // Whether to fit the network view after when done
      fit: true,
      // Padding on fit
      padding: 30,
      // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
      boundingBox: undefined,
      // Excludes the label when calculating node bounding boxes for the layout algorithm
      nodeDimensionsIncludeLabels: false,
      // Randomize the initial positions of the nodes (true) or use existing positions (false)
      randomize: false,
      // Extra spacing between components in non-compound graphs
      componentSpacing: 40,
      // Node repulsion (non overlapping) multiplier
      nodeRepulsion: function nodeRepulsion(node) {
        return 2048;
      },
      // Node repulsion (overlapping) multiplier
      nodeOverlap: 4,
      // Ideal edge (non nested) length
      idealEdgeLength: function idealEdgeLength(edge) {
        return 32;
      },
      // Divisor to compute edge forces
      edgeElasticity: function edgeElasticity(edge) {
        return 32;
      },
      // Nesting factor (multiplier) to compute ideal edge length for nested edges
      nestingFactor: 1.2,
      // Gravity force (constant)
      gravity: 1,
      // Maximum number of iterations to perform
      numIter: 1000,
      // Initial temperature (maximum node displacement)
      initialTemp: 1000,
      // Cooling factor (how the temperature is reduced between consecutive iterations
      coolingFactor: 0.99,
      // Lower temperature threshold (below this point the layout will end)
      minTemp: 1.0
    };
    /**
     * @brief       : constructor
     * @arg options : object containing layout options
     */
  
    function CoseLayout(options) {
      this.options = extend({}, defaults$c, options);
      this.options.layout = this;
    }
    /**
     * @brief : runs the layout
     */
  
  
    CoseLayout.prototype.run = function () {
      var options = this.options;
      var cy = options.cy;
      var layout = this;
      layout.stopped = false;
  
      if (options.animate === true || options.animate === false) {
        layout.emit({
          type: 'layoutstart',
          layout: layout
        });
      } // Set DEBUG - Global variable
  
  
      if (true === options.debug) {
        DEBUG = true;
      } else {
        DEBUG = false;
      } // Initialize layout info
  
  
      var layoutInfo = createLayoutInfo(cy, layout, options); // Show LayoutInfo contents if debugging
  
      if (DEBUG) {
        printLayoutInfo(layoutInfo);
      } // If required, randomize node positions
  
  
      if (options.randomize) {
        randomizePositions(layoutInfo);
      }
  
      var startTime = performanceNow();
  
      var refresh = function refresh() {
        refreshPositions(layoutInfo, cy, options); // Fit the graph if necessary
  
        if (true === options.fit) {
          cy.fit(options.padding);
        }
      };
  
      var mainLoop = function mainLoop(i) {
        if (layout.stopped || i >= options.numIter) {
          // logDebug("Layout manually stopped. Stopping computation in step " + i);
          return false;
        } // Do one step in the phisical simulation
  
  
        step$1(layoutInfo, options); // Update temperature
  
        layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor; // logDebug("New temperature: " + layoutInfo.temperature);
  
        if (layoutInfo.temperature < options.minTemp) {
          // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
          return false;
        }
  
        return true;
      };
  
      var done = function done() {
        if (options.animate === true || options.animate === false) {
          refresh(); // Layout has finished
  
          layout.one('layoutstop', options.stop);
          layout.emit({
            type: 'layoutstop',
            layout: layout
          });
        } else {
          var nodes = options.eles.nodes();
          var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);
          nodes.layoutPositions(layout, options, getScaledPos);
        }
      };
  
      var i = 0;
      var loopRet = true;
  
      if (options.animate === true) {
        var frame = function frame() {
          var f = 0;
  
          while (loopRet && f < options.refresh) {
            loopRet = mainLoop(i);
            i++;
            f++;
          }
  
          if (!loopRet) {
            // it's done
            separateComponents(layoutInfo, options);
            done();
          } else {
            var now = performanceNow();
  
            if (now - startTime >= options.animationThreshold) {
              refresh();
            }
  
            requestAnimationFrame(frame);
          }
        };
  
        frame();
      } else {
        while (loopRet) {
          loopRet = mainLoop(i);
          i++;
        }
  
        separateComponents(layoutInfo, options);
        done();
      }
  
      return this; // chaining
    };
    /**
     * @brief : called on continuous layouts to stop them before they finish
     */
  
  
    CoseLayout.prototype.stop = function () {
      this.stopped = true;
  
      if (this.thread) {
        this.thread.stop();
      }
  
      this.emit('layoutstop');
      return this; // chaining
    };
  
    CoseLayout.prototype.destroy = function () {
      if (this.thread) {
        this.thread.stop();
      }
  
      return this; // chaining
    };
    /**
     * @brief     : Creates an object which is contains all the data
     *              used in the layout process
     * @arg cy    : cytoscape.js object
     * @return    : layoutInfo object initialized
     */
  
  
    var createLayoutInfo = function createLayoutInfo(cy, layout, options) {
      // Shortcut
      var edges = options.eles.edges();
      var nodes = options.eles.nodes();
      var layoutInfo = {
        isCompound: cy.hasCompoundNodes(),
        layoutNodes: [],
        idToIndex: {},
        nodeSize: nodes.size(),
        graphSet: [],
        indexToGraph: [],
        layoutEdges: [],
        edgeSize: edges.size(),
        temperature: options.initialTemp,
        clientWidth: cy.width(),
        clientHeight: cy.width(),
        boundingBox: makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0,
          y1: 0,
          w: cy.width(),
          h: cy.height()
        })
      };
      var components = options.eles.components();
      var id2cmptId = {};
  
      for (var i = 0; i < components.length; i++) {
        var component = components[i];
  
        for (var j = 0; j < component.length; j++) {
          var node = component[j];
          id2cmptId[node.id()] = i;
        }
      } // Iterate over all nodes, creating layout nodes
  
  
      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = nodes[i];
        var nbb = n.layoutDimensions(options);
        var tempNode = {};
        tempNode.isLocked = n.locked();
        tempNode.id = n.data('id');
        tempNode.parentId = n.data('parent');
        tempNode.cmptId = id2cmptId[n.id()];
        tempNode.children = [];
        tempNode.positionX = n.position('x');
        tempNode.positionY = n.position('y');
        tempNode.offsetX = 0;
        tempNode.offsetY = 0;
        tempNode.height = nbb.w;
        tempNode.width = nbb.h;
        tempNode.maxX = tempNode.positionX + tempNode.width / 2;
        tempNode.minX = tempNode.positionX - tempNode.width / 2;
        tempNode.maxY = tempNode.positionY + tempNode.height / 2;
        tempNode.minY = tempNode.positionY - tempNode.height / 2;
        tempNode.padLeft = parseFloat(n.style('padding'));
        tempNode.padRight = parseFloat(n.style('padding'));
        tempNode.padTop = parseFloat(n.style('padding'));
        tempNode.padBottom = parseFloat(n.style('padding')); // forces
  
        tempNode.nodeRepulsion = fn(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion; // Add new node
  
        layoutInfo.layoutNodes.push(tempNode); // Add entry to id-index map
  
        layoutInfo.idToIndex[tempNode.id] = i;
      } // Inline implementation of a queue, used for traversing the graph in BFS order
  
  
      var queue = [];
      var start = 0; // Points to the start the queue
  
      var end = -1; // Points to the end of the queue
  
      var tempGraph = []; // Second pass to add child information and
      // initialize queue for hierarchical traversal
  
      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = layoutInfo.layoutNodes[i];
        var p_id = n.parentId; // Check if node n has a parent node
  
        if (null != p_id) {
          // Add node Id to parent's list of children
          layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
        } else {
          // If a node doesn't have a parent, then it's in the root graph
          queue[++end] = n.id;
          tempGraph.push(n.id);
        }
      } // Add root graph to graphSet
  
  
      layoutInfo.graphSet.push(tempGraph); // Traverse the graph, level by level,
  
      while (start <= end) {
        // Get the node to visit and remove it from queue
        var node_id = queue[start++];
        var node_ix = layoutInfo.idToIndex[node_id];
        var node = layoutInfo.layoutNodes[node_ix];
        var children = node.children;
  
        if (children.length > 0) {
          // Add children nodes as a new graph to graph set
          layoutInfo.graphSet.push(children); // Add children to que queue to be visited
  
          for (var i = 0; i < children.length; i++) {
            queue[++end] = children[i];
          }
        }
      } // Create indexToGraph map
  
  
      for (var i = 0; i < layoutInfo.graphSet.length; i++) {
        var graph = layoutInfo.graphSet[i];
  
        for (var j = 0; j < graph.length; j++) {
          var index = layoutInfo.idToIndex[graph[j]];
          layoutInfo.indexToGraph[index] = i;
        }
      } // Iterate over all edges, creating Layout Edges
  
  
      for (var i = 0; i < layoutInfo.edgeSize; i++) {
        var e = edges[i];
        var tempEdge = {};
        tempEdge.id = e.data('id');
        tempEdge.sourceId = e.data('source');
        tempEdge.targetId = e.data('target'); // Compute ideal length
  
        var idealLength = fn(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;
        var elasticity = fn(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity; // Check if it's an inter graph edge
  
        var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];
        var targetIx = layoutInfo.idToIndex[tempEdge.targetId];
        var sourceGraph = layoutInfo.indexToGraph[sourceIx];
        var targetGraph = layoutInfo.indexToGraph[targetIx];
  
        if (sourceGraph != targetGraph) {
          // Find lowest common graph ancestor
          var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo); // Compute sum of node depths, relative to lca graph
  
          var lcaGraph = layoutInfo.graphSet[lca];
          var depth = 0; // Source depth
  
          var tempNode = layoutInfo.layoutNodes[sourceIx];
  
          while (-1 === lcaGraph.indexOf(tempNode.id)) {
            tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
            depth++;
          } // Target depth
  
  
          tempNode = layoutInfo.layoutNodes[targetIx];
  
          while (-1 === lcaGraph.indexOf(tempNode.id)) {
            tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
            depth++;
          } // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +
          //  ". Index: " + lca + " Contents: " + lcaGraph.toString() +
          //  ". Depth: " + depth);
          // Update idealLength
  
  
          idealLength *= depth * options.nestingFactor;
        }
  
        tempEdge.idealLength = idealLength;
        tempEdge.elasticity = elasticity;
        layoutInfo.layoutEdges.push(tempEdge);
      } // Finally, return layoutInfo object
  
  
      return layoutInfo;
    };
    /**
     * @brief : This function finds the index of the lowest common
     *          graph ancestor between 2 nodes in the subtree
     *          (from the graph hierarchy induced tree) whose
     *          root is graphIx
     *
     * @arg node1: node1's ID
     * @arg node2: node2's ID
     * @arg layoutInfo: layoutInfo object
     *
     */
  
  
    var findLCA = function findLCA(node1, node2, layoutInfo) {
      // Find their common ancester, starting from the root graph
      var res = findLCA_aux(node1, node2, 0, layoutInfo);
  
      if (2 > res.count) {
        // If aux function couldn't find the common ancester,
        // then it is the root graph
        return 0;
      } else {
        return res.graph;
      }
    };
    /**
     * @brief          : Auxiliary function used for LCA computation
     *
     * @arg node1      : node1's ID
     * @arg node2      : node2's ID
     * @arg graphIx    : subgraph index
     * @arg layoutInfo : layoutInfo object
     *
     * @return         : object of the form {count: X, graph: Y}, where:
     *                   X is the number of ancesters (max: 2) found in
     *                   graphIx (and it's subgraphs),
     *                   Y is the graph index of the lowest graph containing
     *                   all X nodes
     */
  
  
    var findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {
      var graph = layoutInfo.graphSet[graphIx]; // If both nodes belongs to graphIx
  
      if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {
        return {
          count: 2,
          graph: graphIx
        };
      } // Make recursive calls for all subgraphs
  
  
      var c = 0;
  
      for (var i = 0; i < graph.length; i++) {
        var nodeId = graph[i];
        var nodeIx = layoutInfo.idToIndex[nodeId];
        var children = layoutInfo.layoutNodes[nodeIx].children; // If the node has no child, skip it
  
        if (0 === children.length) {
          continue;
        }
  
        var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
        var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);
  
        if (0 === result.count) {
          // Neither node1 nor node2 are present in this subgraph
          continue;
        } else if (1 === result.count) {
          // One of (node1, node2) is present in this subgraph
          c++;
  
          if (2 === c) {
            // We've already found both nodes, no need to keep searching
            break;
          }
        } else {
          // Both nodes are present in this subgraph
          return result;
        }
      }
  
      return {
        count: c,
        graph: graphIx
      };
    };
    /**
     * @brief: printsLayoutInfo into js console
     *         Only used for debbuging
     */
  
  
    if (false) {
      var printLayoutInfo;
    }
    /**
     * @brief : Randomizes the position of all nodes
     */
  
  
    var randomizePositions = function randomizePositions(layoutInfo, cy) {
      var width = layoutInfo.clientWidth;
      var height = layoutInfo.clientHeight;
  
      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = layoutInfo.layoutNodes[i]; // No need to randomize compound nodes or locked nodes
  
        if (0 === n.children.length && !n.isLocked) {
          n.positionX = Math.random() * width;
          n.positionY = Math.random() * height;
        }
      }
    };
  
    var getScaleInBoundsFn = function getScaleInBoundsFn(layoutInfo, options, nodes) {
      var bb = layoutInfo.boundingBox;
      var coseBB = {
        x1: Infinity,
        x2: -Infinity,
        y1: Infinity,
        y2: -Infinity
      };
  
      if (options.boundingBox) {
        nodes.forEach(function (node) {
          var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];
          coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);
          coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);
          coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);
          coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);
        });
        coseBB.w = coseBB.x2 - coseBB.x1;
        coseBB.h = coseBB.y2 - coseBB.y1;
      }
  
      return function (ele, i) {
        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];
  
        if (options.boundingBox) {
          // then add extra bounding box constraint
          var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
          var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;
          return {
            x: bb.x1 + pctX * bb.w,
            y: bb.y1 + pctY * bb.h
          };
        } else {
          return {
            x: lnode.positionX,
            y: lnode.positionY
          };
        }
      };
    };
    /**
     * @brief          : Updates the positions of nodes in the network
     * @arg layoutInfo : LayoutInfo object
     * @arg cy         : Cytoscape object
     * @arg options    : Layout options
     */
  
  
    var refreshPositions = function refreshPositions(layoutInfo, cy, options) {
      // var s = 'Refreshing positions';
      // logDebug(s);
      var layout = options.layout;
      var nodes = options.eles.nodes();
      var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);
      nodes.positions(getScaledPos); // Trigger layoutReady only on first call
  
      if (true !== layoutInfo.ready) {
        // s = 'Triggering layoutready';
        // logDebug(s);
        layoutInfo.ready = true;
        layout.one('layoutready', options.ready);
        layout.emit({
          type: 'layoutready',
          layout: this
        });
      }
    };
    /**
     * @brief : Logs a debug message in JS console, if DEBUG is ON
     */
    // var logDebug = function(text) {
    //   if (DEBUG) {
    //     console.debug(text);
    //   }
    // };
  
    /**
     * @brief          : Performs one iteration of the physical simulation
     * @arg layoutInfo : LayoutInfo object already initialized
     * @arg cy         : Cytoscape object
     * @arg options    : Layout options
     */
  
  
    var step$1 = function step(layoutInfo, options, _step) {
      // var s = "\n\n###############################";
      // s += "\nSTEP: " + step;
      // s += "\n###############################\n";
      // logDebug(s);
      // Calculate node repulsions
      calculateNodeForces(layoutInfo, options); // Calculate edge forces
  
      calculateEdgeForces(layoutInfo); // Calculate gravity forces
  
      calculateGravityForces(layoutInfo, options); // Propagate forces from parent to child
  
      propagateForces(layoutInfo); // Update positions based on calculated forces
  
      updatePositions(layoutInfo);
    };
    /**
     * @brief : Computes the node repulsion forces
     */
  
  
    var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {
      // Go through each of the graphs in graphSet
      // Nodes only repel each other if they belong to the same graph
      // var s = 'calculateNodeForces';
      // logDebug(s);
      for (var i = 0; i < layoutInfo.graphSet.length; i++) {
        var graph = layoutInfo.graphSet[i];
        var numNodes = graph.length; // s = "Set: " + graph.toString();
        // logDebug(s);
        // Now get all the pairs of nodes
        // Only get each pair once, (A, B) = (B, A)
  
        for (var j = 0; j < numNodes; j++) {
          var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
  
          for (var k = j + 1; k < numNodes; k++) {
            var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];
            nodeRepulsion(node1, node2, layoutInfo, options);
          }
        }
      }
    };
  
    var randomDistance = function randomDistance(max) {
      return -max + 2 * max * Math.random();
    };
    /**
     * @brief : Compute the node repulsion forces between a pair of nodes
     */
  
  
    var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {
      // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;
      var cmptId1 = node1.cmptId;
      var cmptId2 = node2.cmptId;
  
      if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {
        return;
      } // Get direction of line connecting both node centers
  
  
      var directionX = node2.positionX - node1.positionX;
      var directionY = node2.positionY - node1.positionY;
      var maxRandDist = 1; // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;
      // If both centers are the same, apply a random force
  
      if (0 === directionX && 0 === directionY) {
        directionX = randomDistance(maxRandDist);
        directionY = randomDistance(maxRandDist);
      }
  
      var overlap = nodesOverlap(node1, node2, directionX, directionY);
  
      if (overlap > 0) {
        // s += "\nNodes DO overlap.";
        // s += "\nOverlap: " + overlap;
        // If nodes overlap, repulsion force is proportional
        // to the overlap
        var force = options.nodeOverlap * overlap; // Compute the module and components of the force vector
  
        var distance = Math.sqrt(directionX * directionX + directionY * directionY); // s += "\nDistance: " + distance;
  
        var forceX = force * directionX / distance;
        var forceY = force * directionY / distance;
      } else {
        // s += "\nNodes do NOT overlap.";
        // If there's no overlap, force is inversely proportional
        // to squared distance
        // Get clipping points for both nodes
        var point1 = findClippingPoint(node1, directionX, directionY);
        var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY); // Use clipping points to compute distance
  
        var distanceX = point2.x - point1.x;
        var distanceY = point2.y - point1.y;
        var distanceSqr = distanceX * distanceX + distanceY * distanceY;
        var distance = Math.sqrt(distanceSqr); // s += "\nDistance: " + distance;
        // Compute the module and components of the force vector
  
        var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;
        var forceX = force * distanceX / distance;
        var forceY = force * distanceY / distance;
      } // Apply force
  
  
      if (!node1.isLocked) {
        node1.offsetX -= forceX;
        node1.offsetY -= forceY;
      }
  
      if (!node2.isLocked) {
        node2.offsetX += forceX;
        node2.offsetY += forceY;
      } // s += "\nForceX: " + forceX + " ForceY: " + forceY;
      // logDebug(s);
  
  
      return;
    };
    /**
     * @brief  : Determines whether two nodes overlap or not
     * @return : Amount of overlapping (0 => no overlap)
     */
  
  
    var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {
      if (dX > 0) {
        var overlapX = node1.maxX - node2.minX;
      } else {
        var overlapX = node2.maxX - node1.minX;
      }
  
      if (dY > 0) {
        var overlapY = node1.maxY - node2.minY;
      } else {
        var overlapY = node2.maxY - node1.minY;
      }
  
      if (overlapX >= 0 && overlapY >= 0) {
        return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
      } else {
        return 0;
      }
    };
    /**
     * @brief : Finds the point in which an edge (direction dX, dY) intersects
     *          the rectangular bounding box of it's source/target node
     */
  
  
    var findClippingPoint = function findClippingPoint(node, dX, dY) {
      // Shorcuts
      var X = node.positionX;
      var Y = node.positionY;
      var H = node.height || 1;
      var W = node.width || 1;
      var dirSlope = dY / dX;
      var nodeSlope = H / W; // var s = 'Computing clipping point of node ' + node.id +
      //   " . Height:  " + H + ", Width: " + W +
      //   "\nDirection " + dX + ", " + dY;
      //
      // Compute intersection
  
      var res = {}; // Case: Vertical direction (up)
  
      if (0 === dX && 0 < dY) {
        res.x = X; // s += "\nUp direction";
  
        res.y = Y + H / 2;
        return res;
      } // Case: Vertical direction (down)
  
  
      if (0 === dX && 0 > dY) {
        res.x = X;
        res.y = Y + H / 2; // s += "\nDown direction";
  
        return res;
      } // Case: Intersects the right border
  
  
      if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
        res.x = X + W / 2;
        res.y = Y + W * dY / 2 / dX; // s += "\nRightborder";
  
        return res;
      } // Case: Intersects the left border
  
  
      if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
        res.x = X - W / 2;
        res.y = Y - W * dY / 2 / dX; // s += "\nLeftborder";
  
        return res;
      } // Case: Intersects the top border
  
  
      if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
        res.x = X + H * dX / 2 / dY;
        res.y = Y + H / 2; // s += "\nTop border";
  
        return res;
      } // Case: Intersects the bottom border
  
  
      if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
        res.x = X - H * dX / 2 / dY;
        res.y = Y - H / 2; // s += "\nBottom border";
  
        return res;
      } // s += "\nClipping point found at " + res.x + ", " + res.y;
      // logDebug(s);
  
  
      return res;
    };
    /**
     * @brief : Calculates all edge forces
     */
  
  
    var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {
      // Iterate over all edges
      for (var i = 0; i < layoutInfo.edgeSize; i++) {
        // Get edge, source & target nodes
        var edge = layoutInfo.layoutEdges[i];
        var sourceIx = layoutInfo.idToIndex[edge.sourceId];
        var source = layoutInfo.layoutNodes[sourceIx];
        var targetIx = layoutInfo.idToIndex[edge.targetId];
        var target = layoutInfo.layoutNodes[targetIx]; // Get direction of line connecting both node centers
  
        var directionX = target.positionX - source.positionX;
        var directionY = target.positionY - source.positionY; // If both centers are the same, do nothing.
        // A random force has already been applied as node repulsion
  
        if (0 === directionX && 0 === directionY) {
          continue;
        } // Get clipping points for both nodes
  
  
        var point1 = findClippingPoint(source, directionX, directionY);
        var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);
        var lx = point2.x - point1.x;
        var ly = point2.y - point1.y;
        var l = Math.sqrt(lx * lx + ly * ly);
        var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;
  
        if (0 !== l) {
          var forceX = force * lx / l;
          var forceY = force * ly / l;
        } else {
          var forceX = 0;
          var forceY = 0;
        } // Add this force to target and source nodes
  
  
        if (!source.isLocked) {
          source.offsetX += forceX;
          source.offsetY += forceY;
        }
  
        if (!target.isLocked) {
          target.offsetX -= forceX;
          target.offsetY -= forceY;
        } // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
        // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
        // logDebug(s);
  
      }
    };
    /**
     * @brief : Computes gravity forces for all nodes
     */
  
  
    var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {
      var distThreshold = 1; // var s = 'calculateGravityForces';
      // logDebug(s);
  
      for (var i = 0; i < layoutInfo.graphSet.length; i++) {
        var graph = layoutInfo.graphSet[i];
        var numNodes = graph.length; // s = "Set: " + graph.toString();
        // logDebug(s);
        // Compute graph center
  
        if (0 === i) {
          var centerX = layoutInfo.clientHeight / 2;
          var centerY = layoutInfo.clientWidth / 2;
        } else {
          // Get Parent node for this graph, and use its position as center
          var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
          var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
          var centerX = parent.positionX;
          var centerY = parent.positionY;
        } // s = "Center found at: " + centerX + ", " + centerY;
        // logDebug(s);
        // Apply force to all nodes in graph
  
  
        for (var j = 0; j < numNodes; j++) {
          var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]]; // s = "Node: " + node.id;
  
          if (node.isLocked) {
            continue;
          }
  
          var dx = centerX - node.positionX;
          var dy = centerY - node.positionY;
          var d = Math.sqrt(dx * dx + dy * dy);
  
          if (d > distThreshold) {
            var fx = options.gravity * dx / d;
            var fy = options.gravity * dy / d;
            node.offsetX += fx;
            node.offsetY += fy; // s += ": Applied force: " + fx + ", " + fy;
          } // s += ": skypped since it's too close to center";
            // logDebug(s);
  
        }
      }
    };
    /**
     * @brief          : This function propagates the existing offsets from
     *                   parent nodes to its descendents.
     * @arg layoutInfo : layoutInfo Object
     * @arg cy         : cytoscape Object
     * @arg options    : Layout options
     */
  
  
    var propagateForces = function propagateForces(layoutInfo, options) {
      // Inline implementation of a queue, used for traversing the graph in BFS order
      var queue = [];
      var start = 0; // Points to the start the queue
  
      var end = -1; // Points to the end of the queue
      // logDebug('propagateForces');
      // Start by visiting the nodes in the root graph
  
      queue.push.apply(queue, layoutInfo.graphSet[0]);
      end += layoutInfo.graphSet[0].length; // Traverse the graph, level by level,
  
      while (start <= end) {
        // Get the node to visit and remove it from queue
        var nodeId = queue[start++];
        var nodeIndex = layoutInfo.idToIndex[nodeId];
        var node = layoutInfo.layoutNodes[nodeIndex];
        var children = node.children; // We only need to process the node if it's compound
  
        if (0 < children.length && !node.isLocked) {
          var offX = node.offsetX;
          var offY = node.offsetY; // var s = "Propagating offset from parent node : " + node.id +
          //   ". OffsetX: " + offX + ". OffsetY: " + offY;
          // s += "\n Children: " + children.toString();
          // logDebug(s);
  
          for (var i = 0; i < children.length; i++) {
            var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]]; // Propagate offset
  
            childNode.offsetX += offX;
            childNode.offsetY += offY; // Add children to queue to be visited
  
            queue[++end] = children[i];
          } // Reset parent offsets
  
  
          node.offsetX = 0;
          node.offsetY = 0;
        }
      }
    };
    /**
     * @brief : Updates the layout model positions, based on
     *          the accumulated forces
     */
  
  
    var updatePositions = function updatePositions(layoutInfo, options) {
      // var s = 'Updating positions';
      // logDebug(s);
      // Reset boundaries for compound nodes
      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = layoutInfo.layoutNodes[i];
  
        if (0 < n.children.length) {
          // logDebug("Resetting boundaries of compound node: " + n.id);
          n.maxX = undefined;
          n.minX = undefined;
          n.maxY = undefined;
          n.minY = undefined;
        }
      }
  
      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = layoutInfo.layoutNodes[i];
  
        if (0 < n.children.length || n.isLocked) {
          // No need to set compound or locked node position
          // logDebug("Skipping position update of node: " + n.id);
          continue;
        } // s = "Node: " + n.id + " Previous position: (" +
        // n.positionX + ", " + n.positionY + ").";
        // Limit displacement in order to improve stability
  
  
        var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
        n.positionX += tempForce.x;
        n.positionY += tempForce.y;
        n.offsetX = 0;
        n.offsetY = 0;
        n.minX = n.positionX - n.width;
        n.maxX = n.positionX + n.width;
        n.minY = n.positionY - n.height;
        n.maxY = n.positionY + n.height; // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
        // logDebug(s);
        // Update ancestry boudaries
  
        updateAncestryBoundaries(n, layoutInfo);
      } // Update size, position of compund nodes
  
  
      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = layoutInfo.layoutNodes[i];
  
        if (0 < n.children.length && !n.isLocked) {
          n.positionX = (n.maxX + n.minX) / 2;
          n.positionY = (n.maxY + n.minY) / 2;
          n.width = n.maxX - n.minX;
          n.height = n.maxY - n.minY; // s = "Updating position, size of compound node " + n.id;
          // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
          // s += "\nWidth: " + n.width + ", Height: " + n.height;
          // logDebug(s);
        }
      }
    };
    /**
     * @brief : Limits a force (forceX, forceY) to be not
     *          greater (in modulo) than max.
     8          Preserves force direction.
      */
  
  
    var limitForce = function limitForce(forceX, forceY, max) {
      // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
      var force = Math.sqrt(forceX * forceX + forceY * forceY);
  
      if (force > max) {
        var res = {
          x: max * forceX / force,
          y: max * forceY / force
        };
      } else {
        var res = {
          x: forceX,
          y: forceY
        };
      } // s += ".\nResult: (" + res.x + ", " + res.y + ")";
      // logDebug(s);
  
  
      return res;
    };
    /**
     * @brief : Function used for keeping track of compound node
     *          sizes, since they should bound all their subnodes.
     */
  
  
    var updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {
      // var s = "Propagating new position/size of node " + node.id;
      var parentId = node.parentId;
  
      if (null == parentId) {
        // If there's no parent, we are done
        // s += ". No parent node.";
        // logDebug(s);
        return;
      } // Get Parent Node
  
  
      var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
      var flag = false; // MaxX
  
      if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
        p.maxX = node.maxX + p.padRight;
        flag = true; // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
      } // MinX
  
  
      if (null == p.minX || node.minX - p.padLeft < p.minX) {
        p.minX = node.minX - p.padLeft;
        flag = true; // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
      } // MaxY
  
  
      if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
        p.maxY = node.maxY + p.padBottom;
        flag = true; // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
      } // MinY
  
  
      if (null == p.minY || node.minY - p.padTop < p.minY) {
        p.minY = node.minY - p.padTop;
        flag = true; // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
      } // If updated boundaries, propagate changes upward
  
  
      if (flag) {
        // logDebug(s);
        return updateAncestryBoundaries(p, layoutInfo);
      } // s += ". No changes in boundaries/position of parent node " + p.id;
      // logDebug(s);
  
  
      return;
    };
  
    var separateComponents = function separateComponents(layoutInfo, options) {
      var nodes = layoutInfo.layoutNodes;
      var components = [];
  
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var cid = node.cmptId;
        var component = components[cid] = components[cid] || [];
        component.push(node);
      }
  
      var totalA = 0;
  
      for (var i = 0; i < components.length; i++) {
        var c = components[i];
  
        if (!c) {
          continue;
        }
  
        c.x1 = Infinity;
        c.x2 = -Infinity;
        c.y1 = Infinity;
        c.y2 = -Infinity;
  
        for (var j = 0; j < c.length; j++) {
          var n = c[j];
          c.x1 = Math.min(c.x1, n.positionX - n.width / 2);
          c.x2 = Math.max(c.x2, n.positionX + n.width / 2);
          c.y1 = Math.min(c.y1, n.positionY - n.height / 2);
          c.y2 = Math.max(c.y2, n.positionY + n.height / 2);
        }
  
        c.w = c.x2 - c.x1;
        c.h = c.y2 - c.y1;
        totalA += c.w * c.h;
      }
  
      components.sort(function (c1, c2) {
        return c2.w * c2.h - c1.w * c1.h;
      });
      var x = 0;
      var y = 0;
      var usedW = 0;
      var rowH = 0;
      var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;
  
      for (var i = 0; i < components.length; i++) {
        var c = components[i];
  
        if (!c) {
          continue;
        }
  
        for (var j = 0; j < c.length; j++) {
          var n = c[j];
  
          if (!n.isLocked) {
            n.positionX += x - c.x1;
            n.positionY += y - c.y1;
          }
        }
  
        x += c.w + options.componentSpacing;
        usedW += c.w + options.componentSpacing;
        rowH = Math.max(rowH, c.h);
  
        if (usedW > maxRowW) {
          y += rowH + options.componentSpacing;
          x = 0;
          usedW = 0;
          rowH = 0;
        }
      }
    };
  
    var defaults$d = {
      fit: true,
      // whether to fit the viewport to the graph
      padding: 30,
      // padding used on fit
      boundingBox: undefined,
      // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
      avoidOverlap: true,
      // prevents node overlap, may overflow boundingBox if not enough space
      avoidOverlapPadding: 10,
      // extra spacing around nodes when avoidOverlap: true
      nodeDimensionsIncludeLabels: false,
      // Excludes the label when calculating node bounding boxes for the layout algorithm
      spacingFactor: undefined,
      // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
      condense: false,
      // uses all available space on false, uses minimal space on true
      rows: undefined,
      // force num of rows in the grid
      cols: undefined,
      // force num of columns in the grid
      position: function position(node) {},
      // returns { row, col } for element
      sort: undefined,
      // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
      animate: false,
      // whether to transition the node positions
      animationDuration: 500,
      // duration of animation in ms if enabled
      animationEasing: undefined,
      // easing of animation if enabled
      animateFilter: function animateFilter(node, i) {
        return true;
      },
      // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
      ready: undefined,
      // callback on layoutready
      stop: undefined,
      // callback on layoutstop
      transform: function transform(node, position) {
        return position;
      } // transform a given node position. Useful for changing flow direction in discrete layouts 
  
    };
  
    function GridLayout(options) {
      this.options = extend({}, defaults$d, options);
    }
  
    GridLayout.prototype.run = function () {
      var params = this.options;
      var options = params;
      var cy = params.cy;
      var eles = options.eles;
      var nodes = eles.nodes().not(':parent');
  
      if (options.sort) {
        nodes = nodes.sort(options.sort);
      }
  
      var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
        x1: 0,
        y1: 0,
        w: cy.width(),
        h: cy.height()
      });
  
      if (bb.h === 0 || bb.w === 0) {
        nodes.layoutPositions(this, options, function (ele) {
          return {
            x: bb.x1,
            y: bb.y1
          };
        });
      } else {
        // width/height * splits^2 = cells where splits is number of times to split width
        var cells = nodes.size();
        var splits = Math.sqrt(cells * bb.h / bb.w);
        var rows = Math.round(splits);
        var cols = Math.round(bb.w / bb.h * splits);
  
        var small = function small(val) {
          if (val == null) {
            return Math.min(rows, cols);
          } else {
            var min = Math.min(rows, cols);
  
            if (min == rows) {
              rows = val;
            } else {
              cols = val;
            }
          }
        };
  
        var large = function large(val) {
          if (val == null) {
            return Math.max(rows, cols);
          } else {
            var max = Math.max(rows, cols);
  
            if (max == rows) {
              rows = val;
            } else {
              cols = val;
            }
          }
        };
  
        var oRows = options.rows;
        var oCols = options.cols != null ? options.cols : options.columns; // if rows or columns were set in options, use those values
  
        if (oRows != null && oCols != null) {
          rows = oRows;
          cols = oCols;
        } else if (oRows != null && oCols == null) {
          rows = oRows;
          cols = Math.ceil(cells / rows);
        } else if (oRows == null && oCols != null) {
          cols = oCols;
          rows = Math.ceil(cells / cols);
        } // otherwise use the automatic values and adjust accordingly
        // if rounding was up, see if we can reduce rows or columns
        else if (cols * rows > cells) {
            var sm = small();
            var lg = large(); // reducing the small side takes away the most cells, so try it first
  
            if ((sm - 1) * lg >= cells) {
              small(sm - 1);
            } else if ((lg - 1) * sm >= cells) {
              large(lg - 1);
            }
          } else {
            // if rounding was too low, add rows or columns
            while (cols * rows < cells) {
              var _sm = small();
  
              var _lg = large(); // try to add to larger side first (adds less in multiplication)
  
  
              if ((_lg + 1) * _sm >= cells) {
                large(_lg + 1);
              } else {
                small(_sm + 1);
              }
            }
          }
  
        var cellWidth = bb.w / cols;
        var cellHeight = bb.h / rows;
  
        if (options.condense) {
          cellWidth = 0;
          cellHeight = 0;
        }
  
        if (options.avoidOverlap) {
          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            var pos = node._private.position;
  
            if (pos.x == null || pos.y == null) {
              // for bb
              pos.x = 0;
              pos.y = 0;
            }
  
            var nbb = node.layoutDimensions(options);
            var p = options.avoidOverlapPadding;
            var w = nbb.w + p;
            var h = nbb.h + p;
            cellWidth = Math.max(cellWidth, w);
            cellHeight = Math.max(cellHeight, h);
          }
        }
  
        var cellUsed = {}; // e.g. 'c-0-2' => true
  
        var used = function used(row, col) {
          return cellUsed['c-' + row + '-' + col] ? true : false;
        };
  
        var use = function use(row, col) {
          cellUsed['c-' + row + '-' + col] = true;
        }; // to keep track of current cell position
  
  
        var row = 0;
        var col = 0;
  
        var moveToNextCell = function moveToNextCell() {
          col++;
  
          if (col >= cols) {
            col = 0;
            row++;
          }
        }; // get a cache of all the manual positions
  
  
        var id2manPos = {};
  
        for (var _i = 0; _i < nodes.length; _i++) {
          var _node = nodes[_i];
          var rcPos = options.position(_node);
  
          if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {
            // must have at least row or col def'd
            var _pos = {
              row: rcPos.row,
              col: rcPos.col
            };
  
            if (_pos.col === undefined) {
              // find unused col
              _pos.col = 0;
  
              while (used(_pos.row, _pos.col)) {
                _pos.col++;
              }
            } else if (_pos.row === undefined) {
              // find unused row
              _pos.row = 0;
  
              while (used(_pos.row, _pos.col)) {
                _pos.row++;
              }
            }
  
            id2manPos[_node.id()] = _pos;
            use(_pos.row, _pos.col);
          }
        }
  
        var getPos = function getPos(element, i) {
          var x, y;
  
          if (element.locked() || element.isParent()) {
            return false;
          } // see if we have a manual position set
  
  
          var rcPos = id2manPos[element.id()];
  
          if (rcPos) {
            x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;
            y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;
          } else {
            // otherwise set automatically
            while (used(row, col)) {
              moveToNextCell();
            }
  
            x = col * cellWidth + cellWidth / 2 + bb.x1;
            y = row * cellHeight + cellHeight / 2 + bb.y1;
            use(row, col);
            moveToNextCell();
          }
  
          return {
            x: x,
            y: y
          };
        };
  
        nodes.layoutPositions(this, options, getPos);
      }
  
      return this; // chaining
    };
  
    var defaults$e = {
      ready: function ready() {},
      // on layoutready
      stop: function stop() {} // on layoutstop
  
    }; // constructor
    // options : object containing layout options
  
    function NullLayout(options) {
      this.options = extend({}, defaults$e, options);
    } // runs the layout
  
  
    NullLayout.prototype.run = function () {
      var options = this.options;
      var eles = options.eles; // elements to consider in the layout
  
      var layout = this; // cy is automatically populated for us in the constructor
      // (disable eslint for next line as this serves as example layout code to external developers)
      // eslint-disable-next-line no-unused-vars
  
      var cy = options.cy;
      layout.emit('layoutstart'); // puts all nodes at (0, 0)
      // n.b. most layouts would use layoutPositions(), instead of positions() and manual events
  
      eles.nodes().positions(function () {
        return {
          x: 0,
          y: 0
        };
      }); // trigger layoutready when each node has had its position set at least once
  
      layout.one('layoutready', options.ready);
      layout.emit('layoutready'); // trigger layoutstop when the layout stops (e.g. finishes)
  
      layout.one('layoutstop', options.stop);
      layout.emit('layoutstop');
      return this; // chaining
    }; // called on continuous layouts to stop them before they finish
  
  
    NullLayout.prototype.stop = function () {
      return this; // chaining
    };
  
    var defaults$f = {
      positions: undefined,
      // map of (node id) => (position obj); or function(node){ return somPos; }
      zoom: undefined,
      // the zoom level to set (prob want fit = false if set)
      pan: undefined,
      // the pan level to set (prob want fit = false if set)
      fit: true,
      // whether to fit to viewport
      padding: 30,
      // padding on fit
      animate: false,
      // whether to transition the node positions
      animationDuration: 500,
      // duration of animation in ms if enabled
      animationEasing: undefined,
      // easing of animation if enabled
      animateFilter: function animateFilter(node, i) {
        return true;
      },
      // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
      ready: undefined,
      // callback on layoutready
      stop: undefined,
      // callback on layoutstop
      transform: function transform(node, position) {
        return position;
      } // transform a given node position. Useful for changing flow direction in discrete layouts
  
    };
  
    function PresetLayout(options) {
      this.options = extend({}, defaults$f, options);
    }
  
    PresetLayout.prototype.run = function () {
      var options = this.options;
      var eles = options.eles;
      var nodes = eles.nodes();
      var posIsFn = fn(options.positions);
  
      function getPosition(node) {
        if (options.positions == null) {
          return copyPosition(node.position());
        }
  
        if (posIsFn) {
          return options.positions(node);
        }
  
        var pos = options.positions[node._private.data.id];
  
        if (pos == null) {
          return null;
        }
  
        return pos;
      }
  
      nodes.layoutPositions(this, options, function (node, i) {
        var position = getPosition(node);
  
        if (node.locked() || position == null) {
          return false;
        }
  
        return position;
      });
      return this; // chaining
    };
  
    var defaults$g = {
      fit: true,
      // whether to fit to viewport
      padding: 30,
      // fit padding
      boundingBox: undefined,
      // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
      animate: false,
      // whether to transition the node positions
      animationDuration: 500,
      // duration of animation in ms if enabled
      animationEasing: undefined,
      // easing of animation if enabled
      animateFilter: function animateFilter(node, i) {
        return true;
      },
      // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
      ready: undefined,
      // callback on layoutready
      stop: undefined,
      // callback on layoutstop
      transform: function transform(node, position) {
        return position;
      } // transform a given node position. Useful for changing flow direction in discrete layouts 
  
    };
  
    function RandomLayout(options) {
      this.options = extend({}, defaults$g, options);
    }
  
    RandomLayout.prototype.run = function () {
      var options = this.options;
      var cy = options.cy;
      var eles = options.eles;
      var nodes = eles.nodes().not(':parent');
      var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
        x1: 0,
        y1: 0,
        w: cy.width(),
        h: cy.height()
      });
  
      var getPos = function getPos(node, i) {
        return {
          x: bb.x1 + Math.round(Math.random() * bb.w),
          y: bb.y1 + Math.round(Math.random() * bb.h)
        };
      };
  
      nodes.layoutPositions(this, options, getPos);
      return this; // chaining
    };
  
    var layout = [{
      name: 'breadthfirst',
      impl: BreadthFirstLayout
    }, {
      name: 'circle',
      impl: CircleLayout
    }, {
      name: 'concentric',
      impl: ConcentricLayout
    }, {
      name: 'cose',
      impl: CoseLayout
    }, {
      name: 'grid',
      impl: GridLayout
    }, {
      name: 'null',
      impl: NullLayout
    }, {
      name: 'preset',
      impl: PresetLayout
    }, {
      name: 'random',
      impl: RandomLayout
    }];
  
    function NullRenderer(options) {
      this.options = options;
      this.notifications = 0; // for testing
    }
  
    var noop$1 = function noop() {};
  
    var throwImgErr = function throwImgErr() {
      throw new Error('A headless instance can not render images');
    };
  
    NullRenderer.prototype = {
      recalculateRenderedStyle: noop$1,
      notify: function notify() {
        this.notifications++;
      },
      init: noop$1,
      isHeadless: function isHeadless() {
        return true;
      },
      png: throwImgErr,
      jpg: throwImgErr
    };
  
    var BRp = {};
    BRp.arrowShapeWidth = 0.3;
  
    BRp.registerArrowShapes = function () {
      var arrowShapes = this.arrowShapes = {};
      var renderer = this; // Contract for arrow shapes:
      // 0, 0 is arrow tip
      // (0, 1) is direction towards node
      // (1, 0) is right
      //
      // functional api:
      // collide: check x, y in shape
      // roughCollide: called before collide, no false negatives
      // draw: draw
      // spacing: dist(arrowTip, nodeBoundary)
      // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip
  
      var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {
        var x1 = translation.x - size / 2 - padding;
        var x2 = translation.x + size / 2 + padding;
        var y1 = translation.y - size / 2 - padding;
        var y2 = translation.y + size / 2 + padding;
        var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;
        return inside;
      };
  
      var transform = function transform(x, y, size, angle, translation) {
        var xRotated = x * Math.cos(angle) - y * Math.sin(angle);
        var yRotated = x * Math.sin(angle) + y * Math.cos(angle);
        var xScaled = xRotated * size;
        var yScaled = yRotated * size;
        var xTranslated = xScaled + translation.x;
        var yTranslated = yScaled + translation.y;
        return {
          x: xTranslated,
          y: yTranslated
        };
      };
  
      var transformPoints = function transformPoints(pts, size, angle, translation) {
        var retPts = [];
  
        for (var i = 0; i < pts.length; i += 2) {
          var x = pts[i];
          var y = pts[i + 1];
          retPts.push(transform(x, y, size, angle, translation));
        }
  
        return retPts;
      };
  
      var pointsToArr = function pointsToArr(pts) {
        var ret = [];
  
        for (var i = 0; i < pts.length; i++) {
          var p = pts[i];
          ret.push(p.x, p.y);
        }
  
        return ret;
      };
  
      var standardGap = function standardGap(edge) {
        return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;
      };
  
      var defineArrowShape = function defineArrowShape(name, defn) {
        if (string(defn)) {
          defn = arrowShapes[defn];
        }
  
        arrowShapes[name] = extend({
          name: name,
          points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],
          collide: function collide(x, y, size, angle, translation, padding) {
            var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
            var inside = pointInsidePolygonPoints(x, y, points);
            return inside;
          },
          roughCollide: bbCollide,
          draw: function draw(context, size, angle, translation) {
            var points = transformPoints(this.points, size, angle, translation);
            renderer.arrowShapeImpl('polygon')(context, points);
          },
          spacing: function spacing(edge) {
            return 0;
          },
          gap: standardGap
        }, defn);
      };
  
      defineArrowShape('none', {
        collide: falsify,
        roughCollide: falsify,
        draw: noop,
        spacing: zeroify,
        gap: zeroify
      });
      defineArrowShape('triangle', {
        points: [-0.15, -0.3, 0, 0, 0.15, -0.3]
      });
      defineArrowShape('arrow', 'triangle');
      defineArrowShape('triangle-backcurve', {
        points: arrowShapes['triangle'].points,
        controlPoint: [0, -0.15],
        roughCollide: bbCollide,
        draw: function draw(context, size, angle, translation, edgeWidth) {
          var ptsTrans = transformPoints(this.points, size, angle, translation);
          var ctrlPt = this.controlPoint;
          var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);
          renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);
        },
        gap: function gap(edge) {
          return standardGap(edge) * 0.8;
        }
      });
      defineArrowShape('triangle-tee', {
        points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
        pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],
        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
          var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
          var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));
          var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);
          return inside;
        },
        draw: function draw(context, size, angle, translation, edgeWidth) {
          var triPts = transformPoints(this.points, size, angle, translation);
          var teePts = transformPoints(this.pointsTee, size, angle, translation);
          renderer.arrowShapeImpl(this.name)(context, triPts, teePts);
        }
      });
      defineArrowShape('circle-triangle', {
        radius: 0.15,
        pointsTr: [0, -0.15, 0.15, -0.45, -0.15, -0.45, 0, -0.15],
        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
          var t = translation;
          var circleInside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);
          var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
          return pointInsidePolygonPoints(x, y, triPts) || circleInside;
        },
        draw: function draw(context, size, angle, translation, edgeWidth) {
          var triPts = transformPoints(this.pointsTr, size, angle, translation);
          renderer.arrowShapeImpl(this.name)(context, triPts, translation.x, translation.y, this.radius * size);
        },
        spacing: function spacing(edge) {
          return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;
        }
      });
      defineArrowShape('triangle-cross', {
        points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
        baseCrossLinePts: [-0.15, -0.4, // first half of the rectangle
        -0.15, -0.4, 0.15, -0.4, // second half of the rectangle
        0.15, -0.4],
        crossLinePts: function crossLinePts(size, edgeWidth) {
          // shift points so that the distance between the cross points matches edge width
          var p = this.baseCrossLinePts.slice();
          var shiftFactor = edgeWidth / size;
          var y0 = 3;
          var y1 = 5;
          p[y0] = p[y0] - shiftFactor;
          p[y1] = p[y1] - shiftFactor;
          return p;
        },
        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
          var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
          var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));
          var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);
          return inside;
        },
        draw: function draw(context, size, angle, translation, edgeWidth) {
          var triPts = transformPoints(this.points, size, angle, translation);
          var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);
          renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);
        }
      });
      defineArrowShape('vee', {
        points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],
        gap: function gap(edge) {
          return standardGap(edge) * 0.525;
        }
      });
      defineArrowShape('circle', {
        radius: 0.15,
        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
          var t = translation;
          var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);
          return inside;
        },
        draw: function draw(context, size, angle, translation, edgeWidth) {
          renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);
        },
        spacing: function spacing(edge) {
          return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;
        }
      });
      defineArrowShape('tee', {
        points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],
        spacing: function spacing(edge) {
          return 1;
        },
        gap: function gap(edge) {
          return 1;
        }
      });
      defineArrowShape('square', {
        points: [-0.15, 0.00, 0.15, 0.00, 0.15, -0.3, -0.15, -0.3]
      });
      defineArrowShape('diamond', {
        points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],
        gap: function gap(edge) {
          return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;
        }
      });
      defineArrowShape('chevron', {
        points: [0, 0, -0.15, -0.15, -0.1, -0.2, 0, -0.1, 0.1, -0.2, 0.15, -0.15],
        gap: function gap(edge) {
          return 0.95 * edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;
        }
      });
    };
  
    var BRp$1 = {}; // Project mouse
  
    BRp$1.projectIntoViewport = function (clientX, clientY) {
      var cy = this.cy;
      var offsets = this.findContainerClientCoords();
      var offsetLeft = offsets[0];
      var offsetTop = offsets[1];
      var scale = offsets[4];
      var pan = cy.pan();
      var zoom = cy.zoom();
      var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;
      var y = ((clientY - offsetTop) / scale - pan.y) / zoom;
      return [x, y];
    };
  
    BRp$1.findContainerClientCoords = function () {
      if (this.containerBB) {
        return this.containerBB;
      }
  
      var container = this.container;
      var rect = container.getBoundingClientRect();
      var style = window$1.getComputedStyle(container);
  
      var styleValue = function styleValue(name) {
        return parseFloat(style.getPropertyValue(name));
      };
  
      var padding = {
        left: styleValue('padding-left'),
        right: styleValue('padding-right'),
        top: styleValue('padding-top'),
        bottom: styleValue('padding-bottom')
      };
      var border = {
        left: styleValue('border-left-width'),
        right: styleValue('border-right-width'),
        top: styleValue('border-top-width'),
        bottom: styleValue('border-bottom-width')
      };
      var clientWidth = container.clientWidth;
      var clientHeight = container.clientHeight;
      var paddingHor = padding.left + padding.right;
      var paddingVer = padding.top + padding.bottom;
      var borderHor = border.left + border.right;
      var scale = rect.width / (clientWidth + borderHor);
      var unscaledW = clientWidth - paddingHor;
      var unscaledH = clientHeight - paddingVer;
      var left = rect.left + padding.left + border.left;
      var top = rect.top + padding.top + border.top;
      return this.containerBB = [left, top, unscaledW, unscaledH, scale];
    };
  
    BRp$1.invalidateContainerClientCoordsCache = function () {
      this.containerBB = null;
    };
  
    BRp$1.findNearestElement = function (x, y, interactiveElementsOnly, isTouch) {
      return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];
    };
  
    BRp$1.findNearestElements = function (x, y, interactiveElementsOnly, isTouch) {
      var self = this;
      var r = this;
      var eles = r.getCachedZSortedEles();
      var near = []; // 1 node max, 1 edge max
  
      var zoom = r.cy.zoom();
      var hasCompounds = r.cy.hasCompoundNodes();
      var edgeThreshold = (isTouch ? 24 : 8) / zoom;
      var nodeThreshold = (isTouch ? 8 : 2) / zoom;
      var labelThreshold = (isTouch ? 8 : 2) / zoom;
      var minSqDist = Infinity;
      var nearEdge;
      var nearNode;
  
      if (interactiveElementsOnly) {
        eles = eles.interactive;
      }
  
      function addEle(ele, sqDist) {
        if (ele.isNode()) {
          if (nearNode) {
            return; // can't replace node
          } else {
            nearNode = ele;
            near.push(ele);
          }
        }
  
        if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {
          if (nearEdge) {
            // then replace existing edge
            // can replace only if same z-index
            if (nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value && nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value) {
              for (var i = 0; i < near.length; i++) {
                if (near[i].isEdge()) {
                  near[i] = ele;
                  nearEdge = ele;
                  minSqDist = sqDist != null ? sqDist : minSqDist;
                  break;
                }
              }
            }
          } else {
            near.push(ele);
            nearEdge = ele;
            minSqDist = sqDist != null ? sqDist : minSqDist;
          }
        }
      }
  
      function checkNode(node) {
        var width = node.outerWidth() + 2 * nodeThreshold;
        var height = node.outerHeight() + 2 * nodeThreshold;
        var hw = width / 2;
        var hh = height / 2;
        var pos = node.position();
  
        if (pos.x - hw <= x && x <= pos.x + hw // bb check x
        && pos.y - hh <= y && y <= pos.y + hh // bb check y
        ) {
            var shape = r.nodeShapes[self.getNodeShape(node)];
  
            if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)) {
              addEle(node, 0);
              return true;
            }
          }
      }
  
      function checkEdge(edge) {
        var _p = edge._private;
        var rs = _p.rscratch;
        var styleWidth = edge.pstyle('width').pfValue;
        var scale = edge.pstyle('arrow-scale').value;
        var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre
  
        var widthSq = width * width;
        var width2 = width * 2;
        var src = _p.source;
        var tgt = _p.target;
        var sqDist;
  
        if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {
          var pts = rs.allpts;
  
          for (var i = 0; i + 3 < pts.length; i += 2) {
            if (inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2) && widthSq > (sqDist = sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {
              addEle(edge, sqDist);
              return true;
            }
          }
        } else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
          var pts = rs.allpts;
  
          for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
            if (inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2) && widthSq > (sqDist = sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {
              addEle(edge, sqDist);
              return true;
            }
          }
        } // if we're close to the edge but didn't hit it, maybe we hit its arrows
  
  
        var src = src || _p.source;
        var tgt = tgt || _p.target;
        var arSize = self.getArrowWidth(styleWidth, scale);
        var arrows = [{
          name: 'source',
          x: rs.arrowStartX,
          y: rs.arrowStartY,
          angle: rs.srcArrowAngle
        }, {
          name: 'target',
          x: rs.arrowEndX,
          y: rs.arrowEndY,
          angle: rs.tgtArrowAngle
        }, {
          name: 'mid-source',
          x: rs.midX,
          y: rs.midY,
          angle: rs.midsrcArrowAngle
        }, {
          name: 'mid-target',
          x: rs.midX,
          y: rs.midY,
          angle: rs.midtgtArrowAngle
        }];
  
        for (var i = 0; i < arrows.length; i++) {
          var ar = arrows[i];
          var shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];
          var edgeWidth = edge.pstyle('width').pfValue;
  
          if (shape.roughCollide(x, y, arSize, ar.angle, {
            x: ar.x,
            y: ar.y
          }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, {
            x: ar.x,
            y: ar.y
          }, edgeWidth, edgeThreshold)) {
            addEle(edge);
            return true;
          }
        } // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
  
  
        if (hasCompounds && near.length > 0) {
          checkNode(src);
          checkNode(tgt);
        }
      }
  
      function preprop(obj, name, pre) {
        return getPrefixedProperty(obj, name, pre);
      }
  
      function checkLabel(ele, prefix) {
        var _p = ele._private;
        var th = labelThreshold;
        var prefixDash;
  
        if (prefix) {
          prefixDash = prefix + '-';
        } else {
          prefixDash = '';
        }
  
        ele.boundingBox();
        var bb = _p.labelBounds[prefix || 'main'];
        var text = ele.pstyle(prefixDash + 'label').value;
        var eventsEnabled = ele.pstyle('text-events').strValue === 'yes';
  
        if (!eventsEnabled || !text) {
          return;
        }
  
        var rstyle = _p.rstyle;
        var lx = preprop(rstyle, 'labelX', prefix);
        var ly = preprop(rstyle, 'labelY', prefix);
        var theta = preprop(_p.rscratch, 'labelAngle', prefix);
        var lx1 = bb.x1 - th;
        var lx2 = bb.x2 + th;
        var ly1 = bb.y1 - th;
        var ly2 = bb.y2 + th;
  
        if (theta) {
          var cos = Math.cos(theta);
          var sin = Math.sin(theta);
  
          var rotate = function rotate(x, y) {
            x = x - lx;
            y = y - ly;
            return {
              x: x * cos - y * sin + lx,
              y: x * sin + y * cos + ly
            };
          };
  
          var px1y1 = rotate(lx1, ly1);
          var px1y2 = rotate(lx1, ly2);
          var px2y1 = rotate(lx2, ly1);
          var px2y2 = rotate(lx2, ly2);
          var points = [px1y1.x, px1y1.y, px2y1.x, px2y1.y, px2y2.x, px2y2.y, px1y2.x, px1y2.y];
  
          if (pointInsidePolygonPoints(x, y, points)) {
            addEle(ele);
            return true;
          }
        } else {
          // do a cheaper bb check
          if (inBoundingBox(bb, x, y)) {
            addEle(ele);
            return true;
          }
        }
      }
  
      for (var i = eles.length - 1; i >= 0; i--) {
        // reverse order for precedence
        var ele = eles[i];
  
        if (ele.isNode()) {
          checkNode(ele) || checkLabel(ele);
        } else {
          // then edge
          checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');
        }
      }
  
      return near;
    }; // 'Give me everything from this box'
  
  
    BRp$1.getAllInBox = function (x1, y1, x2, y2) {
      var eles = this.getCachedZSortedEles().interactive;
      var box = [];
      var x1c = Math.min(x1, x2);
      var x2c = Math.max(x1, x2);
      var y1c = Math.min(y1, y2);
      var y2c = Math.max(y1, y2);
      x1 = x1c;
      x2 = x2c;
      y1 = y1c;
      y2 = y2c;
      var boxBb = makeBoundingBox({
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2
      });
  
      for (var e = 0; e < eles.length; e++) {
        var ele = eles[e];
  
        if (ele.isNode()) {
          var node = ele;
          var nodeBb = node.boundingBox({
            includeNodes: true,
            includeEdges: false,
            includeLabels: false
          });
  
          if (boundingBoxesIntersect(boxBb, nodeBb) && !boundingBoxInBoundingBox(nodeBb, boxBb)) {
            box.push(node);
          }
        } else {
          var edge = ele;
          var _p = edge._private;
          var rs = _p.rscratch;
  
          if (rs.startX != null && rs.startY != null && !inBoundingBox(boxBb, rs.startX, rs.startY)) {
            continue;
          }
  
          if (rs.endX != null && rs.endY != null && !inBoundingBox(boxBb, rs.endX, rs.endY)) {
            continue;
          }
  
          if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {
            var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
            var allInside = true;
  
            for (var i = 0; i < pts.length; i++) {
              if (!pointInBoundingBox(boxBb, pts[i])) {
                allInside = false;
                break;
              }
            }
  
            if (allInside) {
              box.push(edge);
            }
          } else if (rs.edgeType === 'haystack' || rs.edgeType === 'straight') {
            box.push(edge);
          }
        }
      }
  
      return box;
    };
  
    var BRp$2 = {};
  
    BRp$2.calculateArrowAngles = function (edge) {
      var rs = edge._private.rscratch;
      var isHaystack = rs.edgeType === 'haystack';
      var isBezier = rs.edgeType === 'bezier';
      var isMultibezier = rs.edgeType === 'multibezier';
      var isSegments = rs.edgeType === 'segments';
      var isCompound = rs.edgeType === 'compound';
      var isSelf = rs.edgeType === 'self'; // Displacement gives direction for arrowhead orientation
  
      var dispX, dispY;
      var startX, startY, endX, endY, midX, midY;
  
      if (isHaystack) {
        startX = rs.haystackPts[0];
        startY = rs.haystackPts[1];
        endX = rs.haystackPts[2];
        endY = rs.haystackPts[3];
      } else {
        startX = rs.arrowStartX;
        startY = rs.arrowStartY;
        endX = rs.arrowEndX;
        endY = rs.arrowEndY;
      }
  
      midX = rs.midX;
      midY = rs.midY; // source
      //
  
      if (isSegments) {
        dispX = startX - rs.segpts[0];
        dispY = startY - rs.segpts[1];
      } else if (isMultibezier || isCompound || isSelf || isBezier) {
        var pts = rs.allpts;
        var bX = qbezierAt(pts[0], pts[2], pts[4], 0.1);
        var bY = qbezierAt(pts[1], pts[3], pts[5], 0.1);
        dispX = startX - bX;
        dispY = startY - bY;
      } else {
        dispX = startX - midX;
        dispY = startY - midY;
      }
  
      rs.srcArrowAngle = getAngleFromDisp(dispX, dispY); // mid target
      //
  
      var midX = rs.midX;
      var midY = rs.midY;
  
      if (isHaystack) {
        midX = (startX + endX) / 2;
        midY = (startY + endY) / 2;
      }
  
      dispX = endX - startX;
      dispY = endY - startY;
  
      if (isSegments) {
        var pts = rs.allpts;
  
        if (pts.length / 2 % 2 === 0) {
          var i2 = pts.length / 2;
          var i1 = i2 - 2;
          dispX = pts[i2] - pts[i1];
          dispY = pts[i2 + 1] - pts[i1 + 1];
        } else {
          var i2 = pts.length / 2 - 1;
          var i1 = i2 - 2;
          var i3 = i2 + 2;
          dispX = pts[i2] - pts[i1];
          dispY = pts[i2 + 1] - pts[i1 + 1];
        }
      } else if (isMultibezier || isCompound || isSelf) {
        var pts = rs.allpts;
        var cpts = rs.ctrlpts;
        var bp0x, bp0y;
        var bp1x, bp1y;
  
        if (cpts.length / 2 % 2 === 0) {
          var p0 = pts.length / 2 - 1; // startpt
  
          var ic = p0 + 2;
          var p1 = ic + 2;
          bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);
          bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);
          bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);
          bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);
        } else {
          var ic = pts.length / 2 - 1; // ctrpt
  
          var p0 = ic - 2; // startpt
  
          var p1 = ic + 2; // endpt
  
          bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);
          bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);
          bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);
          bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);
        }
  
        dispX = bp1x - bp0x;
        dispY = bp1y - bp0y;
      }
  
      rs.midtgtArrowAngle = getAngleFromDisp(dispX, dispY);
      rs.midDispX = dispX;
      rs.midDispY = dispY; // mid source
      //
  
      dispX *= -1;
      dispY *= -1;
  
      if (isSegments) {
        var pts = rs.allpts;
  
        if (pts.length / 2 % 2 === 0) ; else {
          var i2 = pts.length / 2 - 1;
          var i3 = i2 + 2;
          dispX = -(pts[i3] - pts[i2]);
          dispY = -(pts[i3 + 1] - pts[i2 + 1]);
        }
      }
  
      rs.midsrcArrowAngle = getAngleFromDisp(dispX, dispY); // target
      //
  
      if (isSegments) {
        dispX = endX - rs.segpts[rs.segpts.length - 2];
        dispY = endY - rs.segpts[rs.segpts.length - 1];
      } else if (isMultibezier || isCompound || isSelf || isBezier) {
        var pts = rs.allpts;
        var l = pts.length;
        var bX = qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);
        var bY = qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);
        dispX = endX - bX;
        dispY = endY - bY;
      } else {
        dispX = endX - midX;
        dispY = endY - midY;
      }
  
      rs.tgtArrowAngle = getAngleFromDisp(dispX, dispY);
    };
  
    BRp$2.getArrowWidth = BRp$2.getArrowHeight = function (edgeWidth, scale) {
      var cache = this.arrowWidthCache = this.arrowWidthCache || {};
      var cachedVal = cache[edgeWidth + ', ' + scale];
  
      if (cachedVal) {
        return cachedVal;
      }
  
      cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;
      cache[edgeWidth + ', ' + scale] = cachedVal;
      return cachedVal;
    };
  
    var BRp$3 = {};
  
    BRp$3.findHaystackPoints = function (edges) {
      for (var i = 0; i < edges.length; i++) {
        var edge = edges[i];
        var _p = edge._private;
        var rs = _p.rscratch;
  
        if (!rs.haystack) {
          var angle = Math.random() * 2 * Math.PI;
          rs.source = {
            x: Math.cos(angle),
            y: Math.sin(angle)
          };
          angle = Math.random() * 2 * Math.PI;
          rs.target = {
            x: Math.cos(angle),
            y: Math.sin(angle)
          };
        }
  
        var src = _p.source;
        var tgt = _p.target;
        var srcPos = src.position();
        var tgtPos = tgt.position();
        var srcW = src.width();
        var tgtW = tgt.width();
        var srcH = src.height();
        var tgtH = tgt.height();
        var radius = edge.pstyle('haystack-radius').value;
        var halfRadius = radius / 2; // b/c have to half width/height
  
        rs.haystackPts = rs.allpts = [rs.source.x * srcW * halfRadius + srcPos.x, rs.source.y * srcH * halfRadius + srcPos.y, rs.target.x * tgtW * halfRadius + tgtPos.x, rs.target.y * tgtH * halfRadius + tgtPos.y];
        rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;
        rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2; // always override as haystack in case set to different type previously
  
        rs.edgeType = 'haystack';
        rs.haystack = true;
        this.storeEdgeProjections(edge);
        this.calculateArrowAngles(edge);
        this.recalculateEdgeLabelProjections(edge);
        this.calculateLabelAngles(edge);
      }
    };
  
    BRp$3.findSegmentsPoints = function (edge, pairInfo) {
      // Segments (multiple straight lines)
      var rs = edge._private.rscratch;
      var posPts = pairInfo.posPts,
          intersectionPts = pairInfo.intersectionPts,
          vectorNormInverse = pairInfo.vectorNormInverse;
      var edgeDistances = edge.pstyle('edge-distances').value;
      var segmentWs = edge.pstyle('segment-weights');
      var segmentDs = edge.pstyle('segment-distances');
      var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);
      rs.edgeType = 'segments';
      rs.segpts = [];
  
      for (var s = 0; s < segmentsN; s++) {
        var w = segmentWs.pfValue[s];
        var d = segmentDs.pfValue[s];
        var w1 = 1 - w;
        var w2 = w;
        var midptPts = edgeDistances === 'node-position' ? posPts : intersectionPts;
        var adjustedMidpt = {
          x: midptPts.x1 * w1 + midptPts.x2 * w2,
          y: midptPts.y1 * w1 + midptPts.y2 * w2
        };
        rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);
      }
    };
  
    BRp$3.findLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {
      // Self-edge
      var rs = edge._private.rscratch;
      var dirCounts = pairInfo.dirCounts,
          srcPos = pairInfo.srcPos;
      var ctrlptDists = edge.pstyle('control-point-distances');
      var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
      var loopDir = edge.pstyle('loop-direction').pfValue;
      var loopSwp = edge.pstyle('loop-sweep').pfValue;
      var stepSize = edge.pstyle('control-point-step-size').pfValue;
      rs.edgeType = 'self';
      var j = i;
      var loopDist = stepSize;
  
      if (edgeIsUnbundled) {
        j = 0;
        loopDist = ctrlptDist;
      }
  
      var loopAngle = loopDir - Math.PI / 2;
      var outAngle = loopAngle - loopSwp / 2;
      var inAngle = loopAngle + loopSwp / 2; // increase by step size for overlapping loops, keyed on direction and sweep values
  
      var dc = String(loopDir + '_' + loopSwp);
      j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];
      rs.ctrlpts = [srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)];
    };
  
    BRp$3.findCompoundLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {
      // Compound edge
      var rs = edge._private.rscratch;
      rs.edgeType = 'compound';
      var srcPos = pairInfo.srcPos,
          tgtPos = pairInfo.tgtPos,
          srcW = pairInfo.srcW,
          srcH = pairInfo.srcH,
          tgtW = pairInfo.tgtW,
          tgtH = pairInfo.tgtH;
      var stepSize = edge.pstyle('control-point-step-size').pfValue;
      var ctrlptDists = edge.pstyle('control-point-distances');
      var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
      var j = i;
      var loopDist = stepSize;
  
      if (edgeIsUnbundled) {
        j = 0;
        loopDist = ctrlptDist;
      }
  
      var loopW = 50;
      var loopaPos = {
        x: srcPos.x - srcW / 2,
        y: srcPos.y - srcH / 2
      };
      var loopbPos = {
        x: tgtPos.x - tgtW / 2,
        y: tgtPos.y - tgtH / 2
      };
      var loopPos = {
        x: Math.min(loopaPos.x, loopbPos.x),
        y: Math.min(loopaPos.y, loopbPos.y)
      }; // avoids cases with impossible beziers
  
      var minCompoundStretch = 0.5;
      var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));
      var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));
      rs.ctrlpts = [loopPos.x, loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA, loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB, loopPos.y];
    };
  
    BRp$3.findStraightEdgePoints = function (edge) {
      // Straight edge within bundle
      edge._private.rscratch.edgeType = 'straight';
    };
  
    BRp$3.findBezierPoints = function (edge, pairInfo, i, edgeIsUnbundled, edgeIsSwapped) {
      var rs = edge._private.rscratch;
      var vectorNormInverse = pairInfo.vectorNormInverse,
          posPts = pairInfo.posPts,
          intersectionPts = pairInfo.intersectionPts;
      var edgeDistances = edge.pstyle('edge-distances').value;
      var stepSize = edge.pstyle('control-point-step-size').pfValue;
      var ctrlptDists = edge.pstyle('control-point-distances');
      var ctrlptWs = edge.pstyle('control-point-weights');
      var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;
      var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
      var ctrlptWeight = ctrlptWs.value[0]; // (Multi)bezier
  
      var multi = edgeIsUnbundled;
      rs.edgeType = multi ? 'multibezier' : 'bezier';
      rs.ctrlpts = [];
  
      for (var b = 0; b < bezierN; b++) {
        var normctrlptDist = (0.5 - pairInfo.eles.length / 2 + i) * stepSize * (edgeIsSwapped ? -1 : 1);
        var manctrlptDist = void 0;
        var sign = signum(normctrlptDist);
  
        if (multi) {
          ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size
  
          ctrlptWeight = ctrlptWs.value[b];
        }
  
        if (edgeIsUnbundled) {
          // multi or single unbundled
          manctrlptDist = ctrlptDist;
        } else {
          manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;
        }
  
        var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;
        var w1 = 1 - ctrlptWeight;
        var w2 = ctrlptWeight;
        var midptPts = edgeDistances === 'node-position' ? posPts : intersectionPts;
        var adjustedMidpt = {
          x: midptPts.x1 * w1 + midptPts.x2 * w2,
          y: midptPts.y1 * w1 + midptPts.y2 * w2
        };
        rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);
      }
    };
  
    BRp$3.findTaxiPoints = function (edge, pairInfo) {
      // Taxicab geometry with two turns maximum
      var rs = edge._private.rscratch;
      rs.edgeType = 'segments';
      var VERTICAL = 'vertical';
      var HORIZONTAL = 'horizontal';
      var LEFTWARD = 'leftward';
      var RIGHTWARD = 'rightward';
      var DOWNWARD = 'downward';
      var UPWARD = 'upward';
      var AUTO = 'auto';
      var posPts = pairInfo.posPts,
          srcW = pairInfo.srcW,
          srcH = pairInfo.srcH,
          tgtW = pairInfo.tgtW,
          tgtH = pairInfo.tgtH;
      var edgeDistances = edge.pstyle('edge-distances').value;
      var dIncludesNodeBody = edgeDistances !== 'node-position';
      var taxiDir = edge.pstyle('taxi-direction').value;
      var rawTaxiDir = taxiDir; // unprocessed value
  
      var taxiTurn = edge.pstyle('taxi-turn');
      var turnIsPercent = taxiTurn.units === '%';
      var taxiTurnPfVal = turnIsPercent && taxiTurn.pfValue < 0 ? 1 + taxiTurn.pfValue : taxiTurn.pfValue;
      var minD = edge.pstyle('taxi-turn-min-distance').pfValue;
      var dw = dIncludesNodeBody ? (srcW + tgtW) / 2 : 0;
      var dh = dIncludesNodeBody ? (srcH + tgtH) / 2 : 0;
      var pdx = posPts.x2 - posPts.x1;
      var pdy = posPts.y2 - posPts.y1; // take away the effective w/h from the magnitude of the delta value
  
      var subDWH = function subDWH(dxy, dwh) {
        if (dxy > 0) {
          return Math.max(dxy - dwh, 0);
        } else {
          return Math.min(dxy + dwh, 0);
        }
      };
  
      var dx = subDWH(pdx, dw);
      var dy = subDWH(pdy, dh);
      var isExplicitDir = false;
  
      if (taxiDir === AUTO) {
        taxiDir = Math.abs(dx) > Math.abs(dy) ? HORIZONTAL : VERTICAL;
      } else if (taxiDir === UPWARD || taxiDir === DOWNWARD) {
        taxiDir = VERTICAL;
        isExplicitDir = true;
      } else if (taxiDir === LEFTWARD || taxiDir === RIGHTWARD) {
        taxiDir = HORIZONTAL;
        isExplicitDir = true;
      }
  
      var isVert = taxiDir === VERTICAL;
      var l = isVert ? dy : dx;
      var pl = isVert ? pdy : pdx;
      var sgnL = signum(pl);
      var forcedDir = false;
  
      if (!(isExplicitDir && turnIsPercent) // forcing in this case would cause weird growing in the opposite direction
      && (rawTaxiDir === DOWNWARD && pl < 0 || rawTaxiDir === UPWARD && pl > 0 || rawTaxiDir === LEFTWARD && pl > 0 || rawTaxiDir === RIGHTWARD && pl < 0)) {
        sgnL *= -1;
        l = sgnL * Math.abs(l);
        forcedDir = true;
      }
  
      var d = turnIsPercent ? taxiTurnPfVal * l : taxiTurnPfVal * sgnL;
  
      var getIsTooClose = function getIsTooClose(d) {
        return Math.abs(d) < minD || Math.abs(d) >= Math.abs(l);
      };
  
      var isTooCloseSrc = getIsTooClose(d);
      var isTooCloseTgt = getIsTooClose(l - Math.abs(d));
      var isTooClose = isTooCloseSrc || isTooCloseTgt;
  
      if (isTooClose && !forcedDir) {
        // non-ideal routing
        if (isVert) {
          // vertical fallbacks
          var lShapeInsideSrc = Math.abs(pl) <= srcH / 2;
          var lShapeInsideTgt = Math.abs(pdx) <= tgtW / 2;
  
          if (lShapeInsideSrc) {
            // horizontal Z-shape (direction not respected)
            var x = (posPts.x1 + posPts.x2) / 2;
            var y1 = posPts.y1,
                y2 = posPts.y2;
            rs.segpts = [x, y1, x, y2];
          } else if (lShapeInsideTgt) {
            // vertical Z-shape (distance not respected)
            var y = (posPts.y1 + posPts.y2) / 2;
            var x1 = posPts.x1,
                x2 = posPts.x2;
            rs.segpts = [x1, y, x2, y];
          } else {
            // L-shape fallback (turn distance not respected, but works well with tree siblings)
            rs.segpts = [posPts.x1, posPts.y2];
          }
        } else {
          // horizontal fallbacks
          var _lShapeInsideSrc = Math.abs(pl) <= srcW / 2;
  
          var _lShapeInsideTgt = Math.abs(pdy) <= tgtH / 2;
  
          if (_lShapeInsideSrc) {
            // vertical Z-shape (direction not respected)
            var _y = (posPts.y1 + posPts.y2) / 2;
  
            var _x = posPts.x1,
                _x2 = posPts.x2;
            rs.segpts = [_x, _y, _x2, _y];
          } else if (_lShapeInsideTgt) {
            // horizontal Z-shape (turn distance not respected)
            var _x3 = (posPts.x1 + posPts.x2) / 2;
  
            var _y2 = posPts.y1,
                _y3 = posPts.y2;
            rs.segpts = [_x3, _y2, _x3, _y3];
          } else {
            // L-shape (turn distance not respected, but works well for tree siblings)
            rs.segpts = [posPts.x2, posPts.y1];
          }
        }
      } else {
        // ideal routing
        if (isVert) {
          var _y4 = (d < 0 ? posPts.y2 : posPts.y1) + d + (dIncludesNodeBody ? srcH / 2 * sgnL : 0);
  
          var _x4 = posPts.x1,
              _x5 = posPts.x2;
          rs.segpts = [_x4, _y4, _x5, _y4];
        } else {
          // horizontal
          var _x6 = (d < 0 ? posPts.x2 : posPts.x1) + d + (dIncludesNodeBody ? srcW / 2 * sgnL : 0);
  
          var _y5 = posPts.y1,
              _y6 = posPts.y2;
          rs.segpts = [_x6, _y5, _x6, _y6];
        }
      }
    };
  
    BRp$3.tryToCorrectInvalidPoints = function (edge, pairInfo) {
      var rs = edge._private.rscratch; // can only correct beziers for now...
  
      if (rs.edgeType === 'bezier') {
        var srcPos = pairInfo.srcPos,
            tgtPos = pairInfo.tgtPos,
            srcW = pairInfo.srcW,
            srcH = pairInfo.srcH,
            tgtW = pairInfo.tgtW,
            tgtH = pairInfo.tgtH,
            srcShape = pairInfo.srcShape,
            tgtShape = pairInfo.tgtShape;
        var badStart = !number(rs.startX) || !number(rs.startY);
        var badAStart = !number(rs.arrowStartX) || !number(rs.arrowStartY);
        var badEnd = !number(rs.endX) || !number(rs.endY);
        var badAEnd = !number(rs.arrowEndX) || !number(rs.arrowEndY);
        var minCpADistFactor = 3;
        var arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
        var minCpADist = minCpADistFactor * arrowW;
        var startACpDist = dist({
          x: rs.ctrlpts[0],
          y: rs.ctrlpts[1]
        }, {
          x: rs.startX,
          y: rs.startY
        });
        var closeStartACp = startACpDist < minCpADist;
        var endACpDist = dist({
          x: rs.ctrlpts[0],
          y: rs.ctrlpts[1]
        }, {
          x: rs.endX,
          y: rs.endY
        });
        var closeEndACp = endACpDist < minCpADist;
        var overlapping = false;
  
        if (badStart || badAStart || closeStartACp) {
          overlapping = true; // project control point along line from src centre to outside the src shape
          // (otherwise intersection will yield nothing)
  
          var cpD = {
            // delta
            x: rs.ctrlpts[0] - srcPos.x,
            y: rs.ctrlpts[1] - srcPos.y
          };
          var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line
  
          var cpM = {
            // normalised delta
            x: cpD.x / cpL,
            y: cpD.y / cpL
          };
          var radius = Math.max(srcW, srcH);
          var cpProj = {
            // *2 radius guarantees outside shape
            x: rs.ctrlpts[0] + cpM.x * 2 * radius,
            y: rs.ctrlpts[1] + cpM.y * 2 * radius
          };
          var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0);
  
          if (closeStartACp) {
            rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);
            rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);
          } else {
            rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;
            rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;
          }
        }
  
        if (badEnd || badAEnd || closeEndACp) {
          overlapping = true; // project control point along line from tgt centre to outside the tgt shape
          // (otherwise intersection will yield nothing)
  
          var _cpD = {
            // delta
            x: rs.ctrlpts[0] - tgtPos.x,
            y: rs.ctrlpts[1] - tgtPos.y
          };
  
          var _cpL = Math.sqrt(_cpD.x * _cpD.x + _cpD.y * _cpD.y); // length of line
  
  
          var _cpM = {
            // normalised delta
            x: _cpD.x / _cpL,
            y: _cpD.y / _cpL
          };
  
          var _radius = Math.max(srcW, srcH);
  
          var _cpProj = {
            // *2 radius guarantees outside shape
            x: rs.ctrlpts[0] + _cpM.x * 2 * _radius,
            y: rs.ctrlpts[1] + _cpM.y * 2 * _radius
          };
          var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, _cpProj.x, _cpProj.y, 0);
  
          if (closeEndACp) {
            rs.ctrlpts[0] = rs.ctrlpts[0] + _cpM.x * (minCpADist - endACpDist);
            rs.ctrlpts[1] = rs.ctrlpts[1] + _cpM.y * (minCpADist - endACpDist);
          } else {
            rs.ctrlpts[0] = tgtCtrlPtIntn[0] + _cpM.x * minCpADist;
            rs.ctrlpts[1] = tgtCtrlPtIntn[1] + _cpM.y * minCpADist;
          }
        }
  
        if (overlapping) {
          // recalc endpts
          this.findEndpoints(edge);
        }
      }
    };
  
    BRp$3.storeAllpts = function (edge) {
      var rs = edge._private.rscratch;
  
      if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
        rs.allpts = [];
        rs.allpts.push(rs.startX, rs.startY);
  
        for (var b = 0; b + 1 < rs.ctrlpts.length; b += 2) {
          // ctrl pt itself
          rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]); // the midpt between ctrlpts as intermediate destination pts
  
          if (b + 3 < rs.ctrlpts.length) {
            rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);
          }
        }
  
        rs.allpts.push(rs.endX, rs.endY);
        var m, mt;
  
        if (rs.ctrlpts.length / 2 % 2 === 0) {
          m = rs.allpts.length / 2 - 1;
          rs.midX = rs.allpts[m];
          rs.midY = rs.allpts[m + 1];
        } else {
          m = rs.allpts.length / 2 - 3;
          mt = 0.5;
          rs.midX = qbezierAt(rs.allpts[m], rs.allpts[m + 2], rs.allpts[m + 4], mt);
          rs.midY = qbezierAt(rs.allpts[m + 1], rs.allpts[m + 3], rs.allpts[m + 5], mt);
        }
      } else if (rs.edgeType === 'straight') {
        // need to calc these after endpts
        rs.allpts = [rs.startX, rs.startY, rs.endX, rs.endY]; // default midpt for labels etc
  
        rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;
        rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;
      } else if (rs.edgeType === 'segments') {
        rs.allpts = [];
        rs.allpts.push(rs.startX, rs.startY);
        rs.allpts.push.apply(rs.allpts, rs.segpts);
        rs.allpts.push(rs.endX, rs.endY);
  
        if (rs.segpts.length % 4 === 0) {
          var i2 = rs.segpts.length / 2;
          var i1 = i2 - 2;
          rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;
          rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;
        } else {
          var _i = rs.segpts.length / 2 - 1;
  
          rs.midX = rs.segpts[_i];
          rs.midY = rs.segpts[_i + 1];
        }
      }
    };
  
    BRp$3.checkForInvalidEdgeWarning = function (edge) {
      var rs = edge[0]._private.rscratch;
  
      if (rs.nodesOverlap || number(rs.startX) && number(rs.startY) && number(rs.endX) && number(rs.endY)) {
        rs.loggedErr = false;
      } else {
        if (!rs.loggedErr) {
          rs.loggedErr = true;
          warn('Edge `' + edge.id() + '` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap.');
        }
      }
    };
  
    BRp$3.findEdgeControlPoints = function (edges) {
      var _this = this;
  
      if (!edges || edges.length === 0) {
        return;
      }
  
      var r = this;
      var cy = r.cy;
      var hasCompounds = cy.hasCompoundNodes();
      var hashTable = {
        map: new Map$1(),
        get: function get(pairId) {
          var map2 = this.map.get(pairId[0]);
  
          if (map2 != null) {
            return map2.get(pairId[1]);
          } else {
            return null;
          }
        },
        set: function set(pairId, val) {
          var map2 = this.map.get(pairId[0]);
  
          if (map2 == null) {
            map2 = new Map$1();
            this.map.set(pairId[0], map2);
          }
  
          map2.set(pairId[1], val);
        }
      };
      var pairIds = [];
      var haystackEdges = []; // create a table of edge (src, tgt) => list of edges between them
  
      for (var i = 0; i < edges.length; i++) {
        var edge = edges[i];
        var _p = edge._private;
        var curveStyle = edge.pstyle('curve-style').value; // ignore edges who are not to be displayed
        // they shouldn't take up space
  
        if (edge.removed() || !edge.takesUpSpace()) {
          continue;
        }
  
        if (curveStyle === 'haystack') {
          haystackEdges.push(edge);
          continue;
        }
  
        var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments' || curveStyle === 'straight' || curveStyle === 'taxi';
        var edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';
        var src = _p.source;
        var tgt = _p.target;
        var srcIndex = src.poolIndex();
        var tgtIndex = tgt.poolIndex();
        var pairId = [srcIndex, tgtIndex].sort();
        var tableEntry = hashTable.get(pairId);
  
        if (tableEntry == null) {
          tableEntry = {
            eles: []
          };
          hashTable.set(pairId, tableEntry);
          pairIds.push(pairId);
        }
  
        tableEntry.eles.push(edge);
  
        if (edgeIsUnbundled) {
          tableEntry.hasUnbundled = true;
        }
  
        if (edgeIsBezier) {
          tableEntry.hasBezier = true;
        }
      } // for each pair (src, tgt), create the ctrl pts
      // Nested for loop is OK; total number of iterations for both loops = edgeCount
  
  
      var _loop = function _loop(p) {
        var pairId = pairIds[p];
        var pairInfo = hashTable.get(pairId);
        var swappedpairInfo = void 0;
  
        if (!pairInfo.hasUnbundled) {
          var pllEdges = pairInfo.eles[0].parallelEdges().filter(function (e) {
            return e.isBundledBezier();
          });
          clearArray(pairInfo.eles);
          pllEdges.forEach(function (edge) {
            return pairInfo.eles.push(edge);
          }); // for each pair id, the edges should be sorted by index
  
          pairInfo.eles.sort(function (edge1, edge2) {
            return edge1.poolIndex() - edge2.poolIndex();
          });
        }
  
        var firstEdge = pairInfo.eles[0];
        var src = firstEdge.source();
        var tgt = firstEdge.target(); // make sure src/tgt distinction is consistent w.r.t. pairId
  
        if (src.poolIndex() > tgt.poolIndex()) {
          var temp = src;
          src = tgt;
          tgt = temp;
        }
  
        var srcPos = pairInfo.srcPos = src.position();
        var tgtPos = pairInfo.tgtPos = tgt.position();
        var srcW = pairInfo.srcW = src.outerWidth();
        var srcH = pairInfo.srcH = src.outerHeight();
        var tgtW = pairInfo.tgtW = tgt.outerWidth();
        var tgtH = pairInfo.tgtH = tgt.outerHeight();
  
        var srcShape = pairInfo.srcShape = r.nodeShapes[_this.getNodeShape(src)];
  
        var tgtShape = pairInfo.tgtShape = r.nodeShapes[_this.getNodeShape(tgt)];
  
        pairInfo.dirCounts = {
          'north': 0,
          'west': 0,
          'south': 0,
          'east': 0,
          'northwest': 0,
          'southwest': 0,
          'northeast': 0,
          'southeast': 0
        };
  
        for (var _i2 = 0; _i2 < pairInfo.eles.length; _i2++) {
          var _edge = pairInfo.eles[_i2];
          var rs = _edge[0]._private.rscratch;
  
          var _curveStyle = _edge.pstyle('curve-style').value;
  
          var _edgeIsUnbundled = _curveStyle === 'unbundled-bezier' || _curveStyle === 'segments' || _curveStyle === 'taxi'; // whether the normalised pair order is the reverse of the edge's src-tgt order
  
  
          var edgeIsSwapped = !src.same(_edge.source());
  
          if (!pairInfo.calculatedIntersection && src !== tgt && (pairInfo.hasBezier || pairInfo.hasUnbundled)) {
            pairInfo.calculatedIntersection = true; // pt outside src shape to calc distance/displacement from src to tgt
  
            var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0);
            var srcIntn = pairInfo.srcIntn = srcOutside; // pt outside tgt shape to calc distance/displacement from src to tgt
  
            var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0);
            var tgtIntn = pairInfo.tgtIntn = tgtOutside;
            var intersectionPts = pairInfo.intersectionPts = {
              x1: srcOutside[0],
              x2: tgtOutside[0],
              y1: srcOutside[1],
              y2: tgtOutside[1]
            };
            var posPts = pairInfo.posPts = {
              x1: srcPos.x,
              x2: tgtPos.x,
              y1: srcPos.y,
              y2: tgtPos.y
            };
            var dy = tgtOutside[1] - srcOutside[1];
            var dx = tgtOutside[0] - srcOutside[0];
            var l = Math.sqrt(dx * dx + dy * dy);
            var vector = pairInfo.vector = {
              x: dx,
              y: dy
            };
            var vectorNorm = pairInfo.vectorNorm = {
              x: vector.x / l,
              y: vector.y / l
            };
            var vectorNormInverse = {
              x: -vectorNorm.y,
              y: vectorNorm.x
            }; // if node shapes overlap, then no ctrl pts to draw
  
            pairInfo.nodesOverlap = !number(l) || tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y) || srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y);
            pairInfo.vectorNormInverse = vectorNormInverse;
            swappedpairInfo = {
              nodesOverlap: pairInfo.nodesOverlap,
              dirCounts: pairInfo.dirCounts,
              calculatedIntersection: true,
              hasBezier: pairInfo.hasBezier,
              hasUnbundled: pairInfo.hasUnbundled,
              eles: pairInfo.eles,
              srcPos: tgtPos,
              tgtPos: srcPos,
              srcW: tgtW,
              srcH: tgtH,
              tgtW: srcW,
              tgtH: srcH,
              srcIntn: tgtIntn,
              tgtIntn: srcIntn,
              srcShape: tgtShape,
              tgtShape: srcShape,
              posPts: {
                x1: posPts.x2,
                y1: posPts.y2,
                x2: posPts.x1,
                y2: posPts.y1
              },
              intersectionPts: {
                x1: intersectionPts.x2,
                y1: intersectionPts.y2,
                x2: intersectionPts.x1,
                y2: intersectionPts.y1
              },
              vector: {
                x: -vector.x,
                y: -vector.y
              },
              vectorNorm: {
                x: -vectorNorm.x,
                y: -vectorNorm.y
              },
              vectorNormInverse: {
                x: -vectorNormInverse.x,
                y: -vectorNormInverse.y
              }
            };
          }
  
          var passedPairInfo = edgeIsSwapped ? swappedpairInfo : pairInfo;
          rs.nodesOverlap = passedPairInfo.nodesOverlap;
          rs.srcIntn = passedPairInfo.srcIntn;
          rs.tgtIntn = passedPairInfo.tgtIntn;
  
          if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src) || src.same(tgt) && src.isParent())) {
            _this.findCompoundLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);
          } else if (src === tgt) {
            _this.findLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);
          } else if (_curveStyle === 'segments') {
            _this.findSegmentsPoints(_edge, passedPairInfo);
          } else if (_curveStyle === 'taxi') {
            _this.findTaxiPoints(_edge, passedPairInfo);
          } else if (_curveStyle === 'straight' || !_edgeIsUnbundled && pairInfo.eles.length % 2 === 1 && _i2 === Math.floor(pairInfo.eles.length / 2)) {
            _this.findStraightEdgePoints(_edge);
          } else {
            _this.findBezierPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled, edgeIsSwapped);
          }
  
          _this.findEndpoints(_edge);
  
          _this.tryToCorrectInvalidPoints(_edge, passedPairInfo);
  
          _this.checkForInvalidEdgeWarning(_edge);
  
          _this.storeAllpts(_edge);
  
          _this.storeEdgeProjections(_edge);
  
          _this.calculateArrowAngles(_edge);
  
          _this.recalculateEdgeLabelProjections(_edge);
  
          _this.calculateLabelAngles(_edge);
        } // for pair edges
  
      };
  
      for (var p = 0; p < pairIds.length; p++) {
        _loop(p);
      } // for pair ids
      // haystacks avoid the expense of pairInfo stuff (intersections etc.)
  
  
      this.findHaystackPoints(haystackEdges);
    };
  
    function getPts(pts) {
      var retPts = [];
  
      if (pts == null) {
        return;
      }
  
      for (var i = 0; i < pts.length; i += 2) {
        var x = pts[i];
        var y = pts[i + 1];
        retPts.push({
          x: x,
          y: y
        });
      }
  
      return retPts;
    }
  
    BRp$3.getSegmentPoints = function (edge) {
      var rs = edge[0]._private.rscratch;
      var type = rs.edgeType;
  
      if (type === 'segments') {
        this.recalculateRenderedStyle(edge);
        return getPts(rs.segpts);
      }
    };
  
    BRp$3.getControlPoints = function (edge) {
      var rs = edge[0]._private.rscratch;
      var type = rs.edgeType;
  
      if (type === 'bezier' || type === 'multibezier' || type === 'self' || type === 'compound') {
        this.recalculateRenderedStyle(edge);
        return getPts(rs.ctrlpts);
      }
    };
  
    BRp$3.getEdgeMidpoint = function (edge) {
      var rs = edge[0]._private.rscratch;
      this.recalculateRenderedStyle(edge);
      return {
        x: rs.midX,
        y: rs.midY
      };
    };
  
    var BRp$4 = {};
  
    BRp$4.manualEndptToPx = function (node, prop) {
      var r = this;
      var npos = node.position();
      var w = node.outerWidth();
      var h = node.outerHeight();
  
      if (prop.value.length === 2) {
        var p = [prop.pfValue[0], prop.pfValue[1]];
  
        if (prop.units[0] === '%') {
          p[0] = p[0] * w;
        }
  
        if (prop.units[1] === '%') {
          p[1] = p[1] * h;
        }
  
        p[0] += npos.x;
        p[1] += npos.y;
        return p;
      } else {
        var angle = prop.pfValue[0];
        angle = -Math.PI / 2 + angle; // start at 12 o'clock
  
        var l = 2 * Math.max(w, h);
        var _p = [npos.x + Math.cos(angle) * l, npos.y + Math.sin(angle) * l];
        return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0);
      }
    };
  
    BRp$4.findEndpoints = function (edge) {
      var r = this;
      var intersect;
      var source = edge.source()[0];
      var target = edge.target()[0];
      var srcPos = source.position();
      var tgtPos = target.position();
      var tgtArShape = edge.pstyle('target-arrow-shape').value;
      var srcArShape = edge.pstyle('source-arrow-shape').value;
      var tgtDist = edge.pstyle('target-distance-from-node').pfValue;
      var srcDist = edge.pstyle('source-distance-from-node').pfValue;
      var curveStyle = edge.pstyle('curve-style').value;
      var rs = edge._private.rscratch;
      var et = rs.edgeType;
      var taxi = curveStyle === 'taxi';
      var self = et === 'self' || et === 'compound';
      var bezier = et === 'bezier' || et === 'multibezier' || self;
      var multi = et !== 'bezier';
      var lines = et === 'straight' || et === 'segments';
      var segments = et === 'segments';
      var hasEndpts = bezier || multi || lines;
      var overrideEndpts = self || taxi;
      var srcManEndpt = edge.pstyle('source-endpoint');
      var srcManEndptVal = overrideEndpts ? 'outside-to-node' : srcManEndpt.value;
      var tgtManEndpt = edge.pstyle('target-endpoint');
      var tgtManEndptVal = overrideEndpts ? 'outside-to-node' : tgtManEndpt.value;
      rs.srcManEndpt = srcManEndpt;
      rs.tgtManEndpt = tgtManEndpt;
      var p1; // last known point of edge on target side
  
      var p2; // last known point of edge on source side
  
      var p1_i; // point to intersect with target shape
  
      var p2_i; // point to intersect with source shape
  
      if (bezier) {
        var cpStart = [rs.ctrlpts[0], rs.ctrlpts[1]];
        var cpEnd = multi ? [rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1]] : cpStart;
        p1 = cpEnd;
        p2 = cpStart;
      } else if (lines) {
        var srcArrowFromPt = !segments ? [tgtPos.x, tgtPos.y] : rs.segpts.slice(0, 2);
        var tgtArrowFromPt = !segments ? [srcPos.x, srcPos.y] : rs.segpts.slice(rs.segpts.length - 2);
        p1 = tgtArrowFromPt;
        p2 = srcArrowFromPt;
      }
  
      if (tgtManEndptVal === 'inside-to-node') {
        intersect = [tgtPos.x, tgtPos.y];
      } else if (tgtManEndpt.units) {
        intersect = this.manualEndptToPx(target, tgtManEndpt);
      } else if (tgtManEndptVal === 'outside-to-line') {
        intersect = rs.tgtIntn; // use cached value from ctrlpt calc
      } else {
        if (tgtManEndptVal === 'outside-to-node' || tgtManEndptVal === 'outside-to-node-or-label') {
          p1_i = p1;
        } else if (tgtManEndptVal === 'outside-to-line' || tgtManEndptVal === 'outside-to-line-or-label') {
          p1_i = [srcPos.x, srcPos.y];
        }
  
        intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0);
  
        if (tgtManEndptVal === 'outside-to-node-or-label' || tgtManEndptVal === 'outside-to-line-or-label') {
          var trs = target._private.rscratch;
          var lw = trs.labelWidth;
          var lh = trs.labelHeight;
          var lx = trs.labelX;
          var ly = trs.labelY;
          var lw2 = lw / 2;
          var lh2 = lh / 2;
          var va = target.pstyle('text-valign').value;
  
          if (va === 'top') {
            ly -= lh2;
          } else if (va === 'bottom') {
            ly += lh2;
          }
  
          var ha = target.pstyle('text-halign').value;
  
          if (ha === 'left') {
            lx -= lw2;
          } else if (ha === 'right') {
            lx += lw2;
          }
  
          var labelIntersect = polygonIntersectLine(p1_i[0], p1_i[1], [lx - lw2, ly - lh2, lx + lw2, ly - lh2, lx + lw2, ly + lh2, lx - lw2, ly + lh2], tgtPos.x, tgtPos.y);
  
          if (labelIntersect.length > 0) {
            var refPt = srcPos;
            var intSqdist = sqdist(refPt, array2point(intersect));
            var labIntSqdist = sqdist(refPt, array2point(labelIntersect));
            var minSqDist = intSqdist;
  
            if (labIntSqdist < intSqdist) {
              intersect = labelIntersect;
              minSqDist = labIntSqdist;
            }
  
            if (labelIntersect.length > 2) {
              var labInt2SqDist = sqdist(refPt, {
                x: labelIntersect[2],
                y: labelIntersect[3]
              });
  
              if (labInt2SqDist < minSqDist) {
                intersect = [labelIntersect[2], labelIntersect[3]];
              }
            }
          }
        }
      }
  
      var arrowEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);
      var edgeEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);
      rs.endX = edgeEnd[0];
      rs.endY = edgeEnd[1];
      rs.arrowEndX = arrowEnd[0];
      rs.arrowEndY = arrowEnd[1];
  
      if (srcManEndptVal === 'inside-to-node') {
        intersect = [srcPos.x, srcPos.y];
      } else if (srcManEndpt.units) {
        intersect = this.manualEndptToPx(source, srcManEndpt);
      } else if (srcManEndptVal === 'outside-to-line') {
        intersect = rs.srcIntn; // use cached value from ctrlpt calc
      } else {
        if (srcManEndptVal === 'outside-to-node' || srcManEndptVal === 'outside-to-node-or-label') {
          p2_i = p2;
        } else if (srcManEndptVal === 'outside-to-line' || srcManEndptVal === 'outside-to-line-or-label') {
          p2_i = [tgtPos.x, tgtPos.y];
        }
  
        intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0);
  
        if (srcManEndptVal === 'outside-to-node-or-label' || srcManEndptVal === 'outside-to-line-or-label') {
          var srs = source._private.rscratch;
          var _lw = srs.labelWidth;
          var _lh = srs.labelHeight;
          var _lx = srs.labelX;
          var _ly = srs.labelY;
  
          var _lw2 = _lw / 2;
  
          var _lh2 = _lh / 2;
  
          var _va = source.pstyle('text-valign').value;
  
          if (_va === 'top') {
            _ly -= _lh2;
          } else if (_va === 'bottom') {
            _ly += _lh2;
          }
  
          var _ha = source.pstyle('text-halign').value;
  
          if (_ha === 'left') {
            _lx -= _lw2;
          } else if (_ha === 'right') {
            _lx += _lw2;
          }
  
          var _labelIntersect = polygonIntersectLine(p2_i[0], p2_i[1], [_lx - _lw2, _ly - _lh2, _lx + _lw2, _ly - _lh2, _lx + _lw2, _ly + _lh2, _lx - _lw2, _ly + _lh2], srcPos.x, srcPos.y);
  
          if (_labelIntersect.length > 0) {
            var _refPt = tgtPos;
  
            var _intSqdist = sqdist(_refPt, array2point(intersect));
  
            var _labIntSqdist = sqdist(_refPt, array2point(_labelIntersect));
  
            var _minSqDist = _intSqdist;
  
            if (_labIntSqdist < _intSqdist) {
              intersect = [_labelIntersect[0], _labelIntersect[1]];
              _minSqDist = _labIntSqdist;
            }
  
            if (_labelIntersect.length > 2) {
              var _labInt2SqDist = sqdist(_refPt, {
                x: _labelIntersect[2],
                y: _labelIntersect[3]
              });
  
              if (_labInt2SqDist < _minSqDist) {
                intersect = [_labelIntersect[2], _labelIntersect[3]];
              }
            }
          }
        }
      }
  
      var arrowStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);
      var edgeStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);
      rs.startX = edgeStart[0];
      rs.startY = edgeStart[1];
      rs.arrowStartX = arrowStart[0];
      rs.arrowStartY = arrowStart[1];
  
      if (hasEndpts) {
        if (!number(rs.startX) || !number(rs.startY) || !number(rs.endX) || !number(rs.endY)) {
          rs.badLine = true;
        } else {
          rs.badLine = false;
        }
      }
    };
  
    BRp$4.getSourceEndpoint = function (edge) {
      var rs = edge[0]._private.rscratch;
      this.recalculateRenderedStyle(edge);
  
      switch (rs.edgeType) {
        case 'haystack':
          return {
            x: rs.haystackPts[0],
            y: rs.haystackPts[1]
          };
  
        default:
          return {
            x: rs.arrowStartX,
            y: rs.arrowStartY
          };
      }
    };
  
    BRp$4.getTargetEndpoint = function (edge) {
      var rs = edge[0]._private.rscratch;
      this.recalculateRenderedStyle(edge);
  
      switch (rs.edgeType) {
        case 'haystack':
          return {
            x: rs.haystackPts[2],
            y: rs.haystackPts[3]
          };
  
        default:
          return {
            x: rs.arrowEndX,
            y: rs.arrowEndY
          };
      }
    };
  
    var BRp$5 = {};
  
    function pushBezierPts(r, edge, pts) {
      var qbezierAt$1 = function qbezierAt$1(p1, p2, p3, t) {
        return qbezierAt(p1, p2, p3, t);
      };
  
      var _p = edge._private;
      var bpts = _p.rstyle.bezierPts;
  
      for (var i = 0; i < r.bezierProjPcts.length; i++) {
        var p = r.bezierProjPcts[i];
        bpts.push({
          x: qbezierAt$1(pts[0], pts[2], pts[4], p),
          y: qbezierAt$1(pts[1], pts[3], pts[5], p)
        });
      }
    }
  
    BRp$5.storeEdgeProjections = function (edge) {
      var _p = edge._private;
      var rs = _p.rscratch;
      var et = rs.edgeType; // clear the cached points state
  
      _p.rstyle.bezierPts = null;
      _p.rstyle.linePts = null;
      _p.rstyle.haystackPts = null;
  
      if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {
        _p.rstyle.bezierPts = [];
  
        for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
          pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));
        }
      } else if (et === 'segments') {
        var lpts = _p.rstyle.linePts = [];
  
        for (var i = 0; i + 1 < rs.allpts.length; i += 2) {
          lpts.push({
            x: rs.allpts[i],
            y: rs.allpts[i + 1]
          });
        }
      } else if (et === 'haystack') {
        var hpts = rs.haystackPts;
        _p.rstyle.haystackPts = [{
          x: hpts[0],
          y: hpts[1]
        }, {
          x: hpts[2],
          y: hpts[3]
        }];
      }
  
      _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
    };
  
    BRp$5.recalculateEdgeProjections = function (edges) {
      this.findEdgeControlPoints(edges);
    };
  
    var BRp$6 = {};
  
    BRp$6.recalculateNodeLabelProjection = function (node) {
      var content = node.pstyle('label').strValue;
  
      if (emptyString(content)) {
        return;
      }
  
      var textX, textY;
      var _p = node._private;
      var nodeWidth = node.width();
      var nodeHeight = node.height();
      var padding = node.padding();
      var nodePos = node.position();
      var textHalign = node.pstyle('text-halign').strValue;
      var textValign = node.pstyle('text-valign').strValue;
      var rs = _p.rscratch;
      var rstyle = _p.rstyle;
  
      switch (textHalign) {
        case 'left':
          textX = nodePos.x - nodeWidth / 2 - padding;
          break;
  
        case 'right':
          textX = nodePos.x + nodeWidth / 2 + padding;
          break;
  
        default:
          // e.g. center
          textX = nodePos.x;
      }
  
      switch (textValign) {
        case 'top':
          textY = nodePos.y - nodeHeight / 2 - padding;
          break;
  
        case 'bottom':
          textY = nodePos.y + nodeHeight / 2 + padding;
          break;
  
        default:
          // e.g. middle
          textY = nodePos.y;
      }
  
      rs.labelX = textX;
      rs.labelY = textY;
      rstyle.labelX = textX;
      rstyle.labelY = textY;
      this.applyLabelDimensions(node);
    };
  
    var lineAngleFromDelta = function lineAngleFromDelta(dx, dy) {
      var angle = Math.atan(dy / dx);
  
      if (dx === 0 && angle < 0) {
        angle = angle * -1;
      }
  
      return angle;
    };
  
    var lineAngle = function lineAngle(p0, p1) {
      var dx = p1.x - p0.x;
      var dy = p1.y - p0.y;
      return lineAngleFromDelta(dx, dy);
    };
  
    var bezierAngle = function bezierAngle(p0, p1, p2, t) {
      var t0 = bound(0, t - 0.001, 1);
      var t1 = bound(0, t + 0.001, 1);
      var lp0 = qbezierPtAt(p0, p1, p2, t0);
      var lp1 = qbezierPtAt(p0, p1, p2, t1);
      return lineAngle(lp0, lp1);
    };
  
    BRp$6.recalculateEdgeLabelProjections = function (edge) {
      var p;
      var _p = edge._private;
      var rs = _p.rscratch;
      var r = this;
      var content = {
        mid: edge.pstyle('label').strValue,
        source: edge.pstyle('source-label').strValue,
        target: edge.pstyle('target-label').strValue
      };
  
      if (content.mid || content.source || content.target) ; else {
          return; // no labels => no calcs
        } // add center point to style so bounding box calculations can use it
      //
  
  
      p = {
        x: rs.midX,
        y: rs.midY
      };
  
      var setRs = function setRs(propName, prefix, value) {
        setPrefixedProperty(_p.rscratch, propName, prefix, value);
        setPrefixedProperty(_p.rstyle, propName, prefix, value);
      };
  
      setRs('labelX', null, p.x);
      setRs('labelY', null, p.y);
      var midAngle = lineAngleFromDelta(rs.midDispX, rs.midDispY);
      setRs('labelAutoAngle', null, midAngle);
  
      var createControlPointInfo = function createControlPointInfo() {
        if (createControlPointInfo.cache) {
          return createControlPointInfo.cache;
        } // use cache so only 1x per edge
  
  
        var ctrlpts = []; // store each ctrlpt info init
  
        for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
          var p0 = {
            x: rs.allpts[i],
            y: rs.allpts[i + 1]
          };
          var p1 = {
            x: rs.allpts[i + 2],
            y: rs.allpts[i + 3]
          }; // ctrlpt
  
          var p2 = {
            x: rs.allpts[i + 4],
            y: rs.allpts[i + 5]
          };
          ctrlpts.push({
            p0: p0,
            p1: p1,
            p2: p2,
            startDist: 0,
            length: 0,
            segments: []
          });
        }
  
        var bpts = _p.rstyle.bezierPts;
        var nProjs = r.bezierProjPcts.length;
  
        function addSegment(cp, p0, p1, t0, t1) {
          var length = dist(p0, p1);
          var prevSegment = cp.segments[cp.segments.length - 1];
          var segment = {
            p0: p0,
            p1: p1,
            t0: t0,
            t1: t1,
            startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,
            length: length
          };
          cp.segments.push(segment);
          cp.length += length;
        } // update each ctrlpt with segment info
  
  
        for (var _i = 0; _i < ctrlpts.length; _i++) {
          var cp = ctrlpts[_i];
          var prevCp = ctrlpts[_i - 1];
  
          if (prevCp) {
            cp.startDist = prevCp.startDist + prevCp.length;
          }
  
          addSegment(cp, cp.p0, bpts[_i * nProjs], 0, r.bezierProjPcts[0]); // first
  
          for (var j = 0; j < nProjs - 1; j++) {
            addSegment(cp, bpts[_i * nProjs + j], bpts[_i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);
          }
  
          addSegment(cp, bpts[_i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last
        }
  
        return createControlPointInfo.cache = ctrlpts;
      };
  
      var calculateEndProjection = function calculateEndProjection(prefix) {
        var angle;
        var isSrc = prefix === 'source';
  
        if (!content[prefix]) {
          return;
        }
  
        var offset = edge.pstyle(prefix + '-text-offset').pfValue;
  
        switch (rs.edgeType) {
          case 'self':
          case 'compound':
          case 'bezier':
          case 'multibezier':
            {
              var cps = createControlPointInfo();
              var selected;
              var startDist = 0;
              var totalDist = 0; // find the segment we're on
  
              for (var i = 0; i < cps.length; i++) {
                var _cp = cps[isSrc ? i : cps.length - 1 - i];
  
                for (var j = 0; j < _cp.segments.length; j++) {
                  var _seg = _cp.segments[isSrc ? j : _cp.segments.length - 1 - j];
                  var lastSeg = i === cps.length - 1 && j === _cp.segments.length - 1;
                  startDist = totalDist;
                  totalDist += _seg.length;
  
                  if (totalDist >= offset || lastSeg) {
                    selected = {
                      cp: _cp,
                      segment: _seg
                    };
                    break;
                  }
                }
  
                if (selected) {
                  break;
                }
              }
  
              var cp = selected.cp;
              var seg = selected.segment;
              var tSegment = (offset - startDist) / seg.length;
              var segDt = seg.t1 - seg.t0;
              var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;
              t = bound(0, t, 1);
              p = qbezierPtAt(cp.p0, cp.p1, cp.p2, t);
              angle = bezierAngle(cp.p0, cp.p1, cp.p2, t);
              break;
            }
  
          case 'straight':
          case 'segments':
          case 'haystack':
            {
              var d = 0,
                  di,
                  d0;
              var p0, p1;
              var l = rs.allpts.length;
  
              for (var _i2 = 0; _i2 + 3 < l; _i2 += 2) {
                if (isSrc) {
                  p0 = {
                    x: rs.allpts[_i2],
                    y: rs.allpts[_i2 + 1]
                  };
                  p1 = {
                    x: rs.allpts[_i2 + 2],
                    y: rs.allpts[_i2 + 3]
                  };
                } else {
                  p0 = {
                    x: rs.allpts[l - 2 - _i2],
                    y: rs.allpts[l - 1 - _i2]
                  };
                  p1 = {
                    x: rs.allpts[l - 4 - _i2],
                    y: rs.allpts[l - 3 - _i2]
                  };
                }
  
                di = dist(p0, p1);
                d0 = d;
                d += di;
  
                if (d >= offset) {
                  break;
                }
              }
  
              var pD = offset - d0;
  
              var _t = pD / di;
  
              _t = bound(0, _t, 1);
              p = lineAt(p0, p1, _t);
              angle = lineAngle(p0, p1);
              break;
            }
        }
  
        setRs('labelX', prefix, p.x);
        setRs('labelY', prefix, p.y);
        setRs('labelAutoAngle', prefix, angle);
      };
  
      calculateEndProjection('source');
      calculateEndProjection('target');
      this.applyLabelDimensions(edge);
    };
  
    BRp$6.applyLabelDimensions = function (ele) {
      this.applyPrefixedLabelDimensions(ele);
  
      if (ele.isEdge()) {
        this.applyPrefixedLabelDimensions(ele, 'source');
        this.applyPrefixedLabelDimensions(ele, 'target');
      }
    };
  
    BRp$6.applyPrefixedLabelDimensions = function (ele, prefix) {
      var _p = ele._private;
      var text = this.getLabelText(ele, prefix);
      var labelDims = this.calculateLabelDimensions(ele, text);
      var lineHeight = ele.pstyle('line-height').pfValue;
      var textWrap = ele.pstyle('text-wrap').strValue;
      var lines = getPrefixedProperty(_p.rscratch, 'labelWrapCachedLines', prefix) || [];
      var numLines = textWrap !== 'wrap' ? 1 : Math.max(lines.length, 1);
      var normPerLineHeight = labelDims.height / numLines;
      var labelLineHeight = normPerLineHeight * lineHeight;
      var width = labelDims.width;
      var height = labelDims.height + (numLines - 1) * (lineHeight - 1) * normPerLineHeight;
      setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, width);
      setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, width);
      setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, height);
      setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, height);
      setPrefixedProperty(_p.rscratch, 'labelLineHeight', prefix, labelLineHeight);
    };
  
    BRp$6.getLabelText = function (ele, prefix) {
      var _p = ele._private;
      var pfd = prefix ? prefix + '-' : '';
      var text = ele.pstyle(pfd + 'label').strValue;
      var textTransform = ele.pstyle('text-transform').value;
  
      var rscratch = function rscratch(propName, value) {
        if (value) {
          setPrefixedProperty(_p.rscratch, propName, prefix, value);
          return value;
        } else {
          return getPrefixedProperty(_p.rscratch, propName, prefix);
        }
      }; // for empty text, skip all processing
  
  
      if (!text) {
        return '';
      }
  
      if (textTransform == 'none') ; else if (textTransform == 'uppercase') {
        text = text.toUpperCase();
      } else if (textTransform == 'lowercase') {
        text = text.toLowerCase();
      }
  
      var wrapStyle = ele.pstyle('text-wrap').value;
  
      if (wrapStyle === 'wrap') {
        var labelKey = rscratch('labelKey'); // save recalc if the label is the same as before
  
        if (labelKey != null && rscratch('labelWrapKey') === labelKey) {
          return rscratch('labelWrapCachedText');
        }
  
        var zwsp = "\u200B";
        var lines = text.split('\n');
        var maxW = ele.pstyle('text-max-width').pfValue;
        var overflow = ele.pstyle('text-overflow-wrap').value;
        var overflowAny = overflow === 'anywhere';
        var wrappedLines = [];
        var wordsRegex = /[\s\u200b]+/;
        var wordSeparator = overflowAny ? '' : ' ';
  
        for (var l = 0; l < lines.length; l++) {
          var line = lines[l];
          var lineDims = this.calculateLabelDimensions(ele, line);
          var lineW = lineDims.width;
  
          if (overflowAny) {
            var processedLine = line.split('').join(zwsp);
            line = processedLine;
          }
  
          if (lineW > maxW) {
            // line is too long
            var words = line.split(wordsRegex);
            var subline = '';
  
            for (var w = 0; w < words.length; w++) {
              var word = words[w];
              var testLine = subline.length === 0 ? word : subline + wordSeparator + word;
              var testDims = this.calculateLabelDimensions(ele, testLine);
              var testW = testDims.width;
  
              if (testW <= maxW) {
                // word fits on current line
                subline += word + wordSeparator;
              } else {
                // word starts new line
                if (subline) {
                  wrappedLines.push(subline);
                }
  
                subline = word + wordSeparator;
              }
            } // if there's remaining text, put it in a wrapped line
  
  
            if (!subline.match(/^[\s\u200b]+$/)) {
              wrappedLines.push(subline);
            }
          } else {
            // line is already short enough
            wrappedLines.push(line);
          }
        } // for
  
  
        rscratch('labelWrapCachedLines', wrappedLines);
        text = rscratch('labelWrapCachedText', wrappedLines.join('\n'));
        rscratch('labelWrapKey', labelKey);
      } else if (wrapStyle === 'ellipsis') {
        var _maxW = ele.pstyle('text-max-width').pfValue;
        var ellipsized = '';
        var ellipsis = "\u2026";
        var incLastCh = false;
  
        for (var i = 0; i < text.length; i++) {
          var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;
  
          if (widthWithNextCh > _maxW) {
            break;
          }
  
          ellipsized += text[i];
  
          if (i === text.length - 1) {
            incLastCh = true;
          }
        }
  
        if (!incLastCh) {
          ellipsized += ellipsis;
        }
  
        return ellipsized;
      } // if ellipsize
  
  
      return text;
    };
  
    BRp$6.getLabelJustification = function (ele) {
      var justification = ele.pstyle('text-justification').strValue;
      var textHalign = ele.pstyle('text-halign').strValue;
  
      if (justification === 'auto') {
        if (ele.isNode()) {
          switch (textHalign) {
            case 'left':
              return 'right';
  
            case 'right':
              return 'left';
  
            default:
              return 'center';
          }
        } else {
          return 'center';
        }
      } else {
        return justification;
      }
    };
  
    BRp$6.calculateLabelDimensions = function (ele, text) {
      var r = this;
      var cacheKey = hashString(text, ele._private.labelDimsKey);
      var cache = r.labelDimCache || (r.labelDimCache = []);
      var existingVal = cache[cacheKey];
  
      if (existingVal != null) {
        return existingVal;
      }
  
      var sizeMult = 1; // increase the scale to increase accuracy w.r.t. zoomed text
  
      var fStyle = ele.pstyle('font-style').strValue;
      var size = sizeMult * ele.pstyle('font-size').pfValue + 'px';
      var family = ele.pstyle('font-family').strValue;
      var weight = ele.pstyle('font-weight').strValue;
      var div = this.labelCalcDiv;
  
      if (!div) {
        div = this.labelCalcDiv = document.createElement('div'); // eslint-disable-line no-undef
  
        document.body.appendChild(div); // eslint-disable-line no-undef
      }
  
      var ds = div.style; // from ele style
  
      ds.fontFamily = family;
      ds.fontStyle = fStyle;
      ds.fontSize = size;
      ds.fontWeight = weight; // forced style
  
      ds.position = 'absolute';
      ds.left = '-9999px';
      ds.top = '-9999px';
      ds.zIndex = '-1';
      ds.visibility = 'hidden';
      ds.pointerEvents = 'none';
      ds.padding = '0';
      ds.lineHeight = '1'; // - newlines must be taken into account for text-wrap:wrap
      // - since spaces are not collapsed, each space must be taken into account
  
      ds.whiteSpace = 'pre'; // put label content in div
  
      div.textContent = text;
      return cache[cacheKey] = {
        width: Math.ceil(div.clientWidth / sizeMult),
        height: Math.ceil(div.clientHeight / sizeMult)
      };
    };
  
    BRp$6.calculateLabelAngle = function (ele, prefix) {
      var _p = ele._private;
      var rs = _p.rscratch;
      var isEdge = ele.isEdge();
      var prefixDash = prefix ? prefix + '-' : '';
      var rot = ele.pstyle(prefixDash + 'text-rotation');
      var rotStr = rot.strValue;
  
      if (rotStr === 'none') {
        return 0;
      } else if (isEdge && rotStr === 'autorotate') {
        return rs.labelAutoAngle;
      } else if (rotStr === 'autorotate') {
        return 0;
      } else {
        return rot.pfValue;
      }
    };
  
    BRp$6.calculateLabelAngles = function (ele) {
      var r = this;
      var isEdge = ele.isEdge();
      var _p = ele._private;
      var rs = _p.rscratch;
      rs.labelAngle = r.calculateLabelAngle(ele);
  
      if (isEdge) {
        rs.sourceLabelAngle = r.calculateLabelAngle(ele, 'source');
        rs.targetLabelAngle = r.calculateLabelAngle(ele, 'target');
      }
    };
  
    var BRp$7 = {};
    var TOO_SMALL_CUT_RECT = 28;
    var warnedCutRect = false;
  
    BRp$7.getNodeShape = function (node) {
      var r = this;
      var shape = node.pstyle('shape').value;
  
      if (shape === 'cutrectangle' && (node.width() < TOO_SMALL_CUT_RECT || node.height() < TOO_SMALL_CUT_RECT)) {
        if (!warnedCutRect) {
          warn('The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead');
          warnedCutRect = true;
        }
  
        return 'rectangle';
      }
  
      if (node.isParent()) {
        if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'cutrectangle' || shape === 'barrel') {
          return shape;
        } else {
          return 'rectangle';
        }
      }
  
      if (shape === 'polygon') {
        var points = node.pstyle('shape-polygon-points').value;
        return r.nodeShapes.makePolygon(points).name;
      }
  
      return shape;
    };
  
    var BRp$8 = {};
  
    BRp$8.registerCalculationListeners = function () {
      var cy = this.cy;
      var elesToUpdate = cy.collection();
      var r = this;
  
      var enqueue = function enqueue(eles) {
        var dirtyStyleCaches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        elesToUpdate.merge(eles);
  
        if (dirtyStyleCaches) {
          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            var _p = ele._private;
            var rstyle = _p.rstyle;
            rstyle.clean = false;
            rstyle.cleanConnected = false;
          }
        }
      };
  
      r.binder(cy).on('bounds.* dirty.*', function onDirtyBounds(e) {
        var ele = e.target;
        enqueue(ele);
      }).on('style.* background.*', function onDirtyStyle(e) {
        var ele = e.target;
        enqueue(ele, false);
      });
  
      var updateEleCalcs = function updateEleCalcs(willDraw) {
        if (willDraw) {
          var fns = r.onUpdateEleCalcsFns;
  
          for (var i = 0; i < elesToUpdate.length; i++) {
            var ele = elesToUpdate[i];
            var rstyle = ele._private.rstyle;
  
            if (ele.isNode() && !rstyle.cleanConnected) {
              enqueue(ele.connectedEdges());
              rstyle.cleanConnected = true;
            }
          }
  
          if (fns) {
            for (var _i = 0; _i < fns.length; _i++) {
              var fn = fns[_i];
              fn(willDraw, elesToUpdate);
            }
          }
  
          r.recalculateRenderedStyle(elesToUpdate);
          elesToUpdate = cy.collection();
        }
      };
  
      r.flushRenderedStyleQueue = function () {
        updateEleCalcs(true);
      };
  
      r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);
    };
  
    BRp$8.onUpdateEleCalcs = function (fn) {
      var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];
      fns.push(fn);
    };
  
    BRp$8.recalculateRenderedStyle = function (eles, useCache) {
      var isCleanConnected = function isCleanConnected(ele) {
        return ele._private.rstyle.cleanConnected;
      };
  
      var edges = [];
      var nodes = []; // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()
  
      if (this.destroyed) {
        return;
      } // use cache by default for perf
  
  
      if (useCache === undefined) {
        useCache = true;
      }
  
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        var _p = ele._private;
        var rstyle = _p.rstyle; // an edge may be implicitly dirty b/c of one of its connected nodes
        // (and a request for recalc may come in between frames)
  
        if (ele.isEdge() && (!isCleanConnected(ele.source()) || !isCleanConnected(ele.target()))) {
          rstyle.clean = false;
        } // only update if dirty and in graph
  
  
        if (useCache && rstyle.clean || ele.removed()) {
          continue;
        } // only update if not display: none
  
  
        if (ele.pstyle('display').value === 'none') {
          continue;
        }
  
        if (_p.group === 'nodes') {
          nodes.push(ele);
        } else {
          // edges
          edges.push(ele);
        }
  
        rstyle.clean = true;
      } // update node data from projections
  
  
      for (var _i2 = 0; _i2 < nodes.length; _i2++) {
        var _ele = nodes[_i2];
        var _p2 = _ele._private;
        var _rstyle = _p2.rstyle;
  
        var pos = _ele.position();
  
        this.recalculateNodeLabelProjection(_ele);
        _rstyle.nodeX = pos.x;
        _rstyle.nodeY = pos.y;
        _rstyle.nodeW = _ele.pstyle('width').pfValue;
        _rstyle.nodeH = _ele.pstyle('height').pfValue;
      }
  
      this.recalculateEdgeProjections(edges); // update edge data from projections
  
      for (var _i3 = 0; _i3 < edges.length; _i3++) {
        var _ele2 = edges[_i3];
        var _p3 = _ele2._private;
        var _rstyle2 = _p3.rstyle;
        var rs = _p3.rscratch; // update rstyle positions
  
        _rstyle2.srcX = rs.arrowStartX;
        _rstyle2.srcY = rs.arrowStartY;
        _rstyle2.tgtX = rs.arrowEndX;
        _rstyle2.tgtY = rs.arrowEndY;
        _rstyle2.midX = rs.midX;
        _rstyle2.midY = rs.midY;
        _rstyle2.labelAngle = rs.labelAngle;
        _rstyle2.sourceLabelAngle = rs.sourceLabelAngle;
        _rstyle2.targetLabelAngle = rs.targetLabelAngle;
      }
    };
  
    var BRp$9 = {};
  
    BRp$9.updateCachedGrabbedEles = function () {
      var eles = this.cachedZSortedEles;
  
      if (!eles) {
        // just let this be recalculated on the next z sort tick
        return;
      }
  
      eles.drag = [];
      eles.nondrag = [];
      var grabTargets = [];
  
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        var rs = ele._private.rscratch;
  
        if (ele.grabbed() && !ele.isParent()) {
          grabTargets.push(ele);
        } else if (rs.inDragLayer) {
          eles.drag.push(ele);
        } else {
          eles.nondrag.push(ele);
        }
      } // put the grab target nodes last so it's on top of its neighbourhood
  
  
      for (var i = 0; i < grabTargets.length; i++) {
        var ele = grabTargets[i];
        eles.drag.push(ele);
      }
    };
  
    BRp$9.invalidateCachedZSortedEles = function () {
      this.cachedZSortedEles = null;
    };
  
    BRp$9.getCachedZSortedEles = function (forceRecalc) {
      if (forceRecalc || !this.cachedZSortedEles) {
        var eles = this.cy.mutableElements().toArray();
        eles.sort(zIndexSort);
        eles.interactive = eles.filter(function (ele) {
          return ele.interactive();
        });
        this.cachedZSortedEles = eles;
        this.updateCachedGrabbedEles();
      } else {
        eles = this.cachedZSortedEles;
      }
  
      return eles;
    };
  
    var BRp$a = {};
    [BRp$1, BRp$2, BRp$3, BRp$4, BRp$5, BRp$6, BRp$7, BRp$8, BRp$9].forEach(function (props) {
      extend(BRp$a, props);
    });
  
    var BRp$b = {};
  
    BRp$b.getCachedImage = function (url, crossOrigin, onLoad) {
      var r = this;
      var imageCache = r.imageCache = r.imageCache || {};
      var cache = imageCache[url];
  
      if (cache) {
        if (!cache.image.complete) {
          cache.image.addEventListener('load', onLoad);
        }
  
        return cache.image;
      } else {
        cache = imageCache[url] = imageCache[url] || {};
        var image = cache.image = new Image(); // eslint-disable-line no-undef
  
        image.addEventListener('load', onLoad);
        image.addEventListener('error', function () {
          image.error = true;
        }); // #1582 safari doesn't load data uris with crossOrigin properly
        // https://bugs.webkit.org/show_bug.cgi?id=123978
  
        var dataUriPrefix = 'data:';
        var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;
  
        if (!isDataUri) {
          image.crossOrigin = crossOrigin; // prevent tainted canvas
        }
  
        image.src = url;
        return image;
      }
    };
  
    var BRp$c = {};
    /* global document, window, ResizeObserver, MutationObserver */
  
    BRp$c.registerBinding = function (target, event, handler, useCapture) {
      // eslint-disable-line no-unused-vars
      var args = Array.prototype.slice.apply(arguments, [1]); // copy
  
      var b = this.binder(target);
      return b.on.apply(b, args);
    };
  
    BRp$c.binder = function (tgt) {
      var r = this;
      var tgtIsDom = tgt === window || tgt === document || tgt === document.body || domElement(tgt);
  
      if (r.supportsPassiveEvents == null) {
        // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
        var supportsPassive = false;
  
        try {
          var opts = Object.defineProperty({}, 'passive', {
            get: function get() {
              supportsPassive = true;
              return true;
            }
          });
          window.addEventListener('test', null, opts);
        } catch (err) {// not supported
        }
  
        r.supportsPassiveEvents = supportsPassive;
      }
  
      var on = function on(event, handler, useCapture) {
        var args = Array.prototype.slice.call(arguments);
  
        if (tgtIsDom && r.supportsPassiveEvents) {
          // replace useCapture w/ opts obj
          args[2] = {
            capture: useCapture != null ? useCapture : false,
            passive: false,
            once: false
          };
        }
  
        r.bindings.push({
          target: tgt,
          args: args
        });
        (tgt.addEventListener || tgt.on).apply(tgt, args);
        return this;
      };
  
      return {
        on: on,
        addEventListener: on,
        addListener: on,
        bind: on
      };
    };
  
    BRp$c.nodeIsDraggable = function (node) {
      return node && node.isNode() && !node.locked() && node.grabbable();
    };
  
    BRp$c.nodeIsGrabbable = function (node) {
      return this.nodeIsDraggable(node) && node.interactive();
    };
  
    BRp$c.load = function () {
      var r = this;
  
      var isSelected = function isSelected(ele) {
        return ele.selected();
      };
  
      var triggerEvents = function triggerEvents(target, names, e, position) {
        if (target == null) {
          target = r.cy;
        }
  
        for (var i = 0; i < names.length; i++) {
          var name = names[i];
          target.emit({
            originalEvent: e,
            type: name,
            position: position
          });
        }
      };
  
      var isMultSelKeyDown = function isMultSelKeyDown(e) {
        return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey
      };
  
      var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {
        var allowPassthrough = true;
  
        if (r.cy.hasCompoundNodes() && down && down.pannable()) {
          // a grabbable compound node below the ele => no passthrough panning
          for (var i = 0; downs && i < downs.length; i++) {
            var down = downs[i];
  
            if (down.isNode() && down.isParent()) {
              allowPassthrough = false;
              break;
            }
          }
        } else {
          allowPassthrough = true;
        }
  
        return allowPassthrough;
      };
  
      var setGrabbed = function setGrabbed(ele) {
        ele[0]._private.grabbed = true;
      };
  
      var setFreed = function setFreed(ele) {
        ele[0]._private.grabbed = false;
      };
  
      var setInDragLayer = function setInDragLayer(ele) {
        ele[0]._private.rscratch.inDragLayer = true;
      };
  
      var setOutDragLayer = function setOutDragLayer(ele) {
        ele[0]._private.rscratch.inDragLayer = false;
      };
  
      var setGrabTarget = function setGrabTarget(ele) {
        ele[0]._private.rscratch.isGrabTarget = true;
      };
  
      var removeGrabTarget = function removeGrabTarget(ele) {
        ele[0]._private.rscratch.isGrabTarget = false;
      };
  
      var addToDragList = function addToDragList(ele, opts) {
        var list = opts.addToList;
        var listHasEle = list.has(ele);
  
        if (!listHasEle) {
          list.merge(ele);
          setGrabbed(ele);
        }
      }; // helper function to determine which child nodes and inner edges
      // of a compound node to be dragged as well as the grabbed and selected nodes
  
  
      var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {
        if (!node.cy().hasCompoundNodes()) {
          return;
        }
  
        if (opts.inDragLayer == null && opts.addToList == null) {
          return;
        } // nothing to do
  
  
        var innerNodes = node.descendants();
  
        if (opts.inDragLayer) {
          innerNodes.forEach(setInDragLayer);
          innerNodes.connectedEdges().forEach(setInDragLayer);
        }
  
        if (opts.addToList) {
          opts.addToList.unmerge(innerNodes);
        }
      }; // adds the given nodes and its neighbourhood to the drag layer
  
  
      var addNodesToDrag = function addNodesToDrag(nodes, opts) {
        opts = opts || {};
        var hasCompoundNodes = nodes.cy().hasCompoundNodes();
  
        if (opts.inDragLayer) {
          nodes.forEach(setInDragLayer);
          nodes.neighborhood().stdFilter(function (ele) {
            return !hasCompoundNodes || ele.isEdge();
          }).forEach(setInDragLayer);
        }
  
        if (opts.addToList) {
          nodes.forEach(function (ele) {
            addToDragList(ele, opts);
          });
        }
  
        addDescendantsToDrag(nodes, opts); // always add to drag
        // also add nodes and edges related to the topmost ancestor
  
        updateAncestorsInDragLayer(nodes, {
          inDragLayer: opts.inDragLayer
        });
        r.updateCachedGrabbedEles();
      };
  
      var addNodeToDrag = addNodesToDrag;
  
      var freeDraggedElements = function freeDraggedElements(grabbedEles) {
        if (!grabbedEles) {
          return;
        } // just go over all elements rather than doing a bunch of (possibly expensive) traversals
  
  
        r.getCachedZSortedEles().forEach(function (ele) {
          setFreed(ele);
          setOutDragLayer(ele);
          removeGrabTarget(ele);
        });
        r.updateCachedGrabbedEles();
      }; // helper function to determine which ancestor nodes and edges should go
      // to the drag layer (or should be removed from drag layer).
  
  
      var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {
        if (opts.inDragLayer == null && opts.addToList == null) {
          return;
        } // nothing to do
  
  
        if (!node.cy().hasCompoundNodes()) {
          return;
        } // find top-level parent
  
  
        var parent = node.ancestors().orphans(); // no parent node: no nodes to add to the drag layer
  
        if (parent.same(node)) {
          return;
        }
  
        var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());
        var edges = nodes.connectedEdges();
  
        if (opts.inDragLayer) {
          edges.forEach(setInDragLayer);
          nodes.forEach(setInDragLayer);
        }
  
        if (opts.addToList) {
          nodes.forEach(function (ele) {
            addToDragList(ele, opts);
          });
        }
      };
  
      var blurActiveDomElement = function blurActiveDomElement() {
        if (document.activeElement != null && document.activeElement.blur != null) {
          document.activeElement.blur();
        }
      };
  
      var haveMutationsApi = typeof MutationObserver !== 'undefined';
      var haveResizeObserverApi = typeof ResizeObserver !== 'undefined'; // watch for when the cy container is removed from the dom
  
      if (haveMutationsApi) {
        r.removeObserver = new MutationObserver(function (mutns) {
          // eslint-disable-line no-undef
          for (var i = 0; i < mutns.length; i++) {
            var mutn = mutns[i];
            var rNodes = mutn.removedNodes;
  
            if (rNodes) {
              for (var j = 0; j < rNodes.length; j++) {
                var rNode = rNodes[j];
  
                if (rNode === r.container) {
                  r.destroy();
                  break;
                }
              }
            }
          }
        });
  
        if (r.container.parentNode) {
          r.removeObserver.observe(r.container.parentNode, {
            childList: true
          });
        }
      } else {
        r.registerBinding(r.container, 'DOMNodeRemoved', function (e) {
          // eslint-disable-line no-unused-vars
          r.destroy();
        });
      }
  
      var onResize = lodash_debounce(function () {
        r.cy.resize();
      }, 100);
  
      if (haveMutationsApi) {
        r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef
  
        r.styleObserver.observe(r.container, {
          attributes: true
        });
      } // auto resize
  
  
      r.registerBinding(window, 'resize', onResize); // eslint-disable-line no-undef
  
      if (haveResizeObserverApi) {
        r.resizeObserver = new ResizeObserver(onResize); // eslint-disable-line no-undef
  
        r.resizeObserver.observe(r.container);
      }
  
      var forEachUp = function forEachUp(domEle, fn) {
        while (domEle != null) {
          fn(domEle);
          domEle = domEle.parentNode;
        }
      };
  
      var invalidateCoords = function invalidateCoords() {
        r.invalidateContainerClientCoordsCache();
      };
  
      forEachUp(r.container, function (domEle) {
        r.registerBinding(domEle, 'transitionend', invalidateCoords);
        r.registerBinding(domEle, 'animationend', invalidateCoords);
        r.registerBinding(domEle, 'scroll', invalidateCoords);
      }); // stop right click menu from appearing on cy
  
      r.registerBinding(r.container, 'contextmenu', function (e) {
        e.preventDefault();
      });
  
      var inBoxSelection = function inBoxSelection() {
        return r.selection[4] !== 0;
      };
  
      var eventInContainer = function eventInContainer(e) {
        // save cycles if mouse events aren't to be captured
        var containerPageCoords = r.findContainerClientCoords();
        var x = containerPageCoords[0];
        var y = containerPageCoords[1];
        var width = containerPageCoords[2];
        var height = containerPageCoords[3];
        var positions = e.touches ? e.touches : [e];
        var atLeastOnePosInside = false;
  
        for (var i = 0; i < positions.length; i++) {
          var p = positions[i];
  
          if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {
            atLeastOnePosInside = true;
            break;
          }
        }
  
        if (!atLeastOnePosInside) {
          return false;
        }
  
        var container = r.container;
        var target = e.target;
        var tParent = target.parentNode;
        var containerIsTarget = false;
  
        while (tParent) {
          if (tParent === container) {
            containerIsTarget = true;
            break;
          }
  
          tParent = tParent.parentNode;
        }
  
        if (!containerIsTarget) {
          return false;
        } // if target is outisde cy container, then this event is not for us
  
  
        return true;
      }; // Primary key
  
  
      r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {
        if (!eventInContainer(e)) {
          return;
        }
  
        e.preventDefault();
        blurActiveDomElement();
        r.hoverData.capture = true;
        r.hoverData.which = e.which;
        var cy = r.cy;
        var gpos = [e.clientX, e.clientY];
        var pos = r.projectIntoViewport(gpos[0], gpos[1]);
        var select = r.selection;
        var nears = r.findNearestElements(pos[0], pos[1], true, false);
        var near = nears[0];
        var draggedElements = r.dragData.possibleDragElements;
        r.hoverData.mdownPos = pos;
        r.hoverData.mdownGPos = gpos;
  
        var checkForTaphold = function checkForTaphold() {
          r.hoverData.tapholdCancelled = false;
          clearTimeout(r.hoverData.tapholdTimeout);
          r.hoverData.tapholdTimeout = setTimeout(function () {
            if (r.hoverData.tapholdCancelled) {
              return;
            } else {
              var ele = r.hoverData.down;
  
              if (ele) {
                ele.emit({
                  originalEvent: e,
                  type: 'taphold',
                  position: {
                    x: pos[0],
                    y: pos[1]
                  }
                });
              } else {
                cy.emit({
                  originalEvent: e,
                  type: 'taphold',
                  position: {
                    x: pos[0],
                    y: pos[1]
                  }
                });
              }
            }
          }, r.tapholdDuration);
        }; // Right click button
  
  
        if (e.which == 3) {
          r.hoverData.cxtStarted = true;
          var cxtEvt = {
            originalEvent: e,
            type: 'cxttapstart',
            position: {
              x: pos[0],
              y: pos[1]
            }
          };
  
          if (near) {
            near.activate();
            near.emit(cxtEvt);
            r.hoverData.down = near;
          } else {
            cy.emit(cxtEvt);
          }
  
          r.hoverData.downTime = new Date().getTime();
          r.hoverData.cxtDragged = false; // Primary button
        } else if (e.which == 1) {
          if (near) {
            near.activate();
          } // Element dragging
  
  
          {
            // If something is under the cursor and it is draggable, prepare to grab it
            if (near != null) {
              if (r.nodeIsGrabbable(near)) {
                var makeEvent = function makeEvent(type) {
                  return {
                    originalEvent: e,
                    type: type,
                    position: {
                      x: pos[0],
                      y: pos[1]
                    }
                  };
                };
  
                var triggerGrab = function triggerGrab(ele) {
                  ele.emit(makeEvent('grab'));
                };
  
                setGrabTarget(near);
  
                if (!near.selected()) {
                  draggedElements = r.dragData.possibleDragElements = cy.collection();
                  addNodeToDrag(near, {
                    addToList: draggedElements
                  });
                  near.emit(makeEvent('grabon')).emit(makeEvent('grab'));
                } else {
                  draggedElements = r.dragData.possibleDragElements = cy.collection();
                  var selectedNodes = cy.$(function (ele) {
                    return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);
                  });
                  addNodesToDrag(selectedNodes, {
                    addToList: draggedElements
                  });
                  near.emit(makeEvent('grabon'));
                  selectedNodes.forEach(triggerGrab);
                }
  
                r.redrawHint('eles', true);
                r.redrawHint('drag', true);
              }
            }
  
            r.hoverData.down = near;
            r.hoverData.downs = nears;
            r.hoverData.downTime = new Date().getTime();
          }
          triggerEvents(near, ['mousedown', 'tapstart', 'vmousedown'], e, {
            x: pos[0],
            y: pos[1]
          });
  
          if (near == null) {
            select[4] = 1;
            r.data.bgActivePosistion = {
              x: pos[0],
              y: pos[1]
            };
            r.redrawHint('select', true);
            r.redraw();
          } else if (near.pannable()) {
            select[4] = 1; // for future pan
          }
  
          checkForTaphold();
        } // Initialize selection box coordinates
  
  
        select[0] = select[2] = pos[0];
        select[1] = select[3] = pos[1];
      }, false);
      r.registerBinding(window, 'mousemove', function mousemoveHandler(e) {
        // eslint-disable-line no-undef
        var capture = r.hoverData.capture;
  
        if (!capture && !eventInContainer(e)) {
          return;
        }
  
        var preventDefault = false;
        var cy = r.cy;
        var zoom = cy.zoom();
        var gpos = [e.clientX, e.clientY];
        var pos = r.projectIntoViewport(gpos[0], gpos[1]);
        var mdownPos = r.hoverData.mdownPos;
        var mdownGPos = r.hoverData.mdownGPos;
        var select = r.selection;
        var near = null;
  
        if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {
          near = r.findNearestElement(pos[0], pos[1], true, false);
        }
  
        var last = r.hoverData.last;
        var down = r.hoverData.down;
        var disp = [pos[0] - select[2], pos[1] - select[3]];
        var draggedElements = r.dragData.possibleDragElements;
        var isOverThresholdDrag;
  
        if (mdownGPos) {
          var dx = gpos[0] - mdownGPos[0];
          var dx2 = dx * dx;
          var dy = gpos[1] - mdownGPos[1];
          var dy2 = dy * dy;
          var dist2 = dx2 + dy2;
          r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;
        }
  
        var multSelKeyDown = isMultSelKeyDown(e);
  
        if (isOverThresholdDrag) {
          r.hoverData.tapholdCancelled = true;
        }
  
        var updateDragDelta = function updateDragDelta() {
          var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];
  
          if (dragDelta.length === 0) {
            dragDelta.push(disp[0]);
            dragDelta.push(disp[1]);
          } else {
            dragDelta[0] += disp[0];
            dragDelta[1] += disp[1];
          }
        };
  
        preventDefault = true;
        triggerEvents(near, ['mousemove', 'vmousemove', 'tapdrag'], e, {
          x: pos[0],
          y: pos[1]
        });
  
        var goIntoBoxMode = function goIntoBoxMode() {
          r.data.bgActivePosistion = undefined;
  
          if (!r.hoverData.selecting) {
            cy.emit({
              originalEvent: e,
              type: 'boxstart',
              position: {
                x: pos[0],
                y: pos[1]
              }
            });
          }
  
          select[4] = 1;
          r.hoverData.selecting = true;
          r.redrawHint('select', true);
          r.redraw();
        }; // trigger context drag if rmouse down
  
  
        if (r.hoverData.which === 3) {
          // but only if over threshold
          if (isOverThresholdDrag) {
            var cxtEvt = {
              originalEvent: e,
              type: 'cxtdrag',
              position: {
                x: pos[0],
                y: pos[1]
              }
            };
  
            if (down) {
              down.emit(cxtEvt);
            } else {
              cy.emit(cxtEvt);
            }
  
            r.hoverData.cxtDragged = true;
  
            if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {
              if (r.hoverData.cxtOver) {
                r.hoverData.cxtOver.emit({
                  originalEvent: e,
                  type: 'cxtdragout',
                  position: {
                    x: pos[0],
                    y: pos[1]
                  }
                });
              }
  
              r.hoverData.cxtOver = near;
  
              if (near) {
                near.emit({
                  originalEvent: e,
                  type: 'cxtdragover',
                  position: {
                    x: pos[0],
                    y: pos[1]
                  }
                });
              }
            }
          } // Check if we are drag panning the entire graph
  
        } else if (r.hoverData.dragging) {
          preventDefault = true;
  
          if (cy.panningEnabled() && cy.userPanningEnabled()) {
            var deltaP;
  
            if (r.hoverData.justStartedPan) {
              var mdPos = r.hoverData.mdownPos;
              deltaP = {
                x: (pos[0] - mdPos[0]) * zoom,
                y: (pos[1] - mdPos[1]) * zoom
              };
              r.hoverData.justStartedPan = false;
            } else {
              deltaP = {
                x: disp[0] * zoom,
                y: disp[1] * zoom
              };
            }
  
            cy.panBy(deltaP);
            r.hoverData.dragged = true;
          } // Needs reproject due to pan changing viewport
  
  
          pos = r.projectIntoViewport(e.clientX, e.clientY); // Checks primary button down & out of time & mouse not moved much
        } else if (select[4] == 1 && (down == null || down.pannable())) {
          if (isOverThresholdDrag) {
            if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {
              goIntoBoxMode();
            } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {
              var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);
  
              if (allowPassthrough) {
                r.hoverData.dragging = true;
                r.hoverData.justStartedPan = true;
                select[4] = 0;
                r.data.bgActivePosistion = array2point(mdownPos);
                r.redrawHint('select', true);
                r.redraw();
              }
            }
  
            if (down && down.pannable() && down.active()) {
              down.unactivate();
            }
          }
        } else {
          if (down && down.pannable() && down.active()) {
            down.unactivate();
          }
  
          if ((!down || !down.grabbed()) && near != last) {
            if (last) {
              triggerEvents(last, ['mouseout', 'tapdragout'], e, {
                x: pos[0],
                y: pos[1]
              });
            }
  
            if (near) {
              triggerEvents(near, ['mouseover', 'tapdragover'], e, {
                x: pos[0],
                y: pos[1]
              });
            }
  
            r.hoverData.last = near;
          }
  
          if (down) {
            if (isOverThresholdDrag) {
              // then we can take action
              if (cy.boxSelectionEnabled() && multSelKeyDown) {
                // then selection overrides
                if (down && down.grabbed()) {
                  freeDraggedElements(draggedElements);
                  down.emit('freeon');
                  draggedElements.emit('free');
  
                  if (r.dragData.didDrag) {
                    down.emit('dragfreeon');
                    draggedElements.emit('dragfree');
                  }
                }
  
                goIntoBoxMode();
              } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {
                // drag node
                var justStartedDrag = !r.dragData.didDrag;
  
                if (justStartedDrag) {
                  r.redrawHint('eles', true);
                }
  
                r.dragData.didDrag = true; // indicate that we actually did drag the node
  
                var toTrigger = cy.collection(); // now, add the elements to the drag layer if not done already
  
                if (!r.hoverData.draggingEles) {
                  addNodesToDrag(draggedElements, {
                    inDragLayer: true
                  });
                }
  
                var totalShift = {
                  x: 0,
                  y: 0
                };
  
                if (number(disp[0]) && number(disp[1])) {
                  totalShift.x += disp[0];
                  totalShift.y += disp[1];
  
                  if (justStartedDrag) {
                    var dragDelta = r.hoverData.dragDelta;
  
                    if (dragDelta && number(dragDelta[0]) && number(dragDelta[1])) {
                      totalShift.x += dragDelta[0];
                      totalShift.y += dragDelta[1];
                    }
                  }
                }
  
                for (var i = 0; i < draggedElements.length; i++) {
                  var dEle = draggedElements[i];
  
                  if (r.nodeIsDraggable(dEle) && dEle.grabbed()) {
                    toTrigger.merge(dEle);
                  }
                }
  
                r.hoverData.draggingEles = true;
                toTrigger.silentShift(totalShift).emit('position drag');
                r.redrawHint('drag', true);
                r.redraw();
              }
            } else {
              // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
              updateDragDelta();
            }
          } // prevent the dragging from triggering text selection on the page
  
  
          preventDefault = true;
        }
  
        select[2] = pos[0];
        select[3] = pos[1];
  
        if (preventDefault) {
          if (e.stopPropagation) e.stopPropagation();
          if (e.preventDefault) e.preventDefault();
          return false;
        }
      }, false);
      r.registerBinding(window, 'mouseup', function mouseupHandler(e) {
        // eslint-disable-line no-undef
        var capture = r.hoverData.capture;
  
        if (!capture) {
          return;
        }
  
        r.hoverData.capture = false;
        var cy = r.cy;
        var pos = r.projectIntoViewport(e.clientX, e.clientY);
        var select = r.selection;
        var near = r.findNearestElement(pos[0], pos[1], true, false);
        var draggedElements = r.dragData.possibleDragElements;
        var down = r.hoverData.down;
        var multSelKeyDown = isMultSelKeyDown(e);
  
        if (r.data.bgActivePosistion) {
          r.redrawHint('select', true);
          r.redraw();
        }
  
        r.hoverData.tapholdCancelled = true;
        r.data.bgActivePosistion = undefined; // not active bg now
  
        if (down) {
          down.unactivate();
        }
  
        if (r.hoverData.which === 3) {
          var cxtEvt = {
            originalEvent: e,
            type: 'cxttapend',
            position: {
              x: pos[0],
              y: pos[1]
            }
          };
  
          if (down) {
            down.emit(cxtEvt);
          } else {
            cy.emit(cxtEvt);
          }
  
          if (!r.hoverData.cxtDragged) {
            var cxtTap = {
              originalEvent: e,
              type: 'cxttap',
              position: {
                x: pos[0],
                y: pos[1]
              }
            };
  
            if (down) {
              down.emit(cxtTap);
            } else {
              cy.emit(cxtTap);
            }
          }
  
          r.hoverData.cxtDragged = false;
          r.hoverData.which = null;
        } else if (r.hoverData.which === 1) {
          triggerEvents(near, ['mouseup', 'tapend', 'vmouseup'], e, {
            x: pos[0],
            y: pos[1]
          });
  
          if (!r.dragData.didDrag // didn't move a node around
          && !r.hoverData.dragged // didn't pan
          && !r.hoverData.selecting // not box selection
          && !r.hoverData.isOverThresholdDrag // didn't move too much
          ) {
              triggerEvents(down, ['click', 'tap', 'vclick'], e, {
                x: pos[0],
                y: pos[1]
              });
            } // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something
  
  
          if (down == null && // not mousedown on node
          !r.dragData.didDrag // didn't move the node around
          && !r.hoverData.selecting // not box selection
          && !r.hoverData.dragged // didn't pan
          && !isMultSelKeyDown(e)) {
            cy.$(isSelected).unselect(['tapunselect']);
  
            if (draggedElements.length > 0) {
              r.redrawHint('eles', true);
            }
  
            r.dragData.possibleDragElements = draggedElements = cy.collection();
          } // Single selection
  
  
          if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {
            if (near != null && near._private.selectable) {
              if (r.hoverData.dragging) ; else if (cy.selectionType() === 'additive' || multSelKeyDown) {
                if (near.selected()) {
                  near.unselect(['tapunselect']);
                } else {
                  near.select(['tapselect']);
                }
              } else {
                if (!multSelKeyDown) {
                  cy.$(isSelected).unmerge(near).unselect(['tapunselect']);
                  near.select(['tapselect']);
                }
              }
  
              r.redrawHint('eles', true);
            }
          }
  
          if (r.hoverData.selecting) {
            var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));
            r.redrawHint('select', true);
  
            if (box.length > 0) {
              r.redrawHint('eles', true);
            }
  
            cy.emit({
              type: 'boxend',
              originalEvent: e,
              position: {
                x: pos[0],
                y: pos[1]
              }
            });
  
            var eleWouldBeSelected = function eleWouldBeSelected(ele) {
              return ele.selectable() && !ele.selected();
            };
  
            if (cy.selectionType() === 'additive') {
              box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
            } else {
              if (!multSelKeyDown) {
                cy.$(isSelected).unmerge(box).unselect();
              }
  
              box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
            } // always need redraw in case eles unselectable
  
  
            r.redraw();
          } // Cancel drag pan
  
  
          if (r.hoverData.dragging) {
            r.hoverData.dragging = false;
            r.redrawHint('select', true);
            r.redrawHint('eles', true);
            r.redraw();
          }
  
          if (!select[4]) {
            r.redrawHint('drag', true);
            r.redrawHint('eles', true);
            var downWasGrabbed = down && down.grabbed();
            freeDraggedElements(draggedElements);
  
            if (downWasGrabbed) {
              down.emit('freeon');
              draggedElements.emit('free');
  
              if (r.dragData.didDrag) {
                down.emit('dragfreeon');
                draggedElements.emit('dragfree');
              }
            }
          }
        } // else not right mouse
  
  
        select[4] = 0;
        r.hoverData.down = null;
        r.hoverData.cxtStarted = false;
        r.hoverData.draggingEles = false;
        r.hoverData.selecting = false;
        r.hoverData.isOverThresholdDrag = false;
        r.dragData.didDrag = false;
        r.hoverData.dragged = false;
        r.hoverData.dragDelta = [];
        r.hoverData.mdownPos = null;
        r.hoverData.mdownGPos = null;
      }, false);
  
      var wheelHandler = function wheelHandler(e) {
        if (r.scrollingPage) {
          return;
        } // while scrolling, ignore wheel-to-zoom
  
  
        var cy = r.cy;
        var zoom = cy.zoom();
        var pan = cy.pan();
        var pos = r.projectIntoViewport(e.clientX, e.clientY);
        var rpos = [pos[0] * zoom + pan.x, pos[1] * zoom + pan.y];
  
        if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {
          // if pan dragging or cxt dragging, wheel movements make no zoom
          e.preventDefault();
          return;
        }
  
        if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {
          e.preventDefault();
          r.data.wheelZooming = true;
          clearTimeout(r.data.wheelTimeout);
          r.data.wheelTimeout = setTimeout(function () {
            r.data.wheelZooming = false;
            r.redrawHint('eles', true);
            r.redraw();
          }, 150);
          var diff;
  
          if (e.deltaY != null) {
            diff = e.deltaY / -250;
          } else if (e.wheelDeltaY != null) {
            diff = e.wheelDeltaY / 1000;
          } else {
            diff = e.wheelDelta / 1000;
          }
  
          diff = diff * r.wheelSensitivity;
          var needsWheelFix = e.deltaMode === 1;
  
          if (needsWheelFix) {
            // fixes slow wheel events on ff/linux and ff/windows
            diff *= 33;
          }
  
          var newZoom = cy.zoom() * Math.pow(10, diff);
  
          if (e.type === 'gesturechange') {
            newZoom = r.gestureStartZoom * e.scale;
          }
  
          cy.zoom({
            level: newZoom,
            renderedPosition: {
              x: rpos[0],
              y: rpos[1]
            }
          });
        }
      }; // Functions to help with whether mouse wheel should trigger zooming
      // --
  
  
      r.registerBinding(r.container, 'wheel', wheelHandler, true); // disable nonstandard wheel events
      // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);
      // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);
      // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox
  
      r.registerBinding(window, 'scroll', function scrollHandler(e) {
        // eslint-disable-line no-unused-vars
        r.scrollingPage = true;
        clearTimeout(r.scrollingPageTimeout);
        r.scrollingPageTimeout = setTimeout(function () {
          r.scrollingPage = false;
        }, 250);
      }, true); // desktop safari pinch to zoom start
  
      r.registerBinding(r.container, 'gesturestart', function gestureStartHandler(e) {
        r.gestureStartZoom = r.cy.zoom();
  
        if (!r.hasTouchStarted) {
          // don't affect touch devices like iphone
          e.preventDefault();
        }
      }, true);
      r.registerBinding(r.container, 'gesturechange', function (e) {
        if (!r.hasTouchStarted) {
          // don't affect touch devices like iphone
          wheelHandler(e);
        }
      }, true); // Functions to help with handling mouseout/mouseover on the Cytoscape container
      // Handle mouseout on Cytoscape container
  
      r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {
        var pos = r.projectIntoViewport(e.clientX, e.clientY);
        r.cy.emit({
          originalEvent: e,
          type: 'mouseout',
          position: {
            x: pos[0],
            y: pos[1]
          }
        });
      }, false);
      r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {
        var pos = r.projectIntoViewport(e.clientX, e.clientY);
        r.cy.emit({
          originalEvent: e,
          type: 'mouseover',
          position: {
            x: pos[0],
            y: pos[1]
          }
        });
      }, false);
      var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom
  
      var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom
  
      var center1, modelCenter1; // center point on start pinch to zoom
  
      var offsetLeft, offsetTop;
      var containerWidth, containerHeight;
      var twoFingersStartInside;
  
      var distance = function distance(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      };
  
      var distanceSq = function distanceSq(x1, y1, x2, y2) {
        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
      };
  
      var touchstartHandler;
      r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {
        r.hasTouchStarted = true;
  
        if (!eventInContainer(e)) {
          return;
        }
  
        blurActiveDomElement();
        r.touchData.capture = true;
        r.data.bgActivePosistion = undefined;
        var cy = r.cy;
        var now = r.touchData.now;
        var earlier = r.touchData.earlier;
  
        if (e.touches[0]) {
          var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
          now[0] = pos[0];
          now[1] = pos[1];
        }
  
        if (e.touches[1]) {
          var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
          now[2] = pos[0];
          now[3] = pos[1];
        }
  
        if (e.touches[2]) {
          var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
          now[4] = pos[0];
          now[5] = pos[1];
        } // record starting points for pinch-to-zoom
  
  
        if (e.touches[1]) {
          r.touchData.singleTouchMoved = true;
          freeDraggedElements(r.dragData.touchDragEles);
          var offsets = r.findContainerClientCoords();
          offsetLeft = offsets[0];
          offsetTop = offsets[1];
          containerWidth = offsets[2];
          containerHeight = offsets[3];
          f1x1 = e.touches[0].clientX - offsetLeft;
          f1y1 = e.touches[0].clientY - offsetTop;
          f2x1 = e.touches[1].clientX - offsetLeft;
          f2y1 = e.touches[1].clientY - offsetTop;
          twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;
          var pan = cy.pan();
          var zoom = cy.zoom();
          distance1 = distance(f1x1, f1y1, f2x1, f2y1);
          distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);
          center1 = [(f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2];
          modelCenter1 = [(center1[0] - pan.x) / zoom, (center1[1] - pan.y) / zoom]; // consider context tap
  
          var cxtDistThreshold = 200;
          var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
  
          if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {
            var near1 = r.findNearestElement(now[0], now[1], true, true);
            var near2 = r.findNearestElement(now[2], now[3], true, true);
  
            if (near1 && near1.isNode()) {
              near1.activate().emit({
                originalEvent: e,
                type: 'cxttapstart',
                position: {
                  x: now[0],
                  y: now[1]
                }
              });
              r.touchData.start = near1;
            } else if (near2 && near2.isNode()) {
              near2.activate().emit({
                originalEvent: e,
                type: 'cxttapstart',
                position: {
                  x: now[0],
                  y: now[1]
                }
              });
              r.touchData.start = near2;
            } else {
              cy.emit({
                originalEvent: e,
                type: 'cxttapstart',
                position: {
                  x: now[0],
                  y: now[1]
                }
              });
            }
  
            if (r.touchData.start) {
              r.touchData.start._private.grabbed = false;
            }
  
            r.touchData.cxt = true;
            r.touchData.cxtDragged = false;
            r.data.bgActivePosistion = undefined;
            r.redraw();
            return;
          }
        }
  
        if (e.touches[2]) {
          // ignore
          // safari on ios pans the page otherwise (normally you should be able to preventdefault on touchmove...)
          if (cy.boxSelectionEnabled()) {
            e.preventDefault();
          }
        } else if (e.touches[1]) ; else if (e.touches[0]) {
          var nears = r.findNearestElements(now[0], now[1], true, true);
          var near = nears[0];
  
          if (near != null) {
            near.activate();
            r.touchData.start = near;
            r.touchData.starts = nears;
  
            if (r.nodeIsGrabbable(near)) {
              var draggedEles = r.dragData.touchDragEles = cy.collection();
              var selectedNodes = null;
              r.redrawHint('eles', true);
              r.redrawHint('drag', true);
  
              if (near.selected()) {
                // reset drag elements, since near will be added again
                selectedNodes = cy.$(function (ele) {
                  return ele.selected() && r.nodeIsGrabbable(ele);
                });
                addNodesToDrag(selectedNodes, {
                  addToList: draggedEles
                });
              } else {
                addNodeToDrag(near, {
                  addToList: draggedEles
                });
              }
  
              setGrabTarget(near);
  
              var makeEvent = function makeEvent(type) {
                return {
                  originalEvent: e,
                  type: type,
                  position: {
                    x: now[0],
                    y: now[1]
                  }
                };
              };
  
              near.emit(makeEvent('grabon'));
  
              if (selectedNodes) {
                selectedNodes.forEach(function (n) {
                  n.emit(makeEvent('grab'));
                });
              } else {
                near.emit(makeEvent('grab'));
              }
            }
          }
  
          triggerEvents(near, ['touchstart', 'tapstart', 'vmousedown'], e, {
            x: now[0],
            y: now[1]
          });
  
          if (near == null) {
            r.data.bgActivePosistion = {
              x: pos[0],
              y: pos[1]
            };
            r.redrawHint('select', true);
            r.redraw();
          } // Tap, taphold
          // -----
  
  
          r.touchData.singleTouchMoved = false;
          r.touchData.singleTouchStartTime = +new Date();
          clearTimeout(r.touchData.tapholdTimeout);
          r.touchData.tapholdTimeout = setTimeout(function () {
            if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect
            && !r.touchData.selecting // box selection shouldn't allow taphold through
            ) {
                triggerEvents(r.touchData.start, ['taphold'], e, {
                  x: now[0],
                  y: now[1]
                });
              }
          }, r.tapholdDuration);
        }
  
        if (e.touches.length >= 1) {
          var sPos = r.touchData.startPosition = [];
  
          for (var i = 0; i < now.length; i++) {
            sPos[i] = earlier[i] = now[i];
          }
  
          var touch0 = e.touches[0];
          r.touchData.startGPosition = [touch0.clientX, touch0.clientY];
        }
      }, false);
      var touchmoveHandler;
      r.registerBinding(window, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {
        // eslint-disable-line no-undef
        var capture = r.touchData.capture;
  
        if (!capture && !eventInContainer(e)) {
          return;
        }
  
        var select = r.selection;
        var cy = r.cy;
        var now = r.touchData.now;
        var earlier = r.touchData.earlier;
        var zoom = cy.zoom();
  
        if (e.touches[0]) {
          var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
          now[0] = pos[0];
          now[1] = pos[1];
        }
  
        if (e.touches[1]) {
          var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
          now[2] = pos[0];
          now[3] = pos[1];
        }
  
        if (e.touches[2]) {
          var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
          now[4] = pos[0];
          now[5] = pos[1];
        }
  
        var startGPos = r.touchData.startGPosition;
        var isOverThresholdDrag;
  
        if (capture && e.touches[0] && startGPos) {
          var disp = [];
  
          for (var j = 0; j < now.length; j++) {
            disp[j] = now[j] - earlier[j];
          }
  
          var dx = e.touches[0].clientX - startGPos[0];
          var dx2 = dx * dx;
          var dy = e.touches[0].clientY - startGPos[1];
          var dy2 = dy * dy;
          var dist2 = dx2 + dy2;
          isOverThresholdDrag = dist2 >= r.touchTapThreshold2;
        } // context swipe cancelling
  
  
        if (capture && r.touchData.cxt) {
          e.preventDefault();
          var f1x2 = e.touches[0].clientX - offsetLeft,
              f1y2 = e.touches[0].clientY - offsetTop;
          var f2x2 = e.touches[1].clientX - offsetLeft,
              f2y2 = e.touches[1].clientY - offsetTop; // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
  
          var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);
          var factorSq = distance2Sq / distance1Sq;
          var distThreshold = 150;
          var distThresholdSq = distThreshold * distThreshold;
          var factorThreshold = 1.5;
          var factorThresholdSq = factorThreshold * factorThreshold; // cancel ctx gestures if the distance b/t the fingers increases
  
          if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {
            r.touchData.cxt = false;
            r.data.bgActivePosistion = undefined;
            r.redrawHint('select', true);
            var cxtEvt = {
              originalEvent: e,
              type: 'cxttapend',
              position: {
                x: now[0],
                y: now[1]
              }
            };
  
            if (r.touchData.start) {
              r.touchData.start.unactivate().emit(cxtEvt);
              r.touchData.start = null;
            } else {
              cy.emit(cxtEvt);
            }
          }
        } // context swipe
  
  
        if (capture && r.touchData.cxt) {
          var cxtEvt = {
            originalEvent: e,
            type: 'cxtdrag',
            position: {
              x: now[0],
              y: now[1]
            }
          };
          r.data.bgActivePosistion = undefined;
          r.redrawHint('select', true);
  
          if (r.touchData.start) {
            r.touchData.start.emit(cxtEvt);
          } else {
            cy.emit(cxtEvt);
          }
  
          if (r.touchData.start) {
            r.touchData.start._private.grabbed = false;
          }
  
          r.touchData.cxtDragged = true;
          var near = r.findNearestElement(now[0], now[1], true, true);
  
          if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {
            if (r.touchData.cxtOver) {
              r.touchData.cxtOver.emit({
                originalEvent: e,
                type: 'cxtdragout',
                position: {
                  x: now[0],
                  y: now[1]
                }
              });
            }
  
            r.touchData.cxtOver = near;
  
            if (near) {
              near.emit({
                originalEvent: e,
                type: 'cxtdragover',
                position: {
                  x: now[0],
                  y: now[1]
                }
              });
            }
          } // box selection
  
        } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {
          e.preventDefault();
          r.data.bgActivePosistion = undefined;
          this.lastThreeTouch = +new Date();
  
          if (!r.touchData.selecting) {
            cy.emit({
              originalEvent: e,
              type: 'boxstart',
              position: {
                x: now[0],
                y: now[1]
              }
            });
          }
  
          r.touchData.selecting = true;
          r.touchData.didSelect = true;
          select[4] = 1;
  
          if (!select || select.length === 0 || select[0] === undefined) {
            select[0] = (now[0] + now[2] + now[4]) / 3;
            select[1] = (now[1] + now[3] + now[5]) / 3;
            select[2] = (now[0] + now[2] + now[4]) / 3 + 1;
            select[3] = (now[1] + now[3] + now[5]) / 3 + 1;
          } else {
            select[2] = (now[0] + now[2] + now[4]) / 3;
            select[3] = (now[1] + now[3] + now[5]) / 3;
          }
  
          r.redrawHint('select', true);
          r.redraw(); // pinch to zoom
        } else if (capture && e.touches[1] && !r.touchData.didSelect // don't allow box selection to degrade to pinch-to-zoom
        && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {
          // two fingers => pinch to zoom
          e.preventDefault();
          r.data.bgActivePosistion = undefined;
          r.redrawHint('select', true);
          var draggedEles = r.dragData.touchDragEles;
  
          if (draggedEles) {
            r.redrawHint('drag', true);
  
            for (var i = 0; i < draggedEles.length; i++) {
              var de_p = draggedEles[i]._private;
              de_p.grabbed = false;
              de_p.rscratch.inDragLayer = false;
            }
          }
  
          var _start = r.touchData.start; // (x2, y2) for fingers 1 and 2
  
          var f1x2 = e.touches[0].clientX - offsetLeft,
              f1y2 = e.touches[0].clientY - offsetTop;
          var f2x2 = e.touches[1].clientX - offsetLeft,
              f2y2 = e.touches[1].clientY - offsetTop;
          var distance2 = distance(f1x2, f1y2, f2x2, f2y2); // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
          // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
  
          var factor = distance2 / distance1;
  
          if (twoFingersStartInside) {
            // delta finger1
            var df1x = f1x2 - f1x1;
            var df1y = f1y2 - f1y1; // delta finger 2
  
            var df2x = f2x2 - f2x1;
            var df2y = f2y2 - f2y1; // translation is the normalised vector of the two fingers movement
            // i.e. so pinching cancels out and moving together pans
  
            var tx = (df1x + df2x) / 2;
            var ty = (df1y + df2y) / 2; // now calculate the zoom
  
            var zoom1 = cy.zoom();
            var zoom2 = zoom1 * factor;
            var pan1 = cy.pan(); // the model center point converted to the current rendered pos
  
            var ctrx = modelCenter1[0] * zoom1 + pan1.x;
            var ctry = modelCenter1[1] * zoom1 + pan1.y;
            var pan2 = {
              x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,
              y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry
            }; // remove dragged eles
  
            if (_start && _start.active()) {
              var draggedEles = r.dragData.touchDragEles;
              freeDraggedElements(draggedEles);
              r.redrawHint('drag', true);
              r.redrawHint('eles', true);
  
              _start.unactivate().emit('freeon');
  
              draggedEles.emit('free');
  
              if (r.dragData.didDrag) {
                _start.emit('dragfreeon');
  
                draggedEles.emit('dragfree');
              }
            }
  
            cy.viewport({
              zoom: zoom2,
              pan: pan2,
              cancelOnFailedZoom: true
            });
            distance1 = distance2;
            f1x1 = f1x2;
            f1y1 = f1y2;
            f2x1 = f2x2;
            f2y1 = f2y2;
            r.pinching = true;
          } // Re-project
  
  
          if (e.touches[0]) {
            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
            now[0] = pos[0];
            now[1] = pos[1];
          }
  
          if (e.touches[1]) {
            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
            now[2] = pos[0];
            now[3] = pos[1];
          }
  
          if (e.touches[2]) {
            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
            now[4] = pos[0];
            now[5] = pos[1];
          }
        } else if (e.touches[0] && !r.touchData.didSelect // don't allow box selection to degrade to single finger events like panning
        ) {
            var start = r.touchData.start;
            var last = r.touchData.last;
            var near;
  
            if (!r.hoverData.draggingEles && !r.swipePanning) {
              near = r.findNearestElement(now[0], now[1], true, true);
            }
  
            if (capture && start != null) {
              e.preventDefault();
            } // dragging nodes
  
  
            if (capture && start != null && r.nodeIsDraggable(start)) {
              if (isOverThresholdDrag) {
                // then dragging can happen
                var draggedEles = r.dragData.touchDragEles;
                var justStartedDrag = !r.dragData.didDrag;
  
                if (justStartedDrag) {
                  addNodesToDrag(draggedEles, {
                    inDragLayer: true
                  });
                }
  
                r.dragData.didDrag = true;
                var totalShift = {
                  x: 0,
                  y: 0
                };
  
                if (number(disp[0]) && number(disp[1])) {
                  totalShift.x += disp[0];
                  totalShift.y += disp[1];
  
                  if (justStartedDrag) {
                    r.redrawHint('eles', true);
                    var dragDelta = r.touchData.dragDelta;
  
                    if (dragDelta && number(dragDelta[0]) && number(dragDelta[1])) {
                      totalShift.x += dragDelta[0];
                      totalShift.y += dragDelta[1];
                    }
                  }
                }
  
                r.hoverData.draggingEles = true;
                draggedEles.silentShift(totalShift).emit('position drag');
                r.redrawHint('drag', true);
  
                if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {
                  r.redrawHint('eles', true);
                }
  
                r.redraw();
              } else {
                // otherise keep track of drag delta for later
                var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];
  
                if (dragDelta.length === 0) {
                  dragDelta.push(disp[0]);
                  dragDelta.push(disp[1]);
                } else {
                  dragDelta[0] += disp[0];
                  dragDelta[1] += disp[1];
                }
              }
            } // touchmove
  
  
            {
              triggerEvents(start || near, ['touchmove', 'tapdrag', 'vmousemove'], e, {
                x: now[0],
                y: now[1]
              });
  
              if ((!start || !start.grabbed()) && near != last) {
                if (last) {
                  last.emit({
                    originalEvent: e,
                    type: 'tapdragout',
                    position: {
                      x: now[0],
                      y: now[1]
                    }
                  });
                }
  
                if (near) {
                  near.emit({
                    originalEvent: e,
                    type: 'tapdragover',
                    position: {
                      x: now[0],
                      y: now[1]
                    }
                  });
                }
              }
  
              r.touchData.last = near;
            } // check to cancel taphold
  
            if (capture) {
              for (var i = 0; i < now.length; i++) {
                if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {
                  r.touchData.singleTouchMoved = true;
                }
              }
            } // panning
  
  
            if (capture && (start == null || start.pannable()) && cy.panningEnabled() && cy.userPanningEnabled()) {
              var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);
  
              if (allowPassthrough) {
                e.preventDefault();
  
                if (!r.data.bgActivePosistion) {
                  r.data.bgActivePosistion = array2point(r.touchData.startPosition);
                }
  
                if (r.swipePanning) {
                  cy.panBy({
                    x: disp[0] * zoom,
                    y: disp[1] * zoom
                  });
                } else if (isOverThresholdDrag) {
                  r.swipePanning = true;
                  cy.panBy({
                    x: dx * zoom,
                    y: dy * zoom
                  });
  
                  if (start) {
                    start.unactivate();
                    r.redrawHint('select', true);
                    r.touchData.start = null;
                  }
                }
              } // Re-project
  
  
              var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
              now[0] = pos[0];
              now[1] = pos[1];
            }
          }
  
        for (var j = 0; j < now.length; j++) {
          earlier[j] = now[j];
        } // the active bg indicator should be removed when making a swipe that is neither for dragging nodes or panning
  
  
        if (capture && e.touches.length > 0 && !r.hoverData.draggingEles && !r.swipePanning && r.data.bgActivePosistion != null) {
          r.data.bgActivePosistion = undefined;
          r.redrawHint('select', true);
          r.redraw();
        }
      }, false);
      var touchcancelHandler;
      r.registerBinding(window, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {
        // eslint-disable-line no-unused-vars
        var start = r.touchData.start;
        r.touchData.capture = false;
  
        if (start) {
          start.unactivate();
        }
      });
      var touchendHandler;
      r.registerBinding(window, 'touchend', touchendHandler = function touchendHandler(e) {
        // eslint-disable-line no-unused-vars
        var start = r.touchData.start;
        var capture = r.touchData.capture;
  
        if (capture) {
          if (e.touches.length === 0) {
            r.touchData.capture = false;
          }
  
          e.preventDefault();
        } else {
          return;
        }
  
        var select = r.selection;
        r.swipePanning = false;
        r.hoverData.draggingEles = false;
        var cy = r.cy;
        var zoom = cy.zoom();
        var now = r.touchData.now;
        var earlier = r.touchData.earlier;
  
        if (e.touches[0]) {
          var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
          now[0] = pos[0];
          now[1] = pos[1];
        }
  
        if (e.touches[1]) {
          var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
          now[2] = pos[0];
          now[3] = pos[1];
        }
  
        if (e.touches[2]) {
          var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
          now[4] = pos[0];
          now[5] = pos[1];
        }
  
        if (start) {
          start.unactivate();
        }
  
        var ctxTapend;
  
        if (r.touchData.cxt) {
          ctxTapend = {
            originalEvent: e,
            type: 'cxttapend',
            position: {
              x: now[0],
              y: now[1]
            }
          };
  
          if (start) {
            start.emit(ctxTapend);
          } else {
            cy.emit(ctxTapend);
          }
  
          if (!r.touchData.cxtDragged) {
            var ctxTap = {
              originalEvent: e,
              type: 'cxttap',
              position: {
                x: now[0],
                y: now[1]
              }
            };
  
            if (start) {
              start.emit(ctxTap);
            } else {
              cy.emit(ctxTap);
            }
          }
  
          if (r.touchData.start) {
            r.touchData.start._private.grabbed = false;
          }
  
          r.touchData.cxt = false;
          r.touchData.start = null;
          r.redraw();
          return;
        } // no more box selection if we don't have three fingers
  
  
        if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {
          r.touchData.selecting = false;
          var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));
          select[0] = undefined;
          select[1] = undefined;
          select[2] = undefined;
          select[3] = undefined;
          select[4] = 0;
          r.redrawHint('select', true);
          cy.emit({
            type: 'boxend',
            originalEvent: e,
            position: {
              x: now[0],
              y: now[1]
            }
          });
  
          var eleWouldBeSelected = function eleWouldBeSelected(ele) {
            return ele.selectable() && !ele.selected();
          };
  
          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
  
          if (box.nonempty()) {
            r.redrawHint('eles', true);
          }
  
          r.redraw();
        }
  
        if (start != null) {
          start.unactivate();
        }
  
        if (e.touches[2]) {
          r.data.bgActivePosistion = undefined;
          r.redrawHint('select', true);
        } else if (e.touches[1]) ; else if (e.touches[0]) ; else if (!e.touches[0]) {
          r.data.bgActivePosistion = undefined;
          r.redrawHint('select', true);
          var draggedEles = r.dragData.touchDragEles;
  
          if (start != null) {
            var startWasGrabbed = start._private.grabbed;
            freeDraggedElements(draggedEles);
            r.redrawHint('drag', true);
            r.redrawHint('eles', true);
  
            if (startWasGrabbed) {
              start.emit('freeon');
              draggedEles.emit('free');
  
              if (r.dragData.didDrag) {
                start.emit('dragfreeon');
                draggedEles.emit('dragfree');
              }
            }
  
            triggerEvents(start, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
              x: now[0],
              y: now[1]
            });
            start.unactivate();
            r.touchData.start = null;
          } else {
            var near = r.findNearestElement(now[0], now[1], true, true);
            triggerEvents(near, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
              x: now[0],
              y: now[1]
            });
          }
  
          var dx = r.touchData.startPosition[0] - now[0];
          var dx2 = dx * dx;
          var dy = r.touchData.startPosition[1] - now[1];
          var dy2 = dy * dy;
          var dist2 = dx2 + dy2;
          var rdist2 = dist2 * zoom * zoom; // Tap event, roughly same as mouse click event for touch
  
          if (!r.touchData.singleTouchMoved) {
            if (!start) {
              cy.$(':selected').unselect(['tapunselect']);
            }
  
            triggerEvents(start, ['tap', 'vclick'], e, {
              x: now[0],
              y: now[1]
            });
          } // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance
  
  
          if (start != null && !r.dragData.didDrag // didn't drag nodes around
          && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection
          ) {
              if (cy.selectionType() === 'single') {
                cy.$(isSelected).unmerge(start).unselect(['tapunselect']);
                start.select(['tapselect']);
              } else {
                if (start.selected()) {
                  start.unselect(['tapunselect']);
                } else {
                  start.select(['tapselect']);
                }
              }
  
              r.redrawHint('eles', true);
            }
  
          r.touchData.singleTouchMoved = true;
        }
  
        for (var j = 0; j < now.length; j++) {
          earlier[j] = now[j];
        }
  
        r.dragData.didDrag = false; // reset for next touchstart
  
        if (e.touches.length === 0) {
          r.touchData.dragDelta = [];
          r.touchData.startPosition = null;
          r.touchData.startGPosition = null;
          r.touchData.didSelect = false;
        }
  
        if (e.touches.length < 2) {
          if (e.touches.length === 1) {
            // the old start global pos'n may not be the same finger that remains
            r.touchData.startGPosition = [e.touches[0].clientX, e.touches[0].clientY];
          }
  
          r.pinching = false;
          r.redrawHint('eles', true);
          r.redraw();
        } //r.redraw();
  
      }, false); // fallback compatibility layer for ms pointer events
  
      if (typeof TouchEvent === 'undefined') {
        var pointers = [];
  
        var makeTouch = function makeTouch(e) {
          return {
            clientX: e.clientX,
            clientY: e.clientY,
            force: 1,
            identifier: e.pointerId,
            pageX: e.pageX,
            pageY: e.pageY,
            radiusX: e.width / 2,
            radiusY: e.height / 2,
            screenX: e.screenX,
            screenY: e.screenY,
            target: e.target
          };
        };
  
        var makePointer = function makePointer(e) {
          return {
            event: e,
            touch: makeTouch(e)
          };
        };
  
        var addPointer = function addPointer(e) {
          pointers.push(makePointer(e));
        };
  
        var removePointer = function removePointer(e) {
          for (var i = 0; i < pointers.length; i++) {
            var p = pointers[i];
  
            if (p.event.pointerId === e.pointerId) {
              pointers.splice(i, 1);
              return;
            }
          }
        };
  
        var updatePointer = function updatePointer(e) {
          var p = pointers.filter(function (p) {
            return p.event.pointerId === e.pointerId;
          })[0];
          p.event = e;
          p.touch = makeTouch(e);
        };
  
        var addTouchesToEvent = function addTouchesToEvent(e) {
          e.touches = pointers.map(function (p) {
            return p.touch;
          });
        };
  
        var pointerIsMouse = function pointerIsMouse(e) {
          return e.pointerType === 'mouse' || e.pointerType === 4;
        };
  
        r.registerBinding(r.container, 'pointerdown', function (e) {
          if (pointerIsMouse(e)) {
            return;
          } // mouse already handled
  
  
          e.preventDefault();
          addPointer(e);
          addTouchesToEvent(e);
          touchstartHandler(e);
        });
        r.registerBinding(r.container, 'pointerup', function (e) {
          if (pointerIsMouse(e)) {
            return;
          } // mouse already handled
  
  
          removePointer(e);
          addTouchesToEvent(e);
          touchendHandler(e);
        });
        r.registerBinding(r.container, 'pointercancel', function (e) {
          if (pointerIsMouse(e)) {
            return;
          } // mouse already handled
  
  
          removePointer(e);
          addTouchesToEvent(e);
          touchcancelHandler(e);
        });
        r.registerBinding(r.container, 'pointermove', function (e) {
          if (pointerIsMouse(e)) {
            return;
          } // mouse already handled
  
  
          e.preventDefault();
          updatePointer(e);
          addTouchesToEvent(e);
          touchmoveHandler(e);
        });
      }
    };
  
    var BRp$d = {};
  
    BRp$d.generatePolygon = function (name, points) {
      return this.nodeShapes[name] = {
        renderer: this,
        name: name,
        points: points,
        draw: function draw(context, centerX, centerY, width, height) {
          this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);
        },
        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
          return polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);
        },
        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
          return pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [0, -1], padding);
        }
      };
    };
  
    BRp$d.generateEllipse = function () {
      return this.nodeShapes['ellipse'] = {
        renderer: this,
        name: 'ellipse',
        draw: function draw(context, centerX, centerY, width, height) {
          this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
        },
        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
          return intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);
        },
        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
          return checkInEllipse(x, y, width, height, centerX, centerY, padding);
        }
      };
    };
  
    BRp$d.generateRoundPolygon = function (name, points) {
      // Pre-compute control points
      // Since these points depend on the radius length (which in turns depend on the width/height of the node) we will only pre-compute
      // the unit vectors.
      // For simplicity the layout will be:
      // [ p0, UnitVectorP0P1, p1, UniVectorP1P2, ..., pn, UnitVectorPnP0 ]
      var allPoints = new Array(points.length * 2);
  
      for (var i = 0; i < points.length / 2; i++) {
        var sourceIndex = i * 2;
        var destIndex = void 0;
  
        if (i < points.length / 2 - 1) {
          destIndex = (i + 1) * 2;
        } else {
          destIndex = 0;
        }
  
        allPoints[i * 4] = points[sourceIndex];
        allPoints[i * 4 + 1] = points[sourceIndex + 1];
        var xDest = points[destIndex] - points[sourceIndex];
        var yDest = points[destIndex + 1] - points[sourceIndex + 1];
        var norm = Math.sqrt(xDest * xDest + yDest * yDest);
        allPoints[i * 4 + 2] = xDest / norm;
        allPoints[i * 4 + 3] = yDest / norm;
      }
  
      return this.nodeShapes[name] = {
        renderer: this,
        name: name,
        points: allPoints,
        draw: function draw(context, centerX, centerY, width, height) {
          this.renderer.nodeShapeImpl('round-polygon', context, centerX, centerY, width, height, this.points);
        },
        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
          return roundPolygonIntersectLine(x, y, this.points, nodeX, nodeY, width, height);
        },
        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
          return pointInsideRoundPolygon(x, y, this.points, centerX, centerY, width, height);
        }
      };
    };
  
    BRp$d.generateRoundRectangle = function () {
      return this.nodeShapes['round-rectangle'] = this.nodeShapes['roundrectangle'] = {
        renderer: this,
        name: 'round-rectangle',
        points: generateUnitNgonPointsFitToSquare(4, 0),
        draw: function draw(context, centerX, centerY, width, height) {
          this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
        },
        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
          return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
        },
        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
          var cornerRadius = getRoundRectangleRadius(width, height);
          var diam = cornerRadius * 2; // Check hBox
  
          if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
            return true;
          } // Check vBox
  
  
          if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
            return true;
          } // Check top left quarter circle
  
  
          if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY - height / 2 + cornerRadius, padding)) {
            return true;
          } // Check top right quarter circle
  
  
          if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY - height / 2 + cornerRadius, padding)) {
            return true;
          } // Check bottom right quarter circle
  
  
          if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
            return true;
          } // Check bottom left quarter circle
  
  
          if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
            return true;
          }
  
          return false;
        }
      };
    };
  
    BRp$d.generateCutRectangle = function () {
      return this.nodeShapes['cut-rectangle'] = this.nodeShapes['cutrectangle'] = {
        renderer: this,
        name: 'cut-rectangle',
        cornerLength: getCutRectangleCornerLength(),
        points: generateUnitNgonPointsFitToSquare(4, 0),
        draw: function draw(context, centerX, centerY, width, height) {
          this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
        },
        generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY) {
          var cl = this.cornerLength;
          var hh = height / 2;
          var hw = width / 2;
          var xBegin = centerX - hw;
          var xEnd = centerX + hw;
          var yBegin = centerY - hh;
          var yEnd = centerY + hh; // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]
  
          return {
            topLeft: [xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl],
            topRight: [xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl],
            bottomRight: [xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl],
            bottomLeft: [xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl]
          };
        },
        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
          var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);
          var pts = [].concat.apply([], [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4), cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)]);
          return polygonIntersectLine(x, y, pts, nodeX, nodeY);
        },
        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
          // Check hBox
          if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * this.cornerLength, [0, -1], padding)) {
            return true;
          } // Check vBox
  
  
          if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * this.cornerLength, height, [0, -1], padding)) {
            return true;
          }
  
          var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);
          return pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);
        }
      };
    };
  
    BRp$d.generateBarrel = function () {
      return this.nodeShapes['barrel'] = {
        renderer: this,
        name: 'barrel',
        points: generateUnitNgonPointsFitToSquare(4, 0),
        draw: function draw(context, centerX, centerY, width, height) {
          this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
        },
        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
          // use two fixed t values for the bezier curve approximation
          var t0 = 0.15;
          var t1 = 0.5;
          var t2 = 0.85;
          var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);
  
          var approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {
            // approximate curve pts based on the two t values
            var m0 = qbezierPtAt({
              x: pts[0],
              y: pts[1]
            }, {
              x: pts[2],
              y: pts[3]
            }, {
              x: pts[4],
              y: pts[5]
            }, t0);
            var m1 = qbezierPtAt({
              x: pts[0],
              y: pts[1]
            }, {
              x: pts[2],
              y: pts[3]
            }, {
              x: pts[4],
              y: pts[5]
            }, t1);
            var m2 = qbezierPtAt({
              x: pts[0],
              y: pts[1]
            }, {
              x: pts[2],
              y: pts[3]
            }, {
              x: pts[4],
              y: pts[5]
            }, t2);
            return [pts[0], pts[1], m0.x, m0.y, m1.x, m1.y, m2.x, m2.y, pts[4], pts[5]];
          };
  
          var pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));
          return polygonIntersectLine(x, y, pts, nodeX, nodeY);
        },
        generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {
          var hh = height / 2;
          var hw = width / 2;
          var xBegin = centerX - hw;
          var xEnd = centerX + hw;
          var yBegin = centerY - hh;
          var yEnd = centerY + hh;
          var curveConstants = getBarrelCurveConstants(width, height);
          var hOffset = curveConstants.heightOffset;
          var wOffset = curveConstants.widthOffset;
          var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width; // points are in clockwise order, inner (imaginary) control pt on [4, 5]
  
          var pts = {
            topLeft: [xBegin, yBegin + hOffset, xBegin + ctrlPtXOffset, yBegin, xBegin + wOffset, yBegin],
            topRight: [xEnd - wOffset, yBegin, xEnd - ctrlPtXOffset, yBegin, xEnd, yBegin + hOffset],
            bottomRight: [xEnd, yEnd - hOffset, xEnd - ctrlPtXOffset, yEnd, xEnd - wOffset, yEnd],
            bottomLeft: [xBegin + wOffset, yEnd, xBegin + ctrlPtXOffset, yEnd, xBegin, yEnd - hOffset]
          };
          pts.topLeft.isTop = true;
          pts.topRight.isTop = true;
          pts.bottomLeft.isBottom = true;
          pts.bottomRight.isBottom = true;
          return pts;
        },
        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
          var curveConstants = getBarrelCurveConstants(width, height);
          var hOffset = curveConstants.heightOffset;
          var wOffset = curveConstants.widthOffset; // Check hBox
  
          if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [0, -1], padding)) {
            return true;
          } // Check vBox
  
  
          if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [0, -1], padding)) {
            return true;
          }
  
          var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);
  
          var getCurveT = function getCurveT(x, y, curvePts) {
            var x0 = curvePts[4];
            var x1 = curvePts[2];
            var x2 = curvePts[0];
            var y0 = curvePts[5]; // var y1 = curvePts[ 3 ];
  
            var y2 = curvePts[1];
            var xMin = Math.min(x0, x2);
            var xMax = Math.max(x0, x2);
            var yMin = Math.min(y0, y2);
            var yMax = Math.max(y0, y2);
  
            if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {
              var coeff = bezierPtsToQuadCoeff(x0, x1, x2);
              var roots = solveQuadratic(coeff[0], coeff[1], coeff[2], x);
              var validRoots = roots.filter(function (r) {
                return 0 <= r && r <= 1;
              });
  
              if (validRoots.length > 0) {
                return validRoots[0];
              }
            }
  
            return null;
          };
  
          var curveRegions = Object.keys(barrelCurvePts);
  
          for (var i = 0; i < curveRegions.length; i++) {
            var corner = curveRegions[i];
            var cornerPts = barrelCurvePts[corner];
            var t = getCurveT(x, y, cornerPts);
  
            if (t == null) {
              continue;
            }
  
            var y0 = cornerPts[5];
            var y1 = cornerPts[3];
            var y2 = cornerPts[1];
            var bezY = qbezierAt(y0, y1, y2, t);
  
            if (cornerPts.isTop && bezY <= y) {
              return true;
            }
  
            if (cornerPts.isBottom && y <= bezY) {
              return true;
            }
          }
  
          return false;
        }
      };
    };
  
    BRp$d.generateBottomRoundrectangle = function () {
      return this.nodeShapes['bottom-round-rectangle'] = this.nodeShapes['bottomroundrectangle'] = {
        renderer: this,
        name: 'bottom-round-rectangle',
        points: generateUnitNgonPointsFitToSquare(4, 0),
        draw: function draw(context, centerX, centerY, width, height) {
          this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
        },
        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
          var topStartX = nodeX - (width / 2 + padding);
          var topStartY = nodeY - (height / 2 + padding);
          var topEndY = topStartY;
          var topEndX = nodeX + (width / 2 + padding);
          var topIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);
  
          if (topIntersections.length > 0) {
            return topIntersections;
          }
  
          return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
        },
        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
          var cornerRadius = getRoundRectangleRadius(width, height);
          var diam = 2 * cornerRadius; // Check hBox
  
          if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
            return true;
          } // Check vBox
  
  
          if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
            return true;
          } // check non-rounded top side
  
  
          var outerWidth = width / 2 + 2 * padding;
          var outerHeight = height / 2 + 2 * padding;
          var points = [centerX - outerWidth, centerY - outerHeight, centerX - outerWidth, centerY, centerX + outerWidth, centerY, centerX + outerWidth, centerY - outerHeight];
  
          if (pointInsidePolygonPoints(x, y, points)) {
            return true;
          } // Check bottom right quarter circle
  
  
          if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
            return true;
          } // Check bottom left quarter circle
  
  
          if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
            return true;
          }
  
          return false;
        }
      };
    };
  
    BRp$d.registerNodeShapes = function () {
      var nodeShapes = this.nodeShapes = {};
      var renderer = this;
      this.generateEllipse();
      this.generatePolygon('triangle', generateUnitNgonPointsFitToSquare(3, 0));
      this.generateRoundPolygon('round-triangle', generateUnitNgonPointsFitToSquare(3, 0));
      this.generatePolygon('rectangle', generateUnitNgonPointsFitToSquare(4, 0));
      nodeShapes['square'] = nodeShapes['rectangle'];
      this.generateRoundRectangle();
      this.generateCutRectangle();
      this.generateBarrel();
      this.generateBottomRoundrectangle();
      {
        var diamondPoints = [0, 1, 1, 0, 0, -1, -1, 0];
        this.generatePolygon('diamond', diamondPoints);
        this.generateRoundPolygon('round-diamond', diamondPoints);
      }
      this.generatePolygon('pentagon', generateUnitNgonPointsFitToSquare(5, 0));
      this.generateRoundPolygon('round-pentagon', generateUnitNgonPointsFitToSquare(5, 0));
      this.generatePolygon('hexagon', generateUnitNgonPointsFitToSquare(6, 0));
      this.generateRoundPolygon('round-hexagon', generateUnitNgonPointsFitToSquare(6, 0));
      this.generatePolygon('heptagon', generateUnitNgonPointsFitToSquare(7, 0));
      this.generateRoundPolygon('round-heptagon', generateUnitNgonPointsFitToSquare(7, 0));
      this.generatePolygon('octagon', generateUnitNgonPointsFitToSquare(8, 0));
      this.generateRoundPolygon('round-octagon', generateUnitNgonPointsFitToSquare(8, 0));
      var star5Points = new Array(20);
      {
        var outerPoints = generateUnitNgonPoints(5, 0);
        var innerPoints = generateUnitNgonPoints(5, Math.PI / 5); // Outer radius is 1; inner radius of star is smaller
  
        var innerRadius = 0.5 * (3 - Math.sqrt(5));
        innerRadius *= 1.57;
  
        for (var i = 0; i < innerPoints.length / 2; i++) {
          innerPoints[i * 2] *= innerRadius;
          innerPoints[i * 2 + 1] *= innerRadius;
        }
  
        for (var i = 0; i < 20 / 4; i++) {
          star5Points[i * 4] = outerPoints[i * 2];
          star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];
          star5Points[i * 4 + 2] = innerPoints[i * 2];
          star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];
        }
      }
      star5Points = fitPolygonToSquare(star5Points);
      this.generatePolygon('star', star5Points);
      this.generatePolygon('vee', [-1, -1, 0, -0.333, 1, -1, 0, 1]);
      this.generatePolygon('rhomboid', [-1, -1, 0.333, -1, 1, 1, -0.333, 1]);
      this.nodeShapes['concavehexagon'] = this.generatePolygon('concave-hexagon', [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);
      {
        var tagPoints = [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1];
        this.generatePolygon('tag', tagPoints);
        this.generateRoundPolygon('round-tag', tagPoints);
      }
  
      nodeShapes.makePolygon = function (points) {
        // use caching on user-specified polygons so they are as fast as native shapes
        var key = points.join('$');
        var name = 'polygon-' + key;
        var shape;
  
        if (shape = this[name]) {
          // got cached shape
          return shape;
        } // create and cache new shape
  
  
        return renderer.generatePolygon(name, points);
      };
    };
  
    var BRp$e = {};
  
    BRp$e.timeToRender = function () {
      return this.redrawTotalTime / this.redrawCount;
    };
  
    BRp$e.redraw = function (options) {
      options = options || staticEmptyObject();
      var r = this;
  
      if (r.averageRedrawTime === undefined) {
        r.averageRedrawTime = 0;
      }
  
      if (r.lastRedrawTime === undefined) {
        r.lastRedrawTime = 0;
      }
  
      if (r.lastDrawTime === undefined) {
        r.lastDrawTime = 0;
      }
  
      r.requestedFrame = true;
      r.renderOptions = options;
    };
  
    BRp$e.beforeRender = function (fn, priority) {
      // the renderer can't add tick callbacks when destroyed
      if (this.destroyed) {
        return;
      }
  
      if (priority == null) {
        error('Priority is not optional for beforeRender');
      }
  
      var cbs = this.beforeRenderCallbacks;
      cbs.push({
        fn: fn,
        priority: priority
      }); // higher priority callbacks executed first
  
      cbs.sort(function (a, b) {
        return b.priority - a.priority;
      });
    };
  
    var beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {
      var cbs = r.beforeRenderCallbacks;
  
      for (var i = 0; i < cbs.length; i++) {
        cbs[i].fn(willDraw, startTime);
      }
    };
  
    BRp$e.startRenderLoop = function () {
      var r = this;
      var cy = r.cy;
  
      if (r.renderLoopStarted) {
        return;
      } else {
        r.renderLoopStarted = true;
      }
  
      var renderFn = function renderFn(requestTime) {
        if (r.destroyed) {
          return;
        }
  
        if (cy.batching()) ; else if (r.requestedFrame && !r.skipFrame) {
          beforeRenderCallbacks(r, true, requestTime);
          var startTime = performanceNow();
          r.render(r.renderOptions);
          var endTime = r.lastDrawTime = performanceNow();
  
          if (r.averageRedrawTime === undefined) {
            r.averageRedrawTime = endTime - startTime;
          }
  
          if (r.redrawCount === undefined) {
            r.redrawCount = 0;
          }
  
          r.redrawCount++;
  
          if (r.redrawTotalTime === undefined) {
            r.redrawTotalTime = 0;
          }
  
          var duration = endTime - startTime;
          r.redrawTotalTime += duration;
          r.lastRedrawTime = duration; // use a weighted average with a bias from the previous average so we don't spike so easily
  
          r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;
          r.requestedFrame = false;
        } else {
          beforeRenderCallbacks(r, false, requestTime);
        }
  
        r.skipFrame = false;
        requestAnimationFrame(renderFn);
      };
  
      requestAnimationFrame(renderFn);
    };
  
    var BaseRenderer = function BaseRenderer(options) {
      this.init(options);
    };
  
    var BR = BaseRenderer;
    var BRp$f = BR.prototype;
    BRp$f.clientFunctions = ['redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl'];
  
    BRp$f.init = function (options) {
      var r = this;
      r.options = options;
      r.cy = options.cy;
      var ctr = r.container = options.cy.container(); // prepend a stylesheet in the head such that
  
      if (window$1) {
        var document = window$1.document;
        var head = document.head;
        var stylesheetId = '__________cytoscape_stylesheet';
        var className = '__________cytoscape_container';
        var stylesheetAlreadyExists = document.getElementById(stylesheetId) != null;
  
        if (ctr.className.indexOf(className) < 0) {
          ctr.className = (ctr.className || '') + ' ' + className;
        }
  
        if (!stylesheetAlreadyExists) {
          var stylesheet = document.createElement('style');
          stylesheet.id = stylesheetId;
          stylesheet.innerHTML = '.' + className + ' { position: relative; }';
          head.insertBefore(stylesheet, head.children[0]); // first so lowest priority
        }
  
        var computedStyle = window$1.getComputedStyle(ctr);
        var position = computedStyle.getPropertyValue('position');
  
        if (position === 'static') {
          warn('A Cytoscape container has style position:static and so can not use UI extensions properly');
        }
      }
  
      r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag
  
      r.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95]; //--Pointer-related data
  
      r.hoverData = {
        down: null,
        last: null,
        downTime: null,
        triggerMode: null,
        dragging: false,
        initialPan: [null, null],
        capture: false
      };
      r.dragData = {
        possibleDragElements: []
      };
      r.touchData = {
        start: null,
        capture: false,
        // These 3 fields related to tap, taphold events
        startPosition: [null, null, null, null, null, null],
        singleTouchStartTime: null,
        singleTouchMoved: true,
        now: [null, null, null, null, null, null],
        earlier: [null, null, null, null, null, null]
      };
      r.redraws = 0;
      r.showFps = options.showFps;
      r.debug = options.debug;
      r.hideEdgesOnViewport = options.hideEdgesOnViewport;
      r.textureOnViewport = options.textureOnViewport;
      r.wheelSensitivity = options.wheelSensitivity;
      r.motionBlurEnabled = options.motionBlur; // on by default
  
      r.forcedPixelRatio = number(options.pixelRatio) ? options.pixelRatio : null;
      r.motionBlur = options.motionBlur; // for initial kick off
  
      r.motionBlurOpacity = options.motionBlurOpacity;
      r.motionBlurTransparency = 1 - r.motionBlurOpacity;
      r.motionBlurPxRatio = 1;
      r.mbPxRBlurry = 1; //0.8;
  
      r.minMbLowQualFrames = 4;
      r.fullQualityMb = false;
      r.clearedForMotionBlur = [];
      r.desktopTapThreshold = options.desktopTapThreshold;
      r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
      r.touchTapThreshold = options.touchTapThreshold;
      r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
      r.tapholdDuration = 500;
      r.bindings = [];
      r.beforeRenderCallbacks = [];
      r.beforeRenderPriorities = {
        // higher priority execs before lower one
        animations: 400,
        eleCalcs: 300,
        eleTxrDeq: 200,
        lyrTxrDeq: 150,
        lyrTxrSkip: 100
      };
      r.registerNodeShapes();
      r.registerArrowShapes();
      r.registerCalculationListeners();
    };
  
    BRp$f.notify = function (eventName, eles) {
      var r = this;
      var cy = r.cy; // the renderer can't be notified after it's destroyed
  
      if (this.destroyed) {
        return;
      }
  
      if (eventName === 'init') {
        r.load();
        return;
      }
  
      if (eventName === 'destroy') {
        r.destroy();
        return;
      }
  
      if (eventName === 'add' || eventName === 'remove' || eventName === 'move' && cy.hasCompoundNodes() || eventName === 'load' || eventName === 'zorder' || eventName === 'mount') {
        r.invalidateCachedZSortedEles();
      }
  
      if (eventName === 'viewport') {
        r.redrawHint('select', true);
      }
  
      if (eventName === 'load' || eventName === 'resize' || eventName === 'mount') {
        r.invalidateContainerClientCoordsCache();
        r.matchCanvasSize(r.container);
      }
  
      r.redrawHint('eles', true);
      r.redrawHint('drag', true);
      this.startRenderLoop();
      this.redraw();
    };
  
    BRp$f.destroy = function () {
      var r = this;
      r.destroyed = true;
      r.cy.stopAnimationLoop();
  
      for (var i = 0; i < r.bindings.length; i++) {
        var binding = r.bindings[i];
        var b = binding;
        var tgt = b.target;
        (tgt.off || tgt.removeEventListener).apply(tgt, b.args);
      }
  
      r.bindings = [];
      r.beforeRenderCallbacks = [];
      r.onUpdateEleCalcsFns = [];
  
      if (r.removeObserver) {
        r.removeObserver.disconnect();
      }
  
      if (r.styleObserver) {
        r.styleObserver.disconnect();
      }
  
      if (r.resizeObserver) {
        r.resizeObserver.disconnect();
      }
  
      if (r.labelCalcDiv) {
        try {
          document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef
        } catch (e) {// ie10 issue #1014
        }
      }
    };
  
    BRp$f.isHeadless = function () {
      return false;
    };
  
    [BRp, BRp$a, BRp$b, BRp$c, BRp$d, BRp$e].forEach(function (props) {
      extend(BRp$f, props);
    });
  
    var fullFpsTime = 1000 / 60; // assume 60 frames per second
  
    var defs = {
      setupDequeueing: function setupDequeueing(opts) {
        return function setupDequeueingImpl() {
          var self = this;
          var r = this.renderer;
  
          if (self.dequeueingSetup) {
            return;
          } else {
            self.dequeueingSetup = true;
          }
  
          var queueRedraw = lodash_debounce(function () {
            r.redrawHint('eles', true);
            r.redrawHint('drag', true);
            r.redraw();
          }, opts.deqRedrawThreshold);
  
          var dequeue = function dequeue(willDraw, frameStartTime) {
            var startTime = performanceNow();
            var avgRenderTime = r.averageRedrawTime;
            var renderTime = r.lastRedrawTime;
            var deqd = [];
            var extent = r.cy.extent();
            var pixelRatio = r.getPixelRatio(); // if we aren't in a tick that causes a draw, then the rendered style
            // queue won't automatically be flushed before dequeueing starts
  
            if (!willDraw) {
              r.flushRenderedStyleQueue();
            }
  
            while (true) {
              // eslint-disable-line no-constant-condition
              var now = performanceNow();
              var duration = now - startTime;
              var frameDuration = now - frameStartTime;
  
              if (renderTime < fullFpsTime) {
                // if we're rendering faster than the ideal fps, then do dequeueing
                // during all of the remaining frame time
                var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);
  
                if (frameDuration >= opts.deqFastCost * timeAvailable) {
                  break;
                }
              } else {
                if (willDraw) {
                  if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {
                    break;
                  }
                } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {
                  break;
                }
              }
  
              var thisDeqd = opts.deq(self, pixelRatio, extent);
  
              if (thisDeqd.length > 0) {
                for (var i = 0; i < thisDeqd.length; i++) {
                  deqd.push(thisDeqd[i]);
                }
              } else {
                break;
              }
            } // callbacks on dequeue
  
  
            if (deqd.length > 0) {
              opts.onDeqd(self, deqd);
  
              if (!willDraw && opts.shouldRedraw(self, deqd, pixelRatio, extent)) {
                queueRedraw();
              }
            }
          };
  
          var priority = opts.priority || noop;
          r.beforeRender(dequeue, priority(self));
        };
      }
    };
  
    // Uses keys so elements may share the same cache.
  
    var ElementTextureCacheLookup =
    /*#__PURE__*/
    function () {
      function ElementTextureCacheLookup(getKey) {
        var doesEleInvalidateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : falsify;
  
        _classCallCheck(this, ElementTextureCacheLookup);
  
        this.idsByKey = new Map$1();
        this.keyForId = new Map$1();
        this.cachesByLvl = new Map$1();
        this.lvls = [];
        this.getKey = getKey;
        this.doesEleInvalidateKey = doesEleInvalidateKey;
      }
  
      _createClass(ElementTextureCacheLookup, [{
        key: "getIdsFor",
        value: function getIdsFor(key) {
          if (key == null) {
            error("Can not get id list for null key");
          }
  
          var idsByKey = this.idsByKey;
          var ids = this.idsByKey.get(key);
  
          if (!ids) {
            ids = new Set$1();
            idsByKey.set(key, ids);
          }
  
          return ids;
        }
      }, {
        key: "addIdForKey",
        value: function addIdForKey(key, id) {
          if (key != null) {
            this.getIdsFor(key).add(id);
          }
        }
      }, {
        key: "deleteIdForKey",
        value: function deleteIdForKey(key, id) {
          if (key != null) {
            this.getIdsFor(key)["delete"](id);
          }
        }
      }, {
        key: "getNumberOfIdsForKey",
        value: function getNumberOfIdsForKey(key) {
          if (key == null) {
            return 0;
          } else {
            return this.getIdsFor(key).size;
          }
        }
      }, {
        key: "updateKeyMappingFor",
        value: function updateKeyMappingFor(ele) {
          var id = ele.id();
          var prevKey = this.keyForId.get(id);
          var currKey = this.getKey(ele);
          this.deleteIdForKey(prevKey, id);
          this.addIdForKey(currKey, id);
          this.keyForId.set(id, currKey);
        }
      }, {
        key: "deleteKeyMappingFor",
        value: function deleteKeyMappingFor(ele) {
          var id = ele.id();
          var prevKey = this.keyForId.get(id);
          this.deleteIdForKey(prevKey, id);
          this.keyForId["delete"](id);
        }
      }, {
        key: "keyHasChangedFor",
        value: function keyHasChangedFor(ele) {
          var id = ele.id();
          var prevKey = this.keyForId.get(id);
          var newKey = this.getKey(ele);
          return prevKey !== newKey;
        }
      }, {
        key: "isInvalid",
        value: function isInvalid(ele) {
          return this.keyHasChangedFor(ele) || this.doesEleInvalidateKey(ele);
        }
      }, {
        key: "getCachesAt",
        value: function getCachesAt(lvl) {
          var cachesByLvl = this.cachesByLvl,
              lvls = this.lvls;
          var caches = cachesByLvl.get(lvl);
  
          if (!caches) {
            caches = new Map$1();
            cachesByLvl.set(lvl, caches);
            lvls.push(lvl);
          }
  
          return caches;
        }
      }, {
        key: "getCache",
        value: function getCache(key, lvl) {
          return this.getCachesAt(lvl).get(key);
        }
      }, {
        key: "get",
        value: function get(ele, lvl) {
          var key = this.getKey(ele);
          var cache = this.getCache(key, lvl); // getting for an element may need to add to the id list b/c eles can share keys
  
          if (cache != null) {
            this.updateKeyMappingFor(ele);
          }
  
          return cache;
        }
      }, {
        key: "getForCachedKey",
        value: function getForCachedKey(ele, lvl) {
          var key = this.keyForId.get(ele.id()); // n.b. use cached key, not newly computed key
  
          var cache = this.getCache(key, lvl);
          return cache;
        }
      }, {
        key: "hasCache",
        value: function hasCache(key, lvl) {
          return this.getCachesAt(lvl).has(key);
        }
      }, {
        key: "has",
        value: function has(ele, lvl) {
          var key = this.getKey(ele);
          return this.hasCache(key, lvl);
        }
      }, {
        key: "setCache",
        value: function setCache(key, lvl, cache) {
          cache.key = key;
          this.getCachesAt(lvl).set(key, cache);
        }
      }, {
        key: "set",
        value: function set(ele, lvl, cache) {
          var key = this.getKey(ele);
          this.setCache(key, lvl, cache);
          this.updateKeyMappingFor(ele);
        }
      }, {
        key: "deleteCache",
        value: function deleteCache(key, lvl) {
          this.getCachesAt(lvl)["delete"](key);
        }
      }, {
        key: "delete",
        value: function _delete(ele, lvl) {
          var key = this.getKey(ele);
          this.deleteCache(key, lvl);
        }
      }, {
        key: "invalidateKey",
        value: function invalidateKey(key) {
          var _this = this;
  
          this.lvls.forEach(function (lvl) {
            return _this.deleteCache(key, lvl);
          });
        } // returns true if no other eles reference the invalidated cache (n.b. other eles may need the cache with the same key)
  
      }, {
        key: "invalidate",
        value: function invalidate(ele) {
          var id = ele.id();
          var key = this.keyForId.get(id); // n.b. use stored key rather than current (potential key)
  
          this.deleteKeyMappingFor(ele);
          var entireKeyInvalidated = this.doesEleInvalidateKey(ele);
  
          if (entireKeyInvalidated) {
            // clear mapping for current key
            this.invalidateKey(key);
          }
  
          return entireKeyInvalidated || this.getNumberOfIdsForKey(key) === 0;
        }
      }]);
  
      return ElementTextureCacheLookup;
    }();
  
    var minTxrH = 25; // the size of the texture cache for small height eles (special case)
  
    var txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up
  
    var minLvl = -4; // when scaling smaller than that we don't need to re-render
  
    var maxLvl = 3; // when larger than this scale just render directly (caching is not helpful)
  
    var maxZoom = 7.99; // beyond this zoom level, layered textures are not used
  
    var eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps
  
    var defTxrWidth = 1024; // default/minimum texture width
  
    var maxTxrW = 1024; // the maximum width of a texture
  
    var maxTxrH = 1024; // the maximum height of a texture
  
    var minUtility = 0.2; // if usage of texture is less than this, it is retired
  
    var maxFullness = 0.8; // fullness of texture after which queue removal is checked
  
    var maxFullnessChecks = 10; // dequeued after this many checks
  
    var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
  
    var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time
  
    var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
  
    var deqFastCost = 0.9; // % of frame time to be used when >60fps
  
    var deqRedrawThreshold = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
  
    var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch
  
    var getTxrReasons = {
      dequeue: 'dequeue',
      downscale: 'downscale',
      highQuality: 'highQuality'
    };
    var initDefaults = defaults({
      getKey: null,
      doesEleInvalidateKey: falsify,
      drawElement: null,
      getBoundingBox: null,
      getRotationPoint: null,
      getRotationOffset: null,
      isVisible: trueify,
      allowEdgeTxrCaching: true,
      allowParentTxrCaching: true
    });
  
    var ElementTextureCache = function ElementTextureCache(renderer, initOptions) {
      var self = this;
      self.renderer = renderer;
      self.onDequeues = [];
      var opts = initDefaults(initOptions);
      extend(self, opts);
      self.lookup = new ElementTextureCacheLookup(opts.getKey, opts.doesEleInvalidateKey);
      self.setupDequeueing();
    };
  
    var ETCp = ElementTextureCache.prototype;
    ETCp.reasons = getTxrReasons; // the list of textures in which new subtextures for elements can be placed
  
    ETCp.getTextureQueue = function (txrH) {
      var self = this;
      self.eleImgCaches = self.eleImgCaches || {};
      return self.eleImgCaches[txrH] = self.eleImgCaches[txrH] || [];
    }; // the list of usused textures which can be recycled (in use in texture queue)
  
  
    ETCp.getRetiredTextureQueue = function (txrH) {
      var self = this;
      var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};
      var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];
      return rtxtrQ;
    }; // queue of element draw requests at different scale levels
  
  
    ETCp.getElementQueue = function () {
      var self = this;
      var q = self.eleCacheQueue = self.eleCacheQueue || new heap$1(function (a, b) {
        return b.reqs - a.reqs;
      });
      return q;
    }; // queue of element draw requests at different scale levels (element id lookup)
  
  
    ETCp.getElementKeyToQueue = function () {
      var self = this;
      var k2q = self.eleKeyToCacheQueue = self.eleKeyToCacheQueue || {};
      return k2q;
    };
  
    ETCp.getElement = function (ele, bb, pxRatio, lvl, reason) {
      var self = this;
      var r = this.renderer;
      var zoom = r.cy.zoom();
      var lookup = this.lookup;
  
      if (bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible()) {
        return null;
      }
  
      if (!self.allowEdgeTxrCaching && ele.isEdge() || !self.allowParentTxrCaching && ele.isParent()) {
        return null;
      }
  
      if (lvl == null) {
        lvl = Math.ceil(log2(zoom * pxRatio));
      }
  
      if (lvl < minLvl) {
        lvl = minLvl;
      } else if (zoom >= maxZoom || lvl > maxLvl) {
        return null;
      }
  
      var scale = Math.pow(2, lvl);
      var eleScaledH = bb.h * scale;
      var eleScaledW = bb.w * scale;
      var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);
  
      if (!this.isVisible(ele, scaledLabelShown)) {
        return null;
      }
  
      var eleCache = lookup.get(ele, lvl); // if this get was on an unused/invalidated cache, then restore the texture usage metric
  
      if (eleCache && eleCache.invalidated) {
        eleCache.invalidated = false;
        eleCache.texture.invalidatedWidth -= eleCache.width;
      }
  
      if (eleCache) {
        return eleCache;
      }
  
      var txrH; // which texture height this ele belongs to
  
      if (eleScaledH <= minTxrH) {
        txrH = minTxrH;
      } else if (eleScaledH <= txrStepH) {
        txrH = txrStepH;
      } else {
        txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;
      }
  
      if (eleScaledH > maxTxrH || eleScaledW > maxTxrW) {
        return null; // caching large elements is not efficient
      }
  
      var txrQ = self.getTextureQueue(txrH); // first try the second last one in case it has space at the end
  
      var txr = txrQ[txrQ.length - 2];
  
      var addNewTxr = function addNewTxr() {
        return self.recycleTexture(txrH, eleScaledW) || self.addTexture(txrH, eleScaledW);
      }; // try the last one if there is no second last one
  
  
      if (!txr) {
        txr = txrQ[txrQ.length - 1];
      } // if the last one doesn't exist, we need a first one
  
  
      if (!txr) {
        txr = addNewTxr();
      } // if there's no room in the current texture, we need a new one
  
  
      if (txr.width - txr.usedWidth < eleScaledW) {
        txr = addNewTxr();
      }
  
      var scalableFrom = function scalableFrom(otherCache) {
        return otherCache && otherCache.scaledLabelShown === scaledLabelShown;
      };
  
      var deqing = reason && reason === getTxrReasons.dequeue;
      var highQualityReq = reason && reason === getTxrReasons.highQuality;
      var downscaleReq = reason && reason === getTxrReasons.downscale;
      var higherCache; // the nearest cache with a higher level
  
      for (var l = lvl + 1; l <= maxLvl; l++) {
        var c = lookup.get(ele, l);
  
        if (c) {
          higherCache = c;
          break;
        }
      }
  
      var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;
  
      var downscale = function downscale() {
        txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);
      }; // reset ele area in texture
  
  
      txr.context.setTransform(1, 0, 0, 1, 0, 0);
      txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);
  
      if (scalableFrom(oneUpCache)) {
        // then we can relatively cheaply rescale the existing image w/o rerendering
        downscale();
      } else if (scalableFrom(higherCache)) {
        // then use the higher cache for now and queue the next level down
        // to cheaply scale towards the smaller level
        if (highQualityReq) {
          for (var _l = higherCache.level; _l > lvl; _l--) {
            oneUpCache = self.getElement(ele, bb, pxRatio, _l, getTxrReasons.downscale);
          }
  
          downscale();
        } else {
          self.queueElement(ele, higherCache.level - 1);
          return higherCache;
        }
      } else {
        var lowerCache; // the nearest cache with a lower level
  
        if (!deqing && !highQualityReq && !downscaleReq) {
          for (var _l2 = lvl - 1; _l2 >= minLvl; _l2--) {
            var _c = lookup.get(ele, _l2);
  
            if (_c) {
              lowerCache = _c;
              break;
            }
          }
        }
  
        if (scalableFrom(lowerCache)) {
          // then use the lower quality cache for now and queue the better one for later
          self.queueElement(ele, lvl);
          return lowerCache;
        }
  
        txr.context.translate(txr.usedWidth, 0);
        txr.context.scale(scale, scale);
        this.drawElement(txr.context, ele, bb, scaledLabelShown, false);
        txr.context.scale(1 / scale, 1 / scale);
        txr.context.translate(-txr.usedWidth, 0);
      }
  
      eleCache = {
        x: txr.usedWidth,
        texture: txr,
        level: lvl,
        scale: scale,
        width: eleScaledW,
        height: eleScaledH,
        scaledLabelShown: scaledLabelShown
      };
      txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);
      txr.eleCaches.push(eleCache);
      lookup.set(ele, lvl, eleCache);
      self.checkTextureFullness(txr);
      return eleCache;
    };
  
    ETCp.invalidateElements = function (eles) {
      for (var i = 0; i < eles.length; i++) {
        this.invalidateElement(eles[i]);
      }
    };
  
    ETCp.invalidateElement = function (ele) {
      var self = this;
      var lookup = self.lookup;
      var caches = [];
      var invalid = lookup.isInvalid(ele);
  
      if (!invalid) {
        return; // override the invalidation request if the element key has not changed
      }
  
      for (var lvl = minLvl; lvl <= maxLvl; lvl++) {
        var cache = lookup.getForCachedKey(ele, lvl);
  
        if (cache) {
          caches.push(cache);
        }
      }
  
      var noOtherElesUseCache = lookup.invalidate(ele);
  
      if (noOtherElesUseCache) {
        for (var i = 0; i < caches.length; i++) {
          var _cache = caches[i];
          var txr = _cache.texture; // remove space from the texture it belongs to
  
          txr.invalidatedWidth += _cache.width; // mark the cache as invalidated
  
          _cache.invalidated = true; // retire the texture if its utility is low
  
          self.checkTextureUtility(txr);
        }
      } // remove from queue since the old req was for the old state
  
  
      self.removeFromQueue(ele);
    };
  
    ETCp.checkTextureUtility = function (txr) {
      // invalidate all entries in the cache if the cache size is small
      if (txr.invalidatedWidth >= minUtility * txr.width) {
        this.retireTexture(txr);
      }
    };
  
    ETCp.checkTextureFullness = function (txr) {
      // if texture has been mostly filled and passed over several times, remove
      // it from the queue so we don't need to waste time looking at it to put new things
      var self = this;
      var txrQ = self.getTextureQueue(txr.height);
  
      if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {
        removeFromArray(txrQ, txr);
      } else {
        txr.fullnessChecks++;
      }
    };
  
    ETCp.retireTexture = function (txr) {
      var self = this;
      var txrH = txr.height;
      var txrQ = self.getTextureQueue(txrH);
      var lookup = this.lookup; // retire the texture from the active / searchable queue:
  
      removeFromArray(txrQ, txr);
      txr.retired = true; // remove the refs from the eles to the caches:
  
      var eleCaches = txr.eleCaches;
  
      for (var i = 0; i < eleCaches.length; i++) {
        var eleCache = eleCaches[i];
        lookup.deleteCache(eleCache.key, eleCache.level);
      }
  
      clearArray(eleCaches); // add the texture to a retired queue so it can be recycled in future:
  
      var rtxtrQ = self.getRetiredTextureQueue(txrH);
      rtxtrQ.push(txr);
    };
  
    ETCp.addTexture = function (txrH, minW) {
      var self = this;
      var txrQ = self.getTextureQueue(txrH);
      var txr = {};
      txrQ.push(txr);
      txr.eleCaches = [];
      txr.height = txrH;
      txr.width = Math.max(defTxrWidth, minW);
      txr.usedWidth = 0;
      txr.invalidatedWidth = 0;
      txr.fullnessChecks = 0;
      txr.canvas = self.renderer.makeOffscreenCanvas(txr.width, txr.height);
      txr.context = txr.canvas.getContext('2d');
      return txr;
    };
  
    ETCp.recycleTexture = function (txrH, minW) {
      var self = this;
      var txrQ = self.getTextureQueue(txrH);
      var rtxtrQ = self.getRetiredTextureQueue(txrH);
  
      for (var i = 0; i < rtxtrQ.length; i++) {
        var txr = rtxtrQ[i];
  
        if (txr.width >= minW) {
          txr.retired = false;
          txr.usedWidth = 0;
          txr.invalidatedWidth = 0;
          txr.fullnessChecks = 0;
          clearArray(txr.eleCaches);
          txr.context.setTransform(1, 0, 0, 1, 0, 0);
          txr.context.clearRect(0, 0, txr.width, txr.height);
          removeFromArray(rtxtrQ, txr);
          txrQ.push(txr);
          return txr;
        }
      }
    };
  
    ETCp.queueElement = function (ele, lvl) {
      var self = this;
      var q = self.getElementQueue();
      var k2q = self.getElementKeyToQueue();
      var key = this.getKey(ele);
      var existingReq = k2q[key];
  
      if (existingReq) {
        // use the max lvl b/c in between lvls are cheap to make
        existingReq.level = Math.max(existingReq.level, lvl);
        existingReq.eles.merge(ele);
        existingReq.reqs++;
        q.updateItem(existingReq);
      } else {
        var req = {
          eles: ele.spawn().merge(ele),
          level: lvl,
          reqs: 1,
          key: key
        };
        q.push(req);
        k2q[key] = req;
      }
    };
  
    ETCp.dequeue = function (pxRatio
    /*, extent*/
    ) {
      var self = this;
      var q = self.getElementQueue();
      var k2q = self.getElementKeyToQueue();
      var dequeued = [];
      var lookup = self.lookup;
  
      for (var i = 0; i < maxDeqSize; i++) {
        if (q.size() > 0) {
          var req = q.pop();
          var key = req.key;
          var ele = req.eles[0]; // all eles have the same key
  
          var cacheExists = lookup.hasCache(ele, req.level); // clear out the key to req lookup
  
          k2q[key] = null; // dequeueing isn't necessary with an existing cache
  
          if (cacheExists) {
            continue;
          }
  
          dequeued.push(req);
          var bb = self.getBoundingBox(ele);
          self.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);
        } else {
          break;
        }
      }
  
      return dequeued;
    };
  
    ETCp.removeFromQueue = function (ele) {
      var self = this;
      var q = self.getElementQueue();
      var k2q = self.getElementKeyToQueue();
      var key = this.getKey(ele);
      var req = k2q[key];
  
      if (req != null) {
        if (req.eles.length === 1) {
          // remove if last ele in the req
          // bring to front of queue
          req.reqs = MAX_INT;
          q.updateItem(req);
          q.pop(); // remove from queue
  
          k2q[key] = null; // remove from lookup map
        } else {
          // otherwise just remove ele from req
          req.eles.unmerge(ele);
        }
      }
    };
  
    ETCp.onDequeue = function (fn) {
      this.onDequeues.push(fn);
    };
  
    ETCp.offDequeue = function (fn) {
      removeFromArray(this.onDequeues, fn);
    };
  
    ETCp.setupDequeueing = defs.setupDequeueing({
      deqRedrawThreshold: deqRedrawThreshold,
      deqCost: deqCost,
      deqAvgCost: deqAvgCost,
      deqNoDrawCost: deqNoDrawCost,
      deqFastCost: deqFastCost,
      deq: function deq(self, pxRatio, extent) {
        return self.dequeue(pxRatio, extent);
      },
      onDeqd: function onDeqd(self, deqd) {
        for (var i = 0; i < self.onDequeues.length; i++) {
          var fn = self.onDequeues[i];
          fn(deqd);
        }
      },
      shouldRedraw: function shouldRedraw(self, deqd, pxRatio, extent) {
        for (var i = 0; i < deqd.length; i++) {
          var eles = deqd[i].eles;
  
          for (var j = 0; j < eles.length; j++) {
            var bb = eles[j].boundingBox();
  
            if (boundingBoxesIntersect(bb, extent)) {
              return true;
            }
          }
        }
  
        return false;
      },
      priority: function priority(self) {
        return self.renderer.beforeRenderPriorities.eleTxrDeq;
      }
    });
  
    var defNumLayers = 1; // default number of layers to use
  
    var minLvl$1 = -4; // when scaling smaller than that we don't need to re-render
  
    var maxLvl$1 = 2; // when larger than this scale just render directly (caching is not helpful)
  
    var maxZoom$1 = 3.99; // beyond this zoom level, layered textures are not used
  
    var deqRedrawThreshold$1 = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
  
    var refineEleDebounceTime = 50; // time to debounce sharper ele texture updates
  
    var deqCost$1 = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
  
    var deqAvgCost$1 = 0.1; // % of add'l rendering cost compared to average overall redraw time
  
    var deqNoDrawCost$1 = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
  
    var deqFastCost$1 = 0.9; // % of frame time to be used when >60fps
  
    var maxDeqSize$1 = 1; // number of eles to dequeue and render at higher texture in each batch
  
    var invalidThreshold = 250; // time threshold for disabling b/c of invalidations
  
    var maxLayerArea = 4000 * 4000; // layers can't be bigger than this
  
    var useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)
    // var log = function(){ console.log.apply( console, arguments ); };
  
    var LayeredTextureCache = function LayeredTextureCache(renderer) {
      var self = this;
      var r = self.renderer = renderer;
      var cy = r.cy;
      self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]
  
      self.firstGet = true;
      self.lastInvalidationTime = performanceNow() - 2 * invalidThreshold;
      self.skipping = false;
      self.eleTxrDeqs = cy.collection();
      self.scheduleElementRefinement = lodash_debounce(function () {
        self.refineElementTextures(self.eleTxrDeqs);
        self.eleTxrDeqs.unmerge(self.eleTxrDeqs);
      }, refineEleDebounceTime);
      r.beforeRender(function (willDraw, now) {
        if (now - self.lastInvalidationTime <= invalidThreshold) {
          self.skipping = true;
        } else {
          self.skipping = false;
        }
      }, r.beforeRenderPriorities.lyrTxrSkip);
  
      var qSort = function qSort(a, b) {
        return b.reqs - a.reqs;
      };
  
      self.layersQueue = new heap$1(qSort);
      self.setupDequeueing();
    };
  
    var LTCp = LayeredTextureCache.prototype;
    var layerIdPool = 0;
    var MAX_INT$1 = Math.pow(2, 53) - 1;
  
    LTCp.makeLayer = function (bb, lvl) {
      var scale = Math.pow(2, lvl);
      var w = Math.ceil(bb.w * scale);
      var h = Math.ceil(bb.h * scale);
      var canvas = this.renderer.makeOffscreenCanvas(w, h);
      var layer = {
        id: layerIdPool = ++layerIdPool % MAX_INT$1,
        bb: bb,
        level: lvl,
        width: w,
        height: h,
        canvas: canvas,
        context: canvas.getContext('2d'),
        eles: [],
        elesQueue: [],
        reqs: 0
      }; // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);
  
      var cxt = layer.context;
      var dx = -layer.bb.x1;
      var dy = -layer.bb.y1; // do the transform on creation to save cycles (it's the same for all eles)
  
      cxt.scale(scale, scale);
      cxt.translate(dx, dy);
      return layer;
    };
  
    LTCp.getLayers = function (eles, pxRatio, lvl) {
      var self = this;
      var r = self.renderer;
      var cy = r.cy;
      var zoom = cy.zoom();
      var firstGet = self.firstGet;
      self.firstGet = false; // log('--\nget layers with %s eles', eles.length);
      //log eles.map(function(ele){ return ele.id() }) );
  
      if (lvl == null) {
        lvl = Math.ceil(log2(zoom * pxRatio));
  
        if (lvl < minLvl$1) {
          lvl = minLvl$1;
        } else if (zoom >= maxZoom$1 || lvl > maxLvl$1) {
          return null;
        }
      }
  
      self.validateLayersElesOrdering(lvl, eles);
      var layersByLvl = self.layersByLevel;
      var scale = Math.pow(2, lvl);
      var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];
      var bb;
      var lvlComplete = self.levelIsComplete(lvl, eles);
      var tmpLayers;
  
      var checkTempLevels = function checkTempLevels() {
        var canUseAsTmpLvl = function canUseAsTmpLvl(l) {
          self.validateLayersElesOrdering(l, eles);
  
          if (self.levelIsComplete(l, eles)) {
            tmpLayers = layersByLvl[l];
            return true;
          }
        };
  
        var checkLvls = function checkLvls(dir) {
          if (tmpLayers) {
            return;
          }
  
          for (var l = lvl + dir; minLvl$1 <= l && l <= maxLvl$1; l += dir) {
            if (canUseAsTmpLvl(l)) {
              break;
            }
          }
        };
  
        checkLvls(+1);
        checkLvls(-1); // remove the invalid layers; they will be replaced as needed later in this function
  
        for (var i = layers.length - 1; i >= 0; i--) {
          var layer = layers[i];
  
          if (layer.invalid) {
            removeFromArray(layers, layer);
          }
        }
      };
  
      if (!lvlComplete) {
        // if the current level is incomplete, then use the closest, best quality layerset temporarily
        // and later queue the current layerset so we can get the proper quality level soon
        checkTempLevels();
      } else {
        // log('level complete, using existing layers\n--');
        return layers;
      }
  
      var getBb = function getBb() {
        if (!bb) {
          bb = makeBoundingBox();
  
          for (var i = 0; i < eles.length; i++) {
            updateBoundingBox(bb, eles[i].boundingBox());
          }
        }
  
        return bb;
      };
  
      var makeLayer = function makeLayer(opts) {
        opts = opts || {};
        var after = opts.after;
        getBb();
        var area = bb.w * scale * (bb.h * scale);
  
        if (area > maxLayerArea) {
          return null;
        }
  
        var layer = self.makeLayer(bb, lvl);
  
        if (after != null) {
          var index = layers.indexOf(after) + 1;
          layers.splice(index, 0, layer);
        } else if (opts.insert === undefined || opts.insert) {
          // no after specified => first layer made so put at start
          layers.unshift(layer);
        } // if( tmpLayers ){
        //self.queueLayer( layer );
        // }
  
  
        return layer;
      };
  
      if (self.skipping && !firstGet) {
        // log('skip layers');
        return null;
      } // log('do layers');
  
  
      var layer = null;
      var maxElesPerLayer = eles.length / defNumLayers;
      var allowLazyQueueing =  !firstGet;
  
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        var rs = ele._private.rscratch;
        var caches = rs.imgLayerCaches = rs.imgLayerCaches || {}; // log('look at ele', ele.id());
  
        var existingLayer = caches[lvl];
  
        if (existingLayer) {
          // reuse layer for later eles
          // log('reuse layer for', ele.id());
          layer = existingLayer;
          continue;
        }
  
        if (!layer || layer.eles.length >= maxElesPerLayer || !boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {
          // log('make new layer for ele %s', ele.id());
          layer = makeLayer({
            insert: true,
            after: layer
          }); // if now layer can be built then we can't use layers at this level
  
          if (!layer) {
            return null;
          } // log('new layer with id %s', layer.id);
  
        }
  
        if (tmpLayers || allowLazyQueueing) {
          // log('queue ele %s in layer %s', ele.id(), layer.id);
          self.queueLayer(layer, ele);
        } else {
          // log('draw ele %s in layer %s', ele.id(), layer.id);
          self.drawEleInLayer(layer, ele, lvl, pxRatio);
        }
  
        layer.eles.push(ele);
        caches[lvl] = layer;
      } // log('--');
  
  
      if (tmpLayers) {
        // then we only queued the current layerset and can't draw it yet
        return tmpLayers;
      }
  
      if (allowLazyQueueing) {
        // log('lazy queue level', lvl);
        return null;
      }
  
      return layers;
    }; // a layer may want to use an ele cache of a higher level to avoid blurriness
    // so the layer level might not equal the ele level
  
  
    LTCp.getEleLevelForLayerLevel = function (lvl, pxRatio) {
      return lvl;
    };
  
    LTCp.drawEleInLayer = function (layer, ele, lvl, pxRatio) {
      var self = this;
      var r = this.renderer;
      var context = layer.context;
      var bb = ele.boundingBox();
  
      if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
        return;
      }
  
      lvl = self.getEleLevelForLayerLevel(lvl, pxRatio);
  
      {
        r.setImgSmoothing(context, false);
      }
  
      {
        r.drawCachedElement(context, ele, null, null, lvl, useHighQualityEleTxrReqs);
      }
  
      {
        r.setImgSmoothing(context, true);
      }
    };
  
    LTCp.levelIsComplete = function (lvl, eles) {
      var self = this;
      var layers = self.layersByLevel[lvl];
  
      if (!layers || layers.length === 0) {
        return false;
      }
  
      var numElesInLayers = 0;
  
      for (var i = 0; i < layers.length; i++) {
        var layer = layers[i]; // if there are any eles needed to be drawn yet, the level is not complete
  
        if (layer.reqs > 0) {
          return false;
        } // if the layer is invalid, the level is not complete
  
  
        if (layer.invalid) {
          return false;
        }
  
        numElesInLayers += layer.eles.length;
      } // we should have exactly the number of eles passed in to be complete
  
  
      if (numElesInLayers !== eles.length) {
        return false;
      }
  
      return true;
    };
  
    LTCp.validateLayersElesOrdering = function (lvl, eles) {
      var layers = this.layersByLevel[lvl];
  
      if (!layers) {
        return;
      } // if in a layer the eles are not in the same order, then the layer is invalid
      // (i.e. there is an ele in between the eles in the layer)
  
  
      for (var i = 0; i < layers.length; i++) {
        var layer = layers[i];
        var offset = -1; // find the offset
  
        for (var j = 0; j < eles.length; j++) {
          if (layer.eles[0] === eles[j]) {
            offset = j;
            break;
          }
        }
  
        if (offset < 0) {
          // then the layer has nonexistant elements and is invalid
          this.invalidateLayer(layer);
          continue;
        } // the eles in the layer must be in the same continuous order, else the layer is invalid
  
  
        var o = offset;
  
        for (var j = 0; j < layer.eles.length; j++) {
          if (layer.eles[j] !== eles[o + j]) {
            // log('invalidate based on ordering', layer.id);
            this.invalidateLayer(layer);
            break;
          }
        }
      }
    };
  
    LTCp.updateElementsInLayers = function (eles, update) {
      var self = this;
      var isEles = element(eles[0]); // collect udpated elements (cascaded from the layers) and update each
      // layer itself along the way
  
      for (var i = 0; i < eles.length; i++) {
        var req = isEles ? null : eles[i];
        var ele = isEles ? eles[i] : eles[i].ele;
        var rs = ele._private.rscratch;
        var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};
  
        for (var l = minLvl$1; l <= maxLvl$1; l++) {
          var layer = caches[l];
  
          if (!layer) {
            continue;
          } // if update is a request from the ele cache, then it affects only
          // the matching level
  
  
          if (req && self.getEleLevelForLayerLevel(layer.level) !== req.level) {
            continue;
          }
  
          update(layer, ele, req);
        }
      }
    };
  
    LTCp.haveLayers = function () {
      var self = this;
      var haveLayers = false;
  
      for (var l = minLvl$1; l <= maxLvl$1; l++) {
        var layers = self.layersByLevel[l];
  
        if (layers && layers.length > 0) {
          haveLayers = true;
          break;
        }
      }
  
      return haveLayers;
    };
  
    LTCp.invalidateElements = function (eles) {
      var self = this;
  
      if (eles.length === 0) {
        return;
      }
  
      self.lastInvalidationTime = performanceNow(); // log('update invalidate layer time from eles');
  
      if (eles.length === 0 || !self.haveLayers()) {
        return;
      }
  
      self.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {
        self.invalidateLayer(layer);
      });
    };
  
    LTCp.invalidateLayer = function (layer) {
      // log('update invalidate layer time');
      this.lastInvalidationTime = performanceNow();
  
      if (layer.invalid) {
        return;
      } // save cycles
  
  
      var lvl = layer.level;
      var eles = layer.eles;
      var layers = this.layersByLevel[lvl]; // log('invalidate layer', layer.id );
  
      removeFromArray(layers, layer); // layer.eles = [];
  
      layer.elesQueue = [];
      layer.invalid = true;
  
      if (layer.replacement) {
        layer.replacement.invalid = true;
      }
  
      for (var i = 0; i < eles.length; i++) {
        var caches = eles[i]._private.rscratch.imgLayerCaches;
  
        if (caches) {
          caches[lvl] = null;
        }
      }
    };
  
    LTCp.refineElementTextures = function (eles) {
      var self = this; // log('refine', eles.length);
  
      self.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {
        var rLyr = layer.replacement;
  
        if (!rLyr) {
          rLyr = layer.replacement = self.makeLayer(layer.bb, layer.level);
          rLyr.replaces = layer;
          rLyr.eles = layer.eles; // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);
        }
  
        if (!rLyr.reqs) {
          for (var i = 0; i < rLyr.eles.length; i++) {
            self.queueLayer(rLyr, rLyr.eles[i]);
          } // log('queue replacement layer refinement', rLyr.id);
  
        }
      });
    };
  
    LTCp.enqueueElementRefinement = function (ele) {
  
      this.eleTxrDeqs.merge(ele);
      this.scheduleElementRefinement();
    };
  
    LTCp.queueLayer = function (layer, ele) {
      var self = this;
      var q = self.layersQueue;
      var elesQ = layer.elesQueue;
      var hasId = elesQ.hasId = elesQ.hasId || {}; // if a layer is going to be replaced, queuing is a waste of time
  
      if (layer.replacement) {
        return;
      }
  
      if (ele) {
        if (hasId[ele.id()]) {
          return;
        }
  
        elesQ.push(ele);
        hasId[ele.id()] = true;
      }
  
      if (layer.reqs) {
        layer.reqs++;
        q.updateItem(layer);
      } else {
        layer.reqs = 1;
        q.push(layer);
      }
    };
  
    LTCp.dequeue = function (pxRatio) {
      var self = this;
      var q = self.layersQueue;
      var deqd = [];
      var eleDeqs = 0;
  
      while (eleDeqs < maxDeqSize$1) {
        if (q.size() === 0) {
          break;
        }
  
        var layer = q.peek(); // if a layer has been or will be replaced, then don't waste time with it
  
        if (layer.replacement) {
          // log('layer %s in queue skipped b/c it already has a replacement', layer.id);
          q.pop();
          continue;
        } // if this is a replacement layer that has been superceded, then forget it
  
  
        if (layer.replaces && layer !== layer.replaces.replacement) {
          // log('layer is no longer the most uptodate replacement; dequeued', layer.id)
          q.pop();
          continue;
        }
  
        if (layer.invalid) {
          // log('replacement layer %s is invalid; dequeued', layer.id);
          q.pop();
          continue;
        }
  
        var ele = layer.elesQueue.shift();
  
        if (ele) {
          // log('dequeue layer %s', layer.id);
          self.drawEleInLayer(layer, ele, layer.level, pxRatio);
          eleDeqs++;
        }
  
        if (deqd.length === 0) {
          // we need only one entry in deqd to queue redrawing etc
          deqd.push(true);
        } // if the layer has all its eles done, then remove from the queue
  
  
        if (layer.elesQueue.length === 0) {
          q.pop();
          layer.reqs = 0; // log('dequeue of layer %s complete', layer.id);
          // when a replacement layer is dequeued, it replaces the old layer in the level
  
          if (layer.replaces) {
            self.applyLayerReplacement(layer);
          }
  
          self.requestRedraw();
        }
      }
  
      return deqd;
    };
  
    LTCp.applyLayerReplacement = function (layer) {
      var self = this;
      var layersInLevel = self.layersByLevel[layer.level];
      var replaced = layer.replaces;
      var index = layersInLevel.indexOf(replaced); // if the replaced layer is not in the active list for the level, then replacing
      // refs would be a mistake (i.e. overwriting the true active layer)
  
      if (index < 0 || replaced.invalid) {
        // log('replacement layer would have no effect', layer.id);
        return;
      }
  
      layersInLevel[index] = layer; // replace level ref
      // replace refs in eles
  
      for (var i = 0; i < layer.eles.length; i++) {
        var _p = layer.eles[i]._private;
        var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};
  
        if (cache) {
          cache[layer.level] = layer;
        }
      } // log('apply replacement layer %s over %s', layer.id, replaced.id);
  
  
      self.requestRedraw();
    };
  
    LTCp.requestRedraw = lodash_debounce(function () {
      var r = this.renderer;
      r.redrawHint('eles', true);
      r.redrawHint('drag', true);
      r.redraw();
    }, 100);
    LTCp.setupDequeueing = defs.setupDequeueing({
      deqRedrawThreshold: deqRedrawThreshold$1,
      deqCost: deqCost$1,
      deqAvgCost: deqAvgCost$1,
      deqNoDrawCost: deqNoDrawCost$1,
      deqFastCost: deqFastCost$1,
      deq: function deq(self, pxRatio) {
        return self.dequeue(pxRatio);
      },
      onDeqd: noop,
      shouldRedraw: trueify,
      priority: function priority(self) {
        return self.renderer.beforeRenderPriorities.lyrTxrDeq;
      }
    });
  
    var CRp = {};
    var impl;
  
    function polygon(context, points) {
      for (var i = 0; i < points.length; i++) {
        var pt = points[i];
        context.lineTo(pt.x, pt.y);
      }
    }
  
    function triangleBackcurve(context, points, controlPoint) {
      var firstPt;
  
      for (var i = 0; i < points.length; i++) {
        var pt = points[i];
  
        if (i === 0) {
          firstPt = pt;
        }
  
        context.lineTo(pt.x, pt.y);
      }
  
      context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);
    }
  
    function triangleTee(context, trianglePoints, teePoints) {
      if (context.beginPath) {
        context.beginPath();
      }
  
      var triPts = trianglePoints;
  
      for (var i = 0; i < triPts.length; i++) {
        var pt = triPts[i];
        context.lineTo(pt.x, pt.y);
      }
  
      var teePts = teePoints;
      var firstTeePt = teePoints[0];
      context.moveTo(firstTeePt.x, firstTeePt.y);
  
      for (var i = 1; i < teePts.length; i++) {
        var pt = teePts[i];
        context.lineTo(pt.x, pt.y);
      }
  
      if (context.closePath) {
        context.closePath();
      }
    }
  
    function circleTriangle(context, trianglePoints, rx, ry, r) {
      if (context.beginPath) {
        context.beginPath();
      }
  
      context.arc(rx, ry, r, 0, Math.PI * 2, false);
      var triPts = trianglePoints;
      var firstTrPt = triPts[0];
      context.moveTo(firstTrPt.x, firstTrPt.y);
  
      for (var i = 0; i < triPts.length; i++) {
        var pt = triPts[i];
        context.lineTo(pt.x, pt.y);
      }
  
      if (context.closePath) {
        context.closePath();
      }
    }
  
    function circle(context, rx, ry, r) {
      context.arc(rx, ry, r, 0, Math.PI * 2, false);
    }
  
    CRp.arrowShapeImpl = function (name) {
      return (impl || (impl = {
        'polygon': polygon,
        'triangle-backcurve': triangleBackcurve,
        'triangle-tee': triangleTee,
        'circle-triangle': circleTriangle,
        'triangle-cross': triangleTee,
        'circle': circle
      }))[name];
    };
  
    var CRp$1 = {};
  
    CRp$1.drawElement = function (context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity) {
      var r = this;
  
      if (ele.isNode()) {
        r.drawNode(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);
      } else {
        r.drawEdge(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);
      }
    };
  
    CRp$1.drawElementOverlay = function (context, ele) {
      var r = this;
  
      if (ele.isNode()) {
        r.drawNodeOverlay(context, ele);
      } else {
        r.drawEdgeOverlay(context, ele);
      }
    };
  
    CRp$1.drawCachedElementPortion = function (context, ele, eleTxrCache, pxRatio, lvl, reason, getRotation, getOpacity) {
      var r = this;
      var bb = eleTxrCache.getBoundingBox(ele);
  
      if (bb.w === 0 || bb.h === 0) {
        return;
      } // ignore zero size case
  
  
      var eleCache = eleTxrCache.getElement(ele, bb, pxRatio, lvl, reason);
  
      if (eleCache != null) {
        var opacity = getOpacity(r, ele);
  
        if (opacity === 0) {
          return;
        }
  
        var theta = getRotation(r, ele);
        var x1 = bb.x1,
            y1 = bb.y1,
            w = bb.w,
            h = bb.h;
        var x, y, sx, sy, smooth;
  
        if (theta !== 0) {
          var rotPt = eleTxrCache.getRotationPoint(ele);
          sx = rotPt.x;
          sy = rotPt.y;
          context.translate(sx, sy);
          context.rotate(theta);
          smooth = r.getImgSmoothing(context);
  
          if (!smooth) {
            r.setImgSmoothing(context, true);
          }
  
          var off = eleTxrCache.getRotationOffset(ele);
          x = off.x;
          y = off.y;
        } else {
          x = x1;
          y = y1;
        }
  
        var oldGlobalAlpha;
  
        if (opacity !== 1) {
          oldGlobalAlpha = context.globalAlpha;
          context.globalAlpha = oldGlobalAlpha * opacity;
        }
  
        context.drawImage(eleCache.texture.canvas, eleCache.x, 0, eleCache.width, eleCache.height, x, y, w, h);
  
        if (opacity !== 1) {
          context.globalAlpha = oldGlobalAlpha;
        }
  
        if (theta !== 0) {
          context.rotate(-theta);
          context.translate(-sx, -sy);
  
          if (!smooth) {
            r.setImgSmoothing(context, false);
          }
        }
      } else {
        eleTxrCache.drawElement(context, ele); // direct draw fallback
      }
    };
  
    var getZeroRotation = function getZeroRotation() {
      return 0;
    };
  
    var getLabelRotation = function getLabelRotation(r, ele) {
      return r.getTextAngle(ele, null);
    };
  
    var getSourceLabelRotation = function getSourceLabelRotation(r, ele) {
      return r.getTextAngle(ele, 'source');
    };
  
    var getTargetLabelRotation = function getTargetLabelRotation(r, ele) {
      return r.getTextAngle(ele, 'target');
    };
  
    var getOpacity = function getOpacity(r, ele) {
      return ele.effectiveOpacity();
    };
  
    var getTextOpacity = function getTextOpacity(e, ele) {
      return ele.pstyle('text-opacity').pfValue * ele.effectiveOpacity();
    };
  
    CRp$1.drawCachedElement = function (context, ele, pxRatio, extent, lvl, requestHighQuality) {
      var r = this;
      var _r$data = r.data,
          eleTxrCache = _r$data.eleTxrCache,
          lblTxrCache = _r$data.lblTxrCache,
          slbTxrCache = _r$data.slbTxrCache,
          tlbTxrCache = _r$data.tlbTxrCache;
      var bb = ele.boundingBox();
      var reason = requestHighQuality === true ? eleTxrCache.reasons.highQuality : null;
  
      if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
        return;
      }
  
      if (!extent || boundingBoxesIntersect(bb, extent)) {
        var isEdge = ele.isEdge();
  
        var badLine = ele.element()._private.rscratch.badLine;
  
        r.drawCachedElementPortion(context, ele, eleTxrCache, pxRatio, lvl, reason, getZeroRotation, getOpacity);
  
        if (!isEdge || !badLine) {
          r.drawCachedElementPortion(context, ele, lblTxrCache, pxRatio, lvl, reason, getLabelRotation, getTextOpacity);
        }
  
        if (isEdge && !badLine) {
          r.drawCachedElementPortion(context, ele, slbTxrCache, pxRatio, lvl, reason, getSourceLabelRotation, getTextOpacity);
          r.drawCachedElementPortion(context, ele, tlbTxrCache, pxRatio, lvl, reason, getTargetLabelRotation, getTextOpacity);
        }
  
        r.drawElementOverlay(context, ele);
      }
    };
  
    CRp$1.drawElements = function (context, eles) {
      var r = this;
  
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        r.drawElement(context, ele);
      }
    };
  
    CRp$1.drawCachedElements = function (context, eles, pxRatio, extent) {
      var r = this;
  
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        r.drawCachedElement(context, ele, pxRatio, extent);
      }
    };
  
    CRp$1.drawCachedNodes = function (context, eles, pxRatio, extent) {
      var r = this;
  
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
  
        if (!ele.isNode()) {
          continue;
        }
  
        r.drawCachedElement(context, ele, pxRatio, extent);
      }
    };
  
    CRp$1.drawLayeredElements = function (context, eles, pxRatio, extent) {
      var r = this;
      var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);
  
      if (layers) {
        for (var i = 0; i < layers.length; i++) {
          var layer = layers[i];
          var bb = layer.bb;
  
          if (bb.w === 0 || bb.h === 0) {
            continue;
          }
  
          context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);
        }
      } else {
        // fall back on plain caching if no layers
        r.drawCachedElements(context, eles, pxRatio, extent);
      }
    };
  
    /* global Path2D */
    var CRp$2 = {};
  
    CRp$2.drawEdge = function (context, edge, shiftToOriginWithBb) {
      var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
      var r = this;
      var rs = edge._private.rscratch;
  
      if (shouldDrawOpacity && !edge.visible()) {
        return;
      } // if bezier ctrl pts can not be calculated, then die
  
  
      if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {
        // isNaN in case edge is impossible and browser bugs (e.g. safari)
        return;
      }
  
      var bb;
  
      if (shiftToOriginWithBb) {
        bb = shiftToOriginWithBb;
        context.translate(-bb.x1, -bb.y1);
      }
  
      var opacity = shouldDrawOpacity ? edge.pstyle('opacity').value : 1;
      var lineStyle = edge.pstyle('line-style').value;
      var edgeWidth = edge.pstyle('width').pfValue;
      var lineCap = edge.pstyle('line-cap').value;
  
      var drawLine = function drawLine() {
        var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;
        context.lineWidth = edgeWidth;
        context.lineCap = lineCap;
        r.eleStrokeStyle(context, edge, strokeOpacity);
        r.drawEdgePath(edge, context, rs.allpts, lineStyle);
        context.lineCap = 'butt'; // reset for other drawing functions
      };
  
      var drawOverlay = function drawOverlay() {
        if (!shouldDrawOverlay) {
          return;
        }
  
        r.drawEdgeOverlay(context, edge);
      };
  
      var drawArrows = function drawArrows() {
        var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;
        r.drawArrowheads(context, edge, arrowOpacity);
      };
  
      var drawText = function drawText() {
        r.drawElementText(context, edge, null, drawLabel);
      };
  
      context.lineJoin = 'round';
      var ghost = edge.pstyle('ghost').value === 'yes';
  
      if (ghost) {
        var gx = edge.pstyle('ghost-offset-x').pfValue;
        var gy = edge.pstyle('ghost-offset-y').pfValue;
        var ghostOpacity = edge.pstyle('ghost-opacity').value;
        var effectiveGhostOpacity = opacity * ghostOpacity;
        context.translate(gx, gy);
        drawLine(effectiveGhostOpacity);
        drawArrows(effectiveGhostOpacity);
        context.translate(-gx, -gy);
      }
  
      drawLine();
      drawArrows();
      drawOverlay();
      drawText();
  
      if (shiftToOriginWithBb) {
        context.translate(bb.x1, bb.y1);
      }
    };
  
    CRp$2.drawEdgeOverlay = function (context, edge) {
      if (!edge.visible()) {
        return;
      }
  
      var overlayOpacity = edge.pstyle('overlay-opacity').value;
  
      if (overlayOpacity === 0) {
        return;
      }
  
      var r = this;
      var usePaths = r.usePaths();
      var rs = edge._private.rscratch;
      var overlayPadding = edge.pstyle('overlay-padding').pfValue;
      var overlayWidth = 2 * overlayPadding;
      var overlayColor = edge.pstyle('overlay-color').value;
      context.lineWidth = overlayWidth;
  
      if (rs.edgeType === 'self' && !usePaths) {
        context.lineCap = 'butt';
      } else {
        context.lineCap = 'round';
      }
  
      r.colorStrokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
      r.drawEdgePath(edge, context, rs.allpts, 'solid');
    };
  
    CRp$2.drawEdgePath = function (edge, context, pts, type) {
      var rs = edge._private.rscratch;
      var canvasCxt = context;
      var path;
      var pathCacheHit = false;
      var usePaths = this.usePaths();
      var lineDashPattern = edge.pstyle('line-dash-pattern').pfValue;
      var lineDashOffset = edge.pstyle('line-dash-offset').pfValue;
  
      if (usePaths) {
        var pathCacheKey = pts.join('$');
        var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;
  
        if (keyMatches) {
          path = context = rs.pathCache;
          pathCacheHit = true;
        } else {
          path = context = new Path2D();
          rs.pathCacheKey = pathCacheKey;
          rs.pathCache = path;
        }
      }
  
      if (canvasCxt.setLineDash) {
        // for very outofdate browsers
        switch (type) {
          case 'dotted':
            canvasCxt.setLineDash([1, 1]);
            break;
  
          case 'dashed':
            canvasCxt.setLineDash(lineDashPattern);
            canvasCxt.lineDashOffset = lineDashOffset;
            break;
  
          case 'solid':
            canvasCxt.setLineDash([]);
            break;
        }
      }
  
      if (!pathCacheHit && !rs.badLine) {
        if (context.beginPath) {
          context.beginPath();
        }
  
        context.moveTo(pts[0], pts[1]);
  
        switch (rs.edgeType) {
          case 'bezier':
          case 'self':
          case 'compound':
          case 'multibezier':
            for (var i = 2; i + 3 < pts.length; i += 4) {
              context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);
            }
  
            break;
  
          case 'straight':
          case 'segments':
          case 'haystack':
            for (var _i = 2; _i + 1 < pts.length; _i += 2) {
              context.lineTo(pts[_i], pts[_i + 1]);
            }
  
            break;
        }
      }
  
      context = canvasCxt;
  
      if (usePaths) {
        context.stroke(path);
      } else {
        context.stroke();
      } // reset any line dashes
  
  
      if (context.setLineDash) {
        // for very outofdate browsers
        context.setLineDash([]);
      }
    };
  
    CRp$2.drawArrowheads = function (context, edge, opacity) {
      var rs = edge._private.rscratch;
      var isHaystack = rs.edgeType === 'haystack';
  
      if (!isHaystack) {
        this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);
      }
  
      this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);
      this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);
  
      if (!isHaystack) {
        this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);
      }
    };
  
    CRp$2.drawArrowhead = function (context, edge, prefix, x, y, angle, opacity) {
      if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {
        return;
      }
  
      var self = this;
      var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;
  
      if (arrowShape === 'none') {
        return;
      }
  
      var arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';
      var arrowFill = edge.pstyle(prefix + '-arrow-fill').value;
      var edgeWidth = edge.pstyle('width').pfValue;
      var edgeOpacity = edge.pstyle('opacity').value;
  
      if (opacity === undefined) {
        opacity = edgeOpacity;
      }
  
      var gco = context.globalCompositeOperation;
  
      if (opacity !== 1 || arrowFill === 'hollow') {
        // then extra clear is needed
        context.globalCompositeOperation = 'destination-out';
        self.colorFillStyle(context, 255, 255, 255, 1);
        self.colorStrokeStyle(context, 255, 255, 255, 1);
        self.drawArrowShape(edge, context, arrowClearFill, edgeWidth, arrowShape, x, y, angle);
        context.globalCompositeOperation = gco;
      } // otherwise, the opaque arrow clears it for free :)
  
  
      var color = edge.pstyle(prefix + '-arrow-color').value;
      self.colorFillStyle(context, color[0], color[1], color[2], opacity);
      self.colorStrokeStyle(context, color[0], color[1], color[2], opacity);
      self.drawArrowShape(edge, context, arrowFill, edgeWidth, arrowShape, x, y, angle);
    };
  
    CRp$2.drawArrowShape = function (edge, context, fill, edgeWidth, shape, x, y, angle) {
      var r = this;
      var usePaths = this.usePaths() && shape !== 'triangle-cross';
      var pathCacheHit = false;
      var path;
      var canvasContext = context;
      var translation = {
        x: x,
        y: y
      };
      var scale = edge.pstyle('arrow-scale').value;
      var size = this.getArrowWidth(edgeWidth, scale);
      var shapeImpl = r.arrowShapes[shape];
  
      if (usePaths) {
        var cache = r.arrowPathCache = r.arrowPathCache || [];
        var key = hashString(shape);
        var cachedPath = cache[key];
  
        if (cachedPath != null) {
          path = context = cachedPath;
          pathCacheHit = true;
        } else {
          path = context = new Path2D();
          cache[key] = path;
        }
      }
  
      if (!pathCacheHit) {
        if (context.beginPath) {
          context.beginPath();
        }
  
        if (usePaths) {
          // store in the path cache with values easily manipulated later
          shapeImpl.draw(context, 1, 0, {
            x: 0,
            y: 0
          }, 1);
        } else {
          shapeImpl.draw(context, size, angle, translation, edgeWidth);
        }
  
        if (context.closePath) {
          context.closePath();
        }
      }
  
      context = canvasContext;
  
      if (usePaths) {
        // set transform to arrow position/orientation
        context.translate(x, y);
        context.rotate(angle);
        context.scale(size, size);
      }
  
      if (fill === 'filled' || fill === 'both') {
        if (usePaths) {
          context.fill(path);
        } else {
          context.fill();
        }
      }
  
      if (fill === 'hollow' || fill === 'both') {
        context.lineWidth = (shapeImpl.matchEdgeWidth ? edgeWidth : 1) / (usePaths ? size : 1);
        context.lineJoin = 'miter';
  
        if (usePaths) {
          context.stroke(path);
        } else {
          context.stroke();
        }
      }
  
      if (usePaths) {
        // reset transform by applying inverse
        context.scale(1 / size, 1 / size);
        context.rotate(-angle);
        context.translate(-x, -y);
      }
    };
  
    var CRp$3 = {};
  
    CRp$3.safeDrawImage = function (context, img, ix, iy, iw, ih, x, y, w, h) {
      // detect problematic cases for old browsers with bad images (cheaper than try-catch)
      if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {
        return;
      }
  
      context.drawImage(img, ix, iy, iw, ih, x, y, w, h);
    };
  
    CRp$3.drawInscribedImage = function (context, img, node, index, nodeOpacity) {
      var r = this;
      var pos = node.position();
      var nodeX = pos.x;
      var nodeY = pos.y;
      var styleObj = node.cy().style();
      var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);
      var fit = getIndexedStyle(node, 'background-fit', 'value', index);
      var repeat = getIndexedStyle(node, 'background-repeat', 'value', index);
      var nodeW = node.width();
      var nodeH = node.height();
      var paddingX2 = node.padding() * 2;
      var nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
      var nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
      var rs = node._private.rscratch;
      var clip = getIndexedStyle(node, 'background-clip', 'value', index);
      var shouldClip = clip === 'node';
      var imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;
      var imgW = img.width || img.cachedW;
      var imgH = img.height || img.cachedH; // workaround for broken browsers like ie
  
      if (null == imgW || null == imgH) {
        document.body.appendChild(img); // eslint-disable-line no-undef
  
        imgW = img.cachedW = img.width || img.offsetWidth;
        imgH = img.cachedH = img.height || img.offsetHeight;
        document.body.removeChild(img); // eslint-disable-line no-undef
      }
  
      var w = imgW;
      var h = imgH;
  
      if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {
        if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {
          w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;
        } else {
          w = getIndexedStyle(node, 'background-width', 'pfValue', index);
        }
      }
  
      if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {
        if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {
          h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;
        } else {
          h = getIndexedStyle(node, 'background-height', 'pfValue', index);
        }
      }
  
      if (w === 0 || h === 0) {
        return; // no point in drawing empty image (and chrome is broken in this case)
      }
  
      if (fit === 'contain') {
        var scale = Math.min(nodeTW / w, nodeTH / h);
        w *= scale;
        h *= scale;
      } else if (fit === 'cover') {
        var scale = Math.max(nodeTW / w, nodeTH / h);
        w *= scale;
        h *= scale;
      }
  
      var x = nodeX - nodeTW / 2; // left
  
      var posXUnits = getIndexedStyle(node, 'background-position-x', 'units', index);
      var posXPfVal = getIndexedStyle(node, 'background-position-x', 'pfValue', index);
  
      if (posXUnits === '%') {
        x += (nodeTW - w) * posXPfVal;
      } else {
        x += posXPfVal;
      }
  
      var offXUnits = getIndexedStyle(node, 'background-offset-x', 'units', index);
      var offXPfVal = getIndexedStyle(node, 'background-offset-x', 'pfValue', index);
  
      if (offXUnits === '%') {
        x += (nodeTW - w) * offXPfVal;
      } else {
        x += offXPfVal;
      }
  
      var y = nodeY - nodeTH / 2; // top
  
      var posYUnits = getIndexedStyle(node, 'background-position-y', 'units', index);
      var posYPfVal = getIndexedStyle(node, 'background-position-y', 'pfValue', index);
  
      if (posYUnits === '%') {
        y += (nodeTH - h) * posYPfVal;
      } else {
        y += posYPfVal;
      }
  
      var offYUnits = getIndexedStyle(node, 'background-offset-y', 'units', index);
      var offYPfVal = getIndexedStyle(node, 'background-offset-y', 'pfValue', index);
  
      if (offYUnits === '%') {
        y += (nodeTH - h) * offYPfVal;
      } else {
        y += offYPfVal;
      }
  
      if (rs.pathCache) {
        x -= nodeX;
        y -= nodeY;
        nodeX = 0;
        nodeY = 0;
      }
  
      var gAlpha = context.globalAlpha;
      context.globalAlpha = imgOpacity;
  
      if (repeat === 'no-repeat') {
        if (shouldClip) {
          context.save();
  
          if (rs.pathCache) {
            context.clip(rs.pathCache);
          } else {
            r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);
            context.clip();
          }
        }
  
        r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);
  
        if (shouldClip) {
          context.restore();
        }
      } else {
        var pattern = context.createPattern(img, repeat);
        context.fillStyle = pattern;
        r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);
        context.translate(x, y);
        context.fill();
        context.translate(-x, -y);
      }
  
      context.globalAlpha = gAlpha;
    };
  
    var CRp$4 = {};
  
    CRp$4.eleTextBiggerThanMin = function (ele, scale) {
      if (!scale) {
        var zoom = ele.cy().zoom();
        var pxRatio = this.getPixelRatio();
        var lvl = Math.ceil(log2(zoom * pxRatio)); // the effective texture level
  
        scale = Math.pow(2, lvl);
      }
  
      var computedSize = ele.pstyle('font-size').pfValue * scale;
      var minSize = ele.pstyle('min-zoomed-font-size').pfValue;
  
      if (computedSize < minSize) {
        return false;
      }
  
      return true;
    };
  
    CRp$4.drawElementText = function (context, ele, shiftToOriginWithBb, force, prefix) {
      var useEleOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
      var r = this;
  
      if (force == null) {
        if (useEleOpacity && !r.eleTextBiggerThanMin(ele)) {
          return;
        }
      } else if (force === false) {
        return;
      }
  
      if (ele.isNode()) {
        var label = ele.pstyle('label');
  
        if (!label || !label.value) {
          return;
        }
  
        var justification = r.getLabelJustification(ele);
        context.textAlign = justification;
        context.textBaseline = 'bottom';
      } else {
        var badLine = ele.element()._private.rscratch.badLine;
  
        var _label = ele.pstyle('label');
  
        var srcLabel = ele.pstyle('source-label');
        var tgtLabel = ele.pstyle('target-label');
  
        if (badLine || (!_label || !_label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {
          return;
        }
  
        context.textAlign = 'center';
        context.textBaseline = 'bottom';
      }
  
      var applyRotation = !shiftToOriginWithBb;
      var bb;
  
      if (shiftToOriginWithBb) {
        bb = shiftToOriginWithBb;
        context.translate(-bb.x1, -bb.y1);
      }
  
      if (prefix == null) {
        r.drawText(context, ele, null, applyRotation, useEleOpacity);
  
        if (ele.isEdge()) {
          r.drawText(context, ele, 'source', applyRotation, useEleOpacity);
          r.drawText(context, ele, 'target', applyRotation, useEleOpacity);
        }
      } else {
        r.drawText(context, ele, prefix, applyRotation, useEleOpacity);
      }
  
      if (shiftToOriginWithBb) {
        context.translate(bb.x1, bb.y1);
      }
    };
  
    CRp$4.getFontCache = function (context) {
      var cache;
      this.fontCaches = this.fontCaches || [];
  
      for (var i = 0; i < this.fontCaches.length; i++) {
        cache = this.fontCaches[i];
  
        if (cache.context === context) {
          return cache;
        }
      }
  
      cache = {
        context: context
      };
      this.fontCaches.push(cache);
      return cache;
    }; // set up canvas context with font
    // returns transformed text string
  
  
    CRp$4.setupTextStyle = function (context, ele) {
      var useEleOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      // Font style
      var labelStyle = ele.pstyle('font-style').strValue;
      var labelSize = ele.pstyle('font-size').pfValue + 'px';
      var labelFamily = ele.pstyle('font-family').strValue;
      var labelWeight = ele.pstyle('font-weight').strValue;
      var opacity = useEleOpacity ? ele.effectiveOpacity() * ele.pstyle('text-opacity').value : 1;
      var outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;
      var color = ele.pstyle('color').value;
      var outlineColor = ele.pstyle('text-outline-color').value;
      context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;
      context.lineJoin = 'round'; // so text outlines aren't jagged
  
      this.colorFillStyle(context, color[0], color[1], color[2], opacity);
      this.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);
    }; // TODO ensure re-used
  
  
    function roundRect(ctx, x, y, width, height) {
      var radius = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 5;
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
    }
  
    CRp$4.getTextAngle = function (ele, prefix) {
      var theta;
      var _p = ele._private;
      var rscratch = _p.rscratch;
      var pdash = prefix ? prefix + '-' : '';
      var rotation = ele.pstyle(pdash + 'text-rotation');
      var textAngle = getPrefixedProperty(rscratch, 'labelAngle', prefix);
  
      if (rotation.strValue === 'autorotate') {
        theta = ele.isEdge() ? textAngle : 0;
      } else if (rotation.strValue === 'none') {
        theta = 0;
      } else {
        theta = rotation.pfValue;
      }
  
      return theta;
    };
  
    CRp$4.drawText = function (context, ele, prefix) {
      var applyRotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var useEleOpacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      var _p = ele._private;
      var rscratch = _p.rscratch;
      var parentOpacity = useEleOpacity ? ele.effectiveOpacity() : 1;
  
      if (useEleOpacity && (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0)) {
        return;
      } // use 'main' as an alias for the main label (i.e. null prefix)
  
  
      if (prefix === 'main') {
        prefix = null;
      }
  
      var textX = getPrefixedProperty(rscratch, 'labelX', prefix);
      var textY = getPrefixedProperty(rscratch, 'labelY', prefix);
      var orgTextX, orgTextY; // used for rotation
  
      var text = this.getLabelText(ele, prefix);
  
      if (text != null && text !== '' && !isNaN(textX) && !isNaN(textY)) {
        this.setupTextStyle(context, ele, useEleOpacity);
        var pdash = prefix ? prefix + '-' : '';
        var textW = getPrefixedProperty(rscratch, 'labelWidth', prefix);
        var textH = getPrefixedProperty(rscratch, 'labelHeight', prefix);
        var marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;
        var marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;
        var isEdge = ele.isEdge();
        var halign = ele.pstyle('text-halign').value;
        var valign = ele.pstyle('text-valign').value;
  
        if (isEdge) {
          halign = 'center';
          valign = 'center';
        }
  
        textX += marginX;
        textY += marginY;
        var theta;
  
        if (!applyRotation) {
          theta = 0;
        } else {
          theta = this.getTextAngle(ele, prefix);
        }
  
        if (theta !== 0) {
          orgTextX = textX;
          orgTextY = textY;
          context.translate(orgTextX, orgTextY);
          context.rotate(theta);
          textX = 0;
          textY = 0;
        }
  
        switch (valign) {
          case 'top':
            break;
  
          case 'center':
            textY += textH / 2;
            break;
  
          case 'bottom':
            textY += textH;
            break;
        }
  
        var backgroundOpacity = ele.pstyle('text-background-opacity').value;
        var borderOpacity = ele.pstyle('text-border-opacity').value;
        var textBorderWidth = ele.pstyle('text-border-width').pfValue;
        var backgroundPadding = ele.pstyle('text-background-padding').pfValue;
  
        if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {
          var bgX = textX - backgroundPadding;
  
          switch (halign) {
            case 'left':
              bgX -= textW;
              break;
  
            case 'center':
              bgX -= textW / 2;
              break;
          }
  
          var bgY = textY - textH - backgroundPadding;
          var bgW = textW + 2 * backgroundPadding;
          var bgH = textH + 2 * backgroundPadding;
  
          if (backgroundOpacity > 0) {
            var textFill = context.fillStyle;
            var textBackgroundColor = ele.pstyle('text-background-color').value;
            context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';
            var styleShape = ele.pstyle('text-background-shape').strValue;
  
            if (styleShape.indexOf('round') === 0) {
              roundRect(context, bgX, bgY, bgW, bgH, 2);
            } else {
              context.fillRect(bgX, bgY, bgW, bgH);
            }
  
            context.fillStyle = textFill;
          }
  
          if (textBorderWidth > 0 && borderOpacity > 0) {
            var textStroke = context.strokeStyle;
            var textLineWidth = context.lineWidth;
            var textBorderColor = ele.pstyle('text-border-color').value;
            var textBorderStyle = ele.pstyle('text-border-style').value;
            context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';
            context.lineWidth = textBorderWidth;
  
            if (context.setLineDash) {
              // for very outofdate browsers
              switch (textBorderStyle) {
                case 'dotted':
                  context.setLineDash([1, 1]);
                  break;
  
                case 'dashed':
                  context.setLineDash([4, 2]);
                  break;
  
                case 'double':
                  context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders
  
                  context.setLineDash([]);
                  break;
  
                case 'solid':
                  context.setLineDash([]);
                  break;
              }
            }
  
            context.strokeRect(bgX, bgY, bgW, bgH);
  
            if (textBorderStyle === 'double') {
              var whiteWidth = textBorderWidth / 2;
              context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);
            }
  
            if (context.setLineDash) {
              // for very outofdate browsers
              context.setLineDash([]);
            }
  
            context.lineWidth = textLineWidth;
            context.strokeStyle = textStroke;
          }
        }
  
        var lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle
  
        if (lineWidth > 0) {
          context.lineWidth = lineWidth;
        }
  
        if (ele.pstyle('text-wrap').value === 'wrap') {
          var lines = getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);
          var lineHeight = getPrefixedProperty(rscratch, 'labelLineHeight', prefix);
          var halfTextW = textW / 2;
          var justification = this.getLabelJustification(ele);
  
          if (justification === 'auto') ; else if (halign === 'left') {
            // auto justification : right
            if (justification === 'left') {
              textX += -textW;
            } else if (justification === 'center') {
              textX += -halfTextW;
            } // else same as auto
  
          } else if (halign === 'center') {
            // auto justfication : center
            if (justification === 'left') {
              textX += -halfTextW;
            } else if (justification === 'right') {
              textX += halfTextW;
            } // else same as auto
  
          } else if (halign === 'right') {
            // auto justification : left
            if (justification === 'center') {
              textX += halfTextW;
            } else if (justification === 'right') {
              textX += textW;
            } // else same as auto
  
          }
  
          switch (valign) {
            case 'top':
              textY -= (lines.length - 1) * lineHeight;
              break;
  
            case 'center':
            case 'bottom':
              textY -= (lines.length - 1) * lineHeight;
              break;
          }
  
          for (var l = 0; l < lines.length; l++) {
            if (lineWidth > 0) {
              context.strokeText(lines[l], textX, textY);
            }
  
            context.fillText(lines[l], textX, textY);
            textY += lineHeight;
          }
        } else {
          if (lineWidth > 0) {
            context.strokeText(text, textX, textY);
          }
  
          context.fillText(text, textX, textY);
        }
  
        if (theta !== 0) {
          context.rotate(-theta);
          context.translate(-orgTextX, -orgTextY);
        }
      }
    };
  
    /* global Path2D */
    var CRp$5 = {};
  
    CRp$5.drawNode = function (context, node, shiftToOriginWithBb) {
      var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
      var r = this;
      var nodeWidth, nodeHeight;
      var _p = node._private;
      var rs = _p.rscratch;
      var pos = node.position();
  
      if (!number(pos.x) || !number(pos.y)) {
        return; // can't draw node with undefined position
      }
  
      if (shouldDrawOpacity && !node.visible()) {
        return;
      }
  
      var eleOpacity = shouldDrawOpacity ? node.effectiveOpacity() : 1;
      var usePaths = r.usePaths();
      var path;
      var pathCacheHit = false;
      var padding = node.padding();
      nodeWidth = node.width() + 2 * padding;
      nodeHeight = node.height() + 2 * padding; //
      // setup shift
  
      var bb;
  
      if (shiftToOriginWithBb) {
        bb = shiftToOriginWithBb;
        context.translate(-bb.x1, -bb.y1);
      } //
      // load bg image
  
  
      var bgImgProp = node.pstyle('background-image');
      var urls = bgImgProp.value;
      var urlDefined = new Array(urls.length);
      var image = new Array(urls.length);
      var numImages = 0;
  
      for (var i = 0; i < urls.length; i++) {
        var url = urls[i];
        var defd = urlDefined[i] = url != null && url !== 'none';
  
        if (defd) {
          var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);
          numImages++; // get image, and if not loaded then ask to redraw when later loaded
  
          image[i] = r.getCachedImage(url, bgImgCrossOrigin, function () {
            _p.backgroundTimestamp = Date.now();
            node.emitAndNotify('background');
          });
        }
      } //
      // setup styles
  
  
      var darkness = node.pstyle('background-blacken').value;
      var borderWidth = node.pstyle('border-width').pfValue;
      var bgOpacity = node.pstyle('background-opacity').value * eleOpacity;
      var borderColor = node.pstyle('border-color').value;
      var borderStyle = node.pstyle('border-style').value;
      var borderOpacity = node.pstyle('border-opacity').value * eleOpacity;
      context.lineJoin = 'miter'; // so borders are square with the node shape
  
      var setupShapeColor = function setupShapeColor() {
        var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;
        r.eleFillStyle(context, node, bgOpy);
      };
  
      var setupBorderColor = function setupBorderColor() {
        var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;
        r.colorStrokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);
      }; //
      // setup shape
  
  
      var styleShape = node.pstyle('shape').strValue;
      var shapePts = node.pstyle('shape-polygon-points').pfValue;
  
      if (usePaths) {
        context.translate(pos.x, pos.y);
        var pathCache = r.nodePathCache = r.nodePathCache || [];
        var key = hashStrings(styleShape === 'polygon' ? styleShape + ',' + shapePts.join(',') : styleShape, '' + nodeHeight, '' + nodeWidth);
        var cachedPath = pathCache[key];
  
        if (cachedPath != null) {
          path = cachedPath;
          pathCacheHit = true;
          rs.pathCache = path;
        } else {
          path = new Path2D();
          pathCache[key] = rs.pathCache = path;
        }
      }
  
      var drawShape = function drawShape() {
        if (!pathCacheHit) {
          var npos = pos;
  
          if (usePaths) {
            npos = {
              x: 0,
              y: 0
            };
          }
  
          r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight);
        }
  
        if (usePaths) {
          context.fill(path);
        } else {
          context.fill();
        }
      };
  
      var drawImages = function drawImages() {
        var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;
        var prevBging = _p.backgrounding;
        var totalCompleted = 0;
  
        for (var _i = 0; _i < image.length; _i++) {
          if (urlDefined[_i] && image[_i].complete && !image[_i].error) {
            totalCompleted++;
            r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);
          }
        }
  
        _p.backgrounding = !(totalCompleted === numImages);
  
        if (prevBging !== _p.backgrounding) {
          // update style b/c :backgrounding state changed
          node.updateStyle(false);
        }
      };
  
      var drawPie = function drawPie() {
        var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eleOpacity;
  
        if (r.hasPie(node)) {
          r.drawPie(context, node, pieOpacity); // redraw/restore path if steps after pie need it
  
          if (redrawShape) {
            if (!usePaths) {
              r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight);
            }
          }
        }
      };
  
      var darken = function darken() {
        var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;
        var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;
        var c = darkness > 0 ? 0 : 255;
  
        if (darkness !== 0) {
          r.colorFillStyle(context, c, c, c, opacity);
  
          if (usePaths) {
            context.fill(path);
          } else {
            context.fill();
          }
        }
      };
  
      var drawBorder = function drawBorder() {
        if (borderWidth > 0) {
          context.lineWidth = borderWidth;
          context.lineCap = 'butt';
  
          if (context.setLineDash) {
            // for very outofdate browsers
            switch (borderStyle) {
              case 'dotted':
                context.setLineDash([1, 1]);
                break;
  
              case 'dashed':
                context.setLineDash([4, 2]);
                break;
  
              case 'solid':
              case 'double':
                context.setLineDash([]);
                break;
            }
          }
  
          if (usePaths) {
            context.stroke(path);
          } else {
            context.stroke();
          }
  
          if (borderStyle === 'double') {
            context.lineWidth = borderWidth / 3;
            var gco = context.globalCompositeOperation;
            context.globalCompositeOperation = 'destination-out';
  
            if (usePaths) {
              context.stroke(path);
            } else {
              context.stroke();
            }
  
            context.globalCompositeOperation = gco;
          } // reset in case we changed the border style
  
  
          if (context.setLineDash) {
            // for very outofdate browsers
            context.setLineDash([]);
          }
        }
      };
  
      var drawOverlay = function drawOverlay() {
        if (shouldDrawOverlay) {
          r.drawNodeOverlay(context, node, pos, nodeWidth, nodeHeight);
        }
      };
  
      var drawText = function drawText() {
        r.drawElementText(context, node, null, drawLabel);
      };
  
      var ghost = node.pstyle('ghost').value === 'yes';
  
      if (ghost) {
        var gx = node.pstyle('ghost-offset-x').pfValue;
        var gy = node.pstyle('ghost-offset-y').pfValue;
        var ghostOpacity = node.pstyle('ghost-opacity').value;
        var effGhostOpacity = ghostOpacity * eleOpacity;
        context.translate(gx, gy);
        setupShapeColor(ghostOpacity * bgOpacity);
        drawShape();
        drawImages(effGhostOpacity);
        drawPie(darkness !== 0 || borderWidth !== 0);
        darken(effGhostOpacity);
        setupBorderColor(ghostOpacity * borderOpacity);
        drawBorder();
        context.translate(-gx, -gy);
      }
  
      setupShapeColor();
      drawShape();
      drawImages();
      drawPie(darkness !== 0 || borderWidth !== 0);
      darken();
      setupBorderColor();
      drawBorder();
  
      if (usePaths) {
        context.translate(-pos.x, -pos.y);
      }
  
      drawText();
      drawOverlay(); //
      // clean up shift
  
      if (shiftToOriginWithBb) {
        context.translate(bb.x1, bb.y1);
      }
    };
  
    CRp$5.drawNodeOverlay = function (context, node, pos, nodeWidth, nodeHeight) {
      var r = this;
  
      if (!node.visible()) {
        return;
      }
  
      var overlayPadding = node.pstyle('overlay-padding').pfValue;
      var overlayOpacity = node.pstyle('overlay-opacity').value;
      var overlayColor = node.pstyle('overlay-color').value;
  
      if (overlayOpacity > 0) {
        pos = pos || node.position();
  
        if (nodeWidth == null || nodeHeight == null) {
          var padding = node.padding();
          nodeWidth = node.width() + 2 * padding;
          nodeHeight = node.height() + 2 * padding;
        }
  
        r.colorFillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
        r.nodeShapes['roundrectangle'].draw(context, pos.x, pos.y, nodeWidth + overlayPadding * 2, nodeHeight + overlayPadding * 2);
        context.fill();
      }
    }; // does the node have at least one pie piece?
  
  
    CRp$5.hasPie = function (node) {
      node = node[0]; // ensure ele ref
  
      return node._private.hasPie;
    };
  
    CRp$5.drawPie = function (context, node, nodeOpacity, pos) {
      node = node[0]; // ensure ele ref
  
      pos = pos || node.position();
      var cyStyle = node.cy().style();
      var pieSize = node.pstyle('pie-size');
      var x = pos.x;
      var y = pos.y;
      var nodeW = node.width();
      var nodeH = node.height();
      var radius = Math.min(nodeW, nodeH) / 2; // must fit in node
  
      var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]
  
      var usePaths = this.usePaths();
  
      if (usePaths) {
        x = 0;
        y = 0;
      }
  
      if (pieSize.units === '%') {
        radius = radius * pieSize.pfValue;
      } else if (pieSize.pfValue !== undefined) {
        radius = pieSize.pfValue / 2;
      }
  
      for (var i = 1; i <= cyStyle.pieBackgroundN; i++) {
        // 1..N
        var size = node.pstyle('pie-' + i + '-background-size').value;
        var color = node.pstyle('pie-' + i + '-background-color').value;
        var opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;
        var percent = size / 100; // map integer range [0, 100] to [0, 1]
        // percent can't push beyond 1
  
        if (percent + lastPercent > 1) {
          percent = 1 - lastPercent;
        }
  
        var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise
  
        var angleDelta = 2 * Math.PI * percent;
        var angleEnd = angleStart + angleDelta; // ignore if
        // - zero size
        // - we're already beyond the full circle
        // - adding the current slice would go beyond the full circle
  
        if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {
          continue;
        }
  
        context.beginPath();
        context.moveTo(x, y);
        context.arc(x, y, radius, angleStart, angleEnd);
        context.closePath();
        this.colorFillStyle(context, color[0], color[1], color[2], opacity);
        context.fill();
        lastPercent += percent;
      }
    };
  
    var CRp$6 = {};
    var motionBlurDelay = 100; // var isFirefox = typeof InstallTrigger !== 'undefined';
  
    CRp$6.getPixelRatio = function () {
      var context = this.data.contexts[0];
  
      if (this.forcedPixelRatio != null) {
        return this.forcedPixelRatio;
      }
  
      var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
      return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef
    };
  
    CRp$6.paintCache = function (context) {
      var caches = this.paintCaches = this.paintCaches || [];
      var needToCreateCache = true;
      var cache;
  
      for (var i = 0; i < caches.length; i++) {
        cache = caches[i];
  
        if (cache.context === context) {
          needToCreateCache = false;
          break;
        }
      }
  
      if (needToCreateCache) {
        cache = {
          context: context
        };
        caches.push(cache);
      }
  
      return cache;
    };
  
    CRp$6.createGradientStyleFor = function (context, shapeStyleName, ele, fill, opacity) {
      var gradientStyle;
      var usePaths = this.usePaths();
      var colors = ele.pstyle(shapeStyleName + '-gradient-stop-colors').value,
          positions = ele.pstyle(shapeStyleName + '-gradient-stop-positions').pfValue;
  
      if (fill === 'radial-gradient') {
        if (ele.isEdge()) {
          var start = ele.sourceEndpoint(),
              end = ele.targetEndpoint(),
              mid = ele.midpoint();
          var d1 = dist(start, mid);
          var d2 = dist(end, mid);
          gradientStyle = context.createRadialGradient(mid.x, mid.y, 0, mid.x, mid.y, Math.max(d1, d2));
        } else {
          var pos = usePaths ? {
            x: 0,
            y: 0
          } : ele.position(),
              width = ele.paddedWidth(),
              height = ele.paddedHeight();
          gradientStyle = context.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(width, height));
        }
      } else {
        if (ele.isEdge()) {
          var _start = ele.sourceEndpoint(),
              _end = ele.targetEndpoint();
  
          gradientStyle = context.createLinearGradient(_start.x, _start.y, _end.x, _end.y);
        } else {
          var _pos = usePaths ? {
            x: 0,
            y: 0
          } : ele.position(),
              _width = ele.paddedWidth(),
              _height = ele.paddedHeight(),
              halfWidth = _width / 2,
              halfHeight = _height / 2;
  
          var direction = ele.pstyle('background-gradient-direction').value;
  
          switch (direction) {
            case 'to-bottom':
              gradientStyle = context.createLinearGradient(_pos.x, _pos.y - halfHeight, _pos.x, _pos.y + halfHeight);
              break;
  
            case 'to-top':
              gradientStyle = context.createLinearGradient(_pos.x, _pos.y + halfHeight, _pos.x, _pos.y - halfHeight);
              break;
  
            case 'to-left':
              gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y, _pos.x - halfWidth, _pos.y);
              break;
  
            case 'to-right':
              gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y, _pos.x + halfWidth, _pos.y);
              break;
  
            case 'to-bottom-right':
            case 'to-right-bottom':
              gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y - halfHeight, _pos.x + halfWidth, _pos.y + halfHeight);
              break;
  
            case 'to-top-right':
            case 'to-right-top':
              gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y + halfHeight, _pos.x + halfWidth, _pos.y - halfHeight);
              break;
  
            case 'to-bottom-left':
            case 'to-left-bottom':
              gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y - halfHeight, _pos.x - halfWidth, _pos.y + halfHeight);
              break;
  
            case 'to-top-left':
            case 'to-left-top':
              gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y + halfHeight, _pos.x - halfWidth, _pos.y - halfHeight);
              break;
          }
        }
      }
  
      if (!gradientStyle) return null; // invalid gradient style
  
      var hasPositions = positions.length === colors.length;
      var length = colors.length;
  
      for (var i = 0; i < length; i++) {
        gradientStyle.addColorStop(hasPositions ? positions[i] : i / (length - 1), 'rgba(' + colors[i][0] + ',' + colors[i][1] + ',' + colors[i][2] + ',' + opacity + ')');
      }
  
      return gradientStyle;
    };
  
    CRp$6.gradientFillStyle = function (context, ele, fill, opacity) {
      var gradientStyle = this.createGradientStyleFor(context, 'background', ele, fill, opacity);
      if (!gradientStyle) return null; // error
  
      context.fillStyle = gradientStyle;
    };
  
    CRp$6.colorFillStyle = function (context, r, g, b, a) {
      context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; // turn off for now, seems context does its own caching
      // var cache = this.paintCache(context);
      // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
      // if( cache.fillStyle !== fillStyle ){
      //   context.fillStyle = cache.fillStyle = fillStyle;
      // }
    };
  
    CRp$6.eleFillStyle = function (context, ele, opacity) {
      var backgroundFill = ele.pstyle('background-fill').value;
  
      if (backgroundFill === 'linear-gradient' || backgroundFill === 'radial-gradient') {
        this.gradientFillStyle(context, ele, backgroundFill, opacity);
      } else {
        var backgroundColor = ele.pstyle('background-color').value;
        this.colorFillStyle(context, backgroundColor[0], backgroundColor[1], backgroundColor[2], opacity);
      }
    };
  
    CRp$6.gradientStrokeStyle = function (context, ele, fill, opacity) {
      var gradientStyle = this.createGradientStyleFor(context, 'line', ele, fill, opacity);
      if (!gradientStyle) return null; // error
  
      context.strokeStyle = gradientStyle;
    };
  
    CRp$6.colorStrokeStyle = function (context, r, g, b, a) {
      context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; // turn off for now, seems context does its own caching
      // var cache = this.paintCache(context);
      // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
      // if( cache.strokeStyle !== strokeStyle ){
      //   context.strokeStyle = cache.strokeStyle = strokeStyle;
      // }
    };
  
    CRp$6.eleStrokeStyle = function (context, ele, opacity) {
      var lineFill = ele.pstyle('line-fill').value;
  
      if (lineFill === 'linear-gradient' || lineFill === 'radial-gradient') {
        this.gradientStrokeStyle(context, ele, lineFill, opacity);
      } else {
        var lineColor = ele.pstyle('line-color').value;
        this.colorStrokeStyle(context, lineColor[0], lineColor[1], lineColor[2], opacity);
      }
    }; // Resize canvas
  
  
    CRp$6.matchCanvasSize = function (container) {
      var r = this;
      var data = r.data;
      var bb = r.findContainerClientCoords();
      var width = bb[2];
      var height = bb[3];
      var pixelRatio = r.getPixelRatio();
      var mbPxRatio = r.motionBlurPxRatio;
  
      if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {
        pixelRatio = mbPxRatio;
      }
  
      var canvasWidth = width * pixelRatio;
      var canvasHeight = height * pixelRatio;
      var canvas;
  
      if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {
        return; // save cycles if same
      }
  
      r.fontCaches = null; // resizing resets the style
  
      var canvasContainer = data.canvasContainer;
      canvasContainer.style.width = width + 'px';
      canvasContainer.style.height = height + 'px';
  
      for (var i = 0; i < r.CANVAS_LAYERS; i++) {
        canvas = data.canvases[i];
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
      }
  
      for (var i = 0; i < r.BUFFER_COUNT; i++) {
        canvas = data.bufferCanvases[i];
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
      }
  
      r.textureMult = 1;
  
      if (pixelRatio <= 1) {
        canvas = data.bufferCanvases[r.TEXTURE_BUFFER];
        r.textureMult = 2;
        canvas.width = canvasWidth * r.textureMult;
        canvas.height = canvasHeight * r.textureMult;
      }
  
      r.canvasWidth = canvasWidth;
      r.canvasHeight = canvasHeight;
    };
  
    CRp$6.renderTo = function (cxt, zoom, pan, pxRatio) {
      this.render({
        forcedContext: cxt,
        forcedZoom: zoom,
        forcedPan: pan,
        drawAllLayers: true,
        forcedPxRatio: pxRatio
      });
    };
  
    CRp$6.render = function (options) {
      options = options || staticEmptyObject();
      var forcedContext = options.forcedContext;
      var drawAllLayers = options.drawAllLayers;
      var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
      var forcedZoom = options.forcedZoom;
      var forcedPan = options.forcedPan;
      var r = this;
      var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
      var cy = r.cy;
      var data = r.data;
      var needDraw = data.canvasNeedsRedraw;
      var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
      var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
      var mbPxRatio = r.motionBlurPxRatio;
      var hasCompoundNodes = cy.hasCompoundNodes();
      var inNodeDragGesture = r.hoverData.draggingEles;
      var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
      motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
      var motionBlurFadeEffect = motionBlur;
  
      if (!forcedContext) {
        if (r.prevPxRatio !== pixelRatio) {
          r.invalidateContainerClientCoordsCache();
          r.matchCanvasSize(r.container);
          r.redrawHint('eles', true);
          r.redrawHint('drag', true);
        }
  
        r.prevPxRatio = pixelRatio;
      }
  
      if (!forcedContext && r.motionBlurTimeout) {
        clearTimeout(r.motionBlurTimeout);
      }
  
      if (motionBlur) {
        if (r.mbFrames == null) {
          r.mbFrames = 0;
        }
  
        r.mbFrames++;
  
        if (r.mbFrames < 3) {
          // need several frames before even high quality motionblur
          motionBlurFadeEffect = false;
        } // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)
  
  
        if (r.mbFrames > r.minMbLowQualFrames) {
          //r.fullQualityMb = false;
          r.motionBlurPxRatio = r.mbPxRBlurry;
        }
      }
  
      if (r.clearingMotionBlur) {
        r.motionBlurPxRatio = 1;
      } // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
      // because a rogue async texture frame would clear needDraw
  
  
      if (r.textureDrawLastFrame && !textureDraw) {
        needDraw[r.NODE] = true;
        needDraw[r.SELECT_BOX] = true;
      }
  
      var style = cy.style();
      var zoom = cy.zoom();
      var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
      var pan = cy.pan();
      var effectivePan = {
        x: pan.x,
        y: pan.y
      };
      var vp = {
        zoom: zoom,
        pan: {
          x: pan.x,
          y: pan.y
        }
      };
      var prevVp = r.prevViewport;
      var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y; // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)
  
      if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {
        r.motionBlurPxRatio = 1;
      }
  
      if (forcedPan) {
        effectivePan = forcedPan;
      } // apply pixel ratio
  
  
      effectiveZoom *= pixelRatio;
      effectivePan.x *= pixelRatio;
      effectivePan.y *= pixelRatio;
      var eles = r.getCachedZSortedEles();
  
      function mbclear(context, x, y, w, h) {
        var gco = context.globalCompositeOperation;
        context.globalCompositeOperation = 'destination-out';
        r.colorFillStyle(context, 255, 255, 255, r.motionBlurTransparency);
        context.fillRect(x, y, w, h);
        context.globalCompositeOperation = gco;
      }
  
      function setContextTransform(context, clear) {
        var ePan, eZoom, w, h;
  
        if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {
          ePan = {
            x: pan.x * mbPxRatio,
            y: pan.y * mbPxRatio
          };
          eZoom = zoom * mbPxRatio;
          w = r.canvasWidth * mbPxRatio;
          h = r.canvasHeight * mbPxRatio;
        } else {
          ePan = effectivePan;
          eZoom = effectiveZoom;
          w = r.canvasWidth;
          h = r.canvasHeight;
        }
  
        context.setTransform(1, 0, 0, 1, 0, 0);
  
        if (clear === 'motionBlur') {
          mbclear(context, 0, 0, w, h);
        } else if (!forcedContext && (clear === undefined || clear)) {
          context.clearRect(0, 0, w, h);
        }
  
        if (!drawAllLayers) {
          context.translate(ePan.x, ePan.y);
          context.scale(eZoom, eZoom);
        }
  
        if (forcedPan) {
          context.translate(forcedPan.x, forcedPan.y);
        }
  
        if (forcedZoom) {
          context.scale(forcedZoom, forcedZoom);
        }
      }
  
      if (!textureDraw) {
        r.textureDrawLastFrame = false;
      }
  
      if (textureDraw) {
        r.textureDrawLastFrame = true;
  
        if (!r.textureCache) {
          r.textureCache = {};
          r.textureCache.bb = cy.mutableElements().boundingBox();
          r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];
          var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];
          cxt.setTransform(1, 0, 0, 1, 0, 0);
          cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);
          r.render({
            forcedContext: cxt,
            drawOnlyNodeLayer: true,
            forcedPxRatio: pixelRatio * r.textureMult
          });
          var vp = r.textureCache.viewport = {
            zoom: cy.zoom(),
            pan: cy.pan(),
            width: r.canvasWidth,
            height: r.canvasHeight
          };
          vp.mpan = {
            x: (0 - vp.pan.x) / vp.zoom,
            y: (0 - vp.pan.y) / vp.zoom
          };
        }
  
        needDraw[r.DRAG] = false;
        needDraw[r.NODE] = false;
        var context = data.contexts[r.NODE];
        var texture = r.textureCache.texture;
        var vp = r.textureCache.viewport;
        context.setTransform(1, 0, 0, 1, 0, 0);
  
        if (motionBlur) {
          mbclear(context, 0, 0, vp.width, vp.height);
        } else {
          context.clearRect(0, 0, vp.width, vp.height);
        }
  
        var outsideBgColor = style.core('outside-texture-bg-color').value;
        var outsideBgOpacity = style.core('outside-texture-bg-opacity').value;
        r.colorFillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);
        context.fillRect(0, 0, vp.width, vp.height);
        var zoom = cy.zoom();
        setContextTransform(context, false);
        context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
        context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
      } else if (r.textureOnViewport && !forcedContext) {
        // clear the cache since we don't need it
        r.textureCache = null;
      }
  
      var extent = cy.extent();
      var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles || r.cy.animated();
      var hideEdges = r.hideEdgesOnViewport && vpManip;
      var needMbClear = [];
      needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;
  
      if (needMbClear[r.NODE]) {
        r.clearedForMotionBlur[r.NODE] = true;
      }
  
      needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;
  
      if (needMbClear[r.DRAG]) {
        r.clearedForMotionBlur[r.DRAG] = true;
      }
  
      if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {
        var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;
        var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);
        var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;
        setContextTransform(context, clear);
  
        if (hideEdges) {
          r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);
        } else {
          r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);
        }
  
        if (r.debug) {
          r.drawDebugPoints(context, eles.nondrag);
        }
  
        if (!drawAllLayers && !motionBlur) {
          needDraw[r.NODE] = false;
        }
      }
  
      if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {
        var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;
        var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);
        setContextTransform(context, motionBlur && !useBuffer ? 'motionBlur' : undefined);
  
        if (hideEdges) {
          r.drawCachedNodes(context, eles.drag, pixelRatio, extent);
        } else {
          r.drawCachedElements(context, eles.drag, pixelRatio, extent);
        }
  
        if (r.debug) {
          r.drawDebugPoints(context, eles.drag);
        }
  
        if (!drawAllLayers && !motionBlur) {
          needDraw[r.DRAG] = false;
        }
      }
  
      if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {
        var context = forcedContext || data.contexts[r.SELECT_BOX];
        setContextTransform(context);
  
        if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {
          var zoom = r.cy.zoom();
          var borderWidth = style.core('selection-box-border-width').value / zoom;
          context.lineWidth = borderWidth;
          context.fillStyle = 'rgba(' + style.core('selection-box-color').value[0] + ',' + style.core('selection-box-color').value[1] + ',' + style.core('selection-box-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';
          context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);
  
          if (borderWidth > 0) {
            context.strokeStyle = 'rgba(' + style.core('selection-box-border-color').value[0] + ',' + style.core('selection-box-border-color').value[1] + ',' + style.core('selection-box-border-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';
            context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);
          }
        }
  
        if (data.bgActivePosistion && !r.hoverData.selecting) {
          var zoom = r.cy.zoom();
          var pos = data.bgActivePosistion;
          context.fillStyle = 'rgba(' + style.core('active-bg-color').value[0] + ',' + style.core('active-bg-color').value[1] + ',' + style.core('active-bg-color').value[2] + ',' + style.core('active-bg-opacity').value + ')';
          context.beginPath();
          context.arc(pos.x, pos.y, style.core('active-bg-size').pfValue / zoom, 0, 2 * Math.PI);
          context.fill();
        }
  
        var timeToRender = r.lastRedrawTime;
  
        if (r.showFps && timeToRender) {
          timeToRender = Math.round(timeToRender);
          var fps = Math.round(1000 / timeToRender);
          context.setTransform(1, 0, 0, 1, 0, 0);
          context.fillStyle = 'rgba(255, 0, 0, 0.75)';
          context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
          context.lineWidth = 1;
          context.fillText('1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);
          var maxFps = 60;
          context.strokeRect(0, 30, 250, 20);
          context.fillRect(0, 30, 250 * Math.min(fps / maxFps, 1), 20);
        }
  
        if (!drawAllLayers) {
          needDraw[r.SELECT_BOX] = false;
        }
      } // motionblur: blit rendered blurry frames
  
  
      if (motionBlur && mbPxRatio !== 1) {
        var cxtNode = data.contexts[r.NODE];
        var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];
        var cxtDrag = data.contexts[r.DRAG];
        var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];
  
        var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {
          cxt.setTransform(1, 0, 0, 1, 0, 0);
  
          if (needClear || !motionBlurFadeEffect) {
            cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);
          } else {
            mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);
          }
  
          var pxr = mbPxRatio;
          cxt.drawImage(txt, // img
          0, 0, // sx, sy
          r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
          0, 0, // x, y
          r.canvasWidth, r.canvasHeight // w, h
          );
        };
  
        if (needDraw[r.NODE] || needMbClear[r.NODE]) {
          drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);
          needDraw[r.NODE] = false;
        }
  
        if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {
          drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);
          needDraw[r.DRAG] = false;
        }
      }
  
      r.prevViewport = vp;
  
      if (r.clearingMotionBlur) {
        r.clearingMotionBlur = false;
        r.motionBlurCleared = true;
        r.motionBlur = true;
      }
  
      if (motionBlur) {
        r.motionBlurTimeout = setTimeout(function () {
          r.motionBlurTimeout = null;
          r.clearedForMotionBlur[r.NODE] = false;
          r.clearedForMotionBlur[r.DRAG] = false;
          r.motionBlur = false;
          r.clearingMotionBlur = !textureDraw;
          r.mbFrames = 0;
          needDraw[r.NODE] = true;
          needDraw[r.DRAG] = true;
          r.redraw();
        }, motionBlurDelay);
      }
  
      if (!forcedContext) {
        cy.emit('render');
      }
    };
  
    var CRp$7 = {}; // @O Polygon drawing
  
    CRp$7.drawPolygonPath = function (context, x, y, width, height, points) {
      var halfW = width / 2;
      var halfH = height / 2;
  
      if (context.beginPath) {
        context.beginPath();
      }
  
      context.moveTo(x + halfW * points[0], y + halfH * points[1]);
  
      for (var i = 1; i < points.length / 2; i++) {
        context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);
      }
  
      context.closePath();
    };
  
    CRp$7.drawRoundPolygonPath = function (context, x, y, width, height, points) {
      var halfW = width / 2;
      var halfH = height / 2;
      var cornerRadius = getRoundPolygonRadius(width, height);
  
      if (context.beginPath) {
        context.beginPath();
      }
  
      for (var _i = 0; _i < points.length / 4; _i++) {
        var sourceUv = void 0,
            destUv = void 0;
  
        if (_i === 0) {
          sourceUv = points.length - 2;
        } else {
          sourceUv = _i * 4 - 2;
        }
  
        destUv = _i * 4 + 2;
        var px = x + halfW * points[_i * 4];
        var py = y + halfH * points[_i * 4 + 1];
        var cosTheta = -points[sourceUv] * points[destUv] - points[sourceUv + 1] * points[destUv + 1];
        var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
        var cp0x = px - offset * points[sourceUv];
        var cp0y = py - offset * points[sourceUv + 1];
        var cp1x = px + offset * points[destUv];
        var cp1y = py + offset * points[destUv + 1];
  
        if (_i === 0) {
          context.moveTo(cp0x, cp0y);
        } else {
          context.lineTo(cp0x, cp0y);
        }
  
        context.arcTo(px, py, cp1x, cp1y, cornerRadius);
      }
  
      context.closePath();
    }; // Round rectangle drawing
  
  
    CRp$7.drawRoundRectanglePath = function (context, x, y, width, height) {
      var halfWidth = width / 2;
      var halfHeight = height / 2;
      var cornerRadius = getRoundRectangleRadius(width, height);
  
      if (context.beginPath) {
        context.beginPath();
      } // Start at top middle
  
  
      context.moveTo(x, y - halfHeight); // Arc from middle top to right side
  
      context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius); // Arc from right side to bottom
  
      context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius); // Arc from bottom to left side
  
      context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius); // Arc from left side to topBorder
  
      context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius); // Join line
  
      context.lineTo(x, y - halfHeight);
      context.closePath();
    };
  
    CRp$7.drawBottomRoundRectanglePath = function (context, x, y, width, height) {
      var halfWidth = width / 2;
      var halfHeight = height / 2;
      var cornerRadius = getRoundRectangleRadius(width, height);
  
      if (context.beginPath) {
        context.beginPath();
      } // Start at top middle
  
  
      context.moveTo(x, y - halfHeight);
      context.lineTo(x + halfWidth, y - halfHeight);
      context.lineTo(x + halfWidth, y);
      context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
      context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
      context.lineTo(x - halfWidth, y - halfHeight);
      context.lineTo(x, y - halfHeight);
      context.closePath();
    };
  
    CRp$7.drawCutRectanglePath = function (context, x, y, width, height) {
      var halfWidth = width / 2;
      var halfHeight = height / 2;
      var cornerLength = getCutRectangleCornerLength();
  
      if (context.beginPath) {
        context.beginPath();
      }
  
      context.moveTo(x - halfWidth + cornerLength, y - halfHeight);
      context.lineTo(x + halfWidth - cornerLength, y - halfHeight);
      context.lineTo(x + halfWidth, y - halfHeight + cornerLength);
      context.lineTo(x + halfWidth, y + halfHeight - cornerLength);
      context.lineTo(x + halfWidth - cornerLength, y + halfHeight);
      context.lineTo(x - halfWidth + cornerLength, y + halfHeight);
      context.lineTo(x - halfWidth, y + halfHeight - cornerLength);
      context.lineTo(x - halfWidth, y - halfHeight + cornerLength);
      context.closePath();
    };
  
    CRp$7.drawBarrelPath = function (context, x, y, width, height) {
      var halfWidth = width / 2;
      var halfHeight = height / 2;
      var xBegin = x - halfWidth;
      var xEnd = x + halfWidth;
      var yBegin = y - halfHeight;
      var yEnd = y + halfHeight;
      var barrelCurveConstants = getBarrelCurveConstants(width, height);
      var wOffset = barrelCurveConstants.widthOffset;
      var hOffset = barrelCurveConstants.heightOffset;
      var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;
  
      if (context.beginPath) {
        context.beginPath();
      }
  
      context.moveTo(xBegin, yBegin + hOffset);
      context.lineTo(xBegin, yEnd - hOffset);
      context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);
      context.lineTo(xEnd - wOffset, yEnd);
      context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);
      context.lineTo(xEnd, yBegin + hOffset);
      context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);
      context.lineTo(xBegin + wOffset, yBegin);
      context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);
      context.closePath();
    };
  
    var sin0 = Math.sin(0);
    var cos0 = Math.cos(0);
    var sin = {};
    var cos = {};
    var ellipseStepSize = Math.PI / 40;
  
    for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
      sin[i] = Math.sin(i);
      cos[i] = Math.cos(i);
    }
  
    CRp$7.drawEllipsePath = function (context, centerX, centerY, width, height) {
      if (context.beginPath) {
        context.beginPath();
      }
  
      if (context.ellipse) {
        context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);
      } else {
        var xPos, yPos;
        var rw = width / 2;
        var rh = height / 2;
  
        for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
          xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;
          yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;
  
          if (i === 0) {
            context.moveTo(xPos, yPos);
          } else {
            context.lineTo(xPos, yPos);
          }
        }
      }
  
      context.closePath();
    };
  
    /* global atob, ArrayBuffer, Uint8Array, Blob */
    var CRp$8 = {};
  
    CRp$8.createBuffer = function (w, h) {
      var buffer = document.createElement('canvas'); // eslint-disable-line no-undef
  
      buffer.width = w;
      buffer.height = h;
      return [buffer, buffer.getContext('2d')];
    };
  
    CRp$8.bufferCanvasImage = function (options) {
      var cy = this.cy;
      var eles = cy.mutableElements();
      var bb = eles.boundingBox();
      var ctrRect = this.findContainerClientCoords();
      var width = options.full ? Math.ceil(bb.w) : ctrRect[2];
      var height = options.full ? Math.ceil(bb.h) : ctrRect[3];
      var specdMaxDims = number(options.maxWidth) || number(options.maxHeight);
      var pxRatio = this.getPixelRatio();
      var scale = 1;
  
      if (options.scale !== undefined) {
        width *= options.scale;
        height *= options.scale;
        scale = options.scale;
      } else if (specdMaxDims) {
        var maxScaleW = Infinity;
        var maxScaleH = Infinity;
  
        if (number(options.maxWidth)) {
          maxScaleW = scale * options.maxWidth / width;
        }
  
        if (number(options.maxHeight)) {
          maxScaleH = scale * options.maxHeight / height;
        }
  
        scale = Math.min(maxScaleW, maxScaleH);
        width *= scale;
        height *= scale;
      }
  
      if (!specdMaxDims) {
        width *= pxRatio;
        height *= pxRatio;
        scale *= pxRatio;
      }
  
      var buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef
  
      buffCanvas.width = width;
      buffCanvas.height = height;
      buffCanvas.style.width = width + 'px';
      buffCanvas.style.height = height + 'px';
      var buffCxt = buffCanvas.getContext('2d'); // Rasterize the layers, but only if container has nonzero size
  
      if (width > 0 && height > 0) {
        buffCxt.clearRect(0, 0, width, height);
        buffCxt.globalCompositeOperation = 'source-over';
        var zsortedEles = this.getCachedZSortedEles();
  
        if (options.full) {
          // draw the full bounds of the graph
          buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);
          buffCxt.scale(scale, scale);
          this.drawElements(buffCxt, zsortedEles);
          buffCxt.scale(1 / scale, 1 / scale);
          buffCxt.translate(bb.x1 * scale, bb.y1 * scale);
        } else {
          // draw the current view
          var pan = cy.pan();
          var translation = {
            x: pan.x * scale,
            y: pan.y * scale
          };
          scale *= cy.zoom();
          buffCxt.translate(translation.x, translation.y);
          buffCxt.scale(scale, scale);
          this.drawElements(buffCxt, zsortedEles);
          buffCxt.scale(1 / scale, 1 / scale);
          buffCxt.translate(-translation.x, -translation.y);
        } // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs
  
  
        if (options.bg) {
          buffCxt.globalCompositeOperation = 'destination-over';
          buffCxt.fillStyle = options.bg;
          buffCxt.rect(0, 0, width, height);
          buffCxt.fill();
        }
      }
  
      return buffCanvas;
    };
  
    function b64ToBlob(b64, mimeType) {
      var bytes = atob(b64);
      var buff = new ArrayBuffer(bytes.length);
      var buffUint8 = new Uint8Array(buff);
  
      for (var i = 0; i < bytes.length; i++) {
        buffUint8[i] = bytes.charCodeAt(i);
      }
  
      return new Blob([buff], {
        type: mimeType
      });
    }
  
    function b64UriToB64(b64uri) {
      var i = b64uri.indexOf(',');
      return b64uri.substr(i + 1);
    }
  
    function output(options, canvas, mimeType) {
      var getB64Uri = function getB64Uri() {
        return canvas.toDataURL(mimeType, options.quality);
      };
  
      switch (options.output) {
        case 'blob-promise':
          return new Promise$1(function (resolve, reject) {
            try {
              canvas.toBlob(function (blob) {
                if (blob != null) {
                  resolve(blob);
                } else {
                  reject(new Error('`canvas.toBlob()` sent a null value in its callback'));
                }
              }, mimeType, options.quality);
            } catch (err) {
              reject(err);
            }
          });
  
        case 'blob':
          return b64ToBlob(b64UriToB64(getB64Uri()), mimeType);
  
        case 'base64':
          return b64UriToB64(getB64Uri());
  
        case 'base64uri':
        default:
          return getB64Uri();
      }
    }
  
    CRp$8.png = function (options) {
      return output(options, this.bufferCanvasImage(options), 'image/png');
    };
  
    CRp$8.jpg = function (options) {
      return output(options, this.bufferCanvasImage(options), 'image/jpeg');
    };
  
    var CRp$9 = {};
  
    CRp$9.nodeShapeImpl = function (name, context, centerX, centerY, width, height, points) {
      switch (name) {
        case 'ellipse':
          return this.drawEllipsePath(context, centerX, centerY, width, height);
  
        case 'polygon':
          return this.drawPolygonPath(context, centerX, centerY, width, height, points);
  
        case 'round-polygon':
          return this.drawRoundPolygonPath(context, centerX, centerY, width, height, points);
  
        case 'roundrectangle':
        case 'round-rectangle':
          return this.drawRoundRectanglePath(context, centerX, centerY, width, height);
  
        case 'cutrectangle':
        case 'cut-rectangle':
          return this.drawCutRectanglePath(context, centerX, centerY, width, height);
  
        case 'bottomroundrectangle':
        case 'bottom-round-rectangle':
          return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height);
  
        case 'barrel':
          return this.drawBarrelPath(context, centerX, centerY, width, height);
      }
    };
  
    var CR = CanvasRenderer;
    var CRp$a = CanvasRenderer.prototype;
    CRp$a.CANVAS_LAYERS = 3; //
  
    CRp$a.SELECT_BOX = 0;
    CRp$a.DRAG = 1;
    CRp$a.NODE = 2;
    CRp$a.BUFFER_COUNT = 3; //
  
    CRp$a.TEXTURE_BUFFER = 0;
    CRp$a.MOTIONBLUR_BUFFER_NODE = 1;
    CRp$a.MOTIONBLUR_BUFFER_DRAG = 2;
  
    function CanvasRenderer(options) {
      var r = this;
      r.data = {
        canvases: new Array(CRp$a.CANVAS_LAYERS),
        contexts: new Array(CRp$a.CANVAS_LAYERS),
        canvasNeedsRedraw: new Array(CRp$a.CANVAS_LAYERS),
        bufferCanvases: new Array(CRp$a.BUFFER_COUNT),
        bufferContexts: new Array(CRp$a.CANVAS_LAYERS)
      };
      var tapHlOffAttr = '-webkit-tap-highlight-color';
      var tapHlOffStyle = 'rgba(0,0,0,0)';
      r.data.canvasContainer = document.createElement('div'); // eslint-disable-line no-undef
  
      var containerStyle = r.data.canvasContainer.style;
      r.data.canvasContainer.style[tapHlOffAttr] = tapHlOffStyle;
      containerStyle.position = 'relative';
      containerStyle.zIndex = '0';
      containerStyle.overflow = 'hidden';
      var container = options.cy.container();
      container.appendChild(r.data.canvasContainer);
      container.style[tapHlOffAttr] = tapHlOffStyle;
      var styleMap = {
        '-webkit-user-select': 'none',
        '-moz-user-select': '-moz-none',
        'user-select': 'none',
        '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',
        'outline-style': 'none'
      };
  
      if (ms()) {
        styleMap['-ms-touch-action'] = 'none';
        styleMap['touch-action'] = 'none';
      }
  
      for (var i = 0; i < CRp$a.CANVAS_LAYERS; i++) {
        var canvas = r.data.canvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef
  
        r.data.contexts[i] = canvas.getContext('2d');
        Object.keys(styleMap).forEach(function (k) {
          canvas.style[k] = styleMap[k];
        });
        canvas.style.position = 'absolute';
        canvas.setAttribute('data-id', 'layer' + i);
        canvas.style.zIndex = String(CRp$a.CANVAS_LAYERS - i);
        r.data.canvasContainer.appendChild(canvas);
        r.data.canvasNeedsRedraw[i] = false;
      }
  
      r.data.topCanvas = r.data.canvases[0];
      r.data.canvases[CRp$a.NODE].setAttribute('data-id', 'layer' + CRp$a.NODE + '-node');
      r.data.canvases[CRp$a.SELECT_BOX].setAttribute('data-id', 'layer' + CRp$a.SELECT_BOX + '-selectbox');
      r.data.canvases[CRp$a.DRAG].setAttribute('data-id', 'layer' + CRp$a.DRAG + '-drag');
  
      for (var i = 0; i < CRp$a.BUFFER_COUNT; i++) {
        r.data.bufferCanvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef
  
        r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');
        r.data.bufferCanvases[i].style.position = 'absolute';
        r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);
        r.data.bufferCanvases[i].style.zIndex = String(-i - 1);
        r.data.bufferCanvases[i].style.visibility = 'hidden'; //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);
      }
  
      r.pathsEnabled = true;
      var emptyBb = makeBoundingBox();
  
      var getBoxCenter = function getBoxCenter(bb) {
        return {
          x: (bb.x1 + bb.x2) / 2,
          y: (bb.y1 + bb.y2) / 2
        };
      };
  
      var getCenterOffset = function getCenterOffset(bb) {
        return {
          x: -bb.w / 2,
          y: -bb.h / 2
        };
      };
  
      var backgroundTimestampHasChanged = function backgroundTimestampHasChanged(ele) {
        var _p = ele[0]._private;
        var same = _p.oldBackgroundTimestamp === _p.backgroundTimestamp;
        return !same;
      };
  
      var getStyleKey = function getStyleKey(ele) {
        return ele[0]._private.nodeKey;
      };
  
      var getLabelKey = function getLabelKey(ele) {
        return ele[0]._private.labelStyleKey;
      };
  
      var getSourceLabelKey = function getSourceLabelKey(ele) {
        return ele[0]._private.sourceLabelStyleKey;
      };
  
      var getTargetLabelKey = function getTargetLabelKey(ele) {
        return ele[0]._private.targetLabelStyleKey;
      };
  
      var drawElement = function drawElement(context, ele, bb, scaledLabelShown, useEleOpacity) {
        return r.drawElement(context, ele, bb, false, false, useEleOpacity);
      };
  
      var drawLabel = function drawLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
        return r.drawElementText(context, ele, bb, scaledLabelShown, 'main', useEleOpacity);
      };
  
      var drawSourceLabel = function drawSourceLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
        return r.drawElementText(context, ele, bb, scaledLabelShown, 'source', useEleOpacity);
      };
  
      var drawTargetLabel = function drawTargetLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
        return r.drawElementText(context, ele, bb, scaledLabelShown, 'target', useEleOpacity);
      };
  
      var getElementBox = function getElementBox(ele) {
        ele.boundingBox();
        return ele[0]._private.bodyBounds;
      };
  
      var getLabelBox = function getLabelBox(ele) {
        ele.boundingBox();
        return ele[0]._private.labelBounds.main || emptyBb;
      };
  
      var getSourceLabelBox = function getSourceLabelBox(ele) {
        ele.boundingBox();
        return ele[0]._private.labelBounds.source || emptyBb;
      };
  
      var getTargetLabelBox = function getTargetLabelBox(ele) {
        ele.boundingBox();
        return ele[0]._private.labelBounds.target || emptyBb;
      };
  
      var isLabelVisibleAtScale = function isLabelVisibleAtScale(ele, scaledLabelShown) {
        return scaledLabelShown;
      };
  
      var getElementRotationPoint = function getElementRotationPoint(ele) {
        return getBoxCenter(getElementBox(ele));
      };
  
      var addTextMargin = function addTextMargin(prefix, pt, ele) {
        var pre = prefix ? prefix + '-' : '';
        return {
          x: pt.x + ele.pstyle(pre + 'text-margin-x').pfValue,
          y: pt.y + ele.pstyle(pre + 'text-margin-y').pfValue
        };
      };
  
      var getRsPt = function getRsPt(ele, x, y) {
        var rs = ele[0]._private.rscratch;
        return {
          x: rs[x],
          y: rs[y]
        };
      };
  
      var getLabelRotationPoint = function getLabelRotationPoint(ele) {
        return addTextMargin('', getRsPt(ele, 'labelX', 'labelY'), ele);
      };
  
      var getSourceLabelRotationPoint = function getSourceLabelRotationPoint(ele) {
        return addTextMargin('source', getRsPt(ele, 'sourceLabelX', 'sourceLabelY'), ele);
      };
  
      var getTargetLabelRotationPoint = function getTargetLabelRotationPoint(ele) {
        return addTextMargin('target', getRsPt(ele, 'targetLabelX', 'targetLabelY'), ele);
      };
  
      var getElementRotationOffset = function getElementRotationOffset(ele) {
        return getCenterOffset(getElementBox(ele));
      };
  
      var getSourceLabelRotationOffset = function getSourceLabelRotationOffset(ele) {
        return getCenterOffset(getSourceLabelBox(ele));
      };
  
      var getTargetLabelRotationOffset = function getTargetLabelRotationOffset(ele) {
        return getCenterOffset(getTargetLabelBox(ele));
      };
  
      var getLabelRotationOffset = function getLabelRotationOffset(ele) {
        var bb = getLabelBox(ele);
        var p = getCenterOffset(getLabelBox(ele));
  
        if (ele.isNode()) {
          switch (ele.pstyle('text-halign').value) {
            case 'left':
              p.x = -bb.w;
              break;
  
            case 'right':
              p.x = 0;
              break;
          }
  
          switch (ele.pstyle('text-valign').value) {
            case 'top':
              p.y = -bb.h;
              break;
  
            case 'bottom':
              p.y = 0;
              break;
          }
        }
  
        return p;
      };
  
      var eleTxrCache = r.data.eleTxrCache = new ElementTextureCache(r, {
        getKey: getStyleKey,
        doesEleInvalidateKey: backgroundTimestampHasChanged,
        drawElement: drawElement,
        getBoundingBox: getElementBox,
        getRotationPoint: getElementRotationPoint,
        getRotationOffset: getElementRotationOffset,
        allowEdgeTxrCaching: false,
        allowParentTxrCaching: false
      });
      var lblTxrCache = r.data.lblTxrCache = new ElementTextureCache(r, {
        getKey: getLabelKey,
        drawElement: drawLabel,
        getBoundingBox: getLabelBox,
        getRotationPoint: getLabelRotationPoint,
        getRotationOffset: getLabelRotationOffset,
        isVisible: isLabelVisibleAtScale
      });
      var slbTxrCache = r.data.slbTxrCache = new ElementTextureCache(r, {
        getKey: getSourceLabelKey,
        drawElement: drawSourceLabel,
        getBoundingBox: getSourceLabelBox,
        getRotationPoint: getSourceLabelRotationPoint,
        getRotationOffset: getSourceLabelRotationOffset,
        isVisible: isLabelVisibleAtScale
      });
      var tlbTxrCache = r.data.tlbTxrCache = new ElementTextureCache(r, {
        getKey: getTargetLabelKey,
        drawElement: drawTargetLabel,
        getBoundingBox: getTargetLabelBox,
        getRotationPoint: getTargetLabelRotationPoint,
        getRotationOffset: getTargetLabelRotationOffset,
        isVisible: isLabelVisibleAtScale
      });
      var lyrTxrCache = r.data.lyrTxrCache = new LayeredTextureCache(r);
      r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {
        // each cache should check for sub-key diff to see that the update affects that cache particularly
        eleTxrCache.invalidateElements(eles);
        lblTxrCache.invalidateElements(eles);
        slbTxrCache.invalidateElements(eles);
        tlbTxrCache.invalidateElements(eles); // any change invalidates the layers
  
        lyrTxrCache.invalidateElements(eles); // update the old bg timestamp so diffs can be done in the ele txr caches
  
        for (var _i = 0; _i < eles.length; _i++) {
          var _p = eles[_i]._private;
          _p.oldBackgroundTimestamp = _p.backgroundTimestamp;
        }
      });
  
      var refineInLayers = function refineInLayers(reqs) {
        for (var i = 0; i < reqs.length; i++) {
          lyrTxrCache.enqueueElementRefinement(reqs[i].ele);
        }
      };
  
      eleTxrCache.onDequeue(refineInLayers);
      lblTxrCache.onDequeue(refineInLayers);
      slbTxrCache.onDequeue(refineInLayers);
      tlbTxrCache.onDequeue(refineInLayers);
    }
  
    CRp$a.redrawHint = function (group, bool) {
      var r = this;
  
      switch (group) {
        case 'eles':
          r.data.canvasNeedsRedraw[CRp$a.NODE] = bool;
          break;
  
        case 'drag':
          r.data.canvasNeedsRedraw[CRp$a.DRAG] = bool;
          break;
  
        case 'select':
          r.data.canvasNeedsRedraw[CRp$a.SELECT_BOX] = bool;
          break;
      }
    }; // whether to use Path2D caching for drawing
  
  
    var pathsImpld = typeof Path2D !== 'undefined';
  
    CRp$a.path2dEnabled = function (on) {
      if (on === undefined) {
        return this.pathsEnabled;
      }
  
      this.pathsEnabled = on ? true : false;
    };
  
    CRp$a.usePaths = function () {
      return pathsImpld && this.pathsEnabled;
    };
  
    CRp$a.setImgSmoothing = function (context, bool) {
      if (context.imageSmoothingEnabled != null) {
        context.imageSmoothingEnabled = bool;
      } else {
        context.webkitImageSmoothingEnabled = bool;
        context.mozImageSmoothingEnabled = bool;
        context.msImageSmoothingEnabled = bool;
      }
    };
  
    CRp$a.getImgSmoothing = function (context) {
      if (context.imageSmoothingEnabled != null) {
        return context.imageSmoothingEnabled;
      } else {
        return context.webkitImageSmoothingEnabled || context.mozImageSmoothingEnabled || context.msImageSmoothingEnabled;
      }
    };
  
    CRp$a.makeOffscreenCanvas = function (width, height) {
      var canvas;
  
      if ((typeof OffscreenCanvas === "undefined" ? "undefined" : _typeof(OffscreenCanvas)) !== ( "undefined" )) {
        canvas = new OffscreenCanvas(width, height);
      } else {
        canvas = document.createElement('canvas'); // eslint-disable-line no-undef
  
        canvas.width = width;
        canvas.height = height;
      }
  
      return canvas;
    };
  
    [CRp, CRp$1, CRp$2, CRp$3, CRp$4, CRp$5, CRp$6, CRp$7, CRp$8, CRp$9].forEach(function (props) {
      extend(CRp$a, props);
    });
  
    var renderer = [{
      name: 'null',
      impl: NullRenderer
    }, {
      name: 'base',
      impl: BR
    }, {
      name: 'canvas',
      impl: CR
    }];
  
    var incExts = [{
      type: 'layout',
      extensions: layout
    }, {
      type: 'renderer',
      extensions: renderer
    }];
  
    var extensions = {}; // registered modules for extensions, indexed by name
  
    var modules = {};
  
    function setExtension(type, name, registrant) {
      var ext = registrant;
  
      var overrideErr = function overrideErr(field) {
        error('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');
      };
  
      if (type === 'core') {
        if (Core.prototype[name]) {
          return overrideErr(name);
        } else {
          Core.prototype[name] = registrant;
        }
      } else if (type === 'collection') {
        if (Collection.prototype[name]) {
          return overrideErr(name);
        } else {
          Collection.prototype[name] = registrant;
        }
      } else if (type === 'layout') {
        // fill in missing layout functions in the prototype
        var Layout = function Layout(options) {
          this.options = options;
          registrant.call(this, options); // make sure layout has _private for use w/ std apis like .on()
  
          if (!plainObject(this._private)) {
            this._private = {};
          }
  
          this._private.cy = options.cy;
          this._private.listeners = [];
          this.createEmitter();
        };
  
        var layoutProto = Layout.prototype = Object.create(registrant.prototype);
        var optLayoutFns = [];
  
        for (var i = 0; i < optLayoutFns.length; i++) {
          var fnName = optLayoutFns[i];
  
          layoutProto[fnName] = layoutProto[fnName] || function () {
            return this;
          };
        } // either .start() or .run() is defined, so autogen the other
  
  
        if (layoutProto.start && !layoutProto.run) {
          layoutProto.run = function () {
            this.start();
            return this;
          };
        } else if (!layoutProto.start && layoutProto.run) {
          layoutProto.start = function () {
            this.run();
            return this;
          };
        }
  
        var regStop = registrant.prototype.stop;
  
        layoutProto.stop = function () {
          var opts = this.options;
  
          if (opts && opts.animate) {
            var anis = this.animations;
  
            if (anis) {
              for (var _i = 0; _i < anis.length; _i++) {
                anis[_i].stop();
              }
            }
          }
  
          if (regStop) {
            regStop.call(this);
          } else {
            this.emit('layoutstop');
          }
  
          return this;
        };
  
        if (!layoutProto.destroy) {
          layoutProto.destroy = function () {
            return this;
          };
        }
  
        layoutProto.cy = function () {
          return this._private.cy;
        };
  
        var getCy = function getCy(layout) {
          return layout._private.cy;
        };
  
        var emitterOpts = {
          addEventFields: function addEventFields(layout, evt) {
            evt.layout = layout;
            evt.cy = getCy(layout);
            evt.target = layout;
          },
          bubble: function bubble() {
            return true;
          },
          parent: function parent(layout) {
            return getCy(layout);
          }
        };
        extend(layoutProto, {
          createEmitter: function createEmitter() {
            this._private.emitter = new Emitter(emitterOpts, this);
            return this;
          },
          emitter: function emitter() {
            return this._private.emitter;
          },
          on: function on(evt, cb) {
            this.emitter().on(evt, cb);
            return this;
          },
          one: function one(evt, cb) {
            this.emitter().one(evt, cb);
            return this;
          },
          once: function once(evt, cb) {
            this.emitter().one(evt, cb);
            return this;
          },
          removeListener: function removeListener(evt, cb) {
            this.emitter().removeListener(evt, cb);
            return this;
          },
          removeAllListeners: function removeAllListeners() {
            this.emitter().removeAllListeners();
            return this;
          },
          emit: function emit(evt, params) {
            this.emitter().emit(evt, params);
            return this;
          }
        });
        define$3.eventAliasesOn(layoutProto);
        ext = Layout; // replace with our wrapped layout
      } else if (type === 'renderer' && name !== 'null' && name !== 'base') {
        // user registered renderers inherit from base
        var BaseRenderer = getExtension('renderer', 'base');
        var bProto = BaseRenderer.prototype;
        var RegistrantRenderer = registrant;
        var rProto = registrant.prototype;
  
        var Renderer = function Renderer() {
          BaseRenderer.apply(this, arguments);
          RegistrantRenderer.apply(this, arguments);
        };
  
        var proto = Renderer.prototype;
  
        for (var pName in bProto) {
          var pVal = bProto[pName];
          var existsInR = rProto[pName] != null;
  
          if (existsInR) {
            return overrideErr(pName);
          }
  
          proto[pName] = pVal; // take impl from base
        }
  
        for (var _pName in rProto) {
          proto[_pName] = rProto[_pName]; // take impl from registrant
        }
  
        bProto.clientFunctions.forEach(function (name) {
          proto[name] = proto[name] || function () {
            error('Renderer does not implement `renderer.' + name + '()` on its prototype');
          };
        });
        ext = Renderer;
      }
  
      return setMap({
        map: extensions,
        keys: [type, name],
        value: ext
      });
    }
  
    function getExtension(type, name) {
      return getMap({
        map: extensions,
        keys: [type, name]
      });
    }
  
    function setModule(type, name, moduleType, moduleName, registrant) {
      return setMap({
        map: modules,
        keys: [type, name, moduleType, moduleName],
        value: registrant
      });
    }
  
    function getModule(type, name, moduleType, moduleName) {
      return getMap({
        map: modules,
        keys: [type, name, moduleType, moduleName]
      });
    }
  
    var extension = function extension() {
      // e.g. extension('renderer', 'svg')
      if (arguments.length === 2) {
        return getExtension.apply(null, arguments);
      } // e.g. extension('renderer', 'svg', { ... })
      else if (arguments.length === 3) {
          return setExtension.apply(null, arguments);
        } // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')
        else if (arguments.length === 4) {
            return getModule.apply(null, arguments);
          } // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
          else if (arguments.length === 5) {
              return setModule.apply(null, arguments);
            } else {
              error('Invalid extension access syntax');
            }
    }; // allows a core instance to access extensions internally
  
  
    Core.prototype.extension = extension; // included extensions
  
    incExts.forEach(function (group) {
      group.extensions.forEach(function (ext) {
        setExtension(group.type, ext.name, ext.impl);
      });
    });
  
    // (useful for init)
  
    var Stylesheet = function Stylesheet() {
      if (!(this instanceof Stylesheet)) {
        return new Stylesheet();
      }
  
      this.length = 0;
    };
  
    var sheetfn = Stylesheet.prototype;
  
    sheetfn.instanceString = function () {
      return 'stylesheet';
    }; // just store the selector to be parsed later
  
  
    sheetfn.selector = function (selector) {
      var i = this.length++;
      this[i] = {
        selector: selector,
        properties: []
      };
      return this; // chaining
    }; // just store the property to be parsed later
  
  
    sheetfn.css = function (name, value) {
      var i = this.length - 1;
  
      if (string(name)) {
        this[i].properties.push({
          name: name,
          value: value
        });
      } else if (plainObject(name)) {
        var map = name;
        var propNames = Object.keys(map);
  
        for (var j = 0; j < propNames.length; j++) {
          var key = propNames[j];
          var mapVal = map[key];
  
          if (mapVal == null) {
            continue;
          }
  
          var prop = Style.properties[key] || Style.properties[dash2camel(key)];
  
          if (prop == null) {
            continue;
          }
  
          var _name = prop.name;
          var _value = mapVal;
          this[i].properties.push({
            name: _name,
            value: _value
          });
        }
      }
  
      return this; // chaining
    };
  
    sheetfn.style = sheetfn.css; // generate a real style object from the dummy stylesheet
  
    sheetfn.generateStyle = function (cy) {
      var style = new Style(cy);
      return this.appendToStyle(style);
    }; // append a dummy stylesheet object on a real style object
  
  
    sheetfn.appendToStyle = function (style) {
      for (var i = 0; i < this.length; i++) {
        var context = this[i];
        var selector = context.selector;
        var props = context.properties;
        style.selector(selector); // apply selector
  
        for (var j = 0; j < props.length; j++) {
          var prop = props[j];
          style.css(prop.name, prop.value); // apply property
        }
      }
  
      return style;
    };
  
    var version = "3.15.0";
  
    var cytoscape = function cytoscape(options) {
      // if no options specified, use default
      if (options === undefined) {
        options = {};
      } // create instance
  
  
      if (plainObject(options)) {
        return new Core(options);
      } // allow for registration of extensions
      else if (string(options)) {
          return extension.apply(extension, arguments);
        }
    }; // e.g. cytoscape.use( require('cytoscape-foo'), bar )
  
  
    cytoscape.use = function (ext) {
      var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext
  
      args.unshift(cytoscape); // cytoscape is first arg to ext
  
      ext.apply(null, args);
      return this;
    };
  
    cytoscape.warnings = function (bool) {
      return warnings(bool);
    }; // replaced by build system
  
  
    cytoscape.version = version; // expose public apis (mostly for extensions)
  
    cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;
  
    return cytoscape;
  
  })));
  !function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.dagre=e()}}(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){module.exports={graphlib:require("./lib/graphlib"),layout:require("./lib/layout"),debug:require("./lib/debug"),util:{time:require("./lib/util").time,notime:require("./lib/util").notime},version:require("./lib/version")}},{"./lib/debug":6,"./lib/graphlib":7,"./lib/layout":9,"./lib/util":29,"./lib/version":30}],2:[function(require,module,exports){"use strict";var _=require("./lodash"),greedyFAS=require("./greedy-fas");module.exports={run:run,undo:undo};function run(g){var fas=g.graph().acyclicer==="greedy"?greedyFAS(g,weightFn(g)):dfsFAS(g);_.each(fas,function(e){var label=g.edge(e);g.removeEdge(e);label.forwardName=e.name;label.reversed=true;g.setEdge(e.w,e.v,label,_.uniqueId("rev"))});function weightFn(g){return function(e){return g.edge(e).weight}}}function dfsFAS(g){var fas=[],stack={},visited={};function dfs(v){if(_.has(visited,v)){return}visited[v]=true;stack[v]=true;_.each(g.outEdges(v),function(e){if(_.has(stack,e.w)){fas.push(e)}else{dfs(e.w)}});delete stack[v]}_.each(g.nodes(),dfs);return fas}function undo(g){_.each(g.edges(),function(e){var label=g.edge(e);if(label.reversed){g.removeEdge(e);var forwardName=label.forwardName;delete label.reversed;delete label.forwardName;g.setEdge(e.w,e.v,label,forwardName)}})}},{"./greedy-fas":8,"./lodash":10}],3:[function(require,module,exports){var _=require("./lodash"),util=require("./util");module.exports=addBorderSegments;function addBorderSegments(g){function dfs(v){var children=g.children(v),node=g.node(v);if(children.length){_.each(children,dfs)}if(_.has(node,"minRank")){node.borderLeft=[];node.borderRight=[];for(var rank=node.minRank,maxRank=node.maxRank+1;rank<maxRank;++rank){addBorderNode(g,"borderLeft","_bl",v,node,rank);addBorderNode(g,"borderRight","_br",v,node,rank)}}}_.each(g.children(),dfs)}function addBorderNode(g,prop,prefix,sg,sgNode,rank){var label={width:0,height:0,rank:rank,borderType:prop},prev=sgNode[prop][rank-1],curr=util.addDummyNode(g,"border",label,prefix);sgNode[prop][rank]=curr;g.setParent(curr,sg);if(prev){g.setEdge(prev,curr,{weight:1})}}},{"./lodash":10,"./util":29}],4:[function(require,module,exports){"use strict";var _=require("./lodash");module.exports={adjust:adjust,undo:undo};function adjust(g){var rankDir=g.graph().rankdir.toLowerCase();if(rankDir==="lr"||rankDir==="rl"){swapWidthHeight(g)}}function undo(g){var rankDir=g.graph().rankdir.toLowerCase();if(rankDir==="bt"||rankDir==="rl"){reverseY(g)}if(rankDir==="lr"||rankDir==="rl"){swapXY(g);swapWidthHeight(g)}}function swapWidthHeight(g){_.each(g.nodes(),function(v){swapWidthHeightOne(g.node(v))});_.each(g.edges(),function(e){swapWidthHeightOne(g.edge(e))})}function swapWidthHeightOne(attrs){var w=attrs.width;attrs.width=attrs.height;attrs.height=w}function reverseY(g){_.each(g.nodes(),function(v){reverseYOne(g.node(v))});_.each(g.edges(),function(e){var edge=g.edge(e);_.each(edge.points,reverseYOne);if(_.has(edge,"y")){reverseYOne(edge)}})}function reverseYOne(attrs){attrs.y=-attrs.y}function swapXY(g){_.each(g.nodes(),function(v){swapXYOne(g.node(v))});_.each(g.edges(),function(e){var edge=g.edge(e);_.each(edge.points,swapXYOne);if(_.has(edge,"x")){swapXYOne(edge)}})}function swapXYOne(attrs){var x=attrs.x;attrs.x=attrs.y;attrs.y=x}},{"./lodash":10}],5:[function(require,module,exports){module.exports=List;function List(){var sentinel={};sentinel._next=sentinel._prev=sentinel;this._sentinel=sentinel}List.prototype.dequeue=function(){var sentinel=this._sentinel,entry=sentinel._prev;if(entry!==sentinel){unlink(entry);return entry}};List.prototype.enqueue=function(entry){var sentinel=this._sentinel;if(entry._prev&&entry._next){unlink(entry)}entry._next=sentinel._next;sentinel._next._prev=entry;sentinel._next=entry;entry._prev=sentinel};List.prototype.toString=function(){var strs=[],sentinel=this._sentinel,curr=sentinel._prev;while(curr!==sentinel){strs.push(JSON.stringify(curr,filterOutLinks));curr=curr._prev}return"["+strs.join(", ")+"]"};function unlink(entry){entry._prev._next=entry._next;entry._next._prev=entry._prev;delete entry._next;delete entry._prev}function filterOutLinks(k,v){if(k!=="_next"&&k!=="_prev"){return v}}},{}],6:[function(require,module,exports){var _=require("./lodash"),util=require("./util"),Graph=require("./graphlib").Graph;module.exports={debugOrdering:debugOrdering};function debugOrdering(g){var layerMatrix=util.buildLayerMatrix(g);var h=new Graph({compound:true,multigraph:true}).setGraph({});_.each(g.nodes(),function(v){h.setNode(v,{label:v});h.setParent(v,"layer"+g.node(v).rank)});_.each(g.edges(),function(e){h.setEdge(e.v,e.w,{},e.name)});_.each(layerMatrix,function(layer,i){var layerV="layer"+i;h.setNode(layerV,{rank:"same"});_.reduce(layer,function(u,v){h.setEdge(u,v,{style:"invis"});return v})});return h}},{"./graphlib":7,"./lodash":10,"./util":29}],7:[function(require,module,exports){var graphlib;if(require){try{graphlib=require("graphlib")}catch(e){}}if(!graphlib){graphlib=window.graphlib}module.exports=graphlib},{graphlib:31}],8:[function(require,module,exports){var _=require("./lodash"),Graph=require("./graphlib").Graph,List=require("./data/list");module.exports=greedyFAS;var DEFAULT_WEIGHT_FN=_.constant(1);function greedyFAS(g,weightFn){if(g.nodeCount()<=1){return[]}var state=buildState(g,weightFn||DEFAULT_WEIGHT_FN);var results=doGreedyFAS(state.graph,state.buckets,state.zeroIdx);return _.flatten(_.map(results,function(e){return g.outEdges(e.v,e.w)}),true)}function doGreedyFAS(g,buckets,zeroIdx){var results=[],sources=buckets[buckets.length-1],sinks=buckets[0];var entry;while(g.nodeCount()){while(entry=sinks.dequeue()){removeNode(g,buckets,zeroIdx,entry)}while(entry=sources.dequeue()){removeNode(g,buckets,zeroIdx,entry)}if(g.nodeCount()){for(var i=buckets.length-2;i>0;--i){entry=buckets[i].dequeue();if(entry){results=results.concat(removeNode(g,buckets,zeroIdx,entry,true));break}}}}return results}function removeNode(g,buckets,zeroIdx,entry,collectPredecessors){var results=collectPredecessors?[]:undefined;_.each(g.inEdges(entry.v),function(edge){var weight=g.edge(edge),uEntry=g.node(edge.v);if(collectPredecessors){results.push({v:edge.v,w:edge.w})}uEntry.out-=weight;assignBucket(buckets,zeroIdx,uEntry)});_.each(g.outEdges(entry.v),function(edge){var weight=g.edge(edge),w=edge.w,wEntry=g.node(w);wEntry["in"]-=weight;assignBucket(buckets,zeroIdx,wEntry)});g.removeNode(entry.v);return results}function buildState(g,weightFn){var fasGraph=new Graph,maxIn=0,maxOut=0;_.each(g.nodes(),function(v){fasGraph.setNode(v,{v:v,"in":0,out:0})});_.each(g.edges(),function(e){var prevWeight=fasGraph.edge(e.v,e.w)||0,weight=weightFn(e),edgeWeight=prevWeight+weight;fasGraph.setEdge(e.v,e.w,edgeWeight);maxOut=Math.max(maxOut,fasGraph.node(e.v).out+=weight);maxIn=Math.max(maxIn,fasGraph.node(e.w)["in"]+=weight)});var buckets=_.range(maxOut+maxIn+3).map(function(){return new List});var zeroIdx=maxIn+1;_.each(fasGraph.nodes(),function(v){assignBucket(buckets,zeroIdx,fasGraph.node(v))});return{graph:fasGraph,buckets:buckets,zeroIdx:zeroIdx}}function assignBucket(buckets,zeroIdx,entry){if(!entry.out){buckets[0].enqueue(entry)}else if(!entry["in"]){buckets[buckets.length-1].enqueue(entry)}else{buckets[entry.out-entry["in"]+zeroIdx].enqueue(entry)}}},{"./data/list":5,"./graphlib":7,"./lodash":10}],9:[function(require,module,exports){"use strict";var _=require("./lodash"),acyclic=require("./acyclic"),normalize=require("./normalize"),rank=require("./rank"),normalizeRanks=require("./util").normalizeRanks,parentDummyChains=require("./parent-dummy-chains"),removeEmptyRanks=require("./util").removeEmptyRanks,nestingGraph=require("./nesting-graph"),addBorderSegments=require("./add-border-segments"),coordinateSystem=require("./coordinate-system"),order=require("./order"),position=require("./position"),util=require("./util"),Graph=require("./graphlib").Graph;module.exports=layout;function layout(g,opts){var time=opts&&opts.debugTiming?util.time:util.notime;time("layout",function(){var layoutGraph=time("  buildLayoutGraph",function(){return buildLayoutGraph(g)});time("  runLayout",function(){runLayout(layoutGraph,time)});time("  updateInputGraph",function(){updateInputGraph(g,layoutGraph)})})}function runLayout(g,time){time("    makeSpaceForEdgeLabels",function(){makeSpaceForEdgeLabels(g)});time("    removeSelfEdges",function(){removeSelfEdges(g)});time("    acyclic",function(){acyclic.run(g)});time("    nestingGraph.run",function(){nestingGraph.run(g)});time("    rank",function(){rank(util.asNonCompoundGraph(g))});time("    injectEdgeLabelProxies",function(){injectEdgeLabelProxies(g)});time("    removeEmptyRanks",function(){removeEmptyRanks(g)});time("    nestingGraph.cleanup",function(){nestingGraph.cleanup(g)});time("    normalizeRanks",function(){normalizeRanks(g)});time("    assignRankMinMax",function(){assignRankMinMax(g)});time("    removeEdgeLabelProxies",function(){removeEdgeLabelProxies(g)});time("    normalize.run",function(){normalize.run(g)});time("    parentDummyChains",function(){parentDummyChains(g)});time("    addBorderSegments",function(){addBorderSegments(g)});time("    order",function(){order(g)});time("    insertSelfEdges",function(){insertSelfEdges(g)});time("    adjustCoordinateSystem",function(){coordinateSystem.adjust(g)});time("    position",function(){position(g)});time("    positionSelfEdges",function(){positionSelfEdges(g)});time("    removeBorderNodes",function(){removeBorderNodes(g)});time("    normalize.undo",function(){normalize.undo(g)});time("    fixupEdgeLabelCoords",function(){fixupEdgeLabelCoords(g)});time("    undoCoordinateSystem",function(){coordinateSystem.undo(g)});time("    translateGraph",function(){translateGraph(g)});time("    assignNodeIntersects",function(){assignNodeIntersects(g)});time("    reversePoints",function(){reversePointsForReversedEdges(g)});time("    acyclic.undo",function(){acyclic.undo(g)})}function updateInputGraph(inputGraph,layoutGraph){_.each(inputGraph.nodes(),function(v){var inputLabel=inputGraph.node(v),layoutLabel=layoutGraph.node(v);if(inputLabel){inputLabel.x=layoutLabel.x;inputLabel.y=layoutLabel.y;if(layoutGraph.children(v).length){inputLabel.width=layoutLabel.width;inputLabel.height=layoutLabel.height}}});_.each(inputGraph.edges(),function(e){var inputLabel=inputGraph.edge(e),layoutLabel=layoutGraph.edge(e);inputLabel.points=layoutLabel.points;if(_.has(layoutLabel,"x")){inputLabel.x=layoutLabel.x;inputLabel.y=layoutLabel.y}});inputGraph.graph().width=layoutGraph.graph().width;inputGraph.graph().height=layoutGraph.graph().height}var graphNumAttrs=["nodesep","edgesep","ranksep","marginx","marginy"],graphDefaults={ranksep:50,edgesep:20,nodesep:50,rankdir:"tb"},graphAttrs=["acyclicer","ranker","rankdir","align"],nodeNumAttrs=["width","height"],nodeDefaults={width:0,height:0},edgeNumAttrs=["minlen","weight","width","height","labeloffset"],edgeDefaults={minlen:1,weight:1,width:0,height:0,labeloffset:10,labelpos:"r"},edgeAttrs=["labelpos"];function buildLayoutGraph(inputGraph){var g=new Graph({multigraph:true,compound:true}),graph=canonicalize(inputGraph.graph());g.setGraph(_.merge({},graphDefaults,selectNumberAttrs(graph,graphNumAttrs),_.pick(graph,graphAttrs)));_.each(inputGraph.nodes(),function(v){var node=canonicalize(inputGraph.node(v));g.setNode(v,_.defaults(selectNumberAttrs(node,nodeNumAttrs),nodeDefaults));g.setParent(v,inputGraph.parent(v))});_.each(inputGraph.edges(),function(e){var edge=canonicalize(inputGraph.edge(e));g.setEdge(e,_.merge({},edgeDefaults,selectNumberAttrs(edge,edgeNumAttrs),_.pick(edge,edgeAttrs)))});return g}function makeSpaceForEdgeLabels(g){var graph=g.graph();graph.ranksep/=2;_.each(g.edges(),function(e){var edge=g.edge(e);edge.minlen*=2;if(edge.labelpos.toLowerCase()!=="c"){if(graph.rankdir==="TB"||graph.rankdir==="BT"){edge.width+=edge.labeloffset}else{edge.height+=edge.labeloffset}}})}function injectEdgeLabelProxies(g){_.each(g.edges(),function(e){var edge=g.edge(e);if(edge.width&&edge.height){var v=g.node(e.v),w=g.node(e.w),label={rank:(w.rank-v.rank)/2+v.rank,e:e};util.addDummyNode(g,"edge-proxy",label,"_ep")}})}function assignRankMinMax(g){var maxRank=0;_.each(g.nodes(),function(v){var node=g.node(v);if(node.borderTop){node.minRank=g.node(node.borderTop).rank;node.maxRank=g.node(node.borderBottom).rank;maxRank=_.max(maxRank,node.maxRank)}});g.graph().maxRank=maxRank}function removeEdgeLabelProxies(g){_.each(g.nodes(),function(v){var node=g.node(v);if(node.dummy==="edge-proxy"){g.edge(node.e).labelRank=node.rank;g.removeNode(v)}})}function translateGraph(g){var minX=Number.POSITIVE_INFINITY,maxX=0,minY=Number.POSITIVE_INFINITY,maxY=0,graphLabel=g.graph(),marginX=graphLabel.marginx||0,marginY=graphLabel.marginy||0;function getExtremes(attrs){var x=attrs.x,y=attrs.y,w=attrs.width,h=attrs.height;minX=Math.min(minX,x-w/2);maxX=Math.max(maxX,x+w/2);minY=Math.min(minY,y-h/2);maxY=Math.max(maxY,y+h/2)}_.each(g.nodes(),function(v){getExtremes(g.node(v))});_.each(g.edges(),function(e){var edge=g.edge(e);if(_.has(edge,"x")){getExtremes(edge)}});minX-=marginX;minY-=marginY;_.each(g.nodes(),function(v){var node=g.node(v);node.x-=minX;node.y-=minY});_.each(g.edges(),function(e){var edge=g.edge(e);_.each(edge.points,function(p){p.x-=minX;p.y-=minY});if(_.has(edge,"x")){edge.x-=minX}if(_.has(edge,"y")){edge.y-=minY}});graphLabel.width=maxX-minX+marginX;graphLabel.height=maxY-minY+marginY}function assignNodeIntersects(g){_.each(g.edges(),function(e){var edge=g.edge(e),nodeV=g.node(e.v),nodeW=g.node(e.w),p1,p2;if(!edge.points){edge.points=[];p1=nodeW;p2=nodeV}else{p1=edge.points[0];p2=edge.points[edge.points.length-1]}edge.points.unshift(util.intersectRect(nodeV,p1));edge.points.push(util.intersectRect(nodeW,p2))})}function fixupEdgeLabelCoords(g){_.each(g.edges(),function(e){var edge=g.edge(e);if(_.has(edge,"x")){if(edge.labelpos==="l"||edge.labelpos==="r"){edge.width-=edge.labeloffset}switch(edge.labelpos){case"l":edge.x-=edge.width/2+edge.labeloffset;break;case"r":edge.x+=edge.width/2+edge.labeloffset;break}}})}function reversePointsForReversedEdges(g){_.each(g.edges(),function(e){var edge=g.edge(e);if(edge.reversed){edge.points.reverse()}})}function removeBorderNodes(g){_.each(g.nodes(),function(v){if(g.children(v).length){var node=g.node(v),t=g.node(node.borderTop),b=g.node(node.borderBottom),l=g.node(_.last(node.borderLeft)),r=g.node(_.last(node.borderRight));node.width=Math.abs(r.x-l.x);node.height=Math.abs(b.y-t.y);node.x=l.x+node.width/2;node.y=t.y+node.height/2}});_.each(g.nodes(),function(v){if(g.node(v).dummy==="border"){g.removeNode(v)}})}function removeSelfEdges(g){_.each(g.edges(),function(e){if(e.v===e.w){var node=g.node(e.v);if(!node.selfEdges){node.selfEdges=[]}node.selfEdges.push({e:e,label:g.edge(e)});g.removeEdge(e)}})}function insertSelfEdges(g){var layers=util.buildLayerMatrix(g);_.each(layers,function(layer){var orderShift=0;_.each(layer,function(v,i){var node=g.node(v);node.order=i+orderShift;_.each(node.selfEdges,function(selfEdge){util.addDummyNode(g,"selfedge",{width:selfEdge.label.width,height:selfEdge.label.height,rank:node.rank,order:i+ ++orderShift,e:selfEdge.e,label:selfEdge.label},"_se")});delete node.selfEdges})})}function positionSelfEdges(g){_.each(g.nodes(),function(v){var node=g.node(v);if(node.dummy==="selfedge"){var selfNode=g.node(node.e.v),x=selfNode.x+selfNode.width/2,y=selfNode.y,dx=node.x-x,dy=selfNode.height/2;g.setEdge(node.e,node.label);g.removeNode(v);node.label.points=[{x:x+2*dx/3,y:y-dy},{x:x+5*dx/6,y:y-dy},{x:x+dx,y:y},{x:x+5*dx/6,y:y+dy},{x:x+2*dx/3,y:y+dy}];node.label.x=node.x;node.label.y=node.y}})}function selectNumberAttrs(obj,attrs){return _.mapValues(_.pick(obj,attrs),Number)}function canonicalize(attrs){var newAttrs={};_.each(attrs,function(v,k){newAttrs[k.toLowerCase()]=v});return newAttrs}},{"./acyclic":2,"./add-border-segments":3,"./coordinate-system":4,"./graphlib":7,"./lodash":10,"./nesting-graph":11,"./normalize":12,"./order":17,"./parent-dummy-chains":22,"./position":24,"./rank":26,"./util":29}],10:[function(require,module,exports){var lodash;if(require){try{lodash=require("lodash")}catch(e){}}if(!lodash){lodash=window._}module.exports=lodash},{lodash:51}],11:[function(require,module,exports){var _=require("./lodash"),util=require("./util");module.exports={run:run,cleanup:cleanup};function run(g){var root=util.addDummyNode(g,"root",{},"_root"),depths=treeDepths(g),height=_.max(depths)-1,nodeSep=2*height+1;g.graph().nestingRoot=root;_.each(g.edges(),function(e){g.edge(e).minlen*=nodeSep});var weight=sumWeights(g)+1;_.each(g.children(),function(child){dfs(g,root,nodeSep,weight,height,depths,child)});g.graph().nodeRankFactor=nodeSep}function dfs(g,root,nodeSep,weight,height,depths,v){var children=g.children(v);if(!children.length){if(v!==root){g.setEdge(root,v,{weight:0,minlen:nodeSep})}return}var top=util.addBorderNode(g,"_bt"),bottom=util.addBorderNode(g,"_bb"),label=g.node(v);g.setParent(top,v);label.borderTop=top;g.setParent(bottom,v);label.borderBottom=bottom;_.each(children,function(child){dfs(g,root,nodeSep,weight,height,depths,child);var childNode=g.node(child),childTop=childNode.borderTop?childNode.borderTop:child,childBottom=childNode.borderBottom?childNode.borderBottom:child,thisWeight=childNode.borderTop?weight:2*weight,minlen=childTop!==childBottom?1:height-depths[v]+1;g.setEdge(top,childTop,{weight:thisWeight,minlen:minlen,nestingEdge:true});g.setEdge(childBottom,bottom,{weight:thisWeight,minlen:minlen,nestingEdge:true})});if(!g.parent(v)){g.setEdge(root,top,{weight:0,minlen:height+depths[v]})}}function treeDepths(g){var depths={};function dfs(v,depth){var children=g.children(v);if(children&&children.length){_.each(children,function(child){dfs(child,depth+1)})}depths[v]=depth}_.each(g.children(),function(v){dfs(v,1)});return depths}function sumWeights(g){return _.reduce(g.edges(),function(acc,e){return acc+g.edge(e).weight},0)}function cleanup(g){var graphLabel=g.graph();g.removeNode(graphLabel.nestingRoot);delete graphLabel.nestingRoot;_.each(g.edges(),function(e){var edge=g.edge(e);if(edge.nestingEdge){g.removeEdge(e)}})}},{"./lodash":10,"./util":29}],12:[function(require,module,exports){"use strict";var _=require("./lodash"),util=require("./util");module.exports={run:run,undo:undo};function run(g){g.graph().dummyChains=[];_.each(g.edges(),function(edge){normalizeEdge(g,edge)})}function normalizeEdge(g,e){var v=e.v,vRank=g.node(v).rank,w=e.w,wRank=g.node(w).rank,name=e.name,edgeLabel=g.edge(e),labelRank=edgeLabel.labelRank;if(wRank===vRank+1)return;g.removeEdge(e);var dummy,attrs,i;for(i=0,++vRank;vRank<wRank;++i,++vRank){edgeLabel.points=[];attrs={width:0,height:0,edgeLabel:edgeLabel,edgeObj:e,rank:vRank};dummy=util.addDummyNode(g,"edge",attrs,"_d");if(vRank===labelRank){attrs.width=edgeLabel.width;attrs.height=edgeLabel.height;attrs.dummy="edge-label";attrs.labelpos=edgeLabel.labelpos}g.setEdge(v,dummy,{weight:edgeLabel.weight},name);if(i===0){g.graph().dummyChains.push(dummy)}v=dummy}g.setEdge(v,w,{weight:edgeLabel.weight},name)}function undo(g){_.each(g.graph().dummyChains,function(v){var node=g.node(v),origLabel=node.edgeLabel,w;g.setEdge(node.edgeObj,origLabel);while(node.dummy){w=g.successors(v)[0];g.removeNode(v);origLabel.points.push({x:node.x,y:node.y});if(node.dummy==="edge-label"){origLabel.x=node.x;origLabel.y=node.y;origLabel.width=node.width;origLabel.height=node.height}v=w;node=g.node(v)}})}},{"./lodash":10,"./util":29}],13:[function(require,module,exports){var _=require("../lodash");module.exports=addSubgraphConstraints;function addSubgraphConstraints(g,cg,vs){var prev={},rootPrev;_.each(vs,function(v){var child=g.parent(v),parent,prevChild;while(child){parent=g.parent(child);if(parent){prevChild=prev[parent];prev[parent]=child}else{prevChild=rootPrev;rootPrev=child}if(prevChild&&prevChild!==child){cg.setEdge(prevChild,child);return}child=parent}})}},{"../lodash":10}],14:[function(require,module,exports){var _=require("../lodash");module.exports=barycenter;function barycenter(g,movable){return _.map(movable,function(v){var inV=g.inEdges(v);if(!inV.length){return{v:v}}else{var result=_.reduce(inV,function(acc,e){var edge=g.edge(e),nodeU=g.node(e.v);return{sum:acc.sum+edge.weight*nodeU.order,weight:acc.weight+edge.weight}},{sum:0,weight:0});return{v:v,barycenter:result.sum/result.weight,weight:result.weight}}})}},{"../lodash":10}],15:[function(require,module,exports){var _=require("../lodash"),Graph=require("../graphlib").Graph;module.exports=buildLayerGraph;function buildLayerGraph(g,rank,relationship){var root=createRootNode(g),result=new Graph({compound:true}).setGraph({root:root}).setDefaultNodeLabel(function(v){return g.node(v)});_.each(g.nodes(),function(v){var node=g.node(v),parent=g.parent(v);if(node.rank===rank||node.minRank<=rank&&rank<=node.maxRank){result.setNode(v);result.setParent(v,parent||root);_.each(g[relationship](v),function(e){var u=e.v===v?e.w:e.v,edge=result.edge(u,v),weight=!_.isUndefined(edge)?edge.weight:0;result.setEdge(u,v,{weight:g.edge(e).weight+weight})});if(_.has(node,"minRank")){result.setNode(v,{borderLeft:node.borderLeft[rank],borderRight:node.borderRight[rank]})}}});return result}function createRootNode(g){var v;while(g.hasNode(v=_.uniqueId("_root")));return v}},{"../graphlib":7,"../lodash":10}],16:[function(require,module,exports){"use strict";var _=require("../lodash");module.exports=crossCount;function crossCount(g,layering){var cc=0;for(var i=1;i<layering.length;++i){cc+=twoLayerCrossCount(g,layering[i-1],layering[i])}return cc}function twoLayerCrossCount(g,northLayer,southLayer){var southPos=_.zipObject(southLayer,_.map(southLayer,function(v,i){return i}));var southEntries=_.flatten(_.map(northLayer,function(v){return _.chain(g.outEdges(v)).map(function(e){return{pos:southPos[e.w],weight:g.edge(e).weight}}).sortBy("pos").value()}),true);var firstIndex=1;while(firstIndex<southLayer.length)firstIndex<<=1;var treeSize=2*firstIndex-1;firstIndex-=1;var tree=_.map(new Array(treeSize),function(){return 0});var cc=0;_.each(southEntries.forEach(function(entry){var index=entry.pos+firstIndex;tree[index]+=entry.weight;var weightSum=0;while(index>0){if(index%2){weightSum+=tree[index+1]}index=index-1>>1;tree[index]+=entry.weight}cc+=entry.weight*weightSum}));return cc}},{"../lodash":10}],17:[function(require,module,exports){"use strict";var _=require("../lodash"),initOrder=require("./init-order"),crossCount=require("./cross-count"),sortSubgraph=require("./sort-subgraph"),buildLayerGraph=require("./build-layer-graph"),addSubgraphConstraints=require("./add-subgraph-constraints"),Graph=require("../graphlib").Graph,util=require("../util");module.exports=order;function order(g){var maxRank=util.maxRank(g),downLayerGraphs=buildLayerGraphs(g,_.range(1,maxRank+1),"inEdges"),upLayerGraphs=buildLayerGraphs(g,_.range(maxRank-1,-1,-1),"outEdges");var layering=initOrder(g);assignOrder(g,layering);var bestCC=Number.POSITIVE_INFINITY,best;for(var i=0,lastBest=0;lastBest<4;++i,++lastBest){sweepLayerGraphs(i%2?downLayerGraphs:upLayerGraphs,i%4>=2);layering=util.buildLayerMatrix(g);var cc=crossCount(g,layering);if(cc<bestCC){lastBest=0;best=_.cloneDeep(layering);bestCC=cc}}assignOrder(g,best)}function buildLayerGraphs(g,ranks,relationship){return _.map(ranks,function(rank){return buildLayerGraph(g,rank,relationship)})}function sweepLayerGraphs(layerGraphs,biasRight){var cg=new Graph;_.each(layerGraphs,function(lg){var root=lg.graph().root;var sorted=sortSubgraph(lg,root,cg,biasRight);_.each(sorted.vs,function(v,i){lg.node(v).order=i});addSubgraphConstraints(lg,cg,sorted.vs)})}function assignOrder(g,layering){_.each(layering,function(layer){_.each(layer,function(v,i){g.node(v).order=i})})}},{"../graphlib":7,"../lodash":10,"../util":29,"./add-subgraph-constraints":13,"./build-layer-graph":15,"./cross-count":16,"./init-order":18,"./sort-subgraph":20}],18:[function(require,module,exports){"use strict";var _=require("../lodash");module.exports=initOrder;function initOrder(g){var visited={},simpleNodes=_.filter(g.nodes(),function(v){return!g.children(v).length}),maxRank=_.max(_.map(simpleNodes,function(v){return g.node(v).rank})),layers=_.map(_.range(maxRank+1),function(){return[]});function dfs(v){if(_.has(visited,v))return;visited[v]=true;var node=g.node(v);layers[node.rank].push(v);_.each(g.successors(v),dfs)}var orderedVs=_.sortBy(simpleNodes,function(v){return g.node(v).rank});_.each(orderedVs,dfs);return layers}},{"../lodash":10}],19:[function(require,module,exports){"use strict";var _=require("../lodash");module.exports=resolveConflicts;function resolveConflicts(entries,cg){var mappedEntries={};_.each(entries,function(entry,i){var tmp=mappedEntries[entry.v]={indegree:0,"in":[],out:[],vs:[entry.v],i:i};if(!_.isUndefined(entry.barycenter)){tmp.barycenter=entry.barycenter;tmp.weight=entry.weight}});_.each(cg.edges(),function(e){var entryV=mappedEntries[e.v],entryW=mappedEntries[e.w];if(!_.isUndefined(entryV)&&!_.isUndefined(entryW)){entryW.indegree++;entryV.out.push(mappedEntries[e.w])}});var sourceSet=_.filter(mappedEntries,function(entry){return!entry.indegree});return doResolveConflicts(sourceSet)}function doResolveConflicts(sourceSet){var entries=[];function handleIn(vEntry){return function(uEntry){if(uEntry.merged){return}if(_.isUndefined(uEntry.barycenter)||_.isUndefined(vEntry.barycenter)||uEntry.barycenter>=vEntry.barycenter){mergeEntries(vEntry,uEntry)}}}function handleOut(vEntry){return function(wEntry){wEntry["in"].push(vEntry);if(--wEntry.indegree===0){sourceSet.push(wEntry)}}}while(sourceSet.length){var entry=sourceSet.pop();entries.push(entry);_.each(entry["in"].reverse(),handleIn(entry));_.each(entry.out,handleOut(entry))}return _.chain(entries).filter(function(entry){return!entry.merged}).map(function(entry){return _.pick(entry,["vs","i","barycenter","weight"])}).value()}function mergeEntries(target,source){var sum=0,weight=0;if(target.weight){sum+=target.barycenter*target.weight;weight+=target.weight}if(source.weight){sum+=source.barycenter*source.weight;weight+=source.weight}target.vs=source.vs.concat(target.vs);target.barycenter=sum/weight;target.weight=weight;target.i=Math.min(source.i,target.i);source.merged=true}},{"../lodash":10}],20:[function(require,module,exports){var _=require("../lodash"),barycenter=require("./barycenter"),resolveConflicts=require("./resolve-conflicts"),sort=require("./sort");module.exports=sortSubgraph;function sortSubgraph(g,v,cg,biasRight){var movable=g.children(v),node=g.node(v),bl=node?node.borderLeft:undefined,br=node?node.borderRight:undefined,subgraphs={};if(bl){movable=_.filter(movable,function(w){return w!==bl&&w!==br})}var barycenters=barycenter(g,movable);_.each(barycenters,function(entry){if(g.children(entry.v).length){var subgraphResult=sortSubgraph(g,entry.v,cg,biasRight);subgraphs[entry.v]=subgraphResult;if(_.has(subgraphResult,"barycenter")){mergeBarycenters(entry,subgraphResult)}}});var entries=resolveConflicts(barycenters,cg);expandSubgraphs(entries,subgraphs);var result=sort(entries,biasRight);if(bl){result.vs=_.flatten([bl,result.vs,br],true);if(g.predecessors(bl).length){var blPred=g.node(g.predecessors(bl)[0]),brPred=g.node(g.predecessors(br)[0]);if(!_.has(result,"barycenter")){result.barycenter=0;result.weight=0}result.barycenter=(result.barycenter*result.weight+blPred.order+brPred.order)/(result.weight+2);result.weight+=2}}return result}function expandSubgraphs(entries,subgraphs){_.each(entries,function(entry){entry.vs=_.flatten(entry.vs.map(function(v){if(subgraphs[v]){return subgraphs[v].vs}return v}),true)})}function mergeBarycenters(target,other){if(!_.isUndefined(target.barycenter)){target.barycenter=(target.barycenter*target.weight+other.barycenter*other.weight)/(target.weight+other.weight);target.weight+=other.weight}else{target.barycenter=other.barycenter;target.weight=other.weight}}},{"../lodash":10,"./barycenter":14,"./resolve-conflicts":19,"./sort":21}],21:[function(require,module,exports){var _=require("../lodash"),util=require("../util");module.exports=sort;function sort(entries,biasRight){var parts=util.partition(entries,function(entry){return _.has(entry,"barycenter")});var sortable=parts.lhs,unsortable=_.sortBy(parts.rhs,function(entry){return-entry.i}),vs=[],sum=0,weight=0,vsIndex=0;sortable.sort(compareWithBias(!!biasRight));vsIndex=consumeUnsortable(vs,unsortable,vsIndex);_.each(sortable,function(entry){vsIndex+=entry.vs.length;vs.push(entry.vs);sum+=entry.barycenter*entry.weight;weight+=entry.weight;vsIndex=consumeUnsortable(vs,unsortable,vsIndex)});var result={vs:_.flatten(vs,true)};if(weight){result.barycenter=sum/weight;result.weight=weight}return result}function consumeUnsortable(vs,unsortable,index){var last;while(unsortable.length&&(last=_.last(unsortable)).i<=index){unsortable.pop();vs.push(last.vs);index++}return index}function compareWithBias(bias){return function(entryV,entryW){if(entryV.barycenter<entryW.barycenter){return-1}else if(entryV.barycenter>entryW.barycenter){return 1}return!bias?entryV.i-entryW.i:entryW.i-entryV.i}}},{"../lodash":10,"../util":29}],22:[function(require,module,exports){var _=require("./lodash");module.exports=parentDummyChains;function parentDummyChains(g){var postorderNums=postorder(g);_.each(g.graph().dummyChains,function(v){var node=g.node(v),edgeObj=node.edgeObj,pathData=findPath(g,postorderNums,edgeObj.v,edgeObj.w),path=pathData.path,lca=pathData.lca,pathIdx=0,pathV=path[pathIdx],ascending=true;while(v!==edgeObj.w){node=g.node(v);if(ascending){while((pathV=path[pathIdx])!==lca&&g.node(pathV).maxRank<node.rank){pathIdx++}if(pathV===lca){ascending=false}}if(!ascending){while(pathIdx<path.length-1&&g.node(pathV=path[pathIdx+1]).minRank<=node.rank){pathIdx++}pathV=path[pathIdx]}g.setParent(v,pathV);v=g.successors(v)[0]}})}function findPath(g,postorderNums,v,w){var vPath=[],wPath=[],low=Math.min(postorderNums[v].low,postorderNums[w].low),lim=Math.max(postorderNums[v].lim,postorderNums[w].lim),parent,lca;parent=v;do{parent=g.parent(parent);vPath.push(parent)}while(parent&&(postorderNums[parent].low>low||lim>postorderNums[parent].lim));lca=parent;parent=w;while((parent=g.parent(parent))!==lca){wPath.push(parent)}return{path:vPath.concat(wPath.reverse()),lca:lca}}function postorder(g){var result={},lim=0;function dfs(v){var low=lim;_.each(g.children(v),dfs);result[v]={low:low,lim:lim++}}_.each(g.children(),dfs);return result}},{"./lodash":10}],23:[function(require,module,exports){"use strict";var _=require("../lodash"),Graph=require("../graphlib").Graph,util=require("../util");module.exports={positionX:positionX,findType1Conflicts:findType1Conflicts,findType2Conflicts:findType2Conflicts,addConflict:addConflict,hasConflict:hasConflict,verticalAlignment:verticalAlignment,horizontalCompaction:horizontalCompaction,alignCoordinates:alignCoordinates,findSmallestWidthAlignment:findSmallestWidthAlignment,balance:balance};function findType1Conflicts(g,layering){var conflicts={};function visitLayer(prevLayer,layer){var k0=0,scanPos=0,prevLayerLength=prevLayer.length,lastNode=_.last(layer);_.each(layer,function(v,i){var w=findOtherInnerSegmentNode(g,v),k1=w?g.node(w).order:prevLayerLength;if(w||v===lastNode){_.each(layer.slice(scanPos,i+1),function(scanNode){_.each(g.predecessors(scanNode),function(u){var uLabel=g.node(u),uPos=uLabel.order;
  if((uPos<k0||k1<uPos)&&!(uLabel.dummy&&g.node(scanNode).dummy)){addConflict(conflicts,u,scanNode)}})});scanPos=i+1;k0=k1}});return layer}_.reduce(layering,visitLayer);return conflicts}function findType2Conflicts(g,layering){var conflicts={};function scan(south,southPos,southEnd,prevNorthBorder,nextNorthBorder){var v;_.each(_.range(southPos,southEnd),function(i){v=south[i];if(g.node(v).dummy){_.each(g.predecessors(v),function(u){var uNode=g.node(u);if(uNode.dummy&&(uNode.order<prevNorthBorder||uNode.order>nextNorthBorder)){addConflict(conflicts,u,v)}})}})}function visitLayer(north,south){var prevNorthPos=-1,nextNorthPos,southPos=0;_.each(south,function(v,southLookahead){if(g.node(v).dummy==="border"){var predecessors=g.predecessors(v);if(predecessors.length){nextNorthPos=g.node(predecessors[0]).order;scan(south,southPos,southLookahead,prevNorthPos,nextNorthPos);southPos=southLookahead;prevNorthPos=nextNorthPos}}scan(south,southPos,south.length,nextNorthPos,north.length)});return south}_.reduce(layering,visitLayer);return conflicts}function findOtherInnerSegmentNode(g,v){if(g.node(v).dummy){return _.find(g.predecessors(v),function(u){return g.node(u).dummy})}}function addConflict(conflicts,v,w){if(v>w){var tmp=v;v=w;w=tmp}var conflictsV=conflicts[v];if(!conflictsV){conflicts[v]=conflictsV={}}conflictsV[w]=true}function hasConflict(conflicts,v,w){if(v>w){var tmp=v;v=w;w=tmp}return _.has(conflicts[v],w)}function verticalAlignment(g,layering,conflicts,neighborFn){var root={},align={},pos={};_.each(layering,function(layer){_.each(layer,function(v,order){root[v]=v;align[v]=v;pos[v]=order})});_.each(layering,function(layer){var prevIdx=-1;_.each(layer,function(v){var ws=neighborFn(v);if(ws.length){ws=_.sortBy(ws,function(w){return pos[w]});var mp=(ws.length-1)/2;for(var i=Math.floor(mp),il=Math.ceil(mp);i<=il;++i){var w=ws[i];if(align[v]===v&&prevIdx<pos[w]&&!hasConflict(conflicts,v,w)){align[w]=v;align[v]=root[v]=root[w];prevIdx=pos[w]}}}})});return{root:root,align:align}}function horizontalCompaction(g,layering,root,align,reverseSep){var xs={},blockG=buildBlockGraph(g,layering,root,reverseSep);var visited={};function pass1(v){if(!_.has(visited,v)){visited[v]=true;xs[v]=_.reduce(blockG.inEdges(v),function(max,e){pass1(e.v);return Math.max(max,xs[e.v]+blockG.edge(e))},0)}}_.each(blockG.nodes(),pass1);var borderType=reverseSep?"borderLeft":"borderRight";function pass2(v){if(visited[v]!==2){visited[v]++;var node=g.node(v);var min=_.reduce(blockG.outEdges(v),function(min,e){pass2(e.w);return Math.min(min,xs[e.w]-blockG.edge(e))},Number.POSITIVE_INFINITY);if(min!==Number.POSITIVE_INFINITY&&node.borderType!==borderType){xs[v]=Math.max(xs[v],min)}}}_.each(blockG.nodes(),pass2);_.each(align,function(v){xs[v]=xs[root[v]]});return xs}function buildBlockGraph(g,layering,root,reverseSep){var blockGraph=new Graph,graphLabel=g.graph(),sepFn=sep(graphLabel.nodesep,graphLabel.edgesep,reverseSep);_.each(layering,function(layer){var u;_.each(layer,function(v){var vRoot=root[v];blockGraph.setNode(vRoot);if(u){var uRoot=root[u],prevMax=blockGraph.edge(uRoot,vRoot);blockGraph.setEdge(uRoot,vRoot,Math.max(sepFn(g,v,u),prevMax||0))}u=v})});return blockGraph}function findSmallestWidthAlignment(g,xss){return _.min(xss,function(xs){var min=_.min(xs,function(x,v){return x-width(g,v)/2}),max=_.max(xs,function(x,v){return x+width(g,v)/2});return max-min})}function alignCoordinates(xss,alignTo){var alignToMin=_.min(alignTo),alignToMax=_.max(alignTo);_.each(["u","d"],function(vert){_.each(["l","r"],function(horiz){var alignment=vert+horiz,xs=xss[alignment],delta;if(xs===alignTo)return;delta=horiz==="l"?alignToMin-_.min(xs):alignToMax-_.max(xs);if(delta){xss[alignment]=_.mapValues(xs,function(x){return x+delta})}})})}function balance(xss,align){return _.mapValues(xss.ul,function(ignore,v){if(align){return xss[align.toLowerCase()][v]}else{var xs=_.sortBy(_.pluck(xss,v));return(xs[1]+xs[2])/2}})}function positionX(g){var layering=util.buildLayerMatrix(g),conflicts=_.merge(findType1Conflicts(g,layering),findType2Conflicts(g,layering));var xss={},adjustedLayering;_.each(["u","d"],function(vert){adjustedLayering=vert==="u"?layering:_.values(layering).reverse();_.each(["l","r"],function(horiz){if(horiz==="r"){adjustedLayering=_.map(adjustedLayering,function(inner){return _.values(inner).reverse()})}var neighborFn=_.bind(vert==="u"?g.predecessors:g.successors,g);var align=verticalAlignment(g,adjustedLayering,conflicts,neighborFn);var xs=horizontalCompaction(g,adjustedLayering,align.root,align.align,horiz==="r");if(horiz==="r"){xs=_.mapValues(xs,function(x){return-x})}xss[vert+horiz]=xs})});var smallestWidth=findSmallestWidthAlignment(g,xss);alignCoordinates(xss,smallestWidth);return balance(xss,g.graph().align)}function sep(nodeSep,edgeSep,reverseSep){return function(g,v,w){var vLabel=g.node(v),wLabel=g.node(w),sum=0,delta;sum+=vLabel.width/2;if(_.has(vLabel,"labelpos")){switch(vLabel.labelpos.toLowerCase()){case"l":delta=-vLabel.width/2;break;case"r":delta=vLabel.width/2;break}}if(delta){sum+=reverseSep?delta:-delta}delta=0;sum+=(vLabel.dummy?edgeSep:nodeSep)/2;sum+=(wLabel.dummy?edgeSep:nodeSep)/2;sum+=wLabel.width/2;if(_.has(wLabel,"labelpos")){switch(wLabel.labelpos.toLowerCase()){case"l":delta=wLabel.width/2;break;case"r":delta=-wLabel.width/2;break}}if(delta){sum+=reverseSep?delta:-delta}delta=0;return sum}}function width(g,v){return g.node(v).width}},{"../graphlib":7,"../lodash":10,"../util":29}],24:[function(require,module,exports){"use strict";var _=require("../lodash"),util=require("../util"),positionX=require("./bk").positionX;module.exports=position;function position(g){g=util.asNonCompoundGraph(g);positionY(g);_.each(positionX(g),function(x,v){g.node(v).x=x})}function positionY(g){var layering=util.buildLayerMatrix(g),rankSep=g.graph().ranksep,prevY=0;_.each(layering,function(layer){var maxHeight=_.max(_.map(layer,function(v){return g.node(v).height}));_.each(layer,function(v){g.node(v).y=prevY+maxHeight/2});prevY+=maxHeight+rankSep})}},{"../lodash":10,"../util":29,"./bk":23}],25:[function(require,module,exports){"use strict";var _=require("../lodash"),Graph=require("../graphlib").Graph,slack=require("./util").slack;module.exports=feasibleTree;function feasibleTree(g){var t=new Graph({directed:false});var start=g.nodes()[0],size=g.nodeCount();t.setNode(start,{});var edge,delta;while(tightTree(t,g)<size){edge=findMinSlackEdge(t,g);delta=t.hasNode(edge.v)?slack(g,edge):-slack(g,edge);shiftRanks(t,g,delta)}return t}function tightTree(t,g){function dfs(v){_.each(g.nodeEdges(v),function(e){var edgeV=e.v,w=v===edgeV?e.w:edgeV;if(!t.hasNode(w)&&!slack(g,e)){t.setNode(w,{});t.setEdge(v,w,{});dfs(w)}})}_.each(t.nodes(),dfs);return t.nodeCount()}function findMinSlackEdge(t,g){return _.min(g.edges(),function(e){if(t.hasNode(e.v)!==t.hasNode(e.w)){return slack(g,e)}})}function shiftRanks(t,g,delta){_.each(t.nodes(),function(v){g.node(v).rank+=delta})}},{"../graphlib":7,"../lodash":10,"./util":28}],26:[function(require,module,exports){"use strict";var rankUtil=require("./util"),longestPath=rankUtil.longestPath,feasibleTree=require("./feasible-tree"),networkSimplex=require("./network-simplex");module.exports=rank;function rank(g){switch(g.graph().ranker){case"network-simplex":networkSimplexRanker(g);break;case"tight-tree":tightTreeRanker(g);break;case"longest-path":longestPathRanker(g);break;default:networkSimplexRanker(g)}}var longestPathRanker=longestPath;function tightTreeRanker(g){longestPath(g);feasibleTree(g)}function networkSimplexRanker(g){networkSimplex(g)}},{"./feasible-tree":25,"./network-simplex":27,"./util":28}],27:[function(require,module,exports){"use strict";var _=require("../lodash"),feasibleTree=require("./feasible-tree"),slack=require("./util").slack,initRank=require("./util").longestPath,preorder=require("../graphlib").alg.preorder,postorder=require("../graphlib").alg.postorder,simplify=require("../util").simplify;module.exports=networkSimplex;networkSimplex.initLowLimValues=initLowLimValues;networkSimplex.initCutValues=initCutValues;networkSimplex.calcCutValue=calcCutValue;networkSimplex.leaveEdge=leaveEdge;networkSimplex.enterEdge=enterEdge;networkSimplex.exchangeEdges=exchangeEdges;function networkSimplex(g){g=simplify(g);initRank(g);var t=feasibleTree(g);initLowLimValues(t);initCutValues(t,g);var e,f;while(e=leaveEdge(t)){f=enterEdge(t,g,e);exchangeEdges(t,g,e,f)}}function initCutValues(t,g){var vs=postorder(t,t.nodes());vs=vs.slice(0,vs.length-1);_.each(vs,function(v){assignCutValue(t,g,v)})}function assignCutValue(t,g,child){var childLab=t.node(child),parent=childLab.parent;t.edge(child,parent).cutvalue=calcCutValue(t,g,child)}function calcCutValue(t,g,child){var childLab=t.node(child),parent=childLab.parent,childIsTail=true,graphEdge=g.edge(child,parent),cutValue=0;if(!graphEdge){childIsTail=false;graphEdge=g.edge(parent,child)}cutValue=graphEdge.weight;_.each(g.nodeEdges(child),function(e){var isOutEdge=e.v===child,other=isOutEdge?e.w:e.v;if(other!==parent){var pointsToHead=isOutEdge===childIsTail,otherWeight=g.edge(e).weight;cutValue+=pointsToHead?otherWeight:-otherWeight;if(isTreeEdge(t,child,other)){var otherCutValue=t.edge(child,other).cutvalue;cutValue+=pointsToHead?-otherCutValue:otherCutValue}}});return cutValue}function initLowLimValues(tree,root){if(arguments.length<2){root=tree.nodes()[0]}dfsAssignLowLim(tree,{},1,root)}function dfsAssignLowLim(tree,visited,nextLim,v,parent){var low=nextLim,label=tree.node(v);visited[v]=true;_.each(tree.neighbors(v),function(w){if(!_.has(visited,w)){nextLim=dfsAssignLowLim(tree,visited,nextLim,w,v)}});label.low=low;label.lim=nextLim++;if(parent){label.parent=parent}else{delete label.parent}return nextLim}function leaveEdge(tree){return _.find(tree.edges(),function(e){return tree.edge(e).cutvalue<0})}function enterEdge(t,g,edge){var v=edge.v,w=edge.w;if(!g.hasEdge(v,w)){v=edge.w;w=edge.v}var vLabel=t.node(v),wLabel=t.node(w),tailLabel=vLabel,flip=false;if(vLabel.lim>wLabel.lim){tailLabel=wLabel;flip=true}var candidates=_.filter(g.edges(),function(edge){return flip===isDescendant(t,t.node(edge.v),tailLabel)&&flip!==isDescendant(t,t.node(edge.w),tailLabel)});return _.min(candidates,function(edge){return slack(g,edge)})}function exchangeEdges(t,g,e,f){var v=e.v,w=e.w;t.removeEdge(v,w);t.setEdge(f.v,f.w,{});initLowLimValues(t);initCutValues(t,g);updateRanks(t,g)}function updateRanks(t,g){var root=_.find(t.nodes(),function(v){return!g.node(v).parent}),vs=preorder(t,root);vs=vs.slice(1);_.each(vs,function(v){var parent=t.node(v).parent,edge=g.edge(v,parent),flipped=false;if(!edge){edge=g.edge(parent,v);flipped=true}g.node(v).rank=g.node(parent).rank+(flipped?edge.minlen:-edge.minlen)})}function isTreeEdge(tree,u,v){return tree.hasEdge(u,v)}function isDescendant(tree,vLabel,rootLabel){return rootLabel.low<=vLabel.lim&&vLabel.lim<=rootLabel.lim}},{"../graphlib":7,"../lodash":10,"../util":29,"./feasible-tree":25,"./util":28}],28:[function(require,module,exports){"use strict";var _=require("../lodash");module.exports={longestPath:longestPath,slack:slack};function longestPath(g){var visited={};function dfs(v){var label=g.node(v);if(_.has(visited,v)){return label.rank}visited[v]=true;var rank=_.min(_.map(g.outEdges(v),function(e){return dfs(e.w)-g.edge(e).minlen}));if(rank===Number.POSITIVE_INFINITY){rank=0}return label.rank=rank}_.each(g.sources(),dfs)}function slack(g,e){return g.node(e.w).rank-g.node(e.v).rank-g.edge(e).minlen}},{"../lodash":10}],29:[function(require,module,exports){"use strict";var _=require("./lodash"),Graph=require("./graphlib").Graph;module.exports={addDummyNode:addDummyNode,simplify:simplify,asNonCompoundGraph:asNonCompoundGraph,successorWeights:successorWeights,predecessorWeights:predecessorWeights,intersectRect:intersectRect,buildLayerMatrix:buildLayerMatrix,normalizeRanks:normalizeRanks,removeEmptyRanks:removeEmptyRanks,addBorderNode:addBorderNode,maxRank:maxRank,partition:partition,time:time,notime:notime};function addDummyNode(g,type,attrs,name){var v;do{v=_.uniqueId(name)}while(g.hasNode(v));attrs.dummy=type;g.setNode(v,attrs);return v}function simplify(g){var simplified=(new Graph).setGraph(g.graph());_.each(g.nodes(),function(v){simplified.setNode(v,g.node(v))});_.each(g.edges(),function(e){var simpleLabel=simplified.edge(e.v,e.w)||{weight:0,minlen:1},label=g.edge(e);simplified.setEdge(e.v,e.w,{weight:simpleLabel.weight+label.weight,minlen:Math.max(simpleLabel.minlen,label.minlen)})});return simplified}function asNonCompoundGraph(g){var simplified=new Graph({multigraph:g.isMultigraph()}).setGraph(g.graph());_.each(g.nodes(),function(v){if(!g.children(v).length){simplified.setNode(v,g.node(v))}});_.each(g.edges(),function(e){simplified.setEdge(e,g.edge(e))});return simplified}function successorWeights(g){var weightMap=_.map(g.nodes(),function(v){var sucs={};_.each(g.outEdges(v),function(e){sucs[e.w]=(sucs[e.w]||0)+g.edge(e).weight});return sucs});return _.zipObject(g.nodes(),weightMap)}function predecessorWeights(g){var weightMap=_.map(g.nodes(),function(v){var preds={};_.each(g.inEdges(v),function(e){preds[e.v]=(preds[e.v]||0)+g.edge(e).weight});return preds});return _.zipObject(g.nodes(),weightMap)}function intersectRect(rect,point){var x=rect.x;var y=rect.y;var dx=point.x-x;var dy=point.y-y;var w=rect.width/2;var h=rect.height/2;if(!dx&&!dy){throw new Error("Not possible to find intersection inside of the rectangle")}var sx,sy;if(Math.abs(dy)*w>Math.abs(dx)*h){if(dy<0){h=-h}sx=h*dx/dy;sy=h}else{if(dx<0){w=-w}sx=w;sy=w*dy/dx}return{x:x+sx,y:y+sy}}function buildLayerMatrix(g){var layering=_.map(_.range(maxRank(g)+1),function(){return[]});_.each(g.nodes(),function(v){var node=g.node(v),rank=node.rank;if(!_.isUndefined(rank)){layering[rank][node.order]=v}});return layering}function normalizeRanks(g){var min=_.min(_.map(g.nodes(),function(v){return g.node(v).rank}));_.each(g.nodes(),function(v){var node=g.node(v);if(_.has(node,"rank")){node.rank-=min}})}function removeEmptyRanks(g){var offset=_.min(_.map(g.nodes(),function(v){return g.node(v).rank}));var layers=[];_.each(g.nodes(),function(v){var rank=g.node(v).rank-offset;if(!layers[rank]){layers[rank]=[]}layers[rank].push(v)});var delta=0,nodeRankFactor=g.graph().nodeRankFactor;_.each(layers,function(vs,i){if(_.isUndefined(vs)&&i%nodeRankFactor!==0){--delta}else if(delta){_.each(vs,function(v){g.node(v).rank+=delta})}})}function addBorderNode(g,prefix,rank,order){var node={width:0,height:0};if(arguments.length>=4){node.rank=rank;node.order=order}return addDummyNode(g,"border",node,prefix)}function maxRank(g){return _.max(_.map(g.nodes(),function(v){var rank=g.node(v).rank;if(!_.isUndefined(rank)){return rank}}))}function partition(collection,fn){var result={lhs:[],rhs:[]};_.each(collection,function(value){if(fn(value)){result.lhs.push(value)}else{result.rhs.push(value)}});return result}function time(name,fn){var start=_.now();try{return fn()}finally{console.log(name+" time: "+(_.now()-start)+"ms")}}function notime(name,fn){return fn()}},{"./graphlib":7,"./lodash":10}],30:[function(require,module,exports){module.exports="0.7.3"},{}],31:[function(require,module,exports){var lib=require("./lib");module.exports={Graph:lib.Graph,json:require("./lib/json"),alg:require("./lib/alg"),version:lib.version}},{"./lib":47,"./lib/alg":38,"./lib/json":48}],32:[function(require,module,exports){var _=require("../lodash");module.exports=components;function components(g){var visited={},cmpts=[],cmpt;function dfs(v){if(_.has(visited,v))return;visited[v]=true;cmpt.push(v);_.each(g.successors(v),dfs);_.each(g.predecessors(v),dfs)}_.each(g.nodes(),function(v){cmpt=[];dfs(v);if(cmpt.length){cmpts.push(cmpt)}});return cmpts}},{"../lodash":49}],33:[function(require,module,exports){var _=require("../lodash");module.exports=dfs;function dfs(g,vs,order){if(!_.isArray(vs)){vs=[vs]}var acc=[],visited={};_.each(vs,function(v){if(!g.hasNode(v)){throw new Error("Graph does not have node: "+v)}doDfs(g,v,order==="post",visited,acc)});return acc}function doDfs(g,v,postorder,visited,acc){if(!_.has(visited,v)){visited[v]=true;if(!postorder){acc.push(v)}_.each(g.neighbors(v),function(w){doDfs(g,w,postorder,visited,acc)});if(postorder){acc.push(v)}}}},{"../lodash":49}],34:[function(require,module,exports){var dijkstra=require("./dijkstra"),_=require("../lodash");module.exports=dijkstraAll;function dijkstraAll(g,weightFunc,edgeFunc){return _.transform(g.nodes(),function(acc,v){acc[v]=dijkstra(g,v,weightFunc,edgeFunc)},{})}},{"../lodash":49,"./dijkstra":35}],35:[function(require,module,exports){var _=require("../lodash"),PriorityQueue=require("../data/priority-queue");module.exports=dijkstra;var DEFAULT_WEIGHT_FUNC=_.constant(1);function dijkstra(g,source,weightFn,edgeFn){return runDijkstra(g,String(source),weightFn||DEFAULT_WEIGHT_FUNC,edgeFn||function(v){return g.outEdges(v)})}function runDijkstra(g,source,weightFn,edgeFn){var results={},pq=new PriorityQueue,v,vEntry;var updateNeighbors=function(edge){var w=edge.v!==v?edge.v:edge.w,wEntry=results[w],weight=weightFn(edge),distance=vEntry.distance+weight;if(weight<0){throw new Error("dijkstra does not allow negative edge weights. "+"Bad edge: "+edge+" Weight: "+weight)}if(distance<wEntry.distance){wEntry.distance=distance;wEntry.predecessor=v;pq.decrease(w,distance)}};g.nodes().forEach(function(v){var distance=v===source?0:Number.POSITIVE_INFINITY;results[v]={distance:distance};pq.add(v,distance)});while(pq.size()>0){v=pq.removeMin();vEntry=results[v];if(vEntry.distance===Number.POSITIVE_INFINITY){break}edgeFn(v).forEach(updateNeighbors)}return results}},{"../data/priority-queue":45,"../lodash":49}],36:[function(require,module,exports){var _=require("../lodash"),tarjan=require("./tarjan");module.exports=findCycles;function findCycles(g){return _.filter(tarjan(g),function(cmpt){return cmpt.length>1||cmpt.length===1&&g.hasEdge(cmpt[0],cmpt[0])})}},{"../lodash":49,"./tarjan":43}],37:[function(require,module,exports){var _=require("../lodash");module.exports=floydWarshall;var DEFAULT_WEIGHT_FUNC=_.constant(1);function floydWarshall(g,weightFn,edgeFn){return runFloydWarshall(g,weightFn||DEFAULT_WEIGHT_FUNC,edgeFn||function(v){return g.outEdges(v)})}function runFloydWarshall(g,weightFn,edgeFn){var results={},nodes=g.nodes();nodes.forEach(function(v){results[v]={};results[v][v]={distance:0};nodes.forEach(function(w){if(v!==w){results[v][w]={distance:Number.POSITIVE_INFINITY}}});edgeFn(v).forEach(function(edge){var w=edge.v===v?edge.w:edge.v,d=weightFn(edge);results[v][w]={distance:d,predecessor:v}})});nodes.forEach(function(k){var rowK=results[k];nodes.forEach(function(i){var rowI=results[i];nodes.forEach(function(j){var ik=rowI[k];var kj=rowK[j];var ij=rowI[j];var altDistance=ik.distance+kj.distance;if(altDistance<ij.distance){ij.distance=altDistance;ij.predecessor=kj.predecessor}})})});return results}},{"../lodash":49}],38:[function(require,module,exports){module.exports={components:require("./components"),dijkstra:require("./dijkstra"),dijkstraAll:require("./dijkstra-all"),findCycles:require("./find-cycles"),floydWarshall:require("./floyd-warshall"),isAcyclic:require("./is-acyclic"),postorder:require("./postorder"),preorder:require("./preorder"),prim:require("./prim"),tarjan:require("./tarjan"),topsort:require("./topsort")}},{"./components":32,"./dijkstra":35,"./dijkstra-all":34,"./find-cycles":36,"./floyd-warshall":37,"./is-acyclic":39,"./postorder":40,"./preorder":41,"./prim":42,"./tarjan":43,"./topsort":44}],39:[function(require,module,exports){var topsort=require("./topsort");module.exports=isAcyclic;function isAcyclic(g){try{topsort(g)}catch(e){if(e instanceof topsort.CycleException){return false}throw e}return true}},{"./topsort":44}],40:[function(require,module,exports){var dfs=require("./dfs");module.exports=postorder;function postorder(g,vs){return dfs(g,vs,"post")}},{"./dfs":33}],41:[function(require,module,exports){var dfs=require("./dfs");module.exports=preorder;function preorder(g,vs){return dfs(g,vs,"pre")}},{"./dfs":33}],42:[function(require,module,exports){var _=require("../lodash"),Graph=require("../graph"),PriorityQueue=require("../data/priority-queue");module.exports=prim;function prim(g,weightFunc){var result=new Graph,parents={},pq=new PriorityQueue,v;function updateNeighbors(edge){var w=edge.v===v?edge.w:edge.v,pri=pq.priority(w);if(pri!==undefined){var edgeWeight=weightFunc(edge);if(edgeWeight<pri){parents[w]=v;pq.decrease(w,edgeWeight)}}}if(g.nodeCount()===0){return result}_.each(g.nodes(),function(v){pq.add(v,Number.POSITIVE_INFINITY);result.setNode(v)});pq.decrease(g.nodes()[0],0);var init=false;while(pq.size()>0){v=pq.removeMin();if(_.has(parents,v)){result.setEdge(v,parents[v])}else if(init){throw new Error("Input graph is not connected: "+g)}else{init=true}g.nodeEdges(v).forEach(updateNeighbors)}return result}},{"../data/priority-queue":45,"../graph":46,"../lodash":49}],43:[function(require,module,exports){var _=require("../lodash");module.exports=tarjan;function tarjan(g){var index=0,stack=[],visited={},results=[];function dfs(v){var entry=visited[v]={onStack:true,lowlink:index,index:index++};stack.push(v);g.successors(v).forEach(function(w){if(!_.has(visited,w)){dfs(w);entry.lowlink=Math.min(entry.lowlink,visited[w].lowlink)}else if(visited[w].onStack){entry.lowlink=Math.min(entry.lowlink,visited[w].index)}});if(entry.lowlink===entry.index){var cmpt=[],w;do{w=stack.pop();visited[w].onStack=false;cmpt.push(w)}while(v!==w);results.push(cmpt)}}g.nodes().forEach(function(v){if(!_.has(visited,v)){dfs(v)}});return results}},{"../lodash":49}],44:[function(require,module,exports){var _=require("../lodash");module.exports=topsort;topsort.CycleException=CycleException;function topsort(g){var visited={},stack={},results=[];function visit(node){if(_.has(stack,node)){throw new CycleException}if(!_.has(visited,node)){stack[node]=true;visited[node]=true;_.each(g.predecessors(node),visit);delete stack[node];results.push(node)}}_.each(g.sinks(),visit);if(_.size(visited)!==g.nodeCount()){throw new CycleException}return results}function CycleException(){}},{"../lodash":49}],45:[function(require,module,exports){var _=require("../lodash");module.exports=PriorityQueue;function PriorityQueue(){this._arr=[];this._keyIndices={}}PriorityQueue.prototype.size=function(){return this._arr.length};PriorityQueue.prototype.keys=function(){return this._arr.map(function(x){return x.key})};PriorityQueue.prototype.has=function(key){return _.has(this._keyIndices,key)};PriorityQueue.prototype.priority=function(key){var index=this._keyIndices[key];if(index!==undefined){return this._arr[index].priority}};PriorityQueue.prototype.min=function(){if(this.size()===0){throw new Error("Queue underflow")}return this._arr[0].key};PriorityQueue.prototype.add=function(key,priority){var keyIndices=this._keyIndices;key=String(key);if(!_.has(keyIndices,key)){var arr=this._arr;var index=arr.length;keyIndices[key]=index;arr.push({key:key,priority:priority});this._decrease(index);return true}return false};PriorityQueue.prototype.removeMin=function(){this._swap(0,this._arr.length-1);var min=this._arr.pop();delete this._keyIndices[min.key];this._heapify(0);return min.key};PriorityQueue.prototype.decrease=function(key,priority){var index=this._keyIndices[key];if(priority>this._arr[index].priority){throw new Error("New priority is greater than current priority. "+"Key: "+key+" Old: "+this._arr[index].priority+" New: "+priority)}this._arr[index].priority=priority;this._decrease(index)};PriorityQueue.prototype._heapify=function(i){var arr=this._arr;var l=2*i,r=l+1,largest=i;if(l<arr.length){largest=arr[l].priority<arr[largest].priority?l:largest;if(r<arr.length){largest=arr[r].priority<arr[largest].priority?r:largest}if(largest!==i){this._swap(i,largest);this._heapify(largest)}}};PriorityQueue.prototype._decrease=function(index){var arr=this._arr;var priority=arr[index].priority;var parent;while(index!==0){parent=index>>1;if(arr[parent].priority<priority){break}this._swap(index,parent);index=parent}};PriorityQueue.prototype._swap=function(i,j){var arr=this._arr;var keyIndices=this._keyIndices;var origArrI=arr[i];var origArrJ=arr[j];arr[i]=origArrJ;arr[j]=origArrI;keyIndices[origArrJ.key]=i;keyIndices[origArrI.key]=j}},{"../lodash":49}],46:[function(require,module,exports){"use strict";var _=require("./lodash");module.exports=Graph;var DEFAULT_EDGE_NAME="\x00",GRAPH_NODE="\x00",EDGE_KEY_DELIM="";function Graph(opts){this._isDirected=_.has(opts,"directed")?opts.directed:true;this._isMultigraph=_.has(opts,"multigraph")?opts.multigraph:false;this._isCompound=_.has(opts,"compound")?opts.compound:false;this._label=undefined;this._defaultNodeLabelFn=_.constant(undefined);this._defaultEdgeLabelFn=_.constant(undefined);this._nodes={};if(this._isCompound){this._parent={};this._children={};this._children[GRAPH_NODE]={}}this._in={};this._preds={};this._out={};this._sucs={};this._edgeObjs={};this._edgeLabels={}}Graph.prototype._nodeCount=0;Graph.prototype._edgeCount=0;Graph.prototype.isDirected=function(){return this._isDirected};Graph.prototype.isMultigraph=function(){return this._isMultigraph};Graph.prototype.isCompound=function(){return this._isCompound};Graph.prototype.setGraph=function(label){this._label=label;return this};Graph.prototype.graph=function(){return this._label};Graph.prototype.setDefaultNodeLabel=function(newDefault){if(!_.isFunction(newDefault)){newDefault=_.constant(newDefault)}this._defaultNodeLabelFn=newDefault;return this};Graph.prototype.nodeCount=function(){return this._nodeCount};Graph.prototype.nodes=function(){return _.keys(this._nodes)};Graph.prototype.sources=function(){return _.filter(this.nodes(),function(v){return _.isEmpty(this._in[v])},this)};Graph.prototype.sinks=function(){return _.filter(this.nodes(),function(v){return _.isEmpty(this._out[v])},this)};Graph.prototype.setNodes=function(vs,value){var args=arguments;_.each(vs,function(v){if(args.length>1){this.setNode(v,value)}else{this.setNode(v)}},this);return this};Graph.prototype.setNode=function(v,value){if(_.has(this._nodes,v)){if(arguments.length>1){this._nodes[v]=value}return this}this._nodes[v]=arguments.length>1?value:this._defaultNodeLabelFn(v);if(this._isCompound){this._parent[v]=GRAPH_NODE;this._children[v]={};this._children[GRAPH_NODE][v]=true}this._in[v]={};this._preds[v]={};this._out[v]={};this._sucs[v]={};++this._nodeCount;return this};Graph.prototype.node=function(v){return this._nodes[v]};Graph.prototype.hasNode=function(v){return _.has(this._nodes,v)};Graph.prototype.removeNode=function(v){var self=this;if(_.has(this._nodes,v)){var removeEdge=function(e){self.removeEdge(self._edgeObjs[e])};delete this._nodes[v];if(this._isCompound){this._removeFromParentsChildList(v);delete this._parent[v];_.each(this.children(v),function(child){this.setParent(child)},this);delete this._children[v]}_.each(_.keys(this._in[v]),removeEdge);delete this._in[v];delete this._preds[v];_.each(_.keys(this._out[v]),removeEdge);delete this._out[v];delete this._sucs[v];--this._nodeCount}return this};Graph.prototype.setParent=function(v,parent){if(!this._isCompound){throw new Error("Cannot set parent in a non-compound graph")}if(_.isUndefined(parent)){parent=GRAPH_NODE}else{parent+="";for(var ancestor=parent;!_.isUndefined(ancestor);ancestor=this.parent(ancestor)){if(ancestor===v){throw new Error("Setting "+parent+" as parent of "+v+" would create create a cycle")}}this.setNode(parent)}this.setNode(v);this._removeFromParentsChildList(v);this._parent[v]=parent;this._children[parent][v]=true;return this};Graph.prototype._removeFromParentsChildList=function(v){delete this._children[this._parent[v]][v]};Graph.prototype.parent=function(v){if(this._isCompound){var parent=this._parent[v];if(parent!==GRAPH_NODE){return parent}}};Graph.prototype.children=function(v){if(_.isUndefined(v)){v=GRAPH_NODE}if(this._isCompound){var children=this._children[v];if(children){return _.keys(children)}}else if(v===GRAPH_NODE){return this.nodes()}else if(this.hasNode(v)){return[]}};Graph.prototype.predecessors=function(v){var predsV=this._preds[v];if(predsV){return _.keys(predsV)}};Graph.prototype.successors=function(v){var sucsV=this._sucs[v];if(sucsV){return _.keys(sucsV)}};Graph.prototype.neighbors=function(v){var preds=this.predecessors(v);if(preds){return _.union(preds,this.successors(v))}};Graph.prototype.setDefaultEdgeLabel=function(newDefault){if(!_.isFunction(newDefault)){newDefault=_.constant(newDefault)}this._defaultEdgeLabelFn=newDefault;return this};Graph.prototype.edgeCount=function(){return this._edgeCount};Graph.prototype.edges=function(){return _.values(this._edgeObjs)};Graph.prototype.setPath=function(vs,value){var self=this,args=arguments;_.reduce(vs,function(v,w){if(args.length>1){self.setEdge(v,w,value)}else{self.setEdge(v,w)}return w});return this};Graph.prototype.setEdge=function(){var v,w,name,value,valueSpecified=false;if(_.isPlainObject(arguments[0])){v=arguments[0].v;w=arguments[0].w;name=arguments[0].name;if(arguments.length===2){value=arguments[1];valueSpecified=true}}else{v=arguments[0];w=arguments[1];name=arguments[3];if(arguments.length>2){value=arguments[2];valueSpecified=true}}v=""+v;w=""+w;if(!_.isUndefined(name)){name=""+name}var e=edgeArgsToId(this._isDirected,v,w,name);if(_.has(this._edgeLabels,e)){if(valueSpecified){this._edgeLabels[e]=value}return this}if(!_.isUndefined(name)&&!this._isMultigraph){throw new Error("Cannot set a named edge when isMultigraph = false")}this.setNode(v);this.setNode(w);this._edgeLabels[e]=valueSpecified?value:this._defaultEdgeLabelFn(v,w,name);var edgeObj=edgeArgsToObj(this._isDirected,v,w,name);v=edgeObj.v;w=edgeObj.w;Object.freeze(edgeObj);this._edgeObjs[e]=edgeObj;incrementOrInitEntry(this._preds[w],v);incrementOrInitEntry(this._sucs[v],w);this._in[w][e]=edgeObj;this._out[v][e]=edgeObj;this._edgeCount++;return this};Graph.prototype.edge=function(v,w,name){var e=arguments.length===1?edgeObjToId(this._isDirected,arguments[0]):edgeArgsToId(this._isDirected,v,w,name);return this._edgeLabels[e]};Graph.prototype.hasEdge=function(v,w,name){var e=arguments.length===1?edgeObjToId(this._isDirected,arguments[0]):edgeArgsToId(this._isDirected,v,w,name);return _.has(this._edgeLabels,e)};Graph.prototype.removeEdge=function(v,w,name){var e=arguments.length===1?edgeObjToId(this._isDirected,arguments[0]):edgeArgsToId(this._isDirected,v,w,name),edge=this._edgeObjs[e];if(edge){v=edge.v;w=edge.w;delete this._edgeLabels[e];delete this._edgeObjs[e];decrementOrRemoveEntry(this._preds[w],v);decrementOrRemoveEntry(this._sucs[v],w);delete this._in[w][e];delete this._out[v][e];this._edgeCount--}return this};Graph.prototype.inEdges=function(v,u){var inV=this._in[v];if(inV){var edges=_.values(inV);if(!u){return edges}return _.filter(edges,function(edge){return edge.v===u})}};Graph.prototype.outEdges=function(v,w){var outV=this._out[v];if(outV){var edges=_.values(outV);if(!w){return edges}return _.filter(edges,function(edge){return edge.w===w})}};Graph.prototype.nodeEdges=function(v,w){var inEdges=this.inEdges(v,w);if(inEdges){return inEdges.concat(this.outEdges(v,w))}};function incrementOrInitEntry(map,k){if(_.has(map,k)){map[k]++}else{map[k]=1}}function decrementOrRemoveEntry(map,k){if(!--map[k]){delete map[k]}}function edgeArgsToId(isDirected,v,w,name){if(!isDirected&&v>w){var tmp=v;v=w;w=tmp}return v+EDGE_KEY_DELIM+w+EDGE_KEY_DELIM+(_.isUndefined(name)?DEFAULT_EDGE_NAME:name)}function edgeArgsToObj(isDirected,v,w,name){if(!isDirected&&v>w){var tmp=v;v=w;w=tmp}var edgeObj={v:v,w:w};if(name){edgeObj.name=name}return edgeObj}function edgeObjToId(isDirected,edgeObj){return edgeArgsToId(isDirected,edgeObj.v,edgeObj.w,edgeObj.name)}},{"./lodash":49}],47:[function(require,module,exports){module.exports={Graph:require("./graph"),version:require("./version")}},{"./graph":46,"./version":50}],48:[function(require,module,exports){var _=require("./lodash"),Graph=require("./graph");module.exports={write:write,read:read};function write(g){var json={options:{directed:g.isDirected(),multigraph:g.isMultigraph(),compound:g.isCompound()},nodes:writeNodes(g),edges:writeEdges(g)};
  if(!_.isUndefined(g.graph())){json.value=_.clone(g.graph())}return json}function writeNodes(g){return _.map(g.nodes(),function(v){var nodeValue=g.node(v),parent=g.parent(v),node={v:v};if(!_.isUndefined(nodeValue)){node.value=nodeValue}if(!_.isUndefined(parent)){node.parent=parent}return node})}function writeEdges(g){return _.map(g.edges(),function(e){var edgeValue=g.edge(e),edge={v:e.v,w:e.w};if(!_.isUndefined(e.name)){edge.name=e.name}if(!_.isUndefined(edgeValue)){edge.value=edgeValue}return edge})}function read(json){var g=new Graph(json.options).setGraph(json.value);_.each(json.nodes,function(entry){g.setNode(entry.v,entry.value);if(entry.parent){g.setParent(entry.v,entry.parent)}});_.each(json.edges,function(entry){g.setEdge({v:entry.v,w:entry.w,name:entry.name},entry.value)});return g}},{"./graph":46,"./lodash":49}],49:[function(require,module,exports){var lodash;if(typeof require==="function"){try{lodash=require("lodash")}catch(e){}}if(!lodash){lodash=window._}module.exports=lodash},{lodash:51}],50:[function(require,module,exports){module.exports="1.0.5"},{}],51:[function(require,module,exports){(function(global){(function(){var undefined;var VERSION="3.10.0";var BIND_FLAG=1,BIND_KEY_FLAG=2,CURRY_BOUND_FLAG=4,CURRY_FLAG=8,CURRY_RIGHT_FLAG=16,PARTIAL_FLAG=32,PARTIAL_RIGHT_FLAG=64,ARY_FLAG=128,REARG_FLAG=256;var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION="...";var HOT_COUNT=150,HOT_SPAN=16;var LARGE_ARRAY_SIZE=200;var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2;var FUNC_ERROR_TEXT="Expected a function";var PLACEHOLDER="__lodash_placeholder__";var argsTag="[object Arguments]",arrayTag="[object Array]",boolTag="[object Boolean]",dateTag="[object Date]",errorTag="[object Error]",funcTag="[object Function]",mapTag="[object Map]",numberTag="[object Number]",objectTag="[object Object]",regexpTag="[object RegExp]",setTag="[object Set]",stringTag="[object String]",weakMapTag="[object WeakMap]";var arrayBufferTag="[object ArrayBuffer]",float32Tag="[object Float32Array]",float64Tag="[object Float64Array]",int8Tag="[object Int8Array]",int16Tag="[object Int16Array]",int32Tag="[object Int32Array]",uint8Tag="[object Uint8Array]",uint8ClampedTag="[object Uint8ClampedArray]",uint16Tag="[object Uint16Array]",uint32Tag="[object Uint32Array]";var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;var reEscapedHtml=/&(?:amp|lt|gt|quot|#39|#96);/g,reUnescapedHtml=/[&<>"'`]/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;var reRegExpChars=/^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,reHasRegExpChars=RegExp(reRegExpChars.source);var reComboMark=/[\u0300-\u036f\ufe20-\ufe23]/g;var reEscapeChar=/\\(\\)?/g;var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;var reFlags=/\w*$/;var reHasHexPrefix=/^0[xX]/;var reIsHostCtor=/^\[object .+?Constructor\]$/;var reIsUint=/^\d+$/;var reLatin1=/[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;var reNoMatch=/($^)/;var reUnescapedString=/['\n\r\u2028\u2029\\]/g;var reWords=function(){var upper="[A-Z\\xc0-\\xd6\\xd8-\\xde]",lower="[a-z\\xdf-\\xf6\\xf8-\\xff]+";return RegExp(upper+"+(?="+upper+lower+")|"+upper+"?"+lower+"|"+upper+"+|[0-9]+","g")}();var contextProps=["Array","ArrayBuffer","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Math","Number","Object","RegExp","Set","String","_","clearTimeout","isFinite","parseFloat","parseInt","setTimeout","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap"];var templateCounter=-1;var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[stringTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[mapTag]=cloneableTags[setTag]=cloneableTags[weakMapTag]=false;var deburredLetters={"À":"A","Á":"A","Â":"A","Ã":"A","Ä":"A","Å":"A","à":"a","á":"a","â":"a","ã":"a","ä":"a","å":"a","Ç":"C","ç":"c","Ð":"D","ð":"d","È":"E","É":"E","Ê":"E","Ë":"E","è":"e","é":"e","ê":"e","ë":"e","Ì":"I","Í":"I","Î":"I","Ï":"I","ì":"i","í":"i","î":"i","ï":"i","Ñ":"N","ñ":"n","Ò":"O","Ó":"O","Ô":"O","Õ":"O","Ö":"O","Ø":"O","ò":"o","ó":"o","ô":"o","õ":"o","ö":"o","ø":"o","Ù":"U","Ú":"U","Û":"U","Ü":"U","ù":"u","ú":"u","û":"u","ü":"u","Ý":"Y","ý":"y","ÿ":"y","Æ":"Ae","æ":"ae","Þ":"Th","þ":"th","ß":"ss"};var htmlEscapes={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","`":"&#96;"};var htmlUnescapes={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'","&#96;":"`"};var objectTypes={"function":true,object:true};var regexpEscapes={0:"x30",1:"x31",2:"x32",3:"x33",4:"x34",5:"x35",6:"x36",7:"x37",8:"x38",9:"x39",A:"x41",B:"x42",C:"x43",D:"x44",E:"x45",F:"x46",a:"x61",b:"x62",c:"x63",d:"x64",e:"x65",f:"x66",n:"x6e",r:"x72",t:"x74",u:"x75",v:"x76",x:"x78"};var stringEscapes={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"};var freeExports=objectTypes[typeof exports]&&exports&&!exports.nodeType&&exports;var freeModule=objectTypes[typeof module]&&module&&!module.nodeType&&module;var freeGlobal=freeExports&&freeModule&&typeof global=="object"&&global&&global.Object&&global;var freeSelf=objectTypes[typeof self]&&self&&self.Object&&self;var freeWindow=objectTypes[typeof window]&&window&&window.Object&&window;var moduleExports=freeModule&&freeModule.exports===freeExports&&freeExports;var root=freeGlobal||freeWindow!==(this&&this.window)&&freeWindow||freeSelf||this;function baseCompareAscending(value,other){if(value!==other){var valIsNull=value===null,valIsUndef=value===undefined,valIsReflexive=value===value;var othIsNull=other===null,othIsUndef=other===undefined,othIsReflexive=other===other;if(value>other&&!othIsNull||!valIsReflexive||valIsNull&&!othIsUndef&&othIsReflexive||valIsUndef&&othIsReflexive){return 1}if(value<other&&!valIsNull||!othIsReflexive||othIsNull&&!valIsUndef&&valIsReflexive||othIsUndef&&valIsReflexive){return-1}}return 0}function baseFindIndex(array,predicate,fromRight){var length=array.length,index=fromRight?length:-1;while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index}}return-1}function baseIndexOf(array,value,fromIndex){if(value!==value){return indexOfNaN(array,fromIndex)}var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index}}return-1}function baseIsFunction(value){return typeof value=="function"||false}function baseToString(value){return value==null?"":value+""}function charsLeftIndex(string,chars){var index=-1,length=string.length;while(++index<length&&chars.indexOf(string.charAt(index))>-1){}return index}function charsRightIndex(string,chars){var index=string.length;while(index--&&chars.indexOf(string.charAt(index))>-1){}return index}function compareAscending(object,other){return baseCompareAscending(object.criteria,other.criteria)||object.index-other.index}function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=baseCompareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result}var order=orders[index];return result*(order==="asc"||order===true?1:-1)}}return object.index-other.index}function deburrLetter(letter){return deburredLetters[letter]}function escapeHtmlChar(chr){return htmlEscapes[chr]}function escapeRegExpChar(chr,leadingChar,whitespaceChar){if(leadingChar){chr=regexpEscapes[chr]}else if(whitespaceChar){chr=stringEscapes[chr]}return"\\"+chr}function escapeStringChar(chr){return"\\"+stringEscapes[chr]}function indexOfNaN(array,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?0:-1);while(fromRight?index--:++index<length){var other=array[index];if(other!==other){return index}}return-1}function isObjectLike(value){return!!value&&typeof value=="object"}function isSpace(charCode){return charCode<=160&&(charCode>=9&&charCode<=13)||charCode==32||charCode==160||charCode==5760||charCode==6158||charCode>=8192&&(charCode<=8202||charCode==8232||charCode==8233||charCode==8239||charCode==8287||charCode==12288||charCode==65279)}function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=-1,result=[];while(++index<length){if(array[index]===placeholder){array[index]=PLACEHOLDER;result[++resIndex]=index}}return result}function sortedUniq(array,iteratee){var seen,index=-1,length=array.length,resIndex=-1,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value,index,array):value;if(!index||seen!==computed){seen=computed;result[++resIndex]=value}}return result}function trimmedLeftIndex(string){var index=-1,length=string.length;while(++index<length&&isSpace(string.charCodeAt(index))){}return index}function trimmedRightIndex(string){var index=string.length;while(index--&&isSpace(string.charCodeAt(index))){}return index}function unescapeHtmlChar(chr){return htmlUnescapes[chr]}function runInContext(context){context=context?_.defaults(root.Object(),context,_.pick(root,contextProps)):root;var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Number=context.Number,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;var arrayProto=Array.prototype,objectProto=Object.prototype,stringProto=String.prototype;var fnToString=Function.prototype.toString;var hasOwnProperty=objectProto.hasOwnProperty;var idCounter=0;var objToString=objectProto.toString;var oldDash=root._;var reIsNative=RegExp("^"+fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");var ArrayBuffer=context.ArrayBuffer,clearTimeout=context.clearTimeout,parseFloat=context.parseFloat,pow=Math.pow,propertyIsEnumerable=objectProto.propertyIsEnumerable,Set=getNative(context,"Set"),setTimeout=context.setTimeout,splice=arrayProto.splice,Uint8Array=context.Uint8Array,WeakMap=getNative(context,"WeakMap");var nativeCeil=Math.ceil,nativeCreate=getNative(Object,"create"),nativeFloor=Math.floor,nativeIsArray=getNative(Array,"isArray"),nativeIsFinite=context.isFinite,nativeKeys=getNative(Object,"keys"),nativeMax=Math.max,nativeMin=Math.min,nativeNow=getNative(Date,"now"),nativeParseInt=context.parseInt,nativeRandom=Math.random;var NEGATIVE_INFINITY=Number.NEGATIVE_INFINITY,POSITIVE_INFINITY=Number.POSITIVE_INFINITY;var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;var MAX_SAFE_INTEGER=9007199254740991;var metaMap=WeakMap&&new WeakMap;var realNames={};function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value}if(hasOwnProperty.call(value,"__chain__")&&hasOwnProperty.call(value,"__wrapped__")){return wrapperClone(value)}}return new LodashWrapper(value)}function baseLodash(){}function LodashWrapper(value,chainAll,actions){this.__wrapped__=value;this.__actions__=actions||[];this.__chain__=!!chainAll}var support=lodash.support={};lodash.templateSettings={escape:reEscape,evaluate:reEvaluate,interpolate:reInterpolate,variable:"",imports:{_:lodash}};function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=POSITIVE_INFINITY;this.__views__=[]}function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=arrayCopy(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=arrayCopy(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=arrayCopy(this.__views__);return result}function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true}else{result=this.clone();result.__dir__*=-1}return result}function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||arrLength<LARGE_ARRAY_SIZE||arrLength==length&&takeCount==length){return baseWrapperValue(isRight&&isArr?array.reverse():array,this.__actions__)}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer}else{break outer}}}result[resIndex++]=value}return result}function MapCache(){this.__data__={}}function mapDelete(key){return this.has(key)&&delete this.__data__[key]}function mapGet(key){return key=="__proto__"?undefined:this.__data__[key]}function mapHas(key){return key!="__proto__"&&hasOwnProperty.call(this.__data__,key)}function mapSet(key,value){if(key!="__proto__"){this.__data__[key]=value}return this}function SetCache(values){var length=values?values.length:0;this.data={hash:nativeCreate(null),set:new Set};while(length--){this.push(values[length])}}function cacheIndexOf(cache,value){var data=cache.data,result=typeof value=="string"||isObject(value)?data.set.has(value):data.hash[value];return result?0:-1}function cachePush(value){var data=this.data;if(typeof value=="string"||isObject(value)){data.set.add(value)}else{data.hash[value]=true}}function arrayConcat(array,other){var index=-1,length=array.length,othIndex=-1,othLength=other.length,result=Array(length+othLength);while(++index<length){result[index]=array[index]}while(++othIndex<othLength){result[index++]=other[othIndex]}return result}function arrayCopy(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index]}return array}function arrayEach(array,iteratee){var index=-1,length=array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break}}return array}function arrayEachRight(array,iteratee){var length=array.length;while(length--){if(iteratee(array[length],length,array)===false){break}}return array}function arrayEvery(array,predicate){var index=-1,length=array.length;while(++index<length){if(!predicate(array[index],index,array)){return false}}return true}function arrayExtremum(array,iteratee,comparator,exValue){var index=-1,length=array.length,computed=exValue,result=computed;while(++index<length){var value=array[index],current=+iteratee(value);if(comparator(current,computed)){computed=current;result=value}}return result}function arrayFilter(array,predicate){var index=-1,length=array.length,resIndex=-1,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[++resIndex]=value}}return result}function arrayMap(array,iteratee){var index=-1,length=array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array)}return result}function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index]}return array}function arrayReduce(array,iteratee,accumulator,initFromArray){var index=-1,length=array.length;if(initFromArray&&length){accumulator=array[++index]}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array)}return accumulator}function arrayReduceRight(array,iteratee,accumulator,initFromArray){var length=array.length;if(initFromArray&&length){accumulator=array[--length]}while(length--){accumulator=iteratee(accumulator,array[length],length,array)}return accumulator}function arraySome(array,predicate){var index=-1,length=array.length;while(++index<length){if(predicate(array[index],index,array)){return true}}return false}function arraySum(array,iteratee){var length=array.length,result=0;while(length--){result+=+iteratee(array[length])||0}return result}function assignDefaults(objectValue,sourceValue){return objectValue===undefined?sourceValue:objectValue}function assignOwnDefaults(objectValue,sourceValue,key,object){return objectValue===undefined||!hasOwnProperty.call(object,key)?sourceValue:objectValue}function assignWith(object,source,customizer){var index=-1,props=keys(source),length=props.length;while(++index<length){var key=props[index],value=object[key],result=customizer(value,source[key],key,object,source);if((result===result?result!==value:value===value)||value===undefined&&!(key in object)){object[key]=result}}return object}function baseAssign(object,source){return source==null?object:baseCopy(source,keys(source),object)}function baseAt(collection,props){var index=-1,isNil=collection==null,isArr=!isNil&&isArrayLike(collection),length=isArr?collection.length:0,propsLength=props.length,result=Array(propsLength);while(++index<propsLength){var key=props[index];if(isArr){result[index]=isIndex(key,length)?collection[key]:undefined}else{result[index]=isNil?undefined:collection[key]}}return result}function baseCopy(source,props,object){object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];object[key]=source[key]}return object}function baseCallback(func,thisArg,argCount){var type=typeof func;if(type=="function"){return thisArg===undefined?func:bindCallback(func,thisArg,argCount)}if(func==null){return identity}if(type=="object"){return baseMatches(func)}return thisArg===undefined?property(func):baseMatchesProperty(func,thisArg)}function baseClone(value,isDeep,customizer,key,object,stackA,stackB){var result;if(customizer){result=object?customizer(value,key,object):customizer(value)}if(result!==undefined){return result}if(!isObject(value)){return value}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return arrayCopy(value,result)}}else{var tag=objToString.call(value),isFunc=tag==funcTag;if(tag==objectTag||tag==argsTag||isFunc&&!object){result=initCloneObject(isFunc?{}:value);if(!isDeep){return baseAssign(result,value)}}else{return cloneableTags[tag]?initCloneByTag(value,tag,isDeep):object?value:{}}}stackA||(stackA=[]);stackB||(stackB=[]);var length=stackA.length;while(length--){if(stackA[length]==value){return stackB[length]}}stackA.push(value);stackB.push(result);(isArr?arrayEach:baseForOwn)(value,function(subValue,key){result[key]=baseClone(subValue,isDeep,customizer,key,value,stackA,stackB)});return result}var baseCreate=function(){function object(){}return function(prototype){if(isObject(prototype)){object.prototype=prototype;var result=new object;object.prototype=undefined}return result||{}}}();function baseDelay(func,wait,args){if(typeof func!="function"){throw new TypeError(FUNC_ERROR_TEXT)}return setTimeout(function(){func.apply(undefined,args)},wait)}function baseDifference(array,values){var length=array?array.length:0,result=[];if(!length){return result}var index=-1,indexOf=getIndexOf(),isCommon=indexOf==baseIndexOf,cache=isCommon&&values.length>=LARGE_ARRAY_SIZE?createCache(values):null,valuesLength=values.length;if(cache){indexOf=cacheIndexOf;isCommon=false;values=cache}outer:while(++index<length){var value=array[index];if(isCommon&&value===value){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===value){continue outer}}result.push(value)}else if(indexOf(values,value,0)<0){result.push(value)}}return result}var baseEach=createBaseEach(baseForOwn);var baseEachRight=createBaseEach(baseForOwnRight,true);function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result});return result}function baseExtremum(collection,iteratee,comparator,exValue){var computed=exValue,result=computed;baseEach(collection,function(value,index,collection){var current=+iteratee(value,index,collection);if(comparator(current,computed)||current===exValue&&current===result){computed=current;result=value}});return result}function baseFill(array,value,start,end){var length=array.length;start=start==null?0:+start||0;if(start<0){start=-start>length?0:length+start}end=end===undefined||end>length?length:+end||0;if(end<0){end+=length}length=start>end?0:end>>>0;start>>>=0;while(start<length){array[start++]=value}return array}function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value)}});return result}function baseFind(collection,predicate,eachFunc,retKey){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=retKey?key:value;return false}});return result}function baseFlatten(array,isDeep,isStrict,result){result||(result=[]);var index=-1,length=array.length;while(++index<length){var value=array[index];if(isObjectLike(value)&&isArrayLike(value)&&(isStrict||isArray(value)||isArguments(value))){if(isDeep){baseFlatten(value,isDeep,isStrict,result)}else{arrayPush(result,value)}}else if(!isStrict){result[result.length]=value}}return result}var baseFor=createBaseFor();var baseForRight=createBaseFor(true);function baseForIn(object,iteratee){return baseFor(object,iteratee,keysIn)}function baseForOwn(object,iteratee){return baseFor(object,iteratee,keys)}function baseForOwnRight(object,iteratee){return baseForRight(object,iteratee,keys)}function baseFunctions(object,props){var index=-1,length=props.length,resIndex=-1,result=[];while(++index<length){var key=props[index];if(isFunction(object[key])){result[++resIndex]=key}}return result}function baseGet(object,path,pathKey){if(object==null){return}if(pathKey!==undefined&&pathKey in toObject(object)){path=[pathKey]}var index=0,length=path.length;while(object!=null&&index<length){object=object[path[index++]]}return index&&index==length?object:undefined}function baseIsEqual(value,other,customizer,isLoose,stackA,stackB){if(value===other){return true}if(value==null||other==null||!isObject(value)&&!isObjectLike(other)){return value!==value&&other!==other}return baseIsEqualDeep(value,other,baseIsEqual,customizer,isLoose,stackA,stackB)}function baseIsEqualDeep(object,other,equalFunc,customizer,isLoose,stackA,stackB){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=arrayTag,othTag=arrayTag;if(!objIsArr){objTag=objToString.call(object);if(objTag==argsTag){objTag=objectTag}else if(objTag!=objectTag){objIsArr=isTypedArray(object)}}if(!othIsArr){othTag=objToString.call(other);if(othTag==argsTag){othTag=objectTag}else if(othTag!=objectTag){othIsArr=isTypedArray(other)}}var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&!(objIsArr||objIsObj)){return equalByTag(object,other,objTag)}if(!isLoose){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,"__wrapped__"),othIsWrapped=othIsObj&&hasOwnProperty.call(other,"__wrapped__");if(objIsWrapped||othIsWrapped){return equalFunc(objIsWrapped?object.value():object,othIsWrapped?other.value():other,customizer,isLoose,stackA,stackB)}}if(!isSameTag){return false}stackA||(stackA=[]);stackB||(stackB=[]);var length=stackA.length;while(length--){if(stackA[length]==object){return stackB[length]==other}}stackA.push(object);stackB.push(other);var result=(objIsArr?equalArrays:equalObjects)(object,other,equalFunc,customizer,isLoose,stackA,stackB);stackA.pop();stackB.pop();return result}function baseIsMatch(object,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length}object=toObject(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false}}else{var result=customizer?customizer(objValue,srcValue,key):undefined;if(!(result===undefined?baseIsEqual(srcValue,objValue,customizer,true):result)){return false}}}return true}function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection)});return result}function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){var key=matchData[0][0],value=matchData[0][1];return function(object){if(object==null){return false}return object[key]===value&&(value!==undefined||key in toObject(object))}}return function(object){return baseIsMatch(object,matchData)}}function baseMatchesProperty(path,srcValue){var isArr=isArray(path),isCommon=isKey(path)&&isStrictComparable(srcValue),pathKey=path+"";path=toPath(path);return function(object){if(object==null){return false}var key=pathKey;object=toObject(object);if((isArr||!isCommon)&&!(key in object)){object=path.length==1?object:baseGet(object,baseSlice(path,0,-1));if(object==null){return false}key=last(path);object=toObject(object)}return object[key]===srcValue?srcValue!==undefined||key in object:baseIsEqual(srcValue,object[key],undefined,true)}}function baseMerge(object,source,customizer,stackA,stackB){if(!isObject(object)){return object}var isSrcArr=isArrayLike(source)&&(isArray(source)||isTypedArray(source)),props=isSrcArr?undefined:keys(source);arrayEach(props||source,function(srcValue,key){if(props){key=srcValue;srcValue=source[key]}if(isObjectLike(srcValue)){stackA||(stackA=[]);stackB||(stackB=[]);baseMergeDeep(object,source,key,baseMerge,customizer,stackA,stackB)}else{var value=object[key],result=customizer?customizer(value,srcValue,key,object,source):undefined,isCommon=result===undefined;if(isCommon){result=srcValue}if((result!==undefined||isSrcArr&&!(key in object))&&(isCommon||(result===result?result!==value:value===value))){object[key]=result}}});return object}function baseMergeDeep(object,source,key,mergeFunc,customizer,stackA,stackB){var length=stackA.length,srcValue=source[key];while(length--){if(stackA[length]==srcValue){object[key]=stackB[length];return}}var value=object[key],result=customizer?customizer(value,srcValue,key,object,source):undefined,isCommon=result===undefined;if(isCommon){result=srcValue;if(isArrayLike(srcValue)&&(isArray(srcValue)||isTypedArray(srcValue))){result=isArray(value)?value:isArrayLike(value)?arrayCopy(value):[]}else if(isPlainObject(srcValue)||isArguments(srcValue)){result=isArguments(value)?toPlainObject(value):isPlainObject(value)?value:{}}else{isCommon=false}}stackA.push(srcValue);stackB.push(result);if(isCommon){object[key]=mergeFunc(result,srcValue,customizer,stackA,stackB)}else if(result===result?result!==value:value===value){object[key]=result}}function baseProperty(key){return function(object){return object==null?undefined:object[key]}}function basePropertyDeep(path){var pathKey=path+"";path=toPath(path);return function(object){return baseGet(object,path,pathKey)}}function basePullAt(array,indexes){var length=array?indexes.length:0;while(length--){var index=indexes[length];if(index!=previous&&isIndex(index)){var previous=index;splice.call(array,index,1)}}return array}function baseRandom(min,max){return min+nativeFloor(nativeRandom()*(max-min+1))}function baseReduce(collection,iteratee,accumulator,initFromCollection,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initFromCollection?(initFromCollection=false,value):iteratee(accumulator,value,index,collection)});return accumulator}var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func};function baseSlice(array,start,end){var index=-1,length=array.length;start=start==null?0:+start||0;if(start<0){start=-start>length?0:length+start}end=end===undefined||end>length?length:+end||0;if(end<0){end+=length}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start]}return result}function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result});return!!result}function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value}return array}function baseSortByOrder(collection,iteratees,orders){var callback=getCallback(),index=-1;iteratees=arrayMap(iteratees,function(iteratee){return callback(iteratee)});var result=baseMap(collection,function(value){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value)});return{criteria:criteria,index:++index,value:value}});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders)})}function baseSum(collection,iteratee){var result=0;baseEach(collection,function(value,index,collection){result+=+iteratee(value,index,collection)||0});return result}function baseUniq(array,iteratee){var index=-1,indexOf=getIndexOf(),length=array.length,isCommon=indexOf==baseIndexOf,isLarge=isCommon&&length>=LARGE_ARRAY_SIZE,seen=isLarge?createCache():null,result=[];if(seen){indexOf=cacheIndexOf;isCommon=false}else{isLarge=false;seen=iteratee?[]:result}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value,index,array):value;if(isCommon&&value===value){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer}}if(iteratee){seen.push(computed)}result.push(value)}else if(indexOf(seen,computed,0)<0){if(iteratee||isLarge){seen.push(computed)}result.push(value)}}return result}function baseValues(object,props){var index=-1,length=props.length,result=Array(length);while(++index<length){result[index]=object[props[index]]}return result}function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index)}function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value()}var index=-1,length=actions.length;while(++index<length){var action=actions[index];result=action.func.apply(action.thisArg,arrayPush([result],action.args))}return result}function binaryIndex(array,value,retHighest){var low=0,high=array?array.length:low;if(typeof value=="number"&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if((retHighest?computed<=value:computed<value)&&computed!==null){low=mid+1
  }else{high=mid}}return high}return binaryIndexBy(array,value,identity,retHighest)}function binaryIndexBy(array,value,iteratee,retHighest){value=iteratee(value);var low=0,high=array?array.length:0,valIsNaN=value!==value,valIsNull=value===null,valIsUndef=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),isDef=computed!==undefined,isReflexive=computed===computed;if(valIsNaN){var setLow=isReflexive||retHighest}else if(valIsNull){setLow=isReflexive&&isDef&&(retHighest||computed!=null)}else if(valIsUndef){setLow=isReflexive&&(retHighest||isDef)}else if(computed==null){setLow=false}else{setLow=retHighest?computed<=value:computed<value}if(setLow){low=mid+1}else{high=mid}}return nativeMin(high,MAX_ARRAY_INDEX)}function bindCallback(func,thisArg,argCount){if(typeof func!="function"){return identity}if(thisArg===undefined){return func}switch(argCount){case 1:return function(value){return func.call(thisArg,value)};case 3:return function(value,index,collection){return func.call(thisArg,value,index,collection)};case 4:return function(accumulator,value,index,collection){return func.call(thisArg,accumulator,value,index,collection)};case 5:return function(value,other,key,object,source){return func.call(thisArg,value,other,key,object,source)}}return function(){return func.apply(thisArg,arguments)}}function bufferClone(buffer){var result=new ArrayBuffer(buffer.byteLength),view=new Uint8Array(result);view.set(new Uint8Array(buffer));return result}function composeArgs(args,partials,holders){var holdersLength=holders.length,argsIndex=-1,argsLength=nativeMax(args.length-holdersLength,0),leftIndex=-1,leftLength=partials.length,result=Array(leftLength+argsLength);while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex]}while(++argsIndex<holdersLength){result[holders[argsIndex]]=args[argsIndex]}while(argsLength--){result[leftIndex++]=args[argsIndex++]}return result}function composeArgsRight(args,partials,holders){var holdersIndex=-1,holdersLength=holders.length,argsIndex=-1,argsLength=nativeMax(args.length-holdersLength,0),rightIndex=-1,rightLength=partials.length,result=Array(argsLength+rightLength);while(++argsIndex<argsLength){result[argsIndex]=args[argsIndex]}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex]}while(++holdersIndex<holdersLength){result[offset+holders[holdersIndex]]=args[argsIndex++]}return result}function createAggregator(setter,initializer){return function(collection,iteratee,thisArg){var result=initializer?initializer():{};iteratee=getCallback(iteratee,thisArg,3);if(isArray(collection)){var index=-1,length=collection.length;while(++index<length){var value=collection[index];setter(result,value,iteratee(value,index,collection),collection)}}else{baseEach(collection,function(value,key,collection){setter(result,value,iteratee(value,key,collection),collection)})}return result}}function createAssigner(assigner){return restParam(function(object,sources){var index=-1,length=object==null?0:sources.length,customizer=length>2?sources[length-2]:undefined,guard=length>2?sources[2]:undefined,thisArg=length>1?sources[length-1]:undefined;if(typeof customizer=="function"){customizer=bindCallback(customizer,thisArg,5);length-=2}else{customizer=typeof thisArg=="function"?thisArg:undefined;length-=customizer?1:0}if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1}while(++index<length){var source=sources[index];if(source){assigner(object,source,customizer)}}return object})}function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){var length=collection?getLength(collection):0;if(!isLength(length)){return eachFunc(collection,iteratee)}var index=fromRight?length:-1,iterable=toObject(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break}}return collection}}function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var iterable=toObject(object),props=keysFunc(object),length=props.length,index=fromRight?length:-1;while(fromRight?index--:++index<length){var key=props[index];if(iteratee(iterable[key],key,iterable)===false){break}}return object}}function createBindWrapper(func,thisArg){var Ctor=createCtorWrapper(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(thisArg,arguments)}return wrapper}function createCache(values){return nativeCreate&&Set?new SetCache(values):null}function createCompounder(callback){return function(string){var index=-1,array=words(deburr(string)),length=array.length,result="";while(++index<length){result=callback(result,array[index],index)}return result}}function createCtorWrapper(Ctor){return function(){var args=arguments;switch(args.length){case 0:return new Ctor;case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6])}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);return isObject(result)?result:thisBinding}}function createCurry(flag){function curryFunc(func,arity,guard){if(guard&&isIterateeCall(func,arity,guard)){arity=undefined}var result=createWrapper(func,flag,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryFunc.placeholder;return result}return curryFunc}function createDefaults(assigner,customizer){return restParam(function(args){var object=args[0];if(object==null){return object}args.push(customizer);return assigner.apply(undefined,args)})}function createExtremum(comparator,exValue){return function(collection,iteratee,thisArg){if(thisArg&&isIterateeCall(collection,iteratee,thisArg)){iteratee=undefined}iteratee=getCallback(iteratee,thisArg,3);if(iteratee.length==1){collection=isArray(collection)?collection:toIterable(collection);var result=arrayExtremum(collection,iteratee,comparator,exValue);if(!(collection.length&&result===exValue)){return result}}return baseExtremum(collection,iteratee,comparator,exValue)}}function createFind(eachFunc,fromRight){return function(collection,predicate,thisArg){predicate=getCallback(predicate,thisArg,3);if(isArray(collection)){var index=baseFindIndex(collection,predicate,fromRight);return index>-1?collection[index]:undefined}return baseFind(collection,predicate,eachFunc)}}function createFindIndex(fromRight){return function(array,predicate,thisArg){if(!(array&&array.length)){return-1}predicate=getCallback(predicate,thisArg,3);return baseFindIndex(array,predicate,fromRight)}}function createFindKey(objectFunc){return function(object,predicate,thisArg){predicate=getCallback(predicate,thisArg,3);return baseFind(object,predicate,objectFunc,true)}}function createFlow(fromRight){return function(){var wrapper,length=arguments.length,index=fromRight?length:-1,leftIndex=0,funcs=Array(length);while(fromRight?index--:++index<length){var func=funcs[leftIndex++]=arguments[index];if(typeof func!="function"){throw new TypeError(FUNC_ERROR_TEXT)}if(!wrapper&&LodashWrapper.prototype.thru&&getFuncName(func)=="wrapper"){wrapper=new LodashWrapper([],true)}}index=wrapper?-1:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=="wrapper"?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(ARY_FLAG|CURRY_FLAG|PARTIAL_FLAG|REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3])}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func)}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)&&value.length>=LARGE_ARRAY_SIZE){return wrapper.plant(value).value()}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result)}return result}}}function createForEach(arrayFunc,eachFunc){return function(collection,iteratee,thisArg){return typeof iteratee=="function"&&thisArg===undefined&&isArray(collection)?arrayFunc(collection,iteratee):eachFunc(collection,bindCallback(iteratee,thisArg,3))}}function createForIn(objectFunc){return function(object,iteratee,thisArg){if(typeof iteratee!="function"||thisArg!==undefined){iteratee=bindCallback(iteratee,thisArg,3)}return objectFunc(object,iteratee,keysIn)}}function createForOwn(objectFunc){return function(object,iteratee,thisArg){if(typeof iteratee!="function"||thisArg!==undefined){iteratee=bindCallback(iteratee,thisArg,3)}return objectFunc(object,iteratee)}}function createObjectMapper(isMapKeys){return function(object,iteratee,thisArg){var result={};iteratee=getCallback(iteratee,thisArg,3);baseForOwn(object,function(value,key,object){var mapped=iteratee(value,key,object);key=isMapKeys?mapped:key;value=isMapKeys?value:mapped;result[key]=value});return result}}function createPadDir(fromRight){return function(string,length,chars){string=baseToString(string);return(fromRight?string:"")+createPadding(string,length,chars)+(fromRight?"":string)}}function createPartial(flag){var partialFunc=restParam(function(func,partials){var holders=replaceHolders(partials,partialFunc.placeholder);return createWrapper(func,flag,undefined,partials,holders)});return partialFunc}function createReduce(arrayFunc,eachFunc){return function(collection,iteratee,accumulator,thisArg){var initFromArray=arguments.length<3;return typeof iteratee=="function"&&thisArg===undefined&&isArray(collection)?arrayFunc(collection,iteratee,accumulator,initFromArray):baseReduce(collection,getCallback(iteratee,thisArg,4),accumulator,initFromArray,eachFunc)}}function createHybridWrapper(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&ARY_FLAG,isBind=bitmask&BIND_FLAG,isBindKey=bitmask&BIND_KEY_FLAG,isCurry=bitmask&CURRY_FLAG,isCurryBound=bitmask&CURRY_BOUND_FLAG,isCurryRight=bitmask&CURRY_RIGHT_FLAG,Ctor=isBindKey?undefined:createCtorWrapper(func);function wrapper(){var length=arguments.length,index=length,args=Array(length);while(index--){args[index]=arguments[index]}if(partials){args=composeArgs(args,partials,holders)}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight)}if(isCurry||isCurryRight){var placeholder=wrapper.placeholder,argsHolders=replaceHolders(args,placeholder);length-=argsHolders.length;if(length<arity){var newArgPos=argPos?arrayCopy(argPos):undefined,newArity=nativeMax(arity-length,0),newsHolders=isCurry?argsHolders:undefined,newHoldersRight=isCurry?undefined:argsHolders,newPartials=isCurry?args:undefined,newPartialsRight=isCurry?undefined:args;bitmask|=isCurry?PARTIAL_FLAG:PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?PARTIAL_RIGHT_FLAG:PARTIAL_FLAG);if(!isCurryBound){bitmask&=~(BIND_FLAG|BIND_KEY_FLAG)}var newData=[func,bitmask,thisArg,newPartials,newsHolders,newPartialsRight,newHoldersRight,newArgPos,ary,newArity],result=createHybridWrapper.apply(undefined,newData);if(isLaziable(func)){setData(result,newData)}result.placeholder=placeholder;return result}}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;if(argPos){args=reorder(args,argPos)}if(isAry&&ary<args.length){args.length=ary}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtorWrapper(func)}return fn.apply(thisBinding,args)}return wrapper}function createPadding(string,length,chars){var strLength=string.length;length=+length;if(strLength>=length||!nativeIsFinite(length)){return""}var padLength=length-strLength;chars=chars==null?" ":chars+"";return repeat(chars,nativeCeil(padLength/chars.length)).slice(0,padLength)}function createPartialWrapper(func,bitmask,thisArg,partials){var isBind=bitmask&BIND_FLAG,Ctor=createCtorWrapper(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength);while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex]}while(argsLength--){args[leftIndex++]=arguments[++argsIndex]}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,args)}return wrapper}function createRound(methodName){var func=Math[methodName];return function(number,precision){precision=precision===undefined?0:+precision||0;if(precision){precision=pow(10,precision);return func(number*precision)/precision}return func(number)}}function createSortedIndex(retHighest){return function(array,value,iteratee,thisArg){var callback=getCallback(iteratee);return iteratee==null&&callback===baseCallback?binaryIndex(array,value,retHighest):binaryIndexBy(array,value,callback(iteratee,thisArg,1),retHighest)}}function createWrapper(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&BIND_KEY_FLAG;if(!isBindKey&&typeof func!="function"){throw new TypeError(FUNC_ERROR_TEXT)}var length=partials?partials.length:0;if(!length){bitmask&=~(PARTIAL_FLAG|PARTIAL_RIGHT_FLAG);partials=holders=undefined}length-=holders?holders.length:0;if(bitmask&PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined}var data=isBindKey?undefined:getData(func),newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);bitmask=newData[1];arity=newData[9]}newData[9]=arity==null?isBindKey?0:func.length:nativeMax(arity-length,0)||0;if(bitmask==BIND_FLAG){var result=createBindWrapper(newData[0],newData[2])}else if((bitmask==PARTIAL_FLAG||bitmask==(BIND_FLAG|PARTIAL_FLAG))&&!newData[4].length){result=createPartialWrapper.apply(undefined,newData)}else{result=createHybridWrapper.apply(undefined,newData)}var setter=data?baseSetData:setData;return setter(result,newData)}function equalArrays(array,other,equalFunc,customizer,isLoose,stackA,stackB){var index=-1,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isLoose&&othLength>arrLength)){return false}while(++index<arrLength){var arrValue=array[index],othValue=other[index],result=customizer?customizer(isLoose?othValue:arrValue,isLoose?arrValue:othValue,index):undefined;if(result!==undefined){if(result){continue}return false}if(isLoose){if(!arraySome(other,function(othValue){return arrValue===othValue||equalFunc(arrValue,othValue,customizer,isLoose,stackA,stackB)})){return false}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,customizer,isLoose,stackA,stackB))){return false}}return true}function equalByTag(object,other,tag){switch(tag){case boolTag:case dateTag:return+object==+other;case errorTag:return object.name==other.name&&object.message==other.message;case numberTag:return object!=+object?other!=+other:object==+other;case regexpTag:case stringTag:return object==other+""}return false}function equalObjects(object,other,equalFunc,customizer,isLoose,stackA,stackB){var objProps=keys(object),objLength=objProps.length,othProps=keys(other),othLength=othProps.length;if(objLength!=othLength&&!isLoose){return false}var index=objLength;while(index--){var key=objProps[index];if(!(isLoose?key in other:hasOwnProperty.call(other,key))){return false}}var skipCtor=isLoose;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key],result=customizer?customizer(isLoose?othValue:objValue,isLoose?objValue:othValue,key):undefined;if(!(result===undefined?equalFunc(objValue,othValue,customizer,isLoose,stackA,stackB):result)){return false}skipCtor||(skipCtor=key=="constructor")}if(!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;if(objCtor!=othCtor&&("constructor"in object&&"constructor"in other)&&!(typeof objCtor=="function"&&objCtor instanceof objCtor&&typeof othCtor=="function"&&othCtor instanceof othCtor)){return false}}return true}function getCallback(func,thisArg,argCount){var result=lodash.callback||callback;result=result===callback?baseCallback:result;return argCount?result(func,thisArg,argCount):result}var getData=!metaMap?noop:function(func){return metaMap.get(func)};function getFuncName(func){var result=func.name,array=realNames[result],length=array?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name}}return result}function getIndexOf(collection,target,fromIndex){var result=lodash.indexOf||indexOf;result=result===indexOf?baseIndexOf:result;return collection?result(collection,target,fromIndex):result}var getLength=baseProperty("length");function getMatchData(object){var result=pairs(object),length=result.length;while(length--){result[length][2]=isStrictComparable(result[length][1])}return result}function getNative(object,key){var value=object==null?undefined:object[key];return isNative(value)?value:undefined}function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case"drop":start+=size;break;case"dropRight":end-=size;break;case"take":end=nativeMin(end,start+size);break;case"takeRight":start=nativeMax(start,end-size);break}}return{start:start,end:end}}function initCloneArray(array){var length=array.length,result=new array.constructor(length);if(length&&typeof array[0]=="string"&&hasOwnProperty.call(array,"index")){result.index=array.index;result.input=array.input}return result}function initCloneObject(object){var Ctor=object.constructor;if(!(typeof Ctor=="function"&&Ctor instanceof Ctor)){Ctor=Object}return new Ctor}function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return bufferClone(object);case boolTag:case dateTag:return new Ctor(+object);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:var buffer=object.buffer;return new Ctor(isDeep?bufferClone(buffer):buffer,object.byteOffset,object.length);case numberTag:case stringTag:return new Ctor(object);case regexpTag:var result=new Ctor(object.source,reFlags.exec(object));result.lastIndex=object.lastIndex}return result}function invokePath(object,path,args){if(object!=null&&!isKey(path,object)){path=toPath(path);object=path.length==1?object:baseGet(object,baseSlice(path,0,-1));path=last(path)}var func=object==null?object:object[path];return func==null?undefined:func.apply(object,args)}function isArrayLike(value){return value!=null&&isLength(getLength(value))}function isIndex(value,length){value=typeof value=="number"||reIsUint.test(value)?+value:-1;length=length==null?MAX_SAFE_INTEGER:length;return value>-1&&value%1==0&&value<length}function isIterateeCall(value,index,object){if(!isObject(object)){return false}var type=typeof index;if(type=="number"?isArrayLike(object)&&isIndex(index,object.length):type=="string"&&index in object){var other=object[index];return value===value?value===other:other!==other}return false}function isKey(value,object){var type=typeof value;if(type=="string"&&reIsPlainProp.test(value)||type=="number"){return true}if(isArray(value)){return false}var result=!reIsDeepProp.test(value);return result||object!=null&&value in toObject(object)}function isLaziable(func){var funcName=getFuncName(func);if(!(funcName in LazyWrapper.prototype)){return false}var other=lodash[funcName];if(func===other){return true}var data=getData(other);return!!data&&func===data[0]}function isLength(value){return typeof value=="number"&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER}function isStrictComparable(value){return value===value&&!isObject(value)}function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<ARY_FLAG;var isCombo=srcBitmask==ARY_FLAG&&bitmask==CURRY_FLAG||srcBitmask==ARY_FLAG&&bitmask==REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(ARY_FLAG|REARG_FLAG)&&bitmask==CURRY_FLAG;if(!(isCommon||isCombo)){return data}if(srcBitmask&BIND_FLAG){data[2]=source[2];newBitmask|=bitmask&BIND_FLAG?0:CURRY_BOUND_FLAG}var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):arrayCopy(value);data[4]=partials?replaceHolders(data[3],PLACEHOLDER):arrayCopy(source[4])}value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):arrayCopy(value);data[6]=partials?replaceHolders(data[5],PLACEHOLDER):arrayCopy(source[6])}value=source[7];if(value){data[7]=arrayCopy(value)}if(srcBitmask&ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8])}if(data[9]==null){data[9]=source[9]}data[0]=source[0];data[1]=newBitmask;return data}function mergeDefaults(objectValue,sourceValue){return objectValue===undefined?sourceValue:merge(objectValue,sourceValue,mergeDefaults)}function pickByArray(object,props){object=toObject(object);var index=-1,length=props.length,result={};while(++index<length){var key=props[index];if(key in object){result[key]=object[key]}}return result}function pickByCallback(object,predicate){var result={};baseForIn(object,function(value,key,object){if(predicate(value,key,object)){result[key]=value}});return result}function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=arrayCopy(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined}return array}var setData=function(){var count=0,lastCalled=0;return function(key,value){var stamp=now(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return key}}else{count=0}return baseSetData(key,value)}}();function shimKeys(object){var props=keysIn(object),propsLength=props.length,length=propsLength&&object.length;var allowIndexes=!!length&&isLength(length)&&(isArray(object)||isArguments(object));var index=-1,result=[];while(++index<propsLength){var key=props[index];if(allowIndexes&&isIndex(key,length)||hasOwnProperty.call(object,key)){result.push(key)}}return result}function toIterable(value){if(value==null){return[]}if(!isArrayLike(value)){return values(value)}return isObject(value)?value:Object(value)}function toObject(value){return isObject(value)?value:Object(value)}function toPath(value){if(isArray(value)){return value}var result=[];baseToString(value).replace(rePropName,function(match,number,quote,string){result.push(quote?string.replace(reEscapeChar,"$1"):number||match)});return result}function wrapperClone(wrapper){return wrapper instanceof LazyWrapper?wrapper.clone():new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__,arrayCopy(wrapper.__actions__))}function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size==null){size=1}else{size=nativeMax(nativeFloor(size)||1,1)}var index=0,length=array?array.length:0,resIndex=-1,result=Array(nativeCeil(length/size));while(index<length){result[++resIndex]=baseSlice(array,index,index+=size)}return result}function compact(array){var index=-1,length=array?array.length:0,resIndex=-1,result=[];while(++index<length){var value=array[index];if(value){result[++resIndex]=value}}return result}var difference=restParam(function(array,values){return isObjectLike(array)&&isArrayLike(array)?baseDifference(array,baseFlatten(values,false,true)):[]});function drop(array,n,guard){var length=array?array.length:0;if(!length){return[]}if(guard?isIterateeCall(array,n,guard):n==null){n=1}return baseSlice(array,n<0?0:n)}function dropRight(array,n,guard){var length=array?array.length:0;if(!length){return[]}if(guard?isIterateeCall(array,n,guard):n==null){n=1}n=length-(+n||0);return baseSlice(array,0,n<0?0:n)}function dropRightWhile(array,predicate,thisArg){return array&&array.length?baseWhile(array,getCallback(predicate,thisArg,3),true,true):[]}function dropWhile(array,predicate,thisArg){return array&&array.length?baseWhile(array,getCallback(predicate,thisArg,3),true):[]}function fill(array,value,start,end){var length=array?array.length:0;if(!length){return[]}if(start&&typeof start!="number"&&isIterateeCall(array,value,start)){start=0;end=length}return baseFill(array,value,start,end)}var findIndex=createFindIndex();var findLastIndex=createFindIndex(true);function first(array){return array?array[0]:undefined}function flatten(array,isDeep,guard){var length=array?array.length:0;if(guard&&isIterateeCall(array,isDeep,guard)){isDeep=false}return length?baseFlatten(array,isDeep):[]}function flattenDeep(array){var length=array?array.length:0;return length?baseFlatten(array,true):[]}function indexOf(array,value,fromIndex){var length=array?array.length:0;if(!length){return-1}if(typeof fromIndex=="number"){fromIndex=fromIndex<0?nativeMax(length+fromIndex,0):fromIndex}else if(fromIndex){var index=binaryIndex(array,value);if(index<length&&(value===value?value===array[index]:array[index]!==array[index])){return index}return-1}return baseIndexOf(array,value,fromIndex||0)}function initial(array){return dropRight(array,1)}var intersection=restParam(function(arrays){var othLength=arrays.length,othIndex=othLength,caches=Array(length),indexOf=getIndexOf(),isCommon=indexOf==baseIndexOf,result=[];while(othIndex--){var value=arrays[othIndex]=isArrayLike(value=arrays[othIndex])?value:[];caches[othIndex]=isCommon&&value.length>=120?createCache(othIndex&&value):null}var array=arrays[0],index=-1,length=array?array.length:0,seen=caches[0];outer:while(++index<length){value=array[index];if((seen?cacheIndexOf(seen,value):indexOf(result,value,0))<0){var othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if((cache?cacheIndexOf(cache,value):indexOf(arrays[othIndex],value,0))<0){continue outer}}if(seen){seen.push(value)}result.push(value)}}return result});function last(array){var length=array?array.length:0;return length?array[length-1]:undefined}function lastIndexOf(array,value,fromIndex){var length=array?array.length:0;if(!length){return-1}var index=length;if(typeof fromIndex=="number"){index=(fromIndex<0?nativeMax(length+fromIndex,0):nativeMin(fromIndex||0,length-1))+1}else if(fromIndex){index=binaryIndex(array,value,true)-1;var other=array[index];if(value===value?value===other:other!==other){return index}return-1}if(value!==value){return indexOfNaN(array,index,true)}while(index--){if(array[index]===value){return index}}return-1}function pull(){var args=arguments,array=args[0];if(!(array&&array.length)){return array}var index=0,indexOf=getIndexOf(),length=args.length;while(++index<length){var fromIndex=0,value=args[index];while((fromIndex=indexOf(array,value,fromIndex))>-1){splice.call(array,fromIndex,1)}}return array}var pullAt=restParam(function(array,indexes){indexes=baseFlatten(indexes);var result=baseAt(array,indexes);basePullAt(array,indexes.sort(baseCompareAscending));return result});function remove(array,predicate,thisArg){var result=[];if(!(array&&array.length)){return result}var index=-1,indexes=[],length=array.length;predicate=getCallback(predicate,thisArg,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index)}}basePullAt(array,indexes);return result}function rest(array){return drop(array,1)}function slice(array,start,end){var length=array?array.length:0;if(!length){return[]}if(end&&typeof end!="number"&&isIterateeCall(array,start,end)){start=0;end=length}return baseSlice(array,start,end)}var sortedIndex=createSortedIndex();var sortedLastIndex=createSortedIndex(true);function take(array,n,guard){var length=array?array.length:0;if(!length){return[]}if(guard?isIterateeCall(array,n,guard):n==null){n=1}return baseSlice(array,0,n<0?0:n)}function takeRight(array,n,guard){var length=array?array.length:0;if(!length){return[]}if(guard?isIterateeCall(array,n,guard):n==null){n=1}n=length-(+n||0);return baseSlice(array,n<0?0:n)}function takeRightWhile(array,predicate,thisArg){return array&&array.length?baseWhile(array,getCallback(predicate,thisArg,3),false,true):[]}function takeWhile(array,predicate,thisArg){return array&&array.length?baseWhile(array,getCallback(predicate,thisArg,3)):[]}var union=restParam(function(arrays){return baseUniq(baseFlatten(arrays,false,true))});function uniq(array,isSorted,iteratee,thisArg){var length=array?array.length:0;if(!length){return[]}if(isSorted!=null&&typeof isSorted!="boolean"){thisArg=iteratee;iteratee=isIterateeCall(array,isSorted,thisArg)?undefined:isSorted;isSorted=false}var callback=getCallback();if(!(iteratee==null&&callback===baseCallback)){iteratee=callback(iteratee,thisArg,3)}return isSorted&&getIndexOf()==baseIndexOf?sortedUniq(array,iteratee):baseUniq(array,iteratee)}function unzip(array){if(!(array&&array.length)){return[]}var index=-1,length=0;array=arrayFilter(array,function(group){if(isArrayLike(group)){length=nativeMax(group.length,length);return true}});var result=Array(length);while(++index<length){result[index]=arrayMap(array,baseProperty(index))}return result}function unzipWith(array,iteratee,thisArg){var length=array?array.length:0;if(!length){return[]}var result=unzip(array);if(iteratee==null){return result}iteratee=bindCallback(iteratee,thisArg,4);return arrayMap(result,function(group){return arrayReduce(group,iteratee,undefined,true)})}var without=restParam(function(array,values){return isArrayLike(array)?baseDifference(array,values):[]});function xor(){var index=-1,length=arguments.length;while(++index<length){var array=arguments[index];if(isArrayLike(array)){var result=result?arrayPush(baseDifference(result,array),baseDifference(array,result)):array}}return result?baseUniq(result):[]}var zip=restParam(unzip);function zipObject(props,values){var index=-1,length=props?props.length:0,result={};if(length&&!values&&!isArray(props[0])){values=[]}while(++index<length){var key=props[index];if(values){result[key]=values[index]}else if(key){result[key[0]]=key[1]}}return result}var zipWith=restParam(function(arrays){var length=arrays.length,iteratee=length>2?arrays[length-2]:undefined,thisArg=length>1?arrays[length-1]:undefined;if(length>2&&typeof iteratee=="function"){length-=2}else{iteratee=length>1&&typeof thisArg=="function"?(--length,thisArg):undefined;thisArg=undefined}arrays.length=length;return unzipWith(arrays,iteratee,thisArg)});function chain(value){var result=lodash(value);result.__chain__=true;return result}function tap(value,interceptor,thisArg){interceptor.call(thisArg,value);return value}function thru(value,interceptor,thisArg){return interceptor.call(thisArg,value)}function wrapperChain(){return chain(this)}function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__)}var wrapperConcat=restParam(function(values){values=baseFlatten(values);return this.thru(function(array){return arrayConcat(isArray(array)?array:[toObject(array)],values)})});function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);if(result){previous.__wrapped__=clone}else{result=clone}var previous=clone;parent=parent.__wrapped__}previous.__wrapped__=value;return result}function wrapperReverse(){var value=this.__wrapped__;var interceptor=function(value){return wrapped&&wrapped.__dir__<0?value:value.reverse()};if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this)}wrapped=wrapped.reverse();wrapped.__actions__.push({func:thru,args:[interceptor],thisArg:undefined});return new LodashWrapper(wrapped,this.__chain__)}return this.thru(interceptor)}function wrapperToString(){return this.value()+""}function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__)}var at=restParam(function(collection,props){return baseAt(collection,baseFlatten(props))});var countBy=createAggregator(function(result,value,key){hasOwnProperty.call(result,key)?++result[key]:result[key]=1});function every(collection,predicate,thisArg){var func=isArray(collection)?arrayEvery:baseEvery;if(thisArg&&isIterateeCall(collection,predicate,thisArg)){predicate=undefined
  }if(typeof predicate!="function"||thisArg!==undefined){predicate=getCallback(predicate,thisArg,3)}return func(collection,predicate)}function filter(collection,predicate,thisArg){var func=isArray(collection)?arrayFilter:baseFilter;predicate=getCallback(predicate,thisArg,3);return func(collection,predicate)}var find=createFind(baseEach);var findLast=createFind(baseEachRight,true);function findWhere(collection,source){return find(collection,baseMatches(source))}var forEach=createForEach(arrayEach,baseEach);var forEachRight=createForEach(arrayEachRight,baseEachRight);var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value)}else{result[key]=[value]}});function includes(collection,target,fromIndex,guard){var length=collection?getLength(collection):0;if(!isLength(length)){collection=values(collection);length=collection.length}if(typeof fromIndex!="number"||guard&&isIterateeCall(target,fromIndex,guard)){fromIndex=0}else{fromIndex=fromIndex<0?nativeMax(length+fromIndex,0):fromIndex||0}return typeof collection=="string"||!isArray(collection)&&isString(collection)?fromIndex<=length&&collection.indexOf(target,fromIndex)>-1:!!length&&getIndexOf(collection,target,fromIndex)>-1}var indexBy=createAggregator(function(result,value,key){result[key]=value});var invoke=restParam(function(collection,path,args){var index=-1,isFunc=typeof path=="function",isProp=isKey(path),result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){var func=isFunc?path:isProp&&value!=null?value[path]:undefined;result[++index]=func?func.apply(value,args):invokePath(value,path,args)});return result});function map(collection,iteratee,thisArg){var func=isArray(collection)?arrayMap:baseMap;iteratee=getCallback(iteratee,thisArg,3);return func(collection,iteratee)}var partition=createAggregator(function(result,value,key){result[key?0:1].push(value)},function(){return[[],[]]});function pluck(collection,path){return map(collection,property(path))}var reduce=createReduce(arrayReduce,baseEach);var reduceRight=createReduce(arrayReduceRight,baseEachRight);function reject(collection,predicate,thisArg){var func=isArray(collection)?arrayFilter:baseFilter;predicate=getCallback(predicate,thisArg,3);return func(collection,function(value,index,collection){return!predicate(value,index,collection)})}function sample(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n==null){collection=toIterable(collection);var length=collection.length;return length>0?collection[baseRandom(0,length-1)]:undefined}var index=-1,result=toArray(collection),length=result.length,lastIndex=length-1;n=nativeMin(n<0?0:+n||0,length);while(++index<n){var rand=baseRandom(index,lastIndex),value=result[rand];result[rand]=result[index];result[index]=value}result.length=n;return result}function shuffle(collection){return sample(collection,POSITIVE_INFINITY)}function size(collection){var length=collection?getLength(collection):0;return isLength(length)?length:keys(collection).length}function some(collection,predicate,thisArg){var func=isArray(collection)?arraySome:baseSome;if(thisArg&&isIterateeCall(collection,predicate,thisArg)){predicate=undefined}if(typeof predicate!="function"||thisArg!==undefined){predicate=getCallback(predicate,thisArg,3)}return func(collection,predicate)}function sortBy(collection,iteratee,thisArg){if(collection==null){return[]}if(thisArg&&isIterateeCall(collection,iteratee,thisArg)){iteratee=undefined}var index=-1;iteratee=getCallback(iteratee,thisArg,3);var result=baseMap(collection,function(value,key,collection){return{criteria:iteratee(value,key,collection),index:++index,value:value}});return baseSortBy(result,compareAscending)}var sortByAll=restParam(function(collection,iteratees){if(collection==null){return[]}var guard=iteratees[2];if(guard&&isIterateeCall(iteratees[0],iteratees[1],guard)){iteratees.length=1}return baseSortByOrder(collection,baseFlatten(iteratees),[])});function sortByOrder(collection,iteratees,orders,guard){if(collection==null){return[]}if(guard&&isIterateeCall(iteratees,orders,guard)){orders=undefined}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees]}if(!isArray(orders)){orders=orders==null?[]:[orders]}return baseSortByOrder(collection,iteratees,orders)}function where(collection,source){return filter(collection,baseMatches(source))}var now=nativeNow||function(){return(new Date).getTime()};function after(n,func){if(typeof func!="function"){if(typeof n=="function"){var temp=n;n=func;func=temp}else{throw new TypeError(FUNC_ERROR_TEXT)}}n=nativeIsFinite(n=+n)?n:0;return function(){if(--n<1){return func.apply(this,arguments)}}}function ary(func,n,guard){if(guard&&isIterateeCall(func,n,guard)){n=undefined}n=func&&n==null?func.length:nativeMax(+n||0,0);return createWrapper(func,ARY_FLAG,undefined,undefined,undefined,undefined,n)}function before(n,func){var result;if(typeof func!="function"){if(typeof n=="function"){var temp=n;n=func;func=temp}else{throw new TypeError(FUNC_ERROR_TEXT)}}return function(){if(--n>0){result=func.apply(this,arguments)}if(n<=1){func=undefined}return result}}var bind=restParam(function(func,thisArg,partials){var bitmask=BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,bind.placeholder);bitmask|=PARTIAL_FLAG}return createWrapper(func,bitmask,thisArg,partials,holders)});var bindAll=restParam(function(object,methodNames){methodNames=methodNames.length?baseFlatten(methodNames):functions(object);var index=-1,length=methodNames.length;while(++index<length){var key=methodNames[index];object[key]=createWrapper(object[key],BIND_FLAG,object)}return object});var bindKey=restParam(function(object,key,partials){var bitmask=BIND_FLAG|BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,bindKey.placeholder);bitmask|=PARTIAL_FLAG}return createWrapper(key,bitmask,object,partials,holders)});var curry=createCurry(CURRY_FLAG);var curryRight=createCurry(CURRY_RIGHT_FLAG);function debounce(func,wait,options){var args,maxTimeoutId,result,stamp,thisArg,timeoutId,trailingCall,lastCalled=0,maxWait=false,trailing=true;if(typeof func!="function"){throw new TypeError(FUNC_ERROR_TEXT)}wait=wait<0?0:+wait||0;if(options===true){var leading=true;trailing=false}else if(isObject(options)){leading=!!options.leading;maxWait="maxWait"in options&&nativeMax(+options.maxWait||0,wait);trailing="trailing"in options?!!options.trailing:trailing}function cancel(){if(timeoutId){clearTimeout(timeoutId)}if(maxTimeoutId){clearTimeout(maxTimeoutId)}lastCalled=0;maxTimeoutId=timeoutId=trailingCall=undefined}function complete(isCalled,id){if(id){clearTimeout(id)}maxTimeoutId=timeoutId=trailingCall=undefined;if(isCalled){lastCalled=now();result=func.apply(thisArg,args);if(!timeoutId&&!maxTimeoutId){args=thisArg=undefined}}}function delayed(){var remaining=wait-(now()-stamp);if(remaining<=0||remaining>wait){complete(trailingCall,maxTimeoutId)}else{timeoutId=setTimeout(delayed,remaining)}}function maxDelayed(){complete(trailing,timeoutId)}function debounced(){args=arguments;stamp=now();thisArg=this;trailingCall=trailing&&(timeoutId||!leading);if(maxWait===false){var leadingCall=leading&&!timeoutId}else{if(!maxTimeoutId&&!leading){lastCalled=stamp}var remaining=maxWait-(stamp-lastCalled),isCalled=remaining<=0||remaining>maxWait;if(isCalled){if(maxTimeoutId){maxTimeoutId=clearTimeout(maxTimeoutId)}lastCalled=stamp;result=func.apply(thisArg,args)}else if(!maxTimeoutId){maxTimeoutId=setTimeout(maxDelayed,remaining)}}if(isCalled&&timeoutId){timeoutId=clearTimeout(timeoutId)}else if(!timeoutId&&wait!==maxWait){timeoutId=setTimeout(delayed,wait)}if(leadingCall){isCalled=true;result=func.apply(thisArg,args)}if(isCalled&&!timeoutId&&!maxTimeoutId){args=thisArg=undefined}return result}debounced.cancel=cancel;return debounced}var defer=restParam(function(func,args){return baseDelay(func,1,args)});var delay=restParam(function(func,wait,args){return baseDelay(func,wait,args)});var flow=createFlow();var flowRight=createFlow(true);function memoize(func,resolver){if(typeof func!="function"||resolver&&typeof resolver!="function"){throw new TypeError(FUNC_ERROR_TEXT)}var memoized=function(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key)}var result=func.apply(this,args);memoized.cache=cache.set(key,result);return result};memoized.cache=new memoize.Cache;return memoized}var modArgs=restParam(function(func,transforms){transforms=baseFlatten(transforms);if(typeof func!="function"||!arrayEvery(transforms,baseIsFunction)){throw new TypeError(FUNC_ERROR_TEXT)}var length=transforms.length;return restParam(function(args){var index=nativeMin(args.length,length);while(index--){args[index]=transforms[index](args[index])}return func.apply(this,args)})});function negate(predicate){if(typeof predicate!="function"){throw new TypeError(FUNC_ERROR_TEXT)}return function(){return!predicate.apply(this,arguments)}}function once(func){return before(2,func)}var partial=createPartial(PARTIAL_FLAG);var partialRight=createPartial(PARTIAL_RIGHT_FLAG);var rearg=restParam(function(func,indexes){return createWrapper(func,REARG_FLAG,undefined,undefined,undefined,baseFlatten(indexes))});function restParam(func,start){if(typeof func!="function"){throw new TypeError(FUNC_ERROR_TEXT)}start=nativeMax(start===undefined?func.length-1:+start||0,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),rest=Array(length);while(++index<length){rest[index]=args[start+index]}switch(start){case 0:return func.call(this,rest);case 1:return func.call(this,args[0],rest);case 2:return func.call(this,args[0],args[1],rest)}var otherArgs=Array(start+1);index=-1;while(++index<start){otherArgs[index]=args[index]}otherArgs[start]=rest;return func.apply(this,otherArgs)}}function spread(func){if(typeof func!="function"){throw new TypeError(FUNC_ERROR_TEXT)}return function(array){return func.apply(this,array)}}function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!="function"){throw new TypeError(FUNC_ERROR_TEXT)}if(options===false){leading=false}else if(isObject(options)){leading="leading"in options?!!options.leading:leading;trailing="trailing"in options?!!options.trailing:trailing}return debounce(func,wait,{leading:leading,maxWait:+wait,trailing:trailing})}function wrap(value,wrapper){wrapper=wrapper==null?identity:wrapper;return createWrapper(wrapper,PARTIAL_FLAG,undefined,[value],[])}function clone(value,isDeep,customizer,thisArg){if(isDeep&&typeof isDeep!="boolean"&&isIterateeCall(value,isDeep,customizer)){isDeep=false}else if(typeof isDeep=="function"){thisArg=customizer;customizer=isDeep;isDeep=false}return typeof customizer=="function"?baseClone(value,isDeep,bindCallback(customizer,thisArg,1)):baseClone(value,isDeep)}function cloneDeep(value,customizer,thisArg){return typeof customizer=="function"?baseClone(value,true,bindCallback(customizer,thisArg,1)):baseClone(value,true)}function gt(value,other){return value>other}function gte(value,other){return value>=other}function isArguments(value){return isObjectLike(value)&&isArrayLike(value)&&hasOwnProperty.call(value,"callee")&&!propertyIsEnumerable.call(value,"callee")}var isArray=nativeIsArray||function(value){return isObjectLike(value)&&isLength(value.length)&&objToString.call(value)==arrayTag};function isBoolean(value){return value===true||value===false||isObjectLike(value)&&objToString.call(value)==boolTag}function isDate(value){return isObjectLike(value)&&objToString.call(value)==dateTag}function isElement(value){return!!value&&value.nodeType===1&&isObjectLike(value)&&!isPlainObject(value)}function isEmpty(value){if(value==null){return true}if(isArrayLike(value)&&(isArray(value)||isString(value)||isArguments(value)||isObjectLike(value)&&isFunction(value.splice))){return!value.length}return!keys(value).length}function isEqual(value,other,customizer,thisArg){customizer=typeof customizer=="function"?bindCallback(customizer,thisArg,3):undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,customizer):!!result}function isError(value){return isObjectLike(value)&&typeof value.message=="string"&&objToString.call(value)==errorTag}function isFinite(value){return typeof value=="number"&&nativeIsFinite(value)}function isFunction(value){return isObject(value)&&objToString.call(value)==funcTag}function isObject(value){var type=typeof value;return!!value&&(type=="object"||type=="function")}function isMatch(object,source,customizer,thisArg){customizer=typeof customizer=="function"?bindCallback(customizer,thisArg,3):undefined;return baseIsMatch(object,getMatchData(source),customizer)}function isNaN(value){return isNumber(value)&&value!=+value}function isNative(value){if(value==null){return false}if(isFunction(value)){return reIsNative.test(fnToString.call(value))}return isObjectLike(value)&&reIsHostCtor.test(value)}function isNull(value){return value===null}function isNumber(value){return typeof value=="number"||isObjectLike(value)&&objToString.call(value)==numberTag}function isPlainObject(value){var Ctor;if(!(isObjectLike(value)&&objToString.call(value)==objectTag&&!isArguments(value))||!hasOwnProperty.call(value,"constructor")&&(Ctor=value.constructor,typeof Ctor=="function"&&!(Ctor instanceof Ctor))){return false}var result;baseForIn(value,function(subValue,key){result=key});return result===undefined||hasOwnProperty.call(value,result)}function isRegExp(value){return isObject(value)&&objToString.call(value)==regexpTag}function isString(value){return typeof value=="string"||isObjectLike(value)&&objToString.call(value)==stringTag}function isTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[objToString.call(value)]}function isUndefined(value){return value===undefined}function lt(value,other){return value<other}function lte(value,other){return value<=other}function toArray(value){var length=value?getLength(value):0;if(!isLength(length)){return values(value)}if(!length){return[]}return arrayCopy(value)}function toPlainObject(value){return baseCopy(value,keysIn(value))}var merge=createAssigner(baseMerge);var assign=createAssigner(function(object,source,customizer){return customizer?assignWith(object,source,customizer):baseAssign(object,source)});function create(prototype,properties,guard){var result=baseCreate(prototype);if(guard&&isIterateeCall(prototype,properties,guard)){properties=undefined}return properties?baseAssign(result,properties):result}var defaults=createDefaults(assign,assignDefaults);var defaultsDeep=createDefaults(merge,mergeDefaults);var findKey=createFindKey(baseForOwn);var findLastKey=createFindKey(baseForOwnRight);var forIn=createForIn(baseFor);var forInRight=createForIn(baseForRight);var forOwn=createForOwn(baseForOwn);var forOwnRight=createForOwn(baseForOwnRight);function functions(object){return baseFunctions(object,keysIn(object))}function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,toPath(path),path+"");return result===undefined?defaultValue:result}function has(object,path){if(object==null){return false}var result=hasOwnProperty.call(object,path);if(!result&&!isKey(path)){path=toPath(path);object=path.length==1?object:baseGet(object,baseSlice(path,0,-1));if(object==null){return false}path=last(path);result=hasOwnProperty.call(object,path)}return result||isLength(object.length)&&isIndex(path,object.length)&&(isArray(object)||isArguments(object))}function invert(object,multiValue,guard){if(guard&&isIterateeCall(object,multiValue,guard)){multiValue=undefined}var index=-1,props=keys(object),length=props.length,result={};while(++index<length){var key=props[index],value=object[key];if(multiValue){if(hasOwnProperty.call(result,value)){result[value].push(key)}else{result[value]=[key]}}else{result[value]=key}}return result}var keys=!nativeKeys?shimKeys:function(object){var Ctor=object==null?undefined:object.constructor;if(typeof Ctor=="function"&&Ctor.prototype===object||typeof object!="function"&&isArrayLike(object)){return shimKeys(object)}return isObject(object)?nativeKeys(object):[]};function keysIn(object){if(object==null){return[]}if(!isObject(object)){object=Object(object)}var length=object.length;length=length&&isLength(length)&&(isArray(object)||isArguments(object))&&length||0;var Ctor=object.constructor,index=-1,isProto=typeof Ctor=="function"&&Ctor.prototype===object,result=Array(length),skipIndexes=length>0;while(++index<length){result[index]=index+""}for(var key in object){if(!(skipIndexes&&isIndex(key,length))&&!(key=="constructor"&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key)}}return result}var mapKeys=createObjectMapper(true);var mapValues=createObjectMapper();var omit=restParam(function(object,props){if(object==null){return{}}if(typeof props[0]!="function"){var props=arrayMap(baseFlatten(props),String);return pickByArray(object,baseDifference(keysIn(object),props))}var predicate=bindCallback(props[0],props[1],3);return pickByCallback(object,function(value,key,object){return!predicate(value,key,object)})});function pairs(object){object=toObject(object);var index=-1,props=keys(object),length=props.length,result=Array(length);while(++index<length){var key=props[index];result[index]=[key,object[key]]}return result}var pick=restParam(function(object,props){if(object==null){return{}}return typeof props[0]=="function"?pickByCallback(object,bindCallback(props[0],props[1],3)):pickByArray(object,baseFlatten(props))});function result(object,path,defaultValue){var result=object==null?undefined:object[path];if(result===undefined){if(object!=null&&!isKey(path,object)){path=toPath(path);object=path.length==1?object:baseGet(object,baseSlice(path,0,-1));result=object==null?undefined:object[last(path)]}result=result===undefined?defaultValue:result}return isFunction(result)?result.call(object):result}function set(object,path,value){if(object==null){return object}var pathKey=path+"";path=object[pathKey]!=null||isKey(path,object)?[pathKey]:toPath(path);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=path[index];if(isObject(nested)){if(index==lastIndex){nested[key]=value}else if(nested[key]==null){nested[key]=isIndex(path[index+1])?[]:{}}}nested=nested[key]}return object}function transform(object,iteratee,accumulator,thisArg){var isArr=isArray(object)||isTypedArray(object);iteratee=getCallback(iteratee,thisArg,4);if(accumulator==null){if(isArr||isObject(object)){var Ctor=object.constructor;if(isArr){accumulator=isArray(object)?new Ctor:[]}else{accumulator=baseCreate(isFunction(Ctor)?Ctor.prototype:undefined)}}else{accumulator={}}}(isArr?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object)});return accumulator}function values(object){return baseValues(object,keys(object))}function valuesIn(object){return baseValues(object,keysIn(object))}function inRange(value,start,end){start=+start||0;if(end===undefined){end=start;start=0}else{end=+end||0}return value>=nativeMin(start,end)&&value<nativeMax(start,end)}function random(min,max,floating){if(floating&&isIterateeCall(min,max,floating)){max=floating=undefined}var noMin=min==null,noMax=max==null;if(floating==null){if(noMax&&typeof min=="boolean"){floating=min;min=1}else if(typeof max=="boolean"){floating=max;noMax=true}}if(noMin&&noMax){max=1;noMax=false}min=+min||0;if(noMax){max=min;min=0}else{max=+max||0}if(floating||min%1||max%1){var rand=nativeRandom();return nativeMin(min+rand*(max-min+parseFloat("1e-"+((rand+"").length-1))),max)}return baseRandom(min,max)}var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?word.charAt(0).toUpperCase()+word.slice(1):word)});function capitalize(string){string=baseToString(string);return string&&string.charAt(0).toUpperCase()+string.slice(1)}function deburr(string){string=baseToString(string);return string&&string.replace(reLatin1,deburrLetter).replace(reComboMark,"")}function endsWith(string,target,position){string=baseToString(string);target=target+"";var length=string.length;position=position===undefined?length:nativeMin(position<0?0:+position||0,length);position-=target.length;return position>=0&&string.indexOf(target,position)==position}function escape(string){string=baseToString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string}function escapeRegExp(string){string=baseToString(string);return string&&reHasRegExpChars.test(string)?string.replace(reRegExpChars,escapeRegExpChar):string||"(?:)"}var kebabCase=createCompounder(function(result,word,index){return result+(index?"-":"")+word.toLowerCase()});function pad(string,length,chars){string=baseToString(string);length=+length;var strLength=string.length;if(strLength>=length||!nativeIsFinite(length)){return string}var mid=(length-strLength)/2,leftLength=nativeFloor(mid),rightLength=nativeCeil(mid);chars=createPadding("",rightLength,chars);return chars.slice(0,leftLength)+string+chars}var padLeft=createPadDir();var padRight=createPadDir(true);function parseInt(string,radix,guard){if(guard?isIterateeCall(string,radix,guard):radix==null){radix=0}else if(radix){radix=+radix}string=trim(string);return nativeParseInt(string,radix||(reHasHexPrefix.test(string)?16:10))}function repeat(string,n){var result="";string=baseToString(string);n=+n;if(n<1||!string||!nativeIsFinite(n)){return result}do{if(n%2){result+=string}n=nativeFloor(n/2);string+=string}while(n);return result}var snakeCase=createCompounder(function(result,word,index){return result+(index?"_":"")+word.toLowerCase()});var startCase=createCompounder(function(result,word,index){return result+(index?" ":"")+(word.charAt(0).toUpperCase()+word.slice(1))});function startsWith(string,target,position){string=baseToString(string);position=position==null?0:nativeMin(position<0?0:+position||0,string.length);return string.lastIndexOf(target,position)==position}function template(string,options,otherOptions){var settings=lodash.templateSettings;if(otherOptions&&isIterateeCall(string,options,otherOptions)){options=otherOptions=undefined}string=baseToString(string);options=assignWith(baseAssign({},otherOptions||options),settings,assignOwnDefaults);var imports=assignWith(baseAssign({},options.imports),settings.imports,assignOwnDefaults),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";var reDelimiters=RegExp((options.escape||reNoMatch).source+"|"+interpolate.source+"|"+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+"|"+(options.evaluate||reNoMatch).source+"|$","g");var sourceURL="//# sourceURL="+("sourceURL"in options?options.sourceURL:"lodash.templateSources["+ ++templateCounter+"]")+"\n";string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'"}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '"}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'"}index=offset+match.length;return match});source+="';\n";var variable=options.variable;if(!variable){source="with (obj) {\n"+source+"\n}\n"}source=(isEvaluating?source.replace(reEmptyStringLeading,""):source).replace(reEmptyStringMiddle,"$1").replace(reEmptyStringTrailing,"$1;");source="function("+(variable||"obj")+") {\n"+(variable?"":"obj || (obj = {});\n")+"var __t, __p = ''"+(isEscaping?", __e = _.escape":"")+(isEvaluating?", __j = Array.prototype.join;\n"+"function print() { __p += __j.call(arguments, '') }\n":";\n")+source+"return __p\n}";var result=attempt(function(){return Function(importsKeys,sourceURL+"return "+source).apply(undefined,importsValues)});result.source=source;if(isError(result)){throw result}return result}function trim(string,chars,guard){var value=string;string=baseToString(string);if(!string){return string}if(guard?isIterateeCall(value,chars,guard):chars==null){return string.slice(trimmedLeftIndex(string),trimmedRightIndex(string)+1)}chars=chars+"";return string.slice(charsLeftIndex(string,chars),charsRightIndex(string,chars)+1)}function trimLeft(string,chars,guard){var value=string;string=baseToString(string);if(!string){return string}if(guard?isIterateeCall(value,chars,guard):chars==null){return string.slice(trimmedLeftIndex(string))}return string.slice(charsLeftIndex(string,chars+""))}function trimRight(string,chars,guard){var value=string;string=baseToString(string);if(!string){return string}if(guard?isIterateeCall(value,chars,guard):chars==null){return string.slice(0,trimmedRightIndex(string)+1)}return string.slice(0,charsRightIndex(string,chars+"")+1)}function trunc(string,options,guard){if(guard&&isIterateeCall(string,options,guard)){options=undefined}var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(options!=null){if(isObject(options)){var separator="separator"in options?options.separator:separator;length="length"in options?+options.length||0:length;omission="omission"in options?baseToString(options.omission):omission}else{length=+options||0}}string=baseToString(string);if(length>=string.length){return string}var end=length-omission.length;if(end<1){return omission}var result=string.slice(0,end);if(separator==null){return result+omission}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,newEnd,substring=string.slice(0,end);if(!separator.global){separator=RegExp(separator.source,(reFlags.exec(separator)||"")+"g")}separator.lastIndex=0;while(match=separator.exec(substring)){newEnd=match.index}result=result.slice(0,newEnd==null?end:newEnd)}}else if(string.indexOf(separator,end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index)}}return result+omission}function unescape(string){string=baseToString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string}function words(string,pattern,guard){if(guard&&isIterateeCall(string,pattern,guard)){pattern=undefined}string=baseToString(string);return string.match(pattern||reWords)||[]}var attempt=restParam(function(func,args){try{return func.apply(undefined,args)}catch(e){return isError(e)?e:new Error(e)}});function callback(func,thisArg,guard){if(guard&&isIterateeCall(func,thisArg,guard)){thisArg=undefined}return isObjectLike(func)?matches(func):baseCallback(func,thisArg)}function constant(value){return function(){return value}}function identity(value){return value}function matches(source){return baseMatches(baseClone(source,true))}function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,true))}var method=restParam(function(path,args){return function(object){return invokePath(object,path,args)}});var methodOf=restParam(function(object,args){return function(path){return invokePath(object,path,args)}});function mixin(object,source,options){if(options==null){var isObj=isObject(source),props=isObj?keys(source):undefined,methodNames=props&&props.length?baseFunctions(source,props):undefined;if(!(methodNames?methodNames.length:isObj)){methodNames=false;options=source;source=object;object=this}}if(!methodNames){methodNames=baseFunctions(source,keys(source))}var chain=true,index=-1,isFunc=isFunction(object),length=methodNames.length;if(options===false){chain=false}else if(isObject(options)&&"chain"in options){chain=options.chain}while(++index<length){var methodName=methodNames[index],func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(func){return function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=arrayCopy(this.__actions__);actions.push({func:func,args:arguments,thisArg:object});result.__chain__=chainAll;return result}return func.apply(object,arrayPush([this.value()],arguments))}}(func)}}return object}function noConflict(){root._=oldDash;return this}function noop(){}function property(path){return isKey(path)?baseProperty(path):basePropertyDeep(path)}function propertyOf(object){return function(path){return baseGet(object,toPath(path),path+"")}}function range(start,end,step){if(step&&isIterateeCall(start,end,step)){end=step=undefined}start=+start||0;step=step==null?1:+step||0;if(end==null){end=start;start=0}else{end=+end||0}var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(++index<length){result[index]=start;start+=step}return result}function times(n,iteratee,thisArg){n=nativeFloor(n);if(n<1||!nativeIsFinite(n)){return[]}var index=-1,result=Array(nativeMin(n,MAX_ARRAY_LENGTH));iteratee=bindCallback(iteratee,thisArg,1);while(++index<n){if(index<MAX_ARRAY_LENGTH){result[index]=iteratee(index)}else{iteratee(index)}}return result}function uniqueId(prefix){var id=++idCounter;return baseToString(prefix)+id}function add(augend,addend){return(+augend||0)+(+addend||0)}var ceil=createRound("ceil");var floor=createRound("floor");var max=createExtremum(gt,NEGATIVE_INFINITY);var min=createExtremum(lt,POSITIVE_INFINITY);var round=createRound("round");function sum(collection,iteratee,thisArg){if(thisArg&&isIterateeCall(collection,iteratee,thisArg)){iteratee=undefined}iteratee=getCallback(iteratee,thisArg,3);return iteratee.length==1?arraySum(isArray(collection)?collection:toIterable(collection),iteratee):baseSum(collection,iteratee)}lodash.prototype=baseLodash.prototype;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;MapCache.prototype["delete"]=mapDelete;MapCache.prototype.get=mapGet;MapCache.prototype.has=mapHas;MapCache.prototype.set=mapSet;SetCache.prototype.push=cachePush;memoize.Cache=MapCache;lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.callback=callback;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flow=flow;lodash.flowRight=flowRight;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.functions=functions;lodash.groupBy=groupBy;lodash.indexBy=indexBy;lodash.initial=initial;lodash.intersection=intersection;lodash.invert=invert;lodash.invoke=invoke;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.modArgs=modArgs;lodash.negate=negate;lodash.omit=omit;lodash.once=once;lodash.pairs=pairs;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pluck=pluck;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAt=pullAt;lodash.range=range;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.restParam=restParam;lodash.set=set;
  lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortByAll=sortByAll;lodash.sortByOrder=sortByOrder;lodash.spread=spread;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.times=times;lodash.toArray=toArray;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.union=union;lodash.uniq=uniq;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.where=where;lodash.without=without;lodash.wrap=wrap;lodash.xor=xor;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipWith=zipWith;lodash.backflow=flowRight;lodash.collect=map;lodash.compose=flowRight;lodash.each=forEach;lodash.eachRight=forEachRight;lodash.extend=assign;lodash.iteratee=callback;lodash.methods=functions;lodash.object=zipObject;lodash.select=filter;lodash.tail=rest;lodash.unique=uniq;mixin(lodash,lodash);lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.deburr=deburr;lodash.endsWith=endsWith;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.findWhere=findWhere;lodash.first=first;lodash.floor=floor;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isBoolean=isBoolean;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isMatch=isMatch;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isString=isString;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.min=min;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padLeft=padLeft;lodash.padRight=padRight;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedLastIndex=sortedLastIndex;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.sum=sum;lodash.template=template;lodash.trim=trim;lodash.trimLeft=trimLeft;lodash.trimRight=trimRight;lodash.trunc=trunc;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.words=words;lodash.all=every;lodash.any=some;lodash.contains=includes;lodash.eq=isEqual;lodash.detect=find;lodash.foldl=reduce;lodash.foldr=reduceRight;lodash.head=first;lodash.include=includes;lodash.inject=reduce;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!lodash.prototype[methodName]){source[methodName]=func}});return source}(),false);lodash.sample=sample;lodash.prototype.sample=function(n){if(!this.__chain__&&n==null){return sample(this.value())}return this.thru(function(value){return sample(value,n)})};lodash.VERSION=VERSION;arrayEach(["bind","bindKey","curry","curryRight","partial","partialRight"],function(methodName){lodash[methodName].placeholder=lodash});arrayEach(["drop","take"],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){var filtered=this.__filtered__;if(filtered&&!index){return new LazyWrapper(this)}n=n==null?1:nativeMax(nativeFloor(n)||0,0);var result=this.clone();if(filtered){result.__takeCount__=nativeMin(result.__takeCount__,n)}else{result.__views__.push({size:n,type:methodName+(result.__dir__<0?"Right":"")})}return result};LazyWrapper.prototype[methodName+"Right"]=function(n){return this.reverse()[methodName](n).reverse()}});arrayEach(["filter","map","takeWhile"],function(methodName,index){var type=index+1,isFilter=type!=LAZY_MAP_FLAG;LazyWrapper.prototype[methodName]=function(iteratee,thisArg){var result=this.clone();result.__iteratees__.push({iteratee:getCallback(iteratee,thisArg,1),type:type});result.__filtered__=result.__filtered__||isFilter;return result}});arrayEach(["first","last"],function(methodName,index){var takeName="take"+(index?"Right":"");LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0]}});arrayEach(["initial","rest"],function(methodName,index){var dropName="drop"+(index?"":"Right");LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1)}});arrayEach(["pluck","where"],function(methodName,index){var operationName=index?"filter":"map",createCallback=index?baseMatches:property;LazyWrapper.prototype[methodName]=function(value){return this[operationName](createCallback(value))}});LazyWrapper.prototype.compact=function(){return this.filter(identity)};LazyWrapper.prototype.reject=function(predicate,thisArg){predicate=getCallback(predicate,thisArg,1);return this.filter(function(value){return!predicate(value)})};LazyWrapper.prototype.slice=function(start,end){start=start==null?0:+start||0;var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result)}if(start<0){result=result.takeRight(-start)}else if(start){result=result.drop(start)}if(end!==undefined){end=+end||0;result=end<0?result.dropRight(-end):result.take(end-start)}return result};LazyWrapper.prototype.takeRightWhile=function(predicate,thisArg){return this.reverse().takeWhile(predicate,thisArg).reverse()};LazyWrapper.prototype.toArray=function(){return this.take(POSITIVE_INFINITY)};baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|map|reject)|While$/.test(methodName),retUnwrapped=/^(?:first|last)$/.test(methodName),lodashFunc=lodash[retUnwrapped?"take"+(methodName=="last"?"Right":""):methodName];if(!lodashFunc){return}lodash.prototype[methodName]=function(){var args=retUnwrapped?[1]:arguments,chainAll=this.__chain__,value=this.__wrapped__,isHybrid=!!this.__actions__.length,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);if(useLazy&&checkIteratee&&typeof iteratee=="function"&&iteratee.length!=1){isLazy=useLazy=false}var interceptor=function(value){return retUnwrapped&&chainAll?lodashFunc(value,1)[0]:lodashFunc.apply(undefined,arrayPush([value],args))};var action={func:thru,args:[interceptor],thisArg:undefined},onlyLazy=isLazy&&!isHybrid;if(retUnwrapped&&!chainAll){if(onlyLazy){value=value.clone();value.__actions__.push(action);return func.call(value)}return lodashFunc.call(undefined,this.value())[0]}if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push(action);return new LodashWrapper(result,chainAll)}return this.thru(interceptor)}});arrayEach(["join","pop","push","replace","shift","sort","splice","split","unshift"],function(methodName){var func=(/^(?:replace|split)$/.test(methodName)?stringProto:arrayProto)[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?"tap":"thru",retUnwrapped=/^(?:join|pop|replace|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){return func.apply(this.value(),args)}return this[chainName](function(value){return func.apply(value,args)})}});baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name,names=realNames[key]||(realNames[key]=[]);names.push({name:methodName,func:lodashFunc})}});realNames[createHybridWrapper(undefined,BIND_KEY_FLAG).name]=[{name:"wrapper",func:undefined}];LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.concat=wrapperConcat;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toString=wrapperToString;lodash.prototype.run=lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;lodash.prototype.collect=lodash.prototype.map;lodash.prototype.head=lodash.prototype.first;lodash.prototype.select=lodash.prototype.filter;lodash.prototype.tail=lodash.prototype.rest;return lodash}var _=runInContext();if(typeof define=="function"&&typeof define.amd=="object"&&define.amd){root._=_;define(function(){return _})}else if(freeExports&&freeModule){if(moduleExports){(freeModule.exports=_)._=_}else{freeExports._=_}}else{root._=_}}).call(this)}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{}]},{},[1])(1)});
  (function webpackUniversalModuleDefinition(root, factory) {
      if(typeof exports === 'object' && typeof module === 'object')
          module.exports = factory(require("dagre"));
      else if(typeof define === 'function' && define.amd)
          define(["dagre"], factory);
      else if(typeof exports === 'object')
          exports["cytoscapeDagre"] = factory(require("dagre"));
      else
          root["cytoscapeDagre"] = factory(root["dagre"]);
  })(this, function(__WEBPACK_EXTERNAL_MODULE_4__) {
  return /******/ (function(modules) { // webpackBootstrap
  /******/ 	// The module cache
  /******/ 	var installedModules = {};
  /******/
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/
  /******/ 		// Check if module is in cache
  /******/ 		if(installedModules[moduleId]) {
  /******/ 			return installedModules[moduleId].exports;
  /******/ 		}
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = installedModules[moduleId] = {
  /******/ 			i: moduleId,
  /******/ 			l: false,
  /******/ 			exports: {}
  /******/ 		};
  /******/
  /******/ 		// Execute the module function
  /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  /******/
  /******/ 		// Flag the module as loaded
  /******/ 		module.l = true;
  /******/
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/
  /******/
  /******/ 	// expose the modules object (__webpack_modules__)
  /******/ 	__webpack_require__.m = modules;
  /******/
  /******/ 	// expose the module cache
  /******/ 	__webpack_require__.c = installedModules;
  /******/
  /******/ 	// identity function for calling harmony imports with the correct context
  /******/ 	__webpack_require__.i = function(value) { return value; };
  /******/
  /******/ 	// define getter function for harmony exports
  /******/ 	__webpack_require__.d = function(exports, name, getter) {
  /******/ 		if(!__webpack_require__.o(exports, name)) {
  /******/ 			Object.defineProperty(exports, name, {
  /******/ 				configurable: false,
  /******/ 				enumerable: true,
  /******/ 				get: getter
  /******/ 			});
  /******/ 		}
  /******/ 	};
  /******/
  /******/ 	// getDefaultExport function for compatibility with non-harmony modules
  /******/ 	__webpack_require__.n = function(module) {
  /******/ 		var getter = module && module.__esModule ?
  /******/ 			function getDefault() { return module['default']; } :
  /******/ 			function getModuleExports() { return module; };
  /******/ 		__webpack_require__.d(getter, 'a', getter);
  /******/ 		return getter;
  /******/ 	};
  /******/
  /******/ 	// Object.prototype.hasOwnProperty.call
  /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  /******/
  /******/ 	// __webpack_public_path__
  /******/ 	__webpack_require__.p = "";
  /******/
  /******/ 	// Load entry module and return exports
  /******/ 	return __webpack_require__(__webpack_require__.s = 3);
  /******/ })
  /************************************************************************/
  /******/ ([
  /* 0 */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
  
  var isFunction = function isFunction(o) {
    return typeof o === 'function';
  };
  var defaults = __webpack_require__(2);
  var assign = __webpack_require__(1);
  var dagre = __webpack_require__(4);
  
  // constructor
  // options : object containing layout options
  function DagreLayout(options) {
    this.options = assign({}, defaults, options);
  }
  
  // runs the layout
  DagreLayout.prototype.run = function () {
    var options = this.options;
    var layout = this;
  
    var cy = options.cy; // cy is automatically populated for us in the constructor
    var eles = options.eles;
  
    var getVal = function getVal(ele, val) {
      return isFunction(val) ? val.apply(ele, [ele]) : val;
    };
  
    var bb = options.boundingBox || { x1: 0, y1: 0, w: cy.width(), h: cy.height() };
    if (bb.x2 === undefined) {
      bb.x2 = bb.x1 + bb.w;
    }
    if (bb.w === undefined) {
      bb.w = bb.x2 - bb.x1;
    }
    if (bb.y2 === undefined) {
      bb.y2 = bb.y1 + bb.h;
    }
    if (bb.h === undefined) {
      bb.h = bb.y2 - bb.y1;
    }
  
    var g = new dagre.graphlib.Graph({
      multigraph: true,
      compound: true
    });
  
    var gObj = {};
    var setGObj = function setGObj(name, val) {
      if (val != null) {
        gObj[name] = val;
      }
    };
  
    setGObj('nodesep', options.nodeSep);
    setGObj('edgesep', options.edgeSep);
    setGObj('ranksep', options.rankSep);
    setGObj('rankdir', options.rankDir);
    setGObj('ranker', options.ranker);
  
    g.setGraph(gObj);
  
    g.setDefaultEdgeLabel(function () {
      return {};
    });
    g.setDefaultNodeLabel(function () {
      return {};
    });
  
    // add nodes to dagre
    var nodes = eles.nodes();
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      var nbb = node.layoutDimensions(options);
  
      g.setNode(node.id(), {
        width: nbb.w,
        height: nbb.h,
        name: node.id()
      });
  
      // console.log( g.node(node.id()) );
    }
  
    // set compound parents
    for (var _i = 0; _i < nodes.length; _i++) {
      var _node = nodes[_i];
  
      if (_node.isChild()) {
        g.setParent(_node.id(), _node.parent().id());
      }
    }
  
    // add edges to dagre
    var edges = eles.edges().stdFilter(function (edge) {
      return !edge.source().isParent() && !edge.target().isParent(); // dagre can't handle edges on compound nodes
    });
    for (var _i2 = 0; _i2 < edges.length; _i2++) {
      var edge = edges[_i2];
  
      g.setEdge(edge.source().id(), edge.target().id(), {
        minlen: getVal(edge, options.minLen),
        weight: getVal(edge, options.edgeWeight),
        name: edge.id()
      }, edge.id());
  
      // console.log( g.edge(edge.source().id(), edge.target().id(), edge.id()) );
    }
  
    dagre.layout(g);
  
    var gNodeIds = g.nodes();
    for (var _i3 = 0; _i3 < gNodeIds.length; _i3++) {
      var id = gNodeIds[_i3];
      var n = g.node(id);
  
      cy.getElementById(id).scratch().dagre = n;
    }
  
    var dagreBB = void 0;
  
    if (options.boundingBox) {
      dagreBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };
      nodes.forEach(function (node) {
        var dModel = node.scratch().dagre;
  
        dagreBB.x1 = Math.min(dagreBB.x1, dModel.x);
        dagreBB.x2 = Math.max(dagreBB.x2, dModel.x);
  
        dagreBB.y1 = Math.min(dagreBB.y1, dModel.y);
        dagreBB.y2 = Math.max(dagreBB.y2, dModel.y);
      });
  
      dagreBB.w = dagreBB.x2 - dagreBB.x1;
      dagreBB.h = dagreBB.y2 - dagreBB.y1;
    } else {
      dagreBB = bb;
    }
  
    var constrainPos = function constrainPos(p) {
      if (options.boundingBox) {
        var xPct = dagreBB.w === 0 ? 0 : (p.x - dagreBB.x1) / dagreBB.w;
        var yPct = dagreBB.h === 0 ? 0 : (p.y - dagreBB.y1) / dagreBB.h;
  
        return {
          x: bb.x1 + xPct * bb.w,
          y: bb.y1 + yPct * bb.h
        };
      } else {
        return p;
      }
    };
  
    nodes.layoutPositions(layout, options, function (ele) {
      ele = (typeof ele === 'undefined' ? 'undefined' : _typeof(ele)) === "object" ? ele : this;
      var dModel = ele.scratch().dagre;
  
      return constrainPos({
        x: dModel.x,
        y: dModel.y
      });
    });
  
    return this; // chaining
  };
  
  module.exports = DagreLayout;
  
  /***/ }),
  /* 1 */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  // Simple, internal Object.assign() polyfill for options objects etc.
  
  module.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {
    for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      srcs[_key - 1] = arguments[_key];
    }
  
    srcs.forEach(function (src) {
      Object.keys(src).forEach(function (k) {
        return tgt[k] = src[k];
      });
    });
  
    return tgt;
  };
  
  /***/ }),
  /* 2 */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var defaults = {
    // dagre algo options, uses default value on undefined
    nodeSep: undefined, // the separation between adjacent nodes in the same rank
    edgeSep: undefined, // the separation between adjacent edges in the same rank
    rankSep: undefined, // the separation between adjacent nodes in the same rank
    rankDir: undefined, // 'TB' for top to bottom flow, 'LR' for left to right,
    ranker: undefined, // Type of algorithm to assigns a rank to each node in the input graph.
    // Possible values: network-simplex, tight-tree or longest-path
    minLen: function minLen(edge) {
      return 1;
    }, // number of ranks to keep between the source and target of the edge
    edgeWeight: function edgeWeight(edge) {
      return 1;
    }, // higher weight edges are generally made shorter and straighter than lower weight edges
  
    // general layout options
    fit: true, // whether to fit to viewport
    padding: 30, // fit padding
    spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
    nodeDimensionsIncludeLabels: false, // whether labels should be included in determining the space used by a node
    animate: false, // whether to transition the node positions
    animateFilter: function animateFilter(node, i) {
      return true;
    }, // whether to animate specific nodes when animation is on; non-animated nodes immediately go to their final positions
    animationDuration: 500, // duration of animation in ms if enabled
    animationEasing: undefined, // easing of animation if enabled
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    transform: function transform(node, pos) {
      return pos;
    }, // a function that applies a transform to the final node position
    ready: function ready() {}, // on layoutready
    stop: function stop() {} // on layoutstop
  };
  
  module.exports = defaults;
  
  /***/ }),
  /* 3 */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var impl = __webpack_require__(0);
  
  // registers the extension on a cytoscape lib ref
  var register = function register(cytoscape) {
    if (!cytoscape) {
      return;
    } // can't register if cytoscape unspecified
  
    cytoscape('layout', 'dagre', impl); // register with cytoscape.js
  };
  
  if (typeof cytoscape !== 'undefined') {
    // expose to global cytoscape (i.e. window.cytoscape)
    register(cytoscape);
  }
  
  module.exports = register;
  
  /***/ }),
  /* 4 */
  /***/ (function(module, exports) {
  
  module.exports = __WEBPACK_EXTERNAL_MODULE_4__;
  
  /***/ })
  /******/ ]);
  });
  /**!
   * @fileOverview Kickass library to create and place poppers near their reference elements.
   * @version 1.14.5
   * @license
   * Copyright (c) 2016 Federico Zivolo and contributors
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
  
  (function (global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
      typeof define === 'function' && define.amd ? define(factory) :
      (global.Popper = factory());
  }(this, (function () { 'use strict';
  
  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
  
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  var timeoutDuration = 0;
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      timeoutDuration = 1;
      break;
    }
  }
  
  function microtaskDebounce(fn) {
    var called = false;
    return function () {
      if (called) {
        return;
      }
      called = true;
      window.Promise.resolve().then(function () {
        called = false;
        fn();
      });
    };
  }
  
  function taskDebounce(fn) {
    var scheduled = false;
    return function () {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function () {
          scheduled = false;
          fn();
        }, timeoutDuration);
      }
    };
  }
  
  var supportsMicroTasks = isBrowser && window.Promise;
  
  /**
  * Create a debounced version of a method, that's asynchronously deferred
  * but called in the minimum time possible.
  *
  * @method
  * @memberof Popper.Utils
  * @argument {Function} fn
  * @returns {Function}
  */
  var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
  
  /**
   * Check if the given variable is a function
   * @method
   * @memberof Popper.Utils
   * @argument {Any} functionToCheck - variable to check
   * @returns {Boolean} answer to: is a function?
   */
  function isFunction(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
  }
  
  /**
   * Get CSS computed property of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Eement} element
   * @argument {String} property
   */
  function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
      return [];
    }
    // NOTE: 1 DOM access here
    var window = element.ownerDocument.defaultView;
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
  }
  
  /**
   * Returns the parentNode or the host of the element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} parent
   */
  function getParentNode(element) {
    if (element.nodeName === 'HTML') {
      return element;
    }
    return element.parentNode || element.host;
  }
  
  /**
   * Returns the scrolling parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} scroll parent
   */
  function getScrollParent(element) {
    // Return body, `getScroll` will take care to get the correct `scrollTop` from it
    if (!element) {
      return document.body;
    }
  
    switch (element.nodeName) {
      case 'HTML':
      case 'BODY':
        return element.ownerDocument.body;
      case '#document':
        return element.body;
    }
  
    // Firefox want us to check `-x` and `-y` variations as well
  
    var _getStyleComputedProp = getStyleComputedProperty(element),
        overflow = _getStyleComputedProp.overflow,
        overflowX = _getStyleComputedProp.overflowX,
        overflowY = _getStyleComputedProp.overflowY;
  
    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return element;
    }
  
    return getScrollParent(getParentNode(element));
  }
  
  var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
  var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
  
  /**
   * Determines if the browser is Internet Explorer
   * @method
   * @memberof Popper.Utils
   * @param {Number} version to check
   * @returns {Boolean} isIE
   */
  function isIE(version) {
    if (version === 11) {
      return isIE11;
    }
    if (version === 10) {
      return isIE10;
    }
    return isIE11 || isIE10;
  }
  
  /**
   * Returns the offset parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} offset parent
   */
  function getOffsetParent(element) {
    if (!element) {
      return document.documentElement;
    }
  
    var noOffsetParent = isIE(10) ? document.body : null;
  
    // NOTE: 1 DOM access here
    var offsetParent = element.offsetParent || null;
    // Skip hidden elements which don't have an offsetParent
    while (offsetParent === noOffsetParent && element.nextElementSibling) {
      offsetParent = (element = element.nextElementSibling).offsetParent;
    }
  
    var nodeName = offsetParent && offsetParent.nodeName;
  
    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
      return element ? element.ownerDocument.documentElement : document.documentElement;
    }
  
    // .offsetParent will return the closest TH, TD or TABLE in case
    // no offsetParent is present, I hate this job...
    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
      return getOffsetParent(offsetParent);
    }
  
    return offsetParent;
  }
  
  function isOffsetContainer(element) {
    var nodeName = element.nodeName;
  
    if (nodeName === 'BODY') {
      return false;
    }
    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
  }
  
  /**
   * Finds the root node (document, shadowDOM root) of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} node
   * @returns {Element} root node
   */
  function getRoot(node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode);
    }
  
    return node;
  }
  
  /**
   * Finds the offset parent common to the two provided nodes
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element1
   * @argument {Element} element2
   * @returns {Element} common offset parent
   */
  function findCommonOffsetParent(element1, element2) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return document.documentElement;
    }
  
    // Here we make sure to give as "start" the element that comes first in the DOM
    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1;
  
    // Get common ancestor container
    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer;
  
    // Both nodes are inside #document
  
    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer;
      }
  
      return getOffsetParent(commonAncestorContainer);
    }
  
    // one of the nodes is inside shadowDOM, find which one
    var element1root = getRoot(element1);
    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2);
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host);
    }
  }
  
  /**
   * Gets the scroll value of the given element in the given side (top and left)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {String} side `top` or `left`
   * @returns {number} amount of scrolled pixels
   */
  function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
  
    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
    var nodeName = element.nodeName;
  
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      var html = element.ownerDocument.documentElement;
      var scrollingElement = element.ownerDocument.scrollingElement || html;
      return scrollingElement[upperSide];
    }
  
    return element[upperSide];
  }
  
  /*
   * Sum or subtract the element scroll values (left and top) from a given rect object
   * @method
   * @memberof Popper.Utils
   * @param {Object} rect - Rect object you want to change
   * @param {HTMLElement} element - The element from the function reads the scroll values
   * @param {Boolean} subtract - set to true if you want to subtract the scroll values
   * @return {Object} rect - The modifier rect object
   */
  function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  
    var scrollTop = getScroll(element, 'top');
    var scrollLeft = getScroll(element, 'left');
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }
  
  /*
   * Helper to detect borders of a given element
   * @method
   * @memberof Popper.Utils
   * @param {CSSStyleDeclaration} styles
   * Result of `getStyleComputedProperty` on the given element
   * @param {String} axis - `x` or `y`
   * @return {number} borders - The borders size of the given axis
   */
  
  function getBordersSize(styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top';
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
  
    return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
  }
  
  function getSize(axis, body, html, computedStyle) {
    return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
  }
  
  function getWindowSizes(document) {
    var body = document.body;
    var html = document.documentElement;
    var computedStyle = isIE(10) && getComputedStyle(html);
  
    return {
      height: getSize('Height', body, html, computedStyle),
      width: getSize('Width', body, html, computedStyle)
    };
  }
  
  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  
  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
  
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  
  
  
  
  
  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
  
    return obj;
  };
  
  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
  
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
  
    return target;
  };
  
  /**
   * Given element offsets, generate an output similar to getBoundingClientRect
   * @method
   * @memberof Popper.Utils
   * @argument {Object} offsets
   * @returns {Object} ClientRect like output
   */
  function getClientRect(offsets) {
    return _extends({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    });
  }
  
  /**
   * Get bounding client rect of given element
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} element
   * @return {Object} client rect
   */
  function getBoundingClientRect(element) {
    var rect = {};
  
    // IE10 10 FIX: Please, don't ask, the element isn't
    // considered in DOM in some circumstances...
    // This isn't reproducible in IE10 compatibility mode of IE11
    try {
      if (isIE(10)) {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll(element, 'top');
        var scrollLeft = getScroll(element, 'left');
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } else {
        rect = element.getBoundingClientRect();
      }
    } catch (e) {}
  
    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };
  
    // subtract scrollbar size from sizes
    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
    var width = sizes.width || element.clientWidth || result.right - result.left;
    var height = sizes.height || element.clientHeight || result.bottom - result.top;
  
    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height;
  
    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
    // we make this check conditional for performance reasons
    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element);
      horizScrollbar -= getBordersSize(styles, 'x');
      vertScrollbar -= getBordersSize(styles, 'y');
  
      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }
  
    return getClientRect(result);
  }
  
  function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  
    var isIE10 = isIE(10);
    var isHTML = parent.nodeName === 'HTML';
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent(children);
  
    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
    var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);
  
    // In cases where the parent is fixed, we must ignore negative scroll in offset calc
    if (fixedPosition && isHTML) {
      parentRect.top = Math.max(parentRect.top, 0);
      parentRect.left = Math.max(parentRect.left, 0);
    }
    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0;
  
    // Subtract margins of documentElement in case it's being used as parent
    // we do this only on HTML because it's the only element that behaves
    // differently when margins are applied to it. The margins are included in
    // the box of the documentElement, in the other cases not.
    if (!isIE10 && isHTML) {
      var marginTop = parseFloat(styles.marginTop, 10);
      var marginLeft = parseFloat(styles.marginLeft, 10);
  
      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft;
  
      // Attach marginTop and marginLeft because in some circumstances we may need them
      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }
  
    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
      offsets = includeScroll(offsets, parent);
    }
  
    return offsets;
  }
  
  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  
    var html = element.ownerDocument.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);
  
    var scrollTop = !excludeScroll ? getScroll(html) : 0;
    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
  
    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height
    };
  
    return getClientRect(offset);
  }
  
  /**
   * Check if the given element is fixed or is inside a fixed parent
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {Element} customContainer
   * @returns {Boolean} answer to "isFixed?"
   */
  function isFixed(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      return false;
    }
    if (getStyleComputedProperty(element, 'position') === 'fixed') {
      return true;
    }
    return isFixed(getParentNode(element));
  }
  
  /**
   * Finds the first parent of an element that has a transformed property defined
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} first transformed parent or documentElement
   */
  
  function getFixedPositionOffsetParent(element) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element || !element.parentElement || isIE()) {
      return document.documentElement;
    }
    var el = element.parentElement;
    while (el && getStyleComputedProperty(el, 'transform') === 'none') {
      el = el.parentElement;
    }
    return el || document.documentElement;
  }
  
  /**
   * Computed the boundaries limits and return them
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} popper
   * @param {HTMLElement} reference
   * @param {number} padding
   * @param {HTMLElement} boundariesElement - Element used to define the boundaries
   * @param {Boolean} fixedPosition - Is in fixed position mode
   * @returns {Object} Coordinates of the boundaries
   */
  function getBoundaries(popper, reference, padding, boundariesElement) {
    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  
    // NOTE: 1 DOM access here
  
    var boundaries = { top: 0, left: 0 };
    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
  
    // Handle viewport case
    if (boundariesElement === 'viewport') {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
    } else {
      // Handle other cases based on DOM element used as boundaries
      var boundariesNode = void 0;
      if (boundariesElement === 'scrollParent') {
        boundariesNode = getScrollParent(getParentNode(reference));
        if (boundariesNode.nodeName === 'BODY') {
          boundariesNode = popper.ownerDocument.documentElement;
        }
      } else if (boundariesElement === 'window') {
        boundariesNode = popper.ownerDocument.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }
  
      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
  
      // In case of HTML, we need a different computation
      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(popper.ownerDocument),
            height = _getWindowSizes.height,
            width = _getWindowSizes.width;
  
        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        // for all the other DOM elements, this one is good
        boundaries = offsets;
      }
    }
  
    // Add paddings
    padding = padding || 0;
    var isPaddingNumber = typeof padding === 'number';
    boundaries.left += isPaddingNumber ? padding : padding.left || 0;
    boundaries.top += isPaddingNumber ? padding : padding.top || 0;
    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
  
    return boundaries;
  }
  
  function getArea(_ref) {
    var width = _ref.width,
        height = _ref.height;
  
    return width * height;
  }
  
  /**
   * Utility used to transform the `auto` placement to the placement with more
   * available space.
   * @method
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
  
    if (placement.indexOf('auto') === -1) {
      return placement;
    }
  
    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
  
    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    };
  
    var sortedAreas = Object.keys(rects).map(function (key) {
      return _extends({
        key: key
      }, rects[key], {
        area: getArea(rects[key])
      });
    }).sort(function (a, b) {
      return b.area - a.area;
    });
  
    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });
  
    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
  
    var variation = placement.split('-')[1];
  
    return computedPlacement + (variation ? '-' + variation : '');
  }
  
  /**
   * Get offsets to the reference element
   * @method
   * @memberof Popper.Utils
   * @param {Object} state
   * @param {Element} popper - the popper element
   * @param {Element} reference - the reference element (the popper will be relative to this)
   * @param {Element} fixedPosition - is in fixed position mode
   * @returns {Object} An object containing the offsets which will be applied to the popper
   */
  function getReferenceOffsets(state, popper, reference) {
    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  
    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
  }
  
  /**
   * Get the outer sizes of the given element (offset size + margins)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Object} object containing width and height properties
   */
  function getOuterSizes(element) {
    var window = element.ownerDocument.defaultView;
    var styles = window.getComputedStyle(element);
    var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
    var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };
    return result;
  }
  
  /**
   * Get the opposite placement of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement
   * @returns {String} flipped placement
   */
  function getOppositePlacement(placement) {
    var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }
  
  /**
   * Get offsets to the popper
   * @method
   * @memberof Popper.Utils
   * @param {Object} position - CSS position the Popper will get applied
   * @param {HTMLElement} popper - the popper element
   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
   * @param {String} placement - one of the valid placement options
   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
   */
  function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split('-')[0];
  
    // Get popper node sizes
    var popperRect = getOuterSizes(popper);
  
    // Add position, width and height to our offsets object
    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    };
  
    // depending by the popper placement we have to compute its offsets slightly differently
    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
    var mainSide = isHoriz ? 'top' : 'left';
    var secondarySide = isHoriz ? 'left' : 'top';
    var measurement = isHoriz ? 'height' : 'width';
    var secondaryMeasurement = !isHoriz ? 'height' : 'width';
  
    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
    }
  
    return popperOffsets;
  }
  
  /**
   * Mimics the `find` method of Array
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */
  function find(arr, check) {
    // use native find if supported
    if (Array.prototype.find) {
      return arr.find(check);
    }
  
    // use `filter` to obtain the same behavior of `find`
    return arr.filter(check)[0];
  }
  
  /**
   * Return the index of the matching object
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */
  function findIndex(arr, prop, value) {
    // use native findIndex if supported
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value;
      });
    }
  
    // use `find` + `indexOf` if `findIndex` isn't supported
    var match = find(arr, function (obj) {
      return obj[prop] === value;
    });
    return arr.indexOf(match);
  }
  
  /**
   * Loop trough the list of modifiers and run them in order,
   * each of them will then edit the data object.
   * @method
   * @memberof Popper.Utils
   * @param {dataObject} data
   * @param {Array} modifiers
   * @param {String} ends - Optional modifier name used as stopper
   * @returns {dataObject}
   */
  function runModifiers(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
  
    modifiersToRun.forEach(function (modifier) {
      if (modifier['function']) {
        // eslint-disable-line dot-notation
        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
      }
      var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
      if (modifier.enabled && isFunction(fn)) {
        // Add properties to offsets to make them a complete clientRect object
        // we do this before each modifier to make sure the previous one doesn't
        // mess with these values
        data.offsets.popper = getClientRect(data.offsets.popper);
        data.offsets.reference = getClientRect(data.offsets.reference);
  
        data = fn(data, modifier);
      }
    });
  
    return data;
  }
  
  /**
   * Updates the position of the popper, computing the new offsets and applying
   * the new style.<br />
   * Prefer `scheduleUpdate` over `update` because of performance reasons.
   * @method
   * @memberof Popper
   */
  function update() {
    // if popper is destroyed, don't perform any further update
    if (this.state.isDestroyed) {
      return;
    }
  
    var data = {
      instance: this,
      styles: {},
      arrowStyles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    };
  
    // compute reference element offsets
    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
  
    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
  
    // store the computed placement inside `originalPlacement`
    data.originalPlacement = data.placement;
  
    data.positionFixed = this.options.positionFixed;
  
    // compute the popper offsets
    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  
    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';
  
    // run the modifiers
    data = runModifiers(this.modifiers, data);
  
    // the first `update` will call `onCreate` callback
    // the other ones will call `onUpdate` callback
    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }
  
  /**
   * Helper used to know if the given modifier is enabled.
   * @method
   * @memberof Popper.Utils
   * @returns {Boolean}
   */
  function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function (_ref) {
      var name = _ref.name,
          enabled = _ref.enabled;
      return enabled && name === modifierName;
    });
  }
  
  /**
   * Get the prefixed supported property name
   * @method
   * @memberof Popper.Utils
   * @argument {String} property (camelCase)
   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
   */
  function getSupportedPropertyName(property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
  
    for (var i = 0; i < prefixes.length; i++) {
      var prefix = prefixes[i];
      var toCheck = prefix ? '' + prefix + upperProp : property;
      if (typeof document.body.style[toCheck] !== 'undefined') {
        return toCheck;
      }
    }
    return null;
  }
  
  /**
   * Destroys the popper.
   * @method
   * @memberof Popper
   */
  function destroy() {
    this.state.isDestroyed = true;
  
    // touch DOM only if `applyStyle` modifier is enabled
    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
      this.popper.removeAttribute('x-placement');
      this.popper.style.position = '';
      this.popper.style.top = '';
      this.popper.style.left = '';
      this.popper.style.right = '';
      this.popper.style.bottom = '';
      this.popper.style.willChange = '';
      this.popper.style[getSupportedPropertyName('transform')] = '';
    }
  
    this.disableEventListeners();
  
    // remove the popper if user explicity asked for the deletion on destroy
    // do not use `remove` because IE11 doesn't support it
    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }
    return this;
  }
  
  /**
   * Get the window associated with the element
   * @argument {Element} element
   * @returns {Window}
   */
  function getWindow(element) {
    var ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }
  
  function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY';
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
    target.addEventListener(event, callback, { passive: true });
  
    if (!isBody) {
      attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
    }
    scrollParents.push(target);
  }
  
  /**
   * Setup needed event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */
  function setupEventListeners(reference, options, state, updateBound) {
    // Resize event listener on window
    state.updateBound = updateBound;
    getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });
  
    // Scroll event listener on scroll parents
    var scrollElement = getScrollParent(reference);
    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;
  
    return state;
  }
  
  /**
   * It will add resize/scroll events and start recalculating
   * position of the popper element when they are triggered.
   * @method
   * @memberof Popper
   */
  function enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
  }
  
  /**
   * Remove event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */
  function removeEventListeners(reference, state) {
    // Remove resize event listener on window
    getWindow(reference).removeEventListener('resize', state.updateBound);
  
    // Remove scroll event listener on scroll parents
    state.scrollParents.forEach(function (target) {
      target.removeEventListener('scroll', state.updateBound);
    });
  
    // Reset state
    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }
  
  /**
   * It will remove resize/scroll events and won't recalculate popper position
   * when they are triggered. It also won't trigger `onUpdate` callback anymore,
   * unless you call `update` method manually.
   * @method
   * @memberof Popper
   */
  function disableEventListeners() {
    if (this.state.eventsEnabled) {
      cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners(this.reference, this.state);
    }
  }
  
  /**
   * Tells if a given input is a number
   * @method
   * @memberof Popper.Utils
   * @param {*} input to check
   * @return {Boolean}
   */
  function isNumeric(n) {
    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
  }
  
  /**
   * Set the style to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the style to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */
  function setStyles(element, styles) {
    Object.keys(styles).forEach(function (prop) {
      var unit = '';
      // add unit if the value is numeric and is one of the following
      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
        unit = 'px';
      }
      element.style[prop] = styles[prop] + unit;
    });
  }
  
  /**
   * Set the attributes to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the attributes to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */
  function setAttributes(element, attributes) {
    Object.keys(attributes).forEach(function (prop) {
      var value = attributes[prop];
      if (value !== false) {
        element.setAttribute(prop, attributes[prop]);
      } else {
        element.removeAttribute(prop);
      }
    });
  }
  
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} data.styles - List of style properties - values to apply to popper element
   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The same data object
   */
  function applyStyle(data) {
    // any property present in `data.styles` will be applied to the popper,
    // in this way we can make the 3rd party modifiers add custom styles to it
    // Be aware, modifiers could override the properties defined in the previous
    // lines of this modifier!
    setStyles(data.instance.popper, data.styles);
  
    // any property present in `data.attributes` will be applied to the popper,
    // they will be set as HTML attributes of the element
    setAttributes(data.instance.popper, data.attributes);
  
    // if arrowElement is defined and arrowStyles has some properties
    if (data.arrowElement && Object.keys(data.arrowStyles).length) {
      setStyles(data.arrowElement, data.arrowStyles);
    }
  
    return data;
  }
  
  /**
   * Set the x-placement attribute before everything else because it could be used
   * to add margins to the popper margins needs to be calculated to get the
   * correct popper offsets.
   * @method
   * @memberof Popper.modifiers
   * @param {HTMLElement} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper
   * @param {Object} options - Popper.js options
   */
  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    // compute reference element offsets
    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
  
    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
  
    popper.setAttribute('x-placement', placement);
  
    // Apply `position` to popper before anything else because
    // without the position applied we can't guarantee correct computations
    setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });
  
    return options;
  }
  
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function computeStyle(data, options) {
    var x = options.x,
        y = options.y;
    var popper = data.offsets.popper;
  
    // Remove this legacy support in Popper.js v2
  
    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'applyStyle';
    }).gpuAcceleration;
    if (legacyGpuAccelerationOption !== undefined) {
      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
    }
    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
  
    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent);
  
    // Styles
    var styles = {
      position: popper.position
    };
  
    // Avoid blurry text by using full pixel integers.
    // For pixel-perfect positioning, top/bottom prefers rounded
    // values, while left/right prefers floored values.
    var offsets = {
      left: Math.floor(popper.left),
      top: Math.round(popper.top),
      bottom: Math.round(popper.bottom),
      right: Math.floor(popper.right)
    };
  
    var sideA = x === 'bottom' ? 'top' : 'bottom';
    var sideB = y === 'right' ? 'left' : 'right';
  
    // if gpuAcceleration is set to `true` and transform is supported,
    //  we use `translate3d` to apply the position to the popper we
    // automatically use the supported prefixed version if needed
    var prefixedProperty = getSupportedPropertyName('transform');
  
    // now, let's make a step back and look at this code closely (wtf?)
    // If the content of the popper grows once it's been positioned, it
    // may happen that the popper gets misplaced because of the new content
    // overflowing its reference element
    // To avoid this problem, we provide two options (x and y), which allow
    // the consumer to define the offset origin.
    // If we position a popper on top of a reference element, we can set
    // `x` to `top` to make the popper grow towards its top instead of
    // its bottom.
    var left = void 0,
        top = void 0;
    if (sideA === 'bottom') {
      // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
      // and not the bottom of the html element
      if (offsetParent.nodeName === 'HTML') {
        top = -offsetParent.clientHeight + offsets.bottom;
      } else {
        top = -offsetParentRect.height + offsets.bottom;
      }
    } else {
      top = offsets.top;
    }
    if (sideB === 'right') {
      if (offsetParent.nodeName === 'HTML') {
        left = -offsetParent.clientWidth + offsets.right;
      } else {
        left = -offsetParentRect.width + offsets.right;
      }
    } else {
      left = offsets.left;
    }
    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = 'transform';
    } else {
      // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
      var invertTop = sideA === 'bottom' ? -1 : 1;
      var invertLeft = sideB === 'right' ? -1 : 1;
      styles[sideA] = top * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = sideA + ', ' + sideB;
    }
  
    // Attributes
    var attributes = {
      'x-placement': data.placement
    };
  
    // Update `data` attributes, styles and arrowStyles
    data.attributes = _extends({}, attributes, data.attributes);
    data.styles = _extends({}, styles, data.styles);
    data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
  
    return data;
  }
  
  /**
   * Helper used to know if the given modifier depends from another one.<br />
   * It checks if the needed modifier is listed and enabled.
   * @method
   * @memberof Popper.Utils
   * @param {Array} modifiers - list of modifiers
   * @param {String} requestingName - name of requesting modifier
   * @param {String} requestedName - name of requested modifier
   * @returns {Boolean}
   */
  function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function (_ref) {
      var name = _ref.name;
      return name === requestingName;
    });
  
    var isRequired = !!requesting && modifiers.some(function (modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });
  
    if (!isRequired) {
      var _requesting = '`' + requestingName + '`';
      var requested = '`' + requestedName + '`';
      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
    }
    return isRequired;
  }
  
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function arrow(data, options) {
    var _data$offsets$arrow;
  
    // arrow depends on keepTogether in order to work
    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
      return data;
    }
  
    var arrowElement = options.element;
  
    // if arrowElement is a string, suppose it's a CSS selector
    if (typeof arrowElement === 'string') {
      arrowElement = data.instance.popper.querySelector(arrowElement);
  
      // if arrowElement is not found, don't run the modifier
      if (!arrowElement) {
        return data;
      }
    } else {
      // if the arrowElement isn't a query selector we must check that the
      // provided DOM node is child of its popper node
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn('WARNING: `arrow.element` must be child of its popper element!');
        return data;
      }
    }
  
    var placement = data.placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
  
    var isVertical = ['left', 'right'].indexOf(placement) !== -1;
  
    var len = isVertical ? 'height' : 'width';
    var sideCapitalized = isVertical ? 'Top' : 'Left';
    var side = sideCapitalized.toLowerCase();
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowElementSize = getOuterSizes(arrowElement)[len];
  
    //
    // extends keepTogether behavior making sure the popper and its
    // reference have enough pixels in conjunction
    //
  
    // top/left side
    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    }
    // bottom/right side
    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }
    data.offsets.popper = getClientRect(data.offsets.popper);
  
    // compute center of the popper
    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
  
    // Compute the sideValue using the updated popper offsets
    // take popper margin in account because we don't have this info available
    var css = getStyleComputedProperty(data.instance.popper);
    var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
    var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
  
    // prevent arrowElement from being placed not contiguously to its popper
    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
  
    data.arrowElement = arrowElement;
    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
  
    return data;
  }
  
  /**
   * Get the opposite placement variation of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement variation
   * @returns {String} flipped placement variation
   */
  function getOppositeVariation(variation) {
    if (variation === 'end') {
      return 'start';
    } else if (variation === 'start') {
      return 'end';
    }
    return variation;
  }
  
  /**
   * List of accepted placements to use as values of the `placement` option.<br />
   * Valid placements are:
   * - `auto`
   * - `top`
   * - `right`
   * - `bottom`
   * - `left`
   *
   * Each placement can have a variation from this list:
   * - `-start`
   * - `-end`
   *
   * Variations are interpreted easily if you think of them as the left to right
   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
   * is right.<br />
   * Vertically (`left` and `right`), `start` is top and `end` is bottom.
   *
   * Some valid examples are:
   * - `top-end` (on top of reference, right aligned)
   * - `right-start` (on right of reference, top aligned)
   * - `bottom` (on bottom, centered)
   * - `auto-end` (on the side with more space available, alignment depends by placement)
   *
   * @static
   * @type {Array}
   * @enum {String}
   * @readonly
   * @method placements
   * @memberof Popper
   */
  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];
  
  // Get rid of `auto` `auto-start` and `auto-end`
  var validPlacements = placements.slice(3);
  
  /**
   * Given an initial placement, returns all the subsequent placements
   * clockwise (or counter-clockwise).
   *
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement - A valid placement (it accepts variations)
   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
   * @returns {Array} placements including their variations
   */
  function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  
    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
  }
  
  var BEHAVIORS = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
  };
  
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function flip(data, options) {
    // if `inner` modifier is enabled, we can't use the `flip` modifier
    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
      return data;
    }
  
    if (data.flipped && data.placement === data.originalPlacement) {
      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
      return data;
    }
  
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
  
    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';
  
    var flipOrder = [];
  
    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite];
        break;
      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement);
        break;
      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true);
        break;
      default:
        flipOrder = options.behavior;
    }
  
    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }
  
      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);
  
      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference;
  
      // using floor because the reference offsets may contain decimals we are not going to consider here
      var floor = Math.floor;
      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
  
      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
  
      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;
  
      // flip the variation if required
      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
      var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);
  
      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        // this boolean to detect any flip loop
        data.flipped = true;
  
        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }
  
        if (flippedVariation) {
          variation = getOppositeVariation(variation);
        }
  
        data.placement = placement + (variation ? '-' + variation : '');
  
        // this object contains `position`, we want to preserve it along with
        // any additional property we may add in the future
        data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
  
        data = runModifiers(data.instance.modifiers, data, 'flip');
      }
    });
    return data;
  }
  
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function keepTogether(data) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
  
    var placement = data.placement.split('-')[0];
    var floor = Math.floor;
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var side = isVertical ? 'right' : 'bottom';
    var opSide = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';
  
    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }
    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }
  
    return data;
  }
  
  /**
   * Converts a string containing value + unit into a px value number
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} str - Value + unit string
   * @argument {String} measurement - `height` or `width`
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @returns {Number|String}
   * Value in pixels, or original string if no values were extracted
   */
  function toValue(str, measurement, popperOffsets, referenceOffsets) {
    // separate value from unit
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2];
  
    // If it's not a number it's an operator, I guess
    if (!value) {
      return str;
    }
  
    if (unit.indexOf('%') === 0) {
      var element = void 0;
      switch (unit) {
        case '%p':
          element = popperOffsets;
          break;
        case '%':
        case '%r':
        default:
          element = referenceOffsets;
      }
  
      var rect = getClientRect(element);
      return rect[measurement] / 100 * value;
    } else if (unit === 'vh' || unit === 'vw') {
      // if is a vh or vw, we calculate the size based on the viewport
      var size = void 0;
      if (unit === 'vh') {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      }
      return size / 100 * value;
    } else {
      // if is an explicit pixel unit, we get rid of the unit and keep the value
      // if is an implicit unit, it's px, and we return just the value
      return value;
    }
  }
  
  /**
   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} offset
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @argument {String} basePlacement
   * @returns {Array} a two cells array with x and y offsets in numbers
   */
  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0];
  
    // Use height if placement is left or right and index is 0 otherwise use width
    // in this way the first offset will use an axis and the second one
    // will use the other one
    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;
  
    // Split the offset string to obtain a list of values and operands
    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim();
    });
  
    // Detect if the offset string contains a pair of values or a single one
    // they could be separated by comma or space
    var divider = fragments.indexOf(find(fragments, function (frag) {
      return frag.search(/,|\s/) !== -1;
    }));
  
    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    }
  
    // If divider is found, we divide the list of values and operands to divide
    // them by ofset X and Y.
    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
  
    // Convert the values with units to absolute pixels to allow our computations
    ops = ops.map(function (op, index) {
      // Most of the units rely on the orientation of the popper
      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
      var mergeWithPrevious = false;
      return op
      // This aggregates any `+` or `-` sign that aren't considered operators
      // e.g.: 10 + +5 => [10, +, +5]
      .reduce(function (a, b) {
        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
          a[a.length - 1] = b;
          mergeWithPrevious = true;
          return a;
        } else if (mergeWithPrevious) {
          a[a.length - 1] += b;
          mergeWithPrevious = false;
          return a;
        } else {
          return a.concat(b);
        }
      }, [])
      // Here we convert the string values into number values (in px)
      .map(function (str) {
        return toValue(str, measurement, popperOffsets, referenceOffsets);
      });
    });
  
    // Loop trough the offsets arrays and execute the operations
    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
        }
      });
    });
    return offsets;
  }
  
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @argument {Number|String} options.offset=0
   * The offset value as described in the modifier description
   * @returns {Object} The data object, properly modified
   */
  function offset(data, _ref) {
    var offset = _ref.offset;
    var placement = data.placement,
        _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
  
    var basePlacement = placement.split('-')[0];
  
    var offsets = void 0;
    if (isNumeric(+offset)) {
      offsets = [+offset, 0];
    } else {
      offsets = parseOffset(offset, popper, reference, basePlacement);
    }
  
    if (basePlacement === 'left') {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === 'right') {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === 'top') {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === 'bottom') {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }
  
    data.popper = popper;
    return data;
  }
  
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function preventOverflow(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
  
    // If offsetParent is the reference element, we really want to
    // go one step up and use the next offsetParent as reference to
    // avoid to make this modifier completely useless and look like broken
    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent(boundariesElement);
    }
  
    // NOTE: DOM access here
    // resets the popper's position so that the document size can be calculated excluding
    // the size of the popper element itself
    var transformProp = getSupportedPropertyName('transform');
    var popperStyles = data.instance.popper.style; // assignment to help minification
    var top = popperStyles.top,
        left = popperStyles.left,
        transform = popperStyles[transformProp];
  
    popperStyles.top = '';
    popperStyles.left = '';
    popperStyles[transformProp] = '';
  
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
  
    // NOTE: DOM access here
    // restores the original style properties after the offsets have been computed
    popperStyles.top = top;
    popperStyles.left = left;
    popperStyles[transformProp] = transform;
  
    options.boundaries = boundaries;
  
    var order = options.priority;
    var popper = data.offsets.popper;
  
    var check = {
      primary: function primary(placement) {
        var value = popper[placement];
        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement]);
        }
        return defineProperty({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === 'right' ? 'left' : 'top';
        var value = popper[mainSide];
        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
        }
        return defineProperty({}, mainSide, value);
      }
    };
  
    order.forEach(function (placement) {
      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
      popper = _extends({}, popper, check[side](placement));
    });
  
    data.offsets.popper = popper;
  
    return data;
  }
  
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftvariation = placement.split('-')[1];
  
    // if shift shiftvariation is specified, run the modifier
    if (shiftvariation) {
      var _data$offsets = data.offsets,
          reference = _data$offsets.reference,
          popper = _data$offsets.popper;
  
      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
      var side = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';
  
      var shiftOffsets = {
        start: defineProperty({}, side, reference[side]),
        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
      };
  
      data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
    }
  
    return data;
  }
  
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function hide(data) {
    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
      return data;
    }
  
    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'preventOverflow';
    }).boundaries;
  
    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === true) {
        return data;
      }
  
      data.hide = true;
      data.attributes['x-out-of-boundaries'] = '';
    } else {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === false) {
        return data;
      }
  
      data.hide = false;
      data.attributes['x-out-of-boundaries'] = false;
    }
  
    return data;
  }
  
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
  
    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
  
    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
  
    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
  
    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);
  
    return data;
  }
  
  /**
   * Modifier function, each modifier can have a function of this type assigned
   * to its `fn` property.<br />
   * These functions will be called on each update, this means that you must
   * make sure they are performant enough to avoid performance bottlenecks.
   *
   * @function ModifierFn
   * @argument {dataObject} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {dataObject} The data object, properly modified
   */
  
  /**
   * Modifiers are plugins used to alter the behavior of your poppers.<br />
   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
   * needed by the library.
   *
   * Usually you don't want to override the `order`, `fn` and `onLoad` props.
   * All the other properties are configurations that could be tweaked.
   * @namespace modifiers
   */
  var modifiers = {
    /**
     * Modifier used to shift the popper on the start or end of its reference
     * element.<br />
     * It will read the variation of the `placement` property.<br />
     * It can be one either `-end` or `-start`.
     * @memberof modifiers
     * @inner
     */
    shift: {
      /** @prop {number} order=100 - Index used to define the order of execution */
      order: 100,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: shift
    },
  
    /**
     * The `offset` modifier can shift your popper on both its axis.
     *
     * It accepts the following units:
     * - `px` or unit-less, interpreted as pixels
     * - `%` or `%r`, percentage relative to the length of the reference element
     * - `%p`, percentage relative to the length of the popper element
     * - `vw`, CSS viewport width unit
     * - `vh`, CSS viewport height unit
     *
     * For length is intended the main axis relative to the placement of the popper.<br />
     * This means that if the placement is `top` or `bottom`, the length will be the
     * `width`. In case of `left` or `right`, it will be the `height`.
     *
     * You can provide a single value (as `Number` or `String`), or a pair of values
     * as `String` divided by a comma or one (or more) white spaces.<br />
     * The latter is a deprecated method because it leads to confusion and will be
     * removed in v2.<br />
     * Additionally, it accepts additions and subtractions between different units.
     * Note that multiplications and divisions aren't supported.
     *
     * Valid examples are:
     * ```
     * 10
     * '10%'
     * '10, 10'
     * '10%, 10'
     * '10 + 10%'
     * '10 - 5vh + 3%'
     * '-10px + 5vh, 5px - 6%'
     * ```
     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
     *
     * @memberof modifiers
     * @inner
     */
    offset: {
      /** @prop {number} order=200 - Index used to define the order of execution */
      order: 200,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: offset,
      /** @prop {Number|String} offset=0
       * The offset value as described in the modifier description
       */
      offset: 0
    },
  
    /**
     * Modifier used to prevent the popper from being positioned outside the boundary.
     *
     * A scenario exists where the reference itself is not within the boundaries.<br />
     * We can say it has "escaped the boundaries" — or just "escaped".<br />
     * In this case we need to decide whether the popper should either:
     *
     * - detach from the reference and remain "trapped" in the boundaries, or
     * - if it should ignore the boundary and "escape with its reference"
     *
     * When `escapeWithReference` is set to`true` and reference is completely
     * outside its boundaries, the popper will overflow (or completely leave)
     * the boundaries in order to remain attached to the edge of the reference.
     *
     * @memberof modifiers
     * @inner
     */
    preventOverflow: {
      /** @prop {number} order=300 - Index used to define the order of execution */
      order: 300,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: preventOverflow,
      /**
       * @prop {Array} [priority=['left','right','top','bottom']]
       * Popper will try to prevent overflow following these priorities by default,
       * then, it could overflow on the left and on top of the `boundariesElement`
       */
      priority: ['left', 'right', 'top', 'bottom'],
      /**
       * @prop {number} padding=5
       * Amount of pixel used to define a minimum distance between the boundaries
       * and the popper. This makes sure the popper always has a little padding
       * between the edges of its container
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='scrollParent'
       * Boundaries used by the modifier. Can be `scrollParent`, `window`,
       * `viewport` or any DOM element.
       */
      boundariesElement: 'scrollParent'
    },
  
    /**
     * Modifier used to make sure the reference and its popper stay near each other
     * without leaving any gap between the two. Especially useful when the arrow is
     * enabled and you want to ensure that it points to its reference element.
     * It cares only about the first axis. You can still have poppers with margin
     * between the popper and its reference element.
     * @memberof modifiers
     * @inner
     */
    keepTogether: {
      /** @prop {number} order=400 - Index used to define the order of execution */
      order: 400,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: keepTogether
    },
  
    /**
     * This modifier is used to move the `arrowElement` of the popper to make
     * sure it is positioned between the reference element and its popper element.
     * It will read the outer size of the `arrowElement` node to detect how many
     * pixels of conjunction are needed.
     *
     * It has no effect if no `arrowElement` is provided.
     * @memberof modifiers
     * @inner
     */
    arrow: {
      /** @prop {number} order=500 - Index used to define the order of execution */
      order: 500,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: arrow,
      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
      element: '[x-arrow]'
    },
  
    /**
     * Modifier used to flip the popper's placement when it starts to overlap its
     * reference element.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     *
     * **NOTE:** this modifier will interrupt the current update cycle and will
     * restart it if it detects the need to flip the placement.
     * @memberof modifiers
     * @inner
     */
    flip: {
      /** @prop {number} order=600 - Index used to define the order of execution */
      order: 600,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: flip,
      /**
       * @prop {String|Array} behavior='flip'
       * The behavior used to change the popper's placement. It can be one of
       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
       * placements (with optional variations)
       */
      behavior: 'flip',
      /**
       * @prop {number} padding=5
       * The popper will flip if it hits the edges of the `boundariesElement`
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='viewport'
       * The element which will define the boundaries of the popper position.
       * The popper will never be placed outside of the defined boundaries
       * (except if `keepTogether` is enabled)
       */
      boundariesElement: 'viewport'
    },
  
    /**
     * Modifier used to make the popper flow toward the inner of the reference element.
     * By default, when this modifier is disabled, the popper will be placed outside
     * the reference element.
     * @memberof modifiers
     * @inner
     */
    inner: {
      /** @prop {number} order=700 - Index used to define the order of execution */
      order: 700,
      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
      enabled: false,
      /** @prop {ModifierFn} */
      fn: inner
    },
  
    /**
     * Modifier used to hide the popper when its reference element is outside of the
     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
     * be used to hide with a CSS selector the popper when its reference is
     * out of boundaries.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     * @memberof modifiers
     * @inner
     */
    hide: {
      /** @prop {number} order=800 - Index used to define the order of execution */
      order: 800,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: hide
    },
  
    /**
     * Computes the style that will be applied to the popper element to gets
     * properly positioned.
     *
     * Note that this modifier will not touch the DOM, it just prepares the styles
     * so that `applyStyle` modifier can apply it. This separation is useful
     * in case you need to replace `applyStyle` with a custom implementation.
     *
     * This modifier has `850` as `order` value to maintain backward compatibility
     * with previous versions of Popper.js. Expect the modifiers ordering method
     * to change in future major versions of the library.
     *
     * @memberof modifiers
     * @inner
     */
    computeStyle: {
      /** @prop {number} order=850 - Index used to define the order of execution */
      order: 850,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: computeStyle,
      /**
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: true,
      /**
       * @prop {string} [x='bottom']
       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
       * Change this if your popper should grow in a direction different from `bottom`
       */
      x: 'bottom',
      /**
       * @prop {string} [x='left']
       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
       * Change this if your popper should grow in a direction different from `right`
       */
      y: 'right'
    },
  
    /**
     * Applies the computed styles to the popper element.
     *
     * All the DOM manipulations are limited to this modifier. This is useful in case
     * you want to integrate Popper.js inside a framework or view library and you
     * want to delegate all the DOM manipulations to it.
     *
     * Note that if you disable this modifier, you must make sure the popper element
     * has its position set to `absolute` before Popper.js can do its work!
     *
     * Just disable this modifier and define your own to achieve the desired effect.
     *
     * @memberof modifiers
     * @inner
     */
    applyStyle: {
      /** @prop {number} order=900 - Index used to define the order of execution */
      order: 900,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: applyStyle,
      /** @prop {Function} */
      onLoad: applyStyleOnLoad,
      /**
       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: undefined
    }
  };
  
  /**
   * The `dataObject` is an object containing all the information used by Popper.js.
   * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
   * @name dataObject
   * @property {Object} data.instance The Popper.js instance
   * @property {String} data.placement Placement applied to popper
   * @property {String} data.originalPlacement Placement originally defined on init
   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
   * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.boundaries Offsets of the popper boundaries
   * @property {Object} data.offsets The measurements of popper, reference and arrow elements
   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
   */
  
  /**
   * Default options provided to Popper.js constructor.<br />
   * These can be overridden using the `options` argument of Popper.js.<br />
   * To override an option, simply pass an object with the same
   * structure of the `options` object, as the 3rd argument. For example:
   * ```
   * new Popper(ref, pop, {
   *   modifiers: {
   *     preventOverflow: { enabled: false }
   *   }
   * })
   * ```
   * @type {Object}
   * @static
   * @memberof Popper
   */
  var Defaults = {
    /**
     * Popper's placement.
     * @prop {Popper.placements} placement='bottom'
     */
    placement: 'bottom',
  
    /**
     * Set this to true if you want popper to position it self in 'fixed' mode
     * @prop {Boolean} positionFixed=false
     */
    positionFixed: false,
  
    /**
     * Whether events (resize, scroll) are initially enabled.
     * @prop {Boolean} eventsEnabled=true
     */
    eventsEnabled: true,
  
    /**
     * Set to true if you want to automatically remove the popper when
     * you call the `destroy` method.
     * @prop {Boolean} removeOnDestroy=false
     */
    removeOnDestroy: false,
  
    /**
     * Callback called when the popper is created.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onCreate}
     */
    onCreate: function onCreate() {},
  
    /**
     * Callback called when the popper is updated. This callback is not called
     * on the initialization/creation of the popper, but only on subsequent
     * updates.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onUpdate}
     */
    onUpdate: function onUpdate() {},
  
    /**
     * List of modifiers used to modify the offsets before they are applied to the popper.
     * They provide most of the functionalities of Popper.js.
     * @prop {modifiers}
     */
    modifiers: modifiers
  };
  
  /**
   * @callback onCreate
   * @param {dataObject} data
   */
  
  /**
   * @callback onUpdate
   * @param {dataObject} data
   */
  
  // Utils
  // Methods
  var Popper = function () {
    /**
     * Creates a new Popper.js instance.
     * @class Popper
     * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
     * @param {HTMLElement} popper - The HTML element used as the popper
     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
     * @return {Object} instance - The generated Popper.js instance
     */
    function Popper(reference, popper) {
      var _this = this;
  
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      classCallCheck(this, Popper);
  
      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update);
      };
  
      // make update() debounced, so that it only runs at most once-per-tick
      this.update = debounce(this.update.bind(this));
  
      // with {} we create a new object with the options inside it
      this.options = _extends({}, Popper.Defaults, options);
  
      // init state
      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      };
  
      // get reference and popper elements (allow jQuery wrappers)
      this.reference = reference && reference.jquery ? reference[0] : reference;
      this.popper = popper && popper.jquery ? popper[0] : popper;
  
      // Deep merge modifiers options
      this.options.modifiers = {};
      Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
        _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
      });
  
      // Refactoring modifiers' list (Object => Array)
      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
        return _extends({
          name: name
        }, _this.options.modifiers[name]);
      })
      // sort the modifiers by order
      .sort(function (a, b) {
        return a.order - b.order;
      });
  
      // modifiers have the ability to execute arbitrary code when Popper.js get inited
      // such code is executed in the same order of its modifier
      // they could add new properties to their options configuration
      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
        }
      });
  
      // fire the first update to position the popper in the right place
      this.update();
  
      var eventsEnabled = this.options.eventsEnabled;
      if (eventsEnabled) {
        // setup event listeners, they will take care of update the position in specific situations
        this.enableEventListeners();
      }
  
      this.state.eventsEnabled = eventsEnabled;
    }
  
    // We can't use class properties because they don't get listed in the
    // class prototype and break stuff like Sinon stubs
  
  
    createClass(Popper, [{
      key: 'update',
      value: function update$$1() {
        return update.call(this);
      }
    }, {
      key: 'destroy',
      value: function destroy$$1() {
        return destroy.call(this);
      }
    }, {
      key: 'enableEventListeners',
      value: function enableEventListeners$$1() {
        return enableEventListeners.call(this);
      }
    }, {
      key: 'disableEventListeners',
      value: function disableEventListeners$$1() {
        return disableEventListeners.call(this);
      }
  
      /**
       * Schedules an update. It will run on the next UI update available.
       * @method scheduleUpdate
       * @memberof Popper
       */
  
  
      /**
       * Collection of utilities useful when writing custom modifiers.
       * Starting from version 1.7, this method is available only if you
       * include `popper-utils.js` before `popper.js`.
       *
       * **DEPRECATION**: This way to access PopperUtils is deprecated
       * and will be removed in v2! Use the PopperUtils module directly instead.
       * Due to the high instability of the methods contained in Utils, we can't
       * guarantee them to follow semver. Use them at your own risk!
       * @static
       * @private
       * @type {Object}
       * @deprecated since version 1.8
       * @member Utils
       * @memberof Popper
       */
  
    }]);
    return Popper;
  }();
  
  /**
   * The `referenceObject` is an object that provides an interface compatible with Popper.js
   * and lets you use it as replacement of a real DOM node.<br />
   * You can use this method to position a popper relatively to a set of coordinates
   * in case you don't have a DOM node to use as reference.
   *
   * ```
   * new Popper(referenceObject, popperNode);
   * ```
   *
   * NB: This feature isn't supported in Internet Explorer 10.
   * @name referenceObject
   * @property {Function} data.getBoundingClientRect
   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
   * @property {number} data.clientWidth
   * An ES6 getter that will return the width of the virtual reference element.
   * @property {number} data.clientHeight
   * An ES6 getter that will return the height of the virtual reference element.
   */
  
  
  Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
  Popper.placements = placements;
  Popper.Defaults = Defaults;
  
  return Popper;
  
  })));
  (function webpackUniversalModuleDefinition(root, factory) {
      if(typeof exports === 'object' && typeof module === 'object')
          module.exports = factory(require("popper.js"));
      else if(typeof define === 'function' && define.amd)
          define(["popper.js"], factory);
      else if(typeof exports === 'object')
          exports["cytoscapePopper"] = factory(require("popper.js"));
      else
          root["cytoscapePopper"] = factory(root["Popper"]);
  })(this, function(__WEBPACK_EXTERNAL_MODULE_8__) {
  return /******/ (function(modules) { // webpackBootstrap
  /******/ 	// The module cache
  /******/ 	var installedModules = {};
  /******/
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/
  /******/ 		// Check if module is in cache
  /******/ 		if(installedModules[moduleId]) {
  /******/ 			return installedModules[moduleId].exports;
  /******/ 		}
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = installedModules[moduleId] = {
  /******/ 			i: moduleId,
  /******/ 			l: false,
  /******/ 			exports: {}
  /******/ 		};
  /******/
  /******/ 		// Execute the module function
  /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  /******/
  /******/ 		// Flag the module as loaded
  /******/ 		module.l = true;
  /******/
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/
  /******/
  /******/ 	// expose the modules object (__webpack_modules__)
  /******/ 	__webpack_require__.m = modules;
  /******/
  /******/ 	// expose the module cache
  /******/ 	__webpack_require__.c = installedModules;
  /******/
  /******/ 	// identity function for calling harmony imports with the correct context
  /******/ 	__webpack_require__.i = function(value) { return value; };
  /******/
  /******/ 	// define getter function for harmony exports
  /******/ 	__webpack_require__.d = function(exports, name, getter) {
  /******/ 		if(!__webpack_require__.o(exports, name)) {
  /******/ 			Object.defineProperty(exports, name, {
  /******/ 				configurable: false,
  /******/ 				enumerable: true,
  /******/ 				get: getter
  /******/ 			});
  /******/ 		}
  /******/ 	};
  /******/
  /******/ 	// getDefaultExport function for compatibility with non-harmony modules
  /******/ 	__webpack_require__.n = function(module) {
  /******/ 		var getter = module && module.__esModule ?
  /******/ 			function getDefault() { return module['default']; } :
  /******/ 			function getModuleExports() { return module; };
  /******/ 		__webpack_require__.d(getter, 'a', getter);
  /******/ 		return getter;
  /******/ 	};
  /******/
  /******/ 	// Object.prototype.hasOwnProperty.call
  /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  /******/
  /******/ 	// __webpack_public_path__
  /******/ 	__webpack_require__.p = "";
  /******/
  /******/ 	// Load entry module and return exports
  /******/ 	return __webpack_require__(__webpack_require__.s = 7);
  /******/ })
  /************************************************************************/
  /******/ ([
  /* 0 */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  // Simple, internal Object.assign() polyfill for options objects etc.
  
  module.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {
    for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      srcs[_key - 1] = arguments[_key];
    }
  
    srcs.forEach(function (src) {
      if (src !== null && src !== undefined) {
        Object.keys(src).forEach(function (k) {
          return tgt[k] = src[k];
        });
      }
    });
  
    return tgt;
  };
  
  /***/ }),
  /* 1 */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _require = __webpack_require__(5),
      getBoundingBox = _require.getBoundingBox;
  
  // Create a popper reference object
  // https://popper.js.org/popper-documentation.html#referenceObject
  
  
  function getRef(target, opts) {
    var renderedDimensions = opts.renderedDimensions;
  
    //Define popper reference object and cy reference  object
  
    var refObject = {
      getBoundingClientRect: function getBoundingClientRect() {
        return getBoundingBox(target, opts);
      },
  
      get clientWidth() {
        return renderedDimensions(target).w;
      },
  
      get clientHeight() {
        return renderedDimensions(target).h;
      }
    };
  
    return refObject;
  }
  
  module.exports = { getRef: getRef };
  
  /***/ }),
  /* 2 */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var assign = __webpack_require__(0);
  
  var _require = __webpack_require__(1),
      getRef = _require.getRef;
  
  var _require2 = __webpack_require__(6),
      getContent = _require2.getContent;
  
  var popperDefaults = {};
  
  //Fix Popper.js webpack import conflict (Use .default if using webpack)
  var Popper = __webpack_require__(8);
  var EsmWebpackPopper = Popper.default;
  if (EsmWebpackPopper != null && EsmWebpackPopper.Defaults != null) {
    Popper = Popper.default;
  }
  
  // Create a new popper object for a core or element target
  function getPopper(target, opts) {
    var refObject = getRef(target, opts);
    var content = getContent(target, opts.content);
    var popperOpts = assign({}, popperDefaults, opts.popper);
  
    return new Popper(refObject, content, popperOpts);
  }
  
  module.exports = { getPopper: getPopper };
  
  /***/ }),
  /* 3 */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var assign = __webpack_require__(0);
  
  var _require = __webpack_require__(2),
      getPopper = _require.getPopper;
  
  var _require2 = __webpack_require__(1),
      getRef = _require2.getRef;
  
  function popper(opts) {
    checkForWarning(this);
  
    return getPopper(this[0], createOptionsObject(this[0], opts));
  }
  
  function popperRef(opts) {
    checkForWarning(this);
  
    return getRef(this[0], createOptionsObject(this[0], opts));
  }
  
  function createOptionsObject(target, opts) {
    var renderedDimensions = function renderedDimensions(el) {
      return el.isNode() ? { w: el.renderedWidth(), h: el.renderedHeight() } : { w: 3, h: 3 };
    };
    var renderedPosition = function renderedPosition(el) {
      return el.isNode() ? getRenderedCenter(el, renderedDimensions) : getRenderedMidpoint(el);
    };
    var popper = {};
    var cy = target.cy();
  
    var defaults = { renderedDimensions: renderedDimensions, renderedPosition: renderedPosition, popper: popper, cy: cy };
  
    return assign({}, defaults, opts);
  }
  
  //Get the rendered center
  function getRenderedCenter(target, renderedDimensions) {
    var pos = target.renderedPosition();
    var dimensions = renderedDimensions(target);
    var offsetX = dimensions.w / 2;
    var offsetY = dimensions.h / 2;
  
    return {
      x: pos.x - offsetX,
      y: pos.y - offsetY
    };
  }
  
  //Get the rendered position of the midpoint
  function getRenderedMidpoint(target) {
    var p = target.midpoint();
    var pan = target.cy().pan();
    var zoom = target.cy().zoom();
  
    return {
      x: p.x * zoom + pan.x,
      y: p.y * zoom + pan.y
    };
  }
  
  //Warn user about misuse of the plugin
  function checkForWarning(elements) {
    /* eslint-disable no-console */
  
    //Popper.js Should only be used on 1 element
    if (elements.length > 1) {
      console.warn("Popper.js Extension should only be used on one element.");
      console.warn("Ignoring all subsequent elements");
    }
  
    /* eslint-enable */
  }
  
  module.exports = { popper: popper, popperRef: popperRef };
  
  /***/ }),
  /* 4 */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var assign = __webpack_require__(0);
  
  var _require = __webpack_require__(2),
      getPopper = _require.getPopper;
  
  var _require2 = __webpack_require__(1),
      getRef = _require2.getRef;
  
  function popper(opts) {
    return getPopper(this, createOptionsObject(this, opts));
  }
  
  function popperRef(opts) {
    return getRef(this, createOptionsObject(this, opts));
  }
  
  //Create a options object with required default values
  function createOptionsObject(target, opts) {
    var defaults = {
      boundingBox: {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        w: 3,
        h: 3
      },
      renderedDimensions: function renderedDimensions() {
        return { w: 3, h: 3 };
      },
      redneredPosition: function redneredPosition() {
        return { x: 0, y: 0 };
      },
      popper: {},
      cy: target
    };
  
    return assign({}, defaults, opts);
  }
  
  module.exports = { popper: popper, popperRef: popperRef };
  
  /***/ }),
  /* 5 */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  function getBoundingBox(target, opts) {
    var renderedPosition = opts.renderedPosition,
        cy = opts.cy,
        renderedDimensions = opts.renderedDimensions;
  
    var offset = cy.container().getBoundingClientRect();
    var dims = renderedDimensions(target);
    var pos = renderedPosition(target);
  
    return {
      top: pos.y + offset.top,
      left: pos.x + offset.left,
      right: pos.x + dims.w + offset.left,
      bottom: pos.y + dims.h + offset.top,
      width: dims.w,
      height: dims.h
    };
  }
  
  module.exports = { getBoundingBox: getBoundingBox };
  
  /***/ }),
  /* 6 */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  function getContent(target, content) {
    var contentObject = null;
  
    if (typeof content === "function") {
      //Execute function if user opted for a dyanamic target
      contentObject = content(target);
    } else if (content instanceof HTMLElement) {
      //Target option is an HTML element
      return content;
    } else {
      throw new Error("Can not create popper from 'target' with unknown type");
    }
  
    // Check validity of parsed target
    if (contentObject === null) {
      throw new Error("No 'target' specified to create popper");
    } else {
      return contentObject;
    }
  }
  
  module.exports = { getContent: getContent };
  
  /***/ }),
  /* 7 */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  /* global cytoscape */
  
  var coreImpl = __webpack_require__(4);
  var collectionImpl = __webpack_require__(3);
  
  // registers the extension on a cytoscape lib ref
  var register = function register(cytoscape) {
    if (!cytoscape) {
      return;
    } // can't register if cytoscape unspecified
  
    // register with cytoscape.js
    cytoscape('core', 'popper', coreImpl.popper); //Cytoscape Core
    cytoscape('collection', 'popper', collectionImpl.popper); //Cytoscape Collections
    cytoscape('core', 'popperRef', coreImpl.popperRef); //Cytoscape Core for References
    cytoscape('collection', 'popperRef', collectionImpl.popperRef); //Cytoscape Collections for References
  };
  
  if (typeof cytoscape !== 'undefined') {
    // expose to global cytoscape (i.e. window.cytoscape)
    register(cytoscape);
  }
  
  module.exports = register;
  
  /***/ }),
  /* 8 */
  /***/ (function(module, exports) {
  
  module.exports = __WEBPACK_EXTERNAL_MODULE_8__;
  
  /***/ })
  /******/ ]);
  });
  /* Javascript plotting library for jQuery, version 0.8.2.
  
  Copyright (c) 2007-2013 IOLA and Ole Laursen.
  Licensed under the MIT license.
  
  */
  
  // first an inline dependency, jquery.colorhelpers.js, we inline it here
  // for convenience
  
  /* Plugin for jQuery for working with colors.
   *
   * Version 1.1.
   *
   * Inspiration from jQuery color animation plugin by John Resig.
   *
   * Released under the MIT license by Ole Laursen, October 2009.
   *
   * Examples:
   *
   *   $.color.parse("#fff").scale('rgb', 0.25).add('a', -0.5).toString()
   *   var c = $.color.extract($("#mydiv"), 'background-color');
   *   console.log(c.r, c.g, c.b, c.a);
   *   $.color.make(100, 50, 25, 0.4).toString() // returns "rgba(100,50,25,0.4)"
   *
   * Note that .scale() and .add() return the same modified object
   * instead of making a new one.
   *
   * V. 1.1: Fix error handling so e.g. parsing an empty string does
   * produce a color rather than just crashing.
   */
  
  (function($){$.color={};$.color.make=function(r,g,b,a){var o={};o.r=r||0;o.g=g||0;o.b=b||0;o.a=a!=null?a:1;o.add=function(c,d){for(var i=0;i<c.length;++i)o[c.charAt(i)]+=d;return o.normalize()};o.scale=function(c,f){for(var i=0;i<c.length;++i)o[c.charAt(i)]*=f;return o.normalize()};o.toString=function(){if(o.a>=1){return"rgb("+[o.r,o.g,o.b].join(",")+")"}else{return"rgba("+[o.r,o.g,o.b,o.a].join(",")+")"}};o.normalize=function(){function clamp(min,value,max){return value<min?min:value>max?max:value}o.r=clamp(0,parseInt(o.r),255);o.g=clamp(0,parseInt(o.g),255);o.b=clamp(0,parseInt(o.b),255);o.a=clamp(0,o.a,1);return o};o.clone=function(){return $.color.make(o.r,o.b,o.g,o.a)};return o.normalize()};$.color.extract=function(elem,css){var c;do{c=elem.css(css).toLowerCase();if(c!=""&&c!="transparent")break;elem=elem.parent()}while(elem.length&&!$.nodeName(elem.get(0),"body"));if(c=="rgba(0, 0, 0, 0)")c="transparent";return $.color.parse(c)};$.color.parse=function(str){var res,m=$.color.make;if(res=/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10));if(res=/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10),parseFloat(res[4]));if(res=/rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55);if(res=/rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55,parseFloat(res[4]));if(res=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))return m(parseInt(res[1],16),parseInt(res[2],16),parseInt(res[3],16));if(res=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))return m(parseInt(res[1]+res[1],16),parseInt(res[2]+res[2],16),parseInt(res[3]+res[3],16));var name=$.trim(str).toLowerCase();if(name=="transparent")return m(255,255,255,0);else{res=lookupColors[name]||[0,0,0];return m(res[0],res[1],res[2])}};var lookupColors={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);
  
  // the actual Flot code
  (function($) {
  
      // Cache the prototype hasOwnProperty for faster access
  
      var hasOwnProperty = Object.prototype.hasOwnProperty;
  
      ///////////////////////////////////////////////////////////////////////////
      // The Canvas object is a wrapper around an HTML5 <canvas> tag.
      //
      // @constructor
      // @param {string} cls List of classes to apply to the canvas.
      // @param {element} container Element onto which to append the canvas.
      //
      // Requiring a container is a little iffy, but unfortunately canvas
      // operations don't work unless the canvas is attached to the DOM.
  
      function Canvas(cls, container) {
  
          var element = container.children("." + cls)[0];
  
          if (element == null) {
  
              element = document.createElement("canvas");
              element.className = cls;
  
              $(element).css({ direction: "ltr", position: "absolute", left: 0, top: 0 })
                  .appendTo(container);
  
              // If HTML5 Canvas isn't available, fall back to [Ex|Flash]canvas
  
              if (!element.getContext) {
                  if (window.G_vmlCanvasManager) {
                      element = window.G_vmlCanvasManager.initElement(element);
                  } else {
                      throw new Error("Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.");
                  }
              }
          }
  
          this.element = element;
  
          var context = this.context = element.getContext("2d");
  
          // Determine the screen's ratio of physical to device-independent
          // pixels.  This is the ratio between the canvas width that the browser
          // advertises and the number of pixels actually present in that space.
  
          // The iPhone 4, for example, has a device-independent width of 320px,
          // but its screen is actually 640px wide.  It therefore has a pixel
          // ratio of 2, while most normal devices have a ratio of 1.
  
          var devicePixelRatio = window.devicePixelRatio || 1,
              backingStoreRatio =
                  context.webkitBackingStorePixelRatio ||
                  context.mozBackingStorePixelRatio ||
                  context.msBackingStorePixelRatio ||
                  context.oBackingStorePixelRatio ||
                  context.backingStorePixelRatio || 1;
  
          this.pixelRatio = devicePixelRatio / backingStoreRatio;
  
          // Size the canvas to match the internal dimensions of its container
  
          this.resize(container.width(), container.height());
  
          // Collection of HTML div layers for text overlaid onto the canvas
  
          this.textContainer = null;
          this.text = {};
  
          // Cache of text fragments and metrics, so we can avoid expensively
          // re-calculating them when the plot is re-rendered in a loop.
  
          this._textCache = {};
      }
  
      // Resizes the canvas to the given dimensions.
      //
      // @param {number} width New width of the canvas, in pixels.
      // @param {number} width New height of the canvas, in pixels.
  
      Canvas.prototype.resize = function(width, height) {
  
          if (width <= 0 || height <= 0) {
              throw new Error("Invalid dimensions for plot, width = " + width + ", height = " + height);
          }
  
          var element = this.element,
              context = this.context,
              pixelRatio = this.pixelRatio;
  
          // Resize the canvas, increasing its density based on the display's
          // pixel ratio; basically giving it more pixels without increasing the
          // size of its element, to take advantage of the fact that retina
          // displays have that many more pixels in the same advertised space.
  
          // Resizing should reset the state (excanvas seems to be buggy though)
  
          if (this.width != width) {
              element.width = width * pixelRatio;
              element.style.width = width + "px";
              this.width = width;
          }
  
          if (this.height != height) {
              element.height = height * pixelRatio;
              element.style.height = height + "px";
              this.height = height;
          }
  
          // Save the context, so we can reset in case we get replotted.  The
          // restore ensure that we're really back at the initial state, and
          // should be safe even if we haven't saved the initial state yet.
  
          context.restore();
          context.save();
  
          // Scale the coordinate space to match the display density; so even though we
          // may have twice as many pixels, we still want lines and other drawing to
          // appear at the same size; the extra pixels will just make them crisper.
  
          context.scale(pixelRatio, pixelRatio);
      };
  
      // Clears the entire canvas area, not including any overlaid HTML text
  
      Canvas.prototype.clear = function() {
          this.context.clearRect(0, 0, this.width, this.height);
      };
  
      // Finishes rendering the canvas, including managing the text overlay.
  
      Canvas.prototype.render = function() {
  
          var cache = this._textCache;
  
          // For each text layer, add elements marked as active that haven't
          // already been rendered, and remove those that are no longer active.
  
          for (var layerKey in cache) {
              if (hasOwnProperty.call(cache, layerKey)) {
  
                  var layer = this.getTextLayer(layerKey),
                      layerCache = cache[layerKey];
  
                  layer.hide();
  
                  for (var styleKey in layerCache) {
                      if (hasOwnProperty.call(layerCache, styleKey)) {
                          var styleCache = layerCache[styleKey];
                          for (var key in styleCache) {
                              if (hasOwnProperty.call(styleCache, key)) {
  
                                  var positions = styleCache[key].positions;
  
                                  for (var i = 0, position; position = positions[i]; i++) {
                                      if (position.active) {
                                          if (!position.rendered) {
                                              layer.append(position.element);
                                              position.rendered = true;
                                          }
                                      } else {
                                          positions.splice(i--, 1);
                                          if (position.rendered) {
                                              position.element.detach();
                                          }
                                      }
                                  }
  
                                  if (positions.length == 0) {
                                      delete styleCache[key];
                                  }
                              }
                          }
                      }
                  }
  
                  layer.show();
              }
          }
      };
  
      // Creates (if necessary) and returns the text overlay container.
      //
      // @param {string} classes String of space-separated CSS classes used to
      //     uniquely identify the text layer.
      // @return {object} The jQuery-wrapped text-layer div.
  
      Canvas.prototype.getTextLayer = function(classes) {
  
          var layer = this.text[classes];
  
          // Create the text layer if it doesn't exist
  
          if (layer == null) {
  
              // Create the text layer container, if it doesn't exist
  
              if (this.textContainer == null) {
                  this.textContainer = $("<div class='flot-text'></div>")
                      .css({
                          position: "absolute",
                          top: 0,
                          left: 0,
                          bottom: 0,
                          right: 0,
                          'font-size': "smaller",
                          color: "#545454"
                      })
                      .insertAfter(this.element);
              }
  
              layer = this.text[classes] = $("<div></div>")
                  .addClass(classes)
                  .css({
                      position: "absolute",
                      top: 0,
                      left: 0,
                      bottom: 0,
                      right: 0
                  })
                  .appendTo(this.textContainer);
          }
  
          return layer;
      };
  
      // Creates (if necessary) and returns a text info object.
      //
      // The object looks like this:
      //
      // {
      //     width: Width of the text's wrapper div.
      //     height: Height of the text's wrapper div.
      //     element: The jQuery-wrapped HTML div containing the text.
      //     positions: Array of positions at which this text is drawn.
      // }
      //
      // The positions array contains objects that look like this:
      //
      // {
      //     active: Flag indicating whether the text should be visible.
      //     rendered: Flag indicating whether the text is currently visible.
      //     element: The jQuery-wrapped HTML div containing the text.
      //     x: X coordinate at which to draw the text.
      //     y: Y coordinate at which to draw the text.
      // }
      //
      // Each position after the first receives a clone of the original element.
      //
      // The idea is that that the width, height, and general 'identity' of the
      // text is constant no matter where it is placed; the placements are a
      // secondary property.
      //
      // Canvas maintains a cache of recently-used text info objects; getTextInfo
      // either returns the cached element or creates a new entry.
      //
      // @param {string} layer A string of space-separated CSS classes uniquely
      //     identifying the layer containing this text.
      // @param {string} text Text string to retrieve info for.
      // @param {(string|object)=} font Either a string of space-separated CSS
      //     classes or a font-spec object, defining the text's font and style.
      // @param {number=} angle Angle at which to rotate the text, in degrees.
      //     Angle is currently unused, it will be implemented in the future.
      // @param {number=} width Maximum width of the text before it wraps.
      // @return {object} a text info object.
  
      Canvas.prototype.getTextInfo = function(layer, text, font, angle, width) {
  
          var textStyle, layerCache, styleCache, info;
  
          // Cast the value to a string, in case we were given a number or such
  
          text = "" + text;
  
          // If the font is a font-spec object, generate a CSS font definition
  
          if (typeof font === "object") {
              textStyle = font.style + " " + font.variant + " " + font.weight + " " + font.size + "px/" + font.lineHeight + "px " + font.family;
          } else {
              textStyle = font;
          }
  
          // Retrieve (or create) the cache for the text's layer and styles
  
          layerCache = this._textCache[layer];
  
          if (layerCache == null) {
              layerCache = this._textCache[layer] = {};
          }
  
          styleCache = layerCache[textStyle];
  
          if (styleCache == null) {
              styleCache = layerCache[textStyle] = {};
          }
  
          info = styleCache[text];
  
          // If we can't find a matching element in our cache, create a new one
  
          if (info == null) {
  
              var element = $("<div></div>").html(text)
                  .css({
                      position: "absolute",
                      'max-width': width,
                      top: -9999
                  })
                  .appendTo(this.getTextLayer(layer));
  
              if (typeof font === "object") {
                  element.css({
                      font: textStyle,
                      color: font.color
                  });
              } else if (typeof font === "string") {
                  element.addClass(font);
              }
  
              info = styleCache[text] = {
                  width: element.outerWidth(true),
                  height: element.outerHeight(true),
                  element: element,
                  positions: []
              };
  
              element.detach();
          }
  
          return info;
      };
  
      // Adds a text string to the canvas text overlay.
      //
      // The text isn't drawn immediately; it is marked as rendering, which will
      // result in its addition to the canvas on the next render pass.
      //
      // @param {string} layer A string of space-separated CSS classes uniquely
      //     identifying the layer containing this text.
      // @param {number} x X coordinate at which to draw the text.
      // @param {number} y Y coordinate at which to draw the text.
      // @param {string} text Text string to draw.
      // @param {(string|object)=} font Either a string of space-separated CSS
      //     classes or a font-spec object, defining the text's font and style.
      // @param {number=} angle Angle at which to rotate the text, in degrees.
      //     Angle is currently unused, it will be implemented in the future.
      // @param {number=} width Maximum width of the text before it wraps.
      // @param {string=} halign Horizontal alignment of the text; either "left",
      //     "center" or "right".
      // @param {string=} valign Vertical alignment of the text; either "top",
      //     "middle" or "bottom".
  
      Canvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {
  
          var info = this.getTextInfo(layer, text, font, angle, width),
              positions = info.positions;
  
          // Tweak the div's position to match the text's alignment
  
          if (halign == "center") {
              x -= info.width / 2;
          } else if (halign == "right") {
              x -= info.width;
          }
  
          if (valign == "middle") {
              y -= info.height / 2;
          } else if (valign == "bottom") {
              y -= info.height;
          }
  
          // Determine whether this text already exists at this position.
          // If so, mark it for inclusion in the next render pass.
  
          for (var i = 0, position; position = positions[i]; i++) {
              if (position.x == x && position.y == y) {
                  position.active = true;
                  return;
              }
          }
  
          // If the text doesn't exist at this position, create a new entry
  
          // For the very first position we'll re-use the original element,
          // while for subsequent ones we'll clone it.
  
          position = {
              active: true,
              rendered: false,
              element: positions.length ? info.element.clone() : info.element,
              x: x,
              y: y
          };
  
          positions.push(position);
  
          // Move the element to its final position within the container
  
          position.element.css({
              top: Math.round(y),
              left: Math.round(x),
              'text-align': halign	// In case the text wraps
          });
      };
  
      // Removes one or more text strings from the canvas text overlay.
      //
      // If no parameters are given, all text within the layer is removed.
      //
      // Note that the text is not immediately removed; it is simply marked as
      // inactive, which will result in its removal on the next render pass.
      // This avoids the performance penalty for 'clear and redraw' behavior,
      // where we potentially get rid of all text on a layer, but will likely
      // add back most or all of it later, as when redrawing axes, for example.
      //
      // @param {string} layer A string of space-separated CSS classes uniquely
      //     identifying the layer containing this text.
      // @param {number=} x X coordinate of the text.
      // @param {number=} y Y coordinate of the text.
      // @param {string=} text Text string to remove.
      // @param {(string|object)=} font Either a string of space-separated CSS
      //     classes or a font-spec object, defining the text's font and style.
      // @param {number=} angle Angle at which the text is rotated, in degrees.
      //     Angle is currently unused, it will be implemented in the future.
  
      Canvas.prototype.removeText = function(layer, x, y, text, font, angle) {
          if (text == null) {
              var layerCache = this._textCache[layer];
              if (layerCache != null) {
                  for (var styleKey in layerCache) {
                      if (hasOwnProperty.call(layerCache, styleKey)) {
                          var styleCache = layerCache[styleKey];
                          for (var key in styleCache) {
                              if (hasOwnProperty.call(styleCache, key)) {
                                  var positions = styleCache[key].positions;
                                  for (var i = 0, position; position = positions[i]; i++) {
                                      position.active = false;
                                  }
                              }
                          }
                      }
                  }
              }
          } else {
              var positions = this.getTextInfo(layer, text, font, angle).positions;
              for (var i = 0, position; position = positions[i]; i++) {
                  if (position.x == x && position.y == y) {
                      position.active = false;
                  }
              }
          }
      };
  
      ///////////////////////////////////////////////////////////////////////////
      // The top-level container for the entire plot.
  
      function Plot(placeholder, data_, options_, plugins) {
          // data is on the form:
          //   [ series1, series2 ... ]
          // where series is either just the data as [ [x1, y1], [x2, y2], ... ]
          // or { data: [ [x1, y1], [x2, y2], ... ], label: "some label", ... }
  
          var series = [],
              options = {
                  // the color theme used for graphs
                  colors: ["#edc240", "#afd8f8", "#cb4b4b", "#4da74d", "#9440ed"],
                  legend: {
                      show: true,
                      noColumns: 1, // number of colums in legend table
                      labelFormatter: null, // fn: string -> string
                      labelBoxBorderColor: "#ccc", // border color for the little label boxes
                      container: null, // container (as jQuery object) to put legend in, null means default on top of graph
                      position: "ne", // position of default legend container within plot
                      margin: 5, // distance from grid edge to default legend container within plot
                      backgroundColor: null, // null means auto-detect
                      backgroundOpacity: 0.85, // set to 0 to avoid background
                      sorted: null    // default to no legend sorting
                  },
                  xaxis: {
                      show: null, // null = auto-detect, true = always, false = never
                      position: "bottom", // or "top"
                      mode: null, // null or "time"
                      font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: "italic", weight: "bold", family: "sans-serif", variant: "small-caps" }
                      color: null, // base color, labels, ticks
                      tickColor: null, // possibly different color of ticks, e.g. "rgba(0,0,0,0.15)"
                      transform: null, // null or f: number -> number to transform axis
                      inverseTransform: null, // if transform is set, this should be the inverse function
                      min: null, // min. value to show, null means set automatically
                      max: null, // max. value to show, null means set automatically
                      autoscaleMargin: null, // margin in % to add if auto-setting min/max
                      ticks: null, // either [1, 3] or [[1, "a"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks
                      tickFormatter: null, // fn: number -> string
                      labelWidth: null, // size of tick labels in pixels
                      labelHeight: null,
                      reserveSpace: null, // whether to reserve space even if axis isn't shown
                      tickLength: null, // size in pixels of ticks, or "full" for whole line
                      alignTicksWithAxis: null, // axis number or null for no sync
                      tickDecimals: null, // no. of decimals, null means auto
                      tickSize: null, // number or [number, "unit"]
                      minTickSize: null // number or [number, "unit"]
                  },
                  yaxis: {
                      autoscaleMargin: 0.02,
                      position: "left" // or "right"
                  },
                  xaxes: [],
                  yaxes: [],
                  series: {
                      points: {
                          show: false,
                          radius: 3,
                          lineWidth: 2, // in pixels
                          fill: true,
                          fillColor: "#ffffff",
                          symbol: "circle" // or callback
                      },
                      lines: {
                          // we don't put in show: false so we can see
                          // whether lines were actively disabled
                          lineWidth: 2, // in pixels
                          fill: false,
                          fillColor: null,
                          steps: false
                          // Omit 'zero', so we can later default its value to
                          // match that of the 'fill' option.
                      },
                      bars: {
                          show: false,
                          lineWidth: 2, // in pixels
                          barWidth: 1, // in units of the x axis
                          fill: true,
                          fillColor: null,
                          align: "left", // "left", "right", or "center"
                          horizontal: false,
                          zero: true
                      },
                      shadowSize: 3,
                      highlightColor: null
                  },
                  grid: {
                      show: true,
                      aboveData: false,
                      color: "#545454", // primary color used for outline and labels
                      backgroundColor: null, // null for transparent, else color
                      borderColor: null, // set if different from the grid color
                      tickColor: null, // color for the ticks, e.g. "rgba(0,0,0,0.15)"
                      margin: 0, // distance from the canvas edge to the grid
                      labelMargin: 5, // in pixels
                      axisMargin: 8, // in pixels
                      borderWidth: 2, // in pixels
                      minBorderMargin: null, // in pixels, null means taken from points radius
                      markings: null, // array of ranges or fn: axes -> array of ranges
                      markingsColor: "#f4f4f4",
                      markingsLineWidth: 2,
                      // interactive stuff
                      clickable: false,
                      hoverable: false,
                      autoHighlight: true, // highlight in case mouse is near
                      mouseActiveRadius: 10 // how far the mouse can be away to activate an item
                  },
                  interaction: {
                      redrawOverlayInterval: 1000/60 // time between updates, -1 means in same flow
                  },
                  hooks: {}
              },
          surface = null,     // the canvas for the plot itself
          overlay = null,     // canvas for interactive stuff on top of plot
          eventHolder = null, // jQuery object that events should be bound to
          ctx = null, octx = null,
          xaxes = [], yaxes = [],
          plotOffset = { left: 0, right: 0, top: 0, bottom: 0},
          plotWidth = 0, plotHeight = 0,
          hooks = {
              processOptions: [],
              processRawData: [],
              processDatapoints: [],
              processOffset: [],
              drawBackground: [],
              drawSeries: [],
              draw: [],
              bindEvents: [],
              drawOverlay: [],
              shutdown: []
          },
          plot = this;
  
          // public functions
          plot.setData = setData;
          plot.setupGrid = setupGrid;
          plot.draw = draw;
          plot.getPlaceholder = function() { return placeholder; };
          plot.getCanvas = function() { return surface.element; };
          plot.getPlotOffset = function() { return plotOffset; };
          plot.width = function () { return plotWidth; };
          plot.height = function () { return plotHeight; };
          plot.offset = function () {
              var o = eventHolder.offset();
              o.left += plotOffset.left;
              o.top += plotOffset.top;
              return o;
          };
          plot.getData = function () { return series; };
          plot.getAxes = function () {
              var res = {}, i;
              $.each(xaxes.concat(yaxes), function (_, axis) {
                  if (axis)
                      res[axis.direction + (axis.n != 1 ? axis.n : "") + "axis"] = axis;
              });
              return res;
          };
          plot.getXAxes = function () { return xaxes; };
          plot.getYAxes = function () { return yaxes; };
          plot.c2p = canvasToAxisCoords;
          plot.p2c = axisToCanvasCoords;
          plot.getOptions = function () { return options; };
          plot.highlight = highlight;
          plot.unhighlight = unhighlight;
          plot.triggerRedrawOverlay = triggerRedrawOverlay;
          plot.pointOffset = function(point) {
              return {
                  left: parseInt(xaxes[axisNumber(point, "x") - 1].p2c(+point.x) + plotOffset.left, 10),
                  top: parseInt(yaxes[axisNumber(point, "y") - 1].p2c(+point.y) + plotOffset.top, 10)
              };
          };
          plot.shutdown = shutdown;
          plot.destroy = function () {
              shutdown();
              placeholder.removeData("plot").empty();
  
              series = [];
              options = null;
              surface = null;
              overlay = null;
              eventHolder = null;
              ctx = null;
              octx = null;
              xaxes = [];
              yaxes = [];
              hooks = null;
              highlights = [];
              plot = null;
          };
          plot.resize = function () {
              var width = placeholder.width(),
                  height = placeholder.height();
              surface.resize(width, height);
              overlay.resize(width, height);
          };
  
          // public attributes
          plot.hooks = hooks;
  
          // initialize
          initPlugins(plot);
          parseOptions(options_);
          setupCanvases();
          setData(data_);
          setupGrid();
          draw();
          bindEvents();
  
  
          function executeHooks(hook, args) {
              args = [plot].concat(args);
              for (var i = 0; i < hook.length; ++i)
                  hook[i].apply(this, args);
          }
  
          function initPlugins() {
  
              // References to key classes, allowing plugins to modify them
  
              var classes = {
                  Canvas: Canvas
              };
  
              for (var i = 0; i < plugins.length; ++i) {
                  var p = plugins[i];
                  p.init(plot, classes);
                  if (p.options)
                      $.extend(true, options, p.options);
              }
          }
  
          function parseOptions(opts) {
  
              $.extend(true, options, opts);
  
              // $.extend merges arrays, rather than replacing them.  When less
              // colors are provided than the size of the default palette, we
              // end up with those colors plus the remaining defaults, which is
              // not expected behavior; avoid it by replacing them here.
  
              if (opts && opts.colors) {
                  options.colors = opts.colors;
              }
  
              if (options.xaxis.color == null)
                  options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();
              if (options.yaxis.color == null)
                  options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();
  
              if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility
                  options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;
              if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility
                  options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;
  
              if (options.grid.borderColor == null)
                  options.grid.borderColor = options.grid.color;
              if (options.grid.tickColor == null)
                  options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();
  
              // Fill in defaults for axis options, including any unspecified
              // font-spec fields, if a font-spec was provided.
  
              // If no x/y axis options were provided, create one of each anyway,
              // since the rest of the code assumes that they exist.
  
              var i, axisOptions, axisCount,
                  fontSize = placeholder.css("font-size"),
                  fontSizeDefault = fontSize ? +fontSize.replace("px", "") : 13,
                  fontDefaults = {
                      style: placeholder.css("font-style"),
                      size: Math.round(0.8 * fontSizeDefault),
                      variant: placeholder.css("font-variant"),
                      weight: placeholder.css("font-weight"),
                      family: placeholder.css("font-family")
                  };
  
              axisCount = options.xaxes.length || 1;
              for (i = 0; i < axisCount; ++i) {
  
                  axisOptions = options.xaxes[i];
                  if (axisOptions && !axisOptions.tickColor) {
                      axisOptions.tickColor = axisOptions.color;
                  }
  
                  axisOptions = $.extend(true, {}, options.xaxis, axisOptions);
                  options.xaxes[i] = axisOptions;
  
                  if (axisOptions.font) {
                      axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
                      if (!axisOptions.font.color) {
                          axisOptions.font.color = axisOptions.color;
                      }
                      if (!axisOptions.font.lineHeight) {
                          axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);
                      }
                  }
              }
  
              axisCount = options.yaxes.length || 1;
              for (i = 0; i < axisCount; ++i) {
  
                  axisOptions = options.yaxes[i];
                  if (axisOptions && !axisOptions.tickColor) {
                      axisOptions.tickColor = axisOptions.color;
                  }
  
                  axisOptions = $.extend(true, {}, options.yaxis, axisOptions);
                  options.yaxes[i] = axisOptions;
  
                  if (axisOptions.font) {
                      axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
                      if (!axisOptions.font.color) {
                          axisOptions.font.color = axisOptions.color;
                      }
                      if (!axisOptions.font.lineHeight) {
                          axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);
                      }
                  }
              }
  
              // backwards compatibility, to be removed in future
              if (options.xaxis.noTicks && options.xaxis.ticks == null)
                  options.xaxis.ticks = options.xaxis.noTicks;
              if (options.yaxis.noTicks && options.yaxis.ticks == null)
                  options.yaxis.ticks = options.yaxis.noTicks;
              if (options.x2axis) {
                  options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);
                  options.xaxes[1].position = "top";
              }
              if (options.y2axis) {
                  options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);
                  options.yaxes[1].position = "right";
              }
              if (options.grid.coloredAreas)
                  options.grid.markings = options.grid.coloredAreas;
              if (options.grid.coloredAreasColor)
                  options.grid.markingsColor = options.grid.coloredAreasColor;
              if (options.lines)
                  $.extend(true, options.series.lines, options.lines);
              if (options.points)
                  $.extend(true, options.series.points, options.points);
              if (options.bars)
                  $.extend(true, options.series.bars, options.bars);
              if (options.shadowSize != null)
                  options.series.shadowSize = options.shadowSize;
              if (options.highlightColor != null)
                  options.series.highlightColor = options.highlightColor;
  
              // save options on axes for future reference
              for (i = 0; i < options.xaxes.length; ++i)
                  getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];
              for (i = 0; i < options.yaxes.length; ++i)
                  getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];
  
              // add hooks from options
              for (var n in hooks)
                  if (options.hooks[n] && options.hooks[n].length)
                      hooks[n] = hooks[n].concat(options.hooks[n]);
  
              executeHooks(hooks.processOptions, [options]);
          }
  
          function setData(d) {
              series = parseData(d);
              fillInSeriesOptions();
              processData();
          }
  
          function parseData(d) {
              var res = [];
              for (var i = 0; i < d.length; ++i) {
                  var s = $.extend(true, {}, options.series);
  
                  if (d[i].data != null) {
                      s.data = d[i].data; // move the data instead of deep-copy
                      delete d[i].data;
  
                      $.extend(true, s, d[i]);
  
                      d[i].data = s.data;
                  }
                  else
                      s.data = d[i];
                  res.push(s);
              }
  
              return res;
          }
  
          function axisNumber(obj, coord) {
              var a = obj[coord + "axis"];
              if (typeof a == "object") // if we got a real axis, extract number
                  a = a.n;
              if (typeof a != "number")
                  a = 1; // default to first axis
              return a;
          }
  
          function allAxes() {
              // return flat array without annoying null entries
              return $.grep(xaxes.concat(yaxes), function (a) { return a; });
          }
  
          function canvasToAxisCoords(pos) {
              // return an object with x/y corresponding to all used axes
              var res = {}, i, axis;
              for (i = 0; i < xaxes.length; ++i) {
                  axis = xaxes[i];
                  if (axis && axis.used)
                      res["x" + axis.n] = axis.c2p(pos.left);
              }
  
              for (i = 0; i < yaxes.length; ++i) {
                  axis = yaxes[i];
                  if (axis && axis.used)
                      res["y" + axis.n] = axis.c2p(pos.top);
              }
  
              if (res.x1 !== undefined)
                  res.x = res.x1;
              if (res.y1 !== undefined)
                  res.y = res.y1;
  
              return res;
          }
  
          function axisToCanvasCoords(pos) {
              // get canvas coords from the first pair of x/y found in pos
              var res = {}, i, axis, key;
  
              for (i = 0; i < xaxes.length; ++i) {
                  axis = xaxes[i];
                  if (axis && axis.used) {
                      key = "x" + axis.n;
                      if (pos[key] == null && axis.n == 1)
                          key = "x";
  
                      if (pos[key] != null) {
                          res.left = axis.p2c(pos[key]);
                          break;
                      }
                  }
              }
  
              for (i = 0; i < yaxes.length; ++i) {
                  axis = yaxes[i];
                  if (axis && axis.used) {
                      key = "y" + axis.n;
                      if (pos[key] == null && axis.n == 1)
                          key = "y";
  
                      if (pos[key] != null) {
                          res.top = axis.p2c(pos[key]);
                          break;
                      }
                  }
              }
  
              return res;
          }
  
          function getOrCreateAxis(axes, number) {
              if (!axes[number - 1])
                  axes[number - 1] = {
                      n: number, // save the number for future reference
                      direction: axes == xaxes ? "x" : "y",
                      options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)
                  };
  
              return axes[number - 1];
          }
  
          function fillInSeriesOptions() {
  
              var neededColors = series.length, maxIndex = -1, i;
  
              // Subtract the number of series that already have fixed colors or
              // color indexes from the number that we still need to generate.
  
              for (i = 0; i < series.length; ++i) {
                  var sc = series[i].color;
                  if (sc != null) {
                      neededColors--;
                      if (typeof sc == "number" && sc > maxIndex) {
                          maxIndex = sc;
                      }
                  }
              }
  
              // If any of the series have fixed color indexes, then we need to
              // generate at least as many colors as the highest index.
  
              if (neededColors <= maxIndex) {
                  neededColors = maxIndex + 1;
              }
  
              // Generate all the colors, using first the option colors and then
              // variations on those colors once they're exhausted.
  
              var c, colors = [], colorPool = options.colors,
                  colorPoolSize = colorPool.length, variation = 0;
  
              for (i = 0; i < neededColors; i++) {
  
                  c = $.color.parse(colorPool[i % colorPoolSize] || "#666");
  
                  // Each time we exhaust the colors in the pool we adjust
                  // a scaling factor used to produce more variations on
                  // those colors. The factor alternates negative/positive
                  // to produce lighter/darker colors.
  
                  // Reset the variation after every few cycles, or else
                  // it will end up producing only white or black colors.
  
                  if (i % colorPoolSize == 0 && i) {
                      if (variation >= 0) {
                          if (variation < 0.5) {
                              variation = -variation - 0.2;
                          } else variation = 0;
                      } else variation = -variation;
                  }
  
                  colors[i] = c.scale('rgb', 1 + variation);
              }
  
              // Finalize the series options, filling in their colors
  
              var colori = 0, s;
              for (i = 0; i < series.length; ++i) {
                  s = series[i];
  
                  // assign colors
                  if (s.color == null) {
                      s.color = colors[colori].toString();
                      ++colori;
                  }
                  else if (typeof s.color == "number")
                      s.color = colors[s.color].toString();
  
                  // turn on lines automatically in case nothing is set
                  if (s.lines.show == null) {
                      var v, show = true;
                      for (v in s)
                          if (s[v] && s[v].show) {
                              show = false;
                              break;
                          }
                      if (show)
                          s.lines.show = true;
                  }
  
                  // If nothing was provided for lines.zero, default it to match
                  // lines.fill, since areas by default should extend to zero.
  
                  if (s.lines.zero == null) {
                      s.lines.zero = !!s.lines.fill;
                  }
  
                  // setup axes
                  s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, "x"));
                  s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, "y"));
              }
          }
  
          function processData() {
              var topSentry = Number.POSITIVE_INFINITY,
                  bottomSentry = Number.NEGATIVE_INFINITY,
                  fakeInfinity = Number.MAX_VALUE,
                  i, j, k, m, length,
                  s, points, ps, x, y, axis, val, f, p,
                  data, format;
  
              function updateAxis(axis, min, max) {
                  if (min < axis.datamin && min != -fakeInfinity)
                      axis.datamin = min;
                  if (max > axis.datamax && max != fakeInfinity)
                      axis.datamax = max;
              }
  
              $.each(allAxes(), function (_, axis) {
                  // init axis
                  axis.datamin = topSentry;
                  axis.datamax = bottomSentry;
                  axis.used = false;
              });
  
              for (i = 0; i < series.length; ++i) {
                  s = series[i];
                  s.datapoints = { points: [] };
  
                  executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ]);
              }
  
              // first pass: clean and copy data
              for (i = 0; i < series.length; ++i) {
                  s = series[i];
  
                  data = s.data;
                  format = s.datapoints.format;
  
                  if (!format) {
                      format = [];
                      // find out how to copy
                      format.push({ x: true, number: true, required: true });
                      format.push({ y: true, number: true, required: true });
  
                      if (s.bars.show || (s.lines.show && s.lines.fill)) {
                          var autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));
                          format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });
                          if (s.bars.horizontal) {
                              delete format[format.length - 1].y;
                              format[format.length - 1].x = true;
                          }
                      }
  
                      s.datapoints.format = format;
                  }
  
                  if (s.datapoints.pointsize != null)
                      continue; // already filled in
  
                  s.datapoints.pointsize = format.length;
  
                  ps = s.datapoints.pointsize;
                  points = s.datapoints.points;
  
                  var insertSteps = s.lines.show && s.lines.steps;
                  s.xaxis.used = s.yaxis.used = true;
  
                  for (j = k = 0; j < data.length; ++j, k += ps) {
                      p = data[j];
  
                      var nullify = p == null;
                      if (!nullify) {
                          for (m = 0; m < ps; ++m) {
                              val = p[m];
                              f = format[m];
  
                              if (f) {
                                  if (f.number && val != null) {
                                      val = +val; // convert to number
                                      if (isNaN(val))
                                          val = null;
                                      else if (val == Infinity)
                                          val = fakeInfinity;
                                      else if (val == -Infinity)
                                          val = -fakeInfinity;
                                  }
  
                                  if (val == null) {
                                      if (f.required)
                                          nullify = true;
  
                                      if (f.defaultValue != null)
                                          val = f.defaultValue;
                                  }
                              }
  
                              points[k + m] = val;
                          }
                      }
  
                      if (nullify) {
                          for (m = 0; m < ps; ++m) {
                              val = points[k + m];
                              if (val != null) {
                                  f = format[m];
                                  // extract min/max info
                                  if (f.autoscale !== false) {
                                      if (f.x) {
                                          updateAxis(s.xaxis, val, val);
                                      }
                                      if (f.y) {
                                          updateAxis(s.yaxis, val, val);
                                      }
                                  }
                              }
                              points[k + m] = null;
                          }
                      }
                      else {
                          // a little bit of line specific stuff that
                          // perhaps shouldn't be here, but lacking
                          // better means...
                          if (insertSteps && k > 0
                              && points[k - ps] != null
                              && points[k - ps] != points[k]
                              && points[k - ps + 1] != points[k + 1]) {
                              // copy the point to make room for a middle point
                              for (m = 0; m < ps; ++m)
                                  points[k + ps + m] = points[k + m];
  
                              // middle point has same y
                              points[k + 1] = points[k - ps + 1];
  
                              // we've added a point, better reflect that
                              k += ps;
                          }
                      }
                  }
              }
  
              // give the hooks a chance to run
              for (i = 0; i < series.length; ++i) {
                  s = series[i];
  
                  executeHooks(hooks.processDatapoints, [ s, s.datapoints]);
              }
  
              // second pass: find datamax/datamin for auto-scaling
              for (i = 0; i < series.length; ++i) {
                  s = series[i];
                  points = s.datapoints.points;
                  ps = s.datapoints.pointsize;
                  format = s.datapoints.format;
  
                  var xmin = topSentry, ymin = topSentry,
                      xmax = bottomSentry, ymax = bottomSentry;
  
                  for (j = 0; j < points.length; j += ps) {
                      if (points[j] == null)
                          continue;
  
                      for (m = 0; m < ps; ++m) {
                          val = points[j + m];
                          f = format[m];
                          if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity)
                              continue;
  
                          if (f.x) {
                              if (val < xmin)
                                  xmin = val;
                              if (val > xmax)
                                  xmax = val;
                          }
                          if (f.y) {
                              if (val < ymin)
                                  ymin = val;
                              if (val > ymax)
                                  ymax = val;
                          }
                      }
                  }
  
                  if (s.bars.show) {
                      // make sure we got room for the bar on the dancing floor
                      var delta;
  
                      switch (s.bars.align) {
                          case "left":
                              delta = 0;
                              break;
                          case "right":
                              delta = -s.bars.barWidth;
                              break;
                          default:
                              delta = -s.bars.barWidth / 2;
                      }
  
                      if (s.bars.horizontal) {
                          ymin += delta;
                          ymax += delta + s.bars.barWidth;
                      }
                      else {
                          xmin += delta;
                          xmax += delta + s.bars.barWidth;
                      }
                  }
  
                  updateAxis(s.xaxis, xmin, xmax);
                  updateAxis(s.yaxis, ymin, ymax);
              }
  
              $.each(allAxes(), function (_, axis) {
                  if (axis.datamin == topSentry)
                      axis.datamin = null;
                  if (axis.datamax == bottomSentry)
                      axis.datamax = null;
              });
          }
  
          function setupCanvases() {
  
              // Make sure the placeholder is clear of everything except canvases
              // from a previous plot in this container that we'll try to re-use.
  
              placeholder.css("padding", 0) // padding messes up the positioning
                  .children().filter(function(){
                      return !$(this).hasClass("flot-overlay") && !$(this).hasClass('flot-base');
                  }).remove();
  
              if (placeholder.css("position") == 'static')
                  placeholder.css("position", "relative"); // for positioning labels and overlay
  
              surface = new Canvas("flot-base", placeholder);
              overlay = new Canvas("flot-overlay", placeholder); // overlay canvas for interactive features
  
              ctx = surface.context;
              octx = overlay.context;
  
              // define which element we're listening for events on
              eventHolder = $(overlay.element).unbind();
  
              // If we're re-using a plot object, shut down the old one
  
              var existing = placeholder.data("plot");
  
              if (existing) {
                  existing.shutdown();
                  overlay.clear();
              }
  
              // save in case we get replotted
              placeholder.data("plot", plot);
          }
  
          function bindEvents() {
              // bind events
              if (options.grid.hoverable) {
                  eventHolder.mousemove(onMouseMove);
  
                  // Use bind, rather than .mouseleave, because we officially
                  // still support jQuery 1.2.6, which doesn't define a shortcut
                  // for mouseenter or mouseleave.  This was a bug/oversight that
                  // was fixed somewhere around 1.3.x.  We can return to using
                  // .mouseleave when we drop support for 1.2.6.
  
                  eventHolder.bind("mouseleave", onMouseLeave);
              }
  
              if (options.grid.clickable)
                  eventHolder.click(onClick);
  
              executeHooks(hooks.bindEvents, [eventHolder]);
          }
  
          function shutdown() {
              if (redrawTimeout)
                  clearTimeout(redrawTimeout);
  
              eventHolder.unbind("mousemove", onMouseMove);
              eventHolder.unbind("mouseleave", onMouseLeave);
              eventHolder.unbind("click", onClick);
  
              executeHooks(hooks.shutdown, [eventHolder]);
          }
  
          function setTransformationHelpers(axis) {
              // set helper functions on the axis, assumes plot area
              // has been computed already
  
              function identity(x) { return x; }
  
              var s, m, t = axis.options.transform || identity,
                  it = axis.options.inverseTransform;
  
              // precompute how much the axis is scaling a point
              // in canvas space
              if (axis.direction == "x") {
                  s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));
                  m = Math.min(t(axis.max), t(axis.min));
              }
              else {
                  s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));
                  s = -s;
                  m = Math.max(t(axis.max), t(axis.min));
              }
  
              // data point to canvas coordinate
              if (t == identity) // slight optimization
                  axis.p2c = function (p) { return (p - m) * s; };
              else
                  axis.p2c = function (p) { return (t(p) - m) * s; };
              // canvas coordinate to data point
              if (!it)
                  axis.c2p = function (c) { return m + c / s; };
              else
                  axis.c2p = function (c) { return it(m + c / s); };
          }
  
          function measureTickLabels(axis) {
  
              var opts = axis.options,
                  ticks = axis.ticks || [],
                  labelWidth = opts.labelWidth || 0,
                  labelHeight = opts.labelHeight || 0,
                  maxWidth = labelWidth || (axis.direction == "x" ? Math.floor(surface.width / (ticks.length || 1)) : null),
                  legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis",
                  layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles,
                  font = opts.font || "flot-tick-label tickLabel";
  
              for (var i = 0; i < ticks.length; ++i) {
  
                  var t = ticks[i];
  
                  if (!t.label)
                      continue;
  
                  var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);
  
                  labelWidth = Math.max(labelWidth, info.width);
                  labelHeight = Math.max(labelHeight, info.height);
              }
  
              axis.labelWidth = opts.labelWidth || labelWidth;
              axis.labelHeight = opts.labelHeight || labelHeight;
          }
  
          function allocateAxisBoxFirstPhase(axis) {
              // find the bounding box of the axis by looking at label
              // widths/heights and ticks, make room by diminishing the
              // plotOffset; this first phase only looks at one
              // dimension per axis, the other dimension depends on the
              // other axes so will have to wait
  
              var lw = axis.labelWidth,
                  lh = axis.labelHeight,
                  pos = axis.options.position,
                  isXAxis = axis.direction === "x",
                  tickLength = axis.options.tickLength,
                  axisMargin = options.grid.axisMargin,
                  padding = options.grid.labelMargin,
                  innermost = true,
                  outermost = true,
                  first = true,
                  found = false;
  
              // Determine the axis's position in its direction and on its side
  
              $.each(isXAxis ? xaxes : yaxes, function(i, a) {
                  if (a && a.reserveSpace) {
                      if (a === axis) {
                          found = true;
                      } else if (a.options.position === pos) {
                          if (found) {
                              outermost = false;
                          } else {
                              innermost = false;
                          }
                      }
                      if (!found) {
                          first = false;
                      }
                  }
              });
  
              // The outermost axis on each side has no margin
  
              if (outermost) {
                  axisMargin = 0;
              }
  
              // The ticks for the first axis in each direction stretch across
  
              if (tickLength == null) {
                  tickLength = first ? "full" : 5;
              }
  
              if (!isNaN(+tickLength))
                  padding += +tickLength;
  
              if (isXAxis) {
                  lh += padding;
  
                  if (pos == "bottom") {
                      plotOffset.bottom += lh + axisMargin;
                      axis.box = { top: surface.height - plotOffset.bottom, height: lh };
                  }
                  else {
                      axis.box = { top: plotOffset.top + axisMargin, height: lh };
                      plotOffset.top += lh + axisMargin;
                  }
              }
              else {
                  lw += padding;
  
                  if (pos == "left") {
                      axis.box = { left: plotOffset.left + axisMargin, width: lw };
                      plotOffset.left += lw + axisMargin;
                  }
                  else {
                      plotOffset.right += lw + axisMargin;
                      axis.box = { left: surface.width - plotOffset.right, width: lw };
                  }
              }
  
               // save for future reference
              axis.position = pos;
              axis.tickLength = tickLength;
              axis.box.padding = padding;
              axis.innermost = innermost;
          }
  
          function allocateAxisBoxSecondPhase(axis) {
              // now that all axis boxes have been placed in one
              // dimension, we can set the remaining dimension coordinates
              if (axis.direction == "x") {
                  axis.box.left = plotOffset.left - axis.labelWidth / 2;
                  axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;
              }
              else {
                  axis.box.top = plotOffset.top - axis.labelHeight / 2;
                  axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;
              }
          }
  
          function adjustLayoutForThingsStickingOut() {
              // possibly adjust plot offset to ensure everything stays
              // inside the canvas and isn't clipped off
  
              var minMargin = options.grid.minBorderMargin,
                  axis, i;
  
              // check stuff from the plot (FIXME: this should just read
              // a value from the series, otherwise it's impossible to
              // customize)
              if (minMargin == null) {
                  minMargin = 0;
                  for (i = 0; i < series.length; ++i)
                      minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth/2));
              }
  
              var margins = {
                  left: minMargin,
                  right: minMargin,
                  top: minMargin,
                  bottom: minMargin
              };
  
              // check axis labels, note we don't check the actual
              // labels but instead use the overall width/height to not
              // jump as much around with replots
              $.each(allAxes(), function (_, axis) {
                  if (axis.reserveSpace && axis.ticks && axis.ticks.length) {
                      var lastTick = axis.ticks[axis.ticks.length - 1];
                      if (axis.direction === "x") {
                          margins.left = Math.max(margins.left, axis.labelWidth / 2);
                          if (lastTick.v <= axis.max) {
                              margins.right = Math.max(margins.right, axis.labelWidth / 2);
                          }
                      } else {
                          margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);
                          if (lastTick.v <= axis.max) {
                              margins.top = Math.max(margins.top, axis.labelHeight / 2);
                          }
                      }
                  }
              });
  
              plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));
              plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));
              plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));
              plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));
          }
  
          function setupGrid() {
              var i, axes = allAxes(), showGrid = options.grid.show;
  
              // Initialize the plot's offset from the edge of the canvas
  
              for (var a in plotOffset) {
                  var margin = options.grid.margin || 0;
                  plotOffset[a] = typeof margin == "number" ? margin : margin[a] || 0;
              }
  
              executeHooks(hooks.processOffset, [plotOffset]);
  
              // If the grid is visible, add its border width to the offset
  
              for (var a in plotOffset) {
                  if(typeof(options.grid.borderWidth) == "object") {
                      plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;
                  }
                  else {
                      plotOffset[a] += showGrid ? options.grid.borderWidth : 0;
                  }
              }
  
              // init axes
              $.each(axes, function (_, axis) {
                  axis.show = axis.options.show;
                  if (axis.show == null)
                      axis.show = axis.used; // by default an axis is visible if it's got data
  
                  axis.reserveSpace = axis.show || axis.options.reserveSpace;
  
                  setRange(axis);
              });
  
              if (showGrid) {
  
                  var allocatedAxes = $.grep(axes, function (axis) { return axis.reserveSpace; });
  
                  $.each(allocatedAxes, function (_, axis) {
                      // make the ticks
                      setupTickGeneration(axis);
                      setTicks(axis);
                      snapRangeToTicks(axis, axis.ticks);
                      // find labelWidth/Height for axis
                      measureTickLabels(axis);
                  });
  
                  // with all dimensions calculated, we can compute the
                  // axis bounding boxes, start from the outside
                  // (reverse order)
                  for (i = allocatedAxes.length - 1; i >= 0; --i)
                      allocateAxisBoxFirstPhase(allocatedAxes[i]);
  
                  // make sure we've got enough space for things that
                  // might stick out
                  adjustLayoutForThingsStickingOut();
  
                  $.each(allocatedAxes, function (_, axis) {
                      allocateAxisBoxSecondPhase(axis);
                  });
              }
  
              plotWidth = surface.width - plotOffset.left - plotOffset.right;
              plotHeight = surface.height - plotOffset.bottom - plotOffset.top;
  
              // now we got the proper plot dimensions, we can compute the scaling
              $.each(axes, function (_, axis) {
                  setTransformationHelpers(axis);
              });
  
              if (showGrid) {
                  drawAxisLabels();
              }
  
              insertLegend();
          }
  
          function setRange(axis) {
              var opts = axis.options,
                  min = +(opts.min != null ? opts.min : axis.datamin),
                  max = +(opts.max != null ? opts.max : axis.datamax),
                  delta = max - min;
  
              if (delta == 0.0) {
                  // degenerate case
                  var widen = max == 0 ? 1 : 0.01;
  
                  if (opts.min == null)
                      min -= widen;
                  // always widen max if we couldn't widen min to ensure we
                  // don't fall into min == max which doesn't work
                  if (opts.max == null || opts.min != null)
                      max += widen;
              }
              else {
                  // consider autoscaling
                  var margin = opts.autoscaleMargin;
                  if (margin != null) {
                      if (opts.min == null) {
                          min -= delta * margin;
                          // make sure we don't go below zero if all values
                          // are positive
                          if (min < 0 && axis.datamin != null && axis.datamin >= 0)
                              min = 0;
                      }
                      if (opts.max == null) {
                          max += delta * margin;
                          if (max > 0 && axis.datamax != null && axis.datamax <= 0)
                              max = 0;
                      }
                  }
              }
              axis.min = min;
              axis.max = max;
          }
  
          function setupTickGeneration(axis) {
              var opts = axis.options;
  
              // estimate number of ticks
              var noTicks;
              if (typeof opts.ticks == "number" && opts.ticks > 0)
                  noTicks = opts.ticks;
              else
                  // heuristic based on the model a*sqrt(x) fitted to
                  // some data points that seemed reasonable
                  noTicks = 0.3 * Math.sqrt(axis.direction == "x" ? surface.width : surface.height);
  
              var delta = (axis.max - axis.min) / noTicks,
                  dec = -Math.floor(Math.log(delta) / Math.LN10),
                  maxDec = opts.tickDecimals;
  
              if (maxDec != null && dec > maxDec) {
                  dec = maxDec;
              }
  
              var magn = Math.pow(10, -dec),
                  norm = delta / magn, // norm is between 1.0 and 10.0
                  size;
  
              if (norm < 1.5) {
                  size = 1;
              } else if (norm < 3) {
                  size = 2;
                  // special case for 2.5, requires an extra decimal
                  if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {
                      size = 2.5;
                      ++dec;
                  }
              } else if (norm < 7.5) {
                  size = 5;
              } else {
                  size = 10;
              }
  
              size *= magn;
  
              if (opts.minTickSize != null && size < opts.minTickSize) {
                  size = opts.minTickSize;
              }
  
              axis.delta = delta;
              axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);
              axis.tickSize = opts.tickSize || size;
  
              // Time mode was moved to a plug-in in 0.8, but since so many people use this
              // we'll add an especially friendly make sure they remembered to include it.
  
              if (opts.mode == "time" && !axis.tickGenerator) {
                  throw new Error("Time mode requires the flot.time plugin.");
              }
  
              // Flot supports base-10 axes; any other mode else is handled by a plug-in,
              // like flot.time.js.
  
              if (!axis.tickGenerator) {
  
                  axis.tickGenerator = function (axis) {
  
                      var ticks = [],
                          start = floorInBase(axis.min, axis.tickSize),
                          i = 0,
                          v = Number.NaN,
                          prev;
  
                      do {
                          prev = v;
                          v = start + i * axis.tickSize;
                          ticks.push(v);
                          ++i;
                      } while (v < axis.max && v != prev);
                      return ticks;
                  };
  
                  axis.tickFormatter = function (value, axis) {
  
                      var factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;
                      var formatted = "" + Math.round(value * factor) / factor;
  
                      // If tickDecimals was specified, ensure that we have exactly that
                      // much precision; otherwise default to the value's own precision.
  
                      if (axis.tickDecimals != null) {
                          var decimal = formatted.indexOf(".");
                          var precision = decimal == -1 ? 0 : formatted.length - decimal - 1;
                          if (precision < axis.tickDecimals) {
                              return (precision ? formatted : formatted + ".") + ("" + factor).substr(1, axis.tickDecimals - precision);
                          }
                      }
  
                      return formatted;
                  };
              }
  
              if ($.isFunction(opts.tickFormatter))
                  axis.tickFormatter = function (v, axis) { return "" + opts.tickFormatter(v, axis); };
  
              if (opts.alignTicksWithAxis != null) {
                  var otherAxis = (axis.direction == "x" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];
                  if (otherAxis && otherAxis.used && otherAxis != axis) {
                      // consider snapping min/max to outermost nice ticks
                      var niceTicks = axis.tickGenerator(axis);
                      if (niceTicks.length > 0) {
                          if (opts.min == null)
                              axis.min = Math.min(axis.min, niceTicks[0]);
                          if (opts.max == null && niceTicks.length > 1)
                              axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);
                      }
  
                      axis.tickGenerator = function (axis) {
                          // copy ticks, scaled to this axis
                          var ticks = [], v, i;
                          for (i = 0; i < otherAxis.ticks.length; ++i) {
                              v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);
                              v = axis.min + v * (axis.max - axis.min);
                              ticks.push(v);
                          }
                          return ticks;
                      };
  
                      // we might need an extra decimal since forced
                      // ticks don't necessarily fit naturally
                      if (!axis.mode && opts.tickDecimals == null) {
                          var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),
                              ts = axis.tickGenerator(axis);
  
                          // only proceed if the tick interval rounded
                          // with an extra decimal doesn't give us a
                          // zero at end
                          if (!(ts.length > 1 && /\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))
                              axis.tickDecimals = extraDec;
                      }
                  }
              }
          }
  
          function setTicks(axis) {
              var oticks = axis.options.ticks, ticks = [];
              if (oticks == null || (typeof oticks == "number" && oticks > 0))
                  ticks = axis.tickGenerator(axis);
              else if (oticks) {
                  if ($.isFunction(oticks))
                      // generate the ticks
                      ticks = oticks(axis);
                  else
                      ticks = oticks;
              }
  
              // clean up/labelify the supplied ticks, copy them over
              var i, v;
              axis.ticks = [];
              for (i = 0; i < ticks.length; ++i) {
                  var label = null;
                  var t = ticks[i];
                  if (typeof t == "object") {
                      v = +t[0];
                      if (t.length > 1)
                          label = t[1];
                  }
                  else
                      v = +t;
                  if (label == null)
                      label = axis.tickFormatter(v, axis);
                  if (!isNaN(v))
                      axis.ticks.push({ v: v, label: label });
              }
          }
  
          function snapRangeToTicks(axis, ticks) {
              if (axis.options.autoscaleMargin && ticks.length > 0) {
                  // snap to ticks
                  if (axis.options.min == null)
                      axis.min = Math.min(axis.min, ticks[0].v);
                  if (axis.options.max == null && ticks.length > 1)
                      axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);
              }
          }
  
          function draw() {
  
              surface.clear();
  
              executeHooks(hooks.drawBackground, [ctx]);
  
              var grid = options.grid;
  
              // draw background, if any
              if (grid.show && grid.backgroundColor)
                  drawBackground();
  
              if (grid.show && !grid.aboveData) {
                  drawGrid();
              }
  
              for (var i = 0; i < series.length; ++i) {
                  executeHooks(hooks.drawSeries, [ctx, series[i]]);
                  drawSeries(series[i]);
              }
  
              executeHooks(hooks.draw, [ctx]);
  
              if (grid.show && grid.aboveData) {
                  drawGrid();
              }
  
              surface.render();
  
              // A draw implies that either the axes or data have changed, so we
              // should probably update the overlay highlights as well.
  
              triggerRedrawOverlay();
          }
  
          function extractRange(ranges, coord) {
              var axis, from, to, key, axes = allAxes();
  
              for (var i = 0; i < axes.length; ++i) {
                  axis = axes[i];
                  if (axis.direction == coord) {
                      key = coord + axis.n + "axis";
                      if (!ranges[key] && axis.n == 1)
                          key = coord + "axis"; // support x1axis as xaxis
                      if (ranges[key]) {
                          from = ranges[key].from;
                          to = ranges[key].to;
                          break;
                      }
                  }
              }
  
              // backwards-compat stuff - to be removed in future
              if (!ranges[key]) {
                  axis = coord == "x" ? xaxes[0] : yaxes[0];
                  from = ranges[coord + "1"];
                  to = ranges[coord + "2"];
              }
  
              // auto-reverse as an added bonus
              if (from != null && to != null && from > to) {
                  var tmp = from;
                  from = to;
                  to = tmp;
              }
  
              return { from: from, to: to, axis: axis };
          }
  
          function drawBackground() {
              ctx.save();
              ctx.translate(plotOffset.left, plotOffset.top);
  
              ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, "rgba(255, 255, 255, 0)");
              ctx.fillRect(0, 0, plotWidth, plotHeight);
              ctx.restore();
          }
  
          function drawGrid() {
              var i, axes, bw, bc;
  
              ctx.save();
              ctx.translate(plotOffset.left, plotOffset.top);
  
              // draw markings
              var markings = options.grid.markings;
              if (markings) {
                  if ($.isFunction(markings)) {
                      axes = plot.getAxes();
                      // xmin etc. is backwards compatibility, to be
                      // removed in the future
                      axes.xmin = axes.xaxis.min;
                      axes.xmax = axes.xaxis.max;
                      axes.ymin = axes.yaxis.min;
                      axes.ymax = axes.yaxis.max;
  
                      markings = markings(axes);
                  }
  
                  for (i = 0; i < markings.length; ++i) {
                      var m = markings[i],
                          xrange = extractRange(m, "x"),
                          yrange = extractRange(m, "y");
  
                      // fill in missing
                      if (xrange.from == null)
                          xrange.from = xrange.axis.min;
                      if (xrange.to == null)
                          xrange.to = xrange.axis.max;
                      if (yrange.from == null)
                          yrange.from = yrange.axis.min;
                      if (yrange.to == null)
                          yrange.to = yrange.axis.max;
  
                      // clip
                      if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||
                          yrange.to < yrange.axis.min || yrange.from > yrange.axis.max)
                          continue;
  
                      xrange.from = Math.max(xrange.from, xrange.axis.min);
                      xrange.to = Math.min(xrange.to, xrange.axis.max);
                      yrange.from = Math.max(yrange.from, yrange.axis.min);
                      yrange.to = Math.min(yrange.to, yrange.axis.max);
  
                      if (xrange.from == xrange.to && yrange.from == yrange.to)
                          continue;
  
                      // then draw
                      xrange.from = xrange.axis.p2c(xrange.from);
                      xrange.to = xrange.axis.p2c(xrange.to);
                      yrange.from = yrange.axis.p2c(yrange.from);
                      yrange.to = yrange.axis.p2c(yrange.to);
  
                      if (xrange.from == xrange.to || yrange.from == yrange.to) {
                          // draw line
                          ctx.beginPath();
                          ctx.strokeStyle = m.color || options.grid.markingsColor;
                          ctx.lineWidth = m.lineWidth || options.grid.markingsLineWidth;
                          ctx.moveTo(xrange.from, yrange.from);
                          ctx.lineTo(xrange.to, yrange.to);
                          ctx.stroke();
                      }
                      else {
                          // fill area
                          ctx.fillStyle = m.color || options.grid.markingsColor;
                          ctx.fillRect(xrange.from, yrange.to,
                                       xrange.to - xrange.from,
                                       yrange.from - yrange.to);
                      }
                  }
              }
  
              // draw the ticks
              axes = allAxes();
              bw = options.grid.borderWidth;
  
              for (var j = 0; j < axes.length; ++j) {
                  var axis = axes[j], box = axis.box,
                      t = axis.tickLength, x, y, xoff, yoff;
                  if (!axis.show || axis.ticks.length == 0)
                      continue;
  
                  ctx.lineWidth = 1;
  
                  // find the edges
                  if (axis.direction == "x") {
                      x = 0;
                      if (t == "full")
                          y = (axis.position == "top" ? 0 : plotHeight);
                      else
                          y = box.top - plotOffset.top + (axis.position == "top" ? box.height : 0);
                  }
                  else {
                      y = 0;
                      if (t == "full")
                          x = (axis.position == "left" ? 0 : plotWidth);
                      else
                          x = box.left - plotOffset.left + (axis.position == "left" ? box.width : 0);
                  }
  
                  // draw tick bar
                  if (!axis.innermost) {
                      ctx.strokeStyle = axis.options.color;
                      ctx.beginPath();
                      xoff = yoff = 0;
                      if (axis.direction == "x")
                          xoff = plotWidth + 1;
                      else
                          yoff = plotHeight + 1;
  
                      if (ctx.lineWidth == 1) {
                          if (axis.direction == "x") {
                              y = Math.floor(y) + 0.5;
                          } else {
                              x = Math.floor(x) + 0.5;
                          }
                      }
  
                      ctx.moveTo(x, y);
                      ctx.lineTo(x + xoff, y + yoff);
                      ctx.stroke();
                  }
  
                  // draw ticks
  
                  ctx.strokeStyle = axis.options.tickColor;
  
                  ctx.beginPath();
                  for (i = 0; i < axis.ticks.length; ++i) {
                      var v = axis.ticks[i].v;
  
                      xoff = yoff = 0;
  
                      if (isNaN(v) || v < axis.min || v > axis.max
                          // skip those lying on the axes if we got a border
                          || (t == "full"
                              && ((typeof bw == "object" && bw[axis.position] > 0) || bw > 0)
                              && (v == axis.min || v == axis.max)))
                          continue;
  
                      if (axis.direction == "x") {
                          x = axis.p2c(v);
                          yoff = t == "full" ? -plotHeight : t;
  
                          if (axis.position == "top")
                              yoff = -yoff;
                      }
                      else {
                          y = axis.p2c(v);
                          xoff = t == "full" ? -plotWidth : t;
  
                          if (axis.position == "left")
                              xoff = -xoff;
                      }
  
                      if (ctx.lineWidth == 1) {
                          if (axis.direction == "x")
                              x = Math.floor(x) + 0.5;
                          else
                              y = Math.floor(y) + 0.5;
                      }
  
                      ctx.moveTo(x, y);
                      ctx.lineTo(x + xoff, y + yoff);
                  }
  
                  ctx.stroke();
              }
  
  
              // draw border
              if (bw) {
                  // If either borderWidth or borderColor is an object, then draw the border
                  // line by line instead of as one rectangle
                  bc = options.grid.borderColor;
                  if(typeof bw == "object" || typeof bc == "object") {
                      if (typeof bw !== "object") {
                          bw = {top: bw, right: bw, bottom: bw, left: bw};
                      }
                      if (typeof bc !== "object") {
                          bc = {top: bc, right: bc, bottom: bc, left: bc};
                      }
  
                      if (bw.top > 0) {
                          ctx.strokeStyle = bc.top;
                          ctx.lineWidth = bw.top;
                          ctx.beginPath();
                          ctx.moveTo(0 - bw.left, 0 - bw.top/2);
                          ctx.lineTo(plotWidth, 0 - bw.top/2);
                          ctx.stroke();
                      }
  
                      if (bw.right > 0) {
                          ctx.strokeStyle = bc.right;
                          ctx.lineWidth = bw.right;
                          ctx.beginPath();
                          ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);
                          ctx.lineTo(plotWidth + bw.right / 2, plotHeight);
                          ctx.stroke();
                      }
  
                      if (bw.bottom > 0) {
                          ctx.strokeStyle = bc.bottom;
                          ctx.lineWidth = bw.bottom;
                          ctx.beginPath();
                          ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);
                          ctx.lineTo(0, plotHeight + bw.bottom / 2);
                          ctx.stroke();
                      }
  
                      if (bw.left > 0) {
                          ctx.strokeStyle = bc.left;
                          ctx.lineWidth = bw.left;
                          ctx.beginPath();
                          ctx.moveTo(0 - bw.left/2, plotHeight + bw.bottom);
                          ctx.lineTo(0- bw.left/2, 0);
                          ctx.stroke();
                      }
                  }
                  else {
                      ctx.lineWidth = bw;
                      ctx.strokeStyle = options.grid.borderColor;
                      ctx.strokeRect(-bw/2, -bw/2, plotWidth + bw, plotHeight + bw);
                  }
              }
  
              ctx.restore();
          }
  
          function drawAxisLabels() {
  
              $.each(allAxes(), function (_, axis) {
                  var box = axis.box,
                      legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis",
                      layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles,
                      font = axis.options.font || "flot-tick-label tickLabel",
                      tick, x, y, halign, valign;
  
                  // Remove text before checking for axis.show and ticks.length;
                  // otherwise plugins, like flot-tickrotor, that draw their own
                  // tick labels will end up with both theirs and the defaults.
  
                  surface.removeText(layer);
  
                  if (!axis.show || axis.ticks.length == 0)
                      return;
  
                  for (var i = 0; i < axis.ticks.length; ++i) {
  
                      tick = axis.ticks[i];
                      if (!tick.label || tick.v < axis.min || tick.v > axis.max)
                          continue;
  
                      if (axis.direction == "x") {
                          halign = "center";
                          x = plotOffset.left + axis.p2c(tick.v);
                          if (axis.position == "bottom") {
                              y = box.top + box.padding;
                          } else {
                              y = box.top + box.height - box.padding;
                              valign = "bottom";
                          }
                      } else {
                          valign = "middle";
                          y = plotOffset.top + axis.p2c(tick.v);
                          if (axis.position == "left") {
                              x = box.left + box.width - box.padding;
                              halign = "right";
                          } else {
                              x = box.left + box.padding;
                          }
                      }
  
                      surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);
                  }
              });
          }
  
          function drawSeries(series) {
              if (series.lines.show)
                  drawSeriesLines(series);
              if (series.bars.show)
                  drawSeriesBars(series);
              if (series.points.show)
                  drawSeriesPoints(series);
          }
  
          function drawSeriesLines(series) {
              function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {
                  var points = datapoints.points,
                      ps = datapoints.pointsize,
                      prevx = null, prevy = null;
  
                  ctx.beginPath();
                  for (var i = ps; i < points.length; i += ps) {
                      var x1 = points[i - ps], y1 = points[i - ps + 1],
                          x2 = points[i], y2 = points[i + 1];
  
                      if (x1 == null || x2 == null)
                          continue;
  
                      // clip with ymin
                      if (y1 <= y2 && y1 < axisy.min) {
                          if (y2 < axisy.min)
                              continue;   // line segment is outside
                          // compute new intersection point
                          x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                          y1 = axisy.min;
                      }
                      else if (y2 <= y1 && y2 < axisy.min) {
                          if (y1 < axisy.min)
                              continue;
                          x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                          y2 = axisy.min;
                      }
  
                      // clip with ymax
                      if (y1 >= y2 && y1 > axisy.max) {
                          if (y2 > axisy.max)
                              continue;
                          x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                          y1 = axisy.max;
                      }
                      else if (y2 >= y1 && y2 > axisy.max) {
                          if (y1 > axisy.max)
                              continue;
                          x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                          y2 = axisy.max;
                      }
  
                      // clip with xmin
                      if (x1 <= x2 && x1 < axisx.min) {
                          if (x2 < axisx.min)
                              continue;
                          y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                          x1 = axisx.min;
                      }
                      else if (x2 <= x1 && x2 < axisx.min) {
                          if (x1 < axisx.min)
                              continue;
                          y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                          x2 = axisx.min;
                      }
  
                      // clip with xmax
                      if (x1 >= x2 && x1 > axisx.max) {
                          if (x2 > axisx.max)
                              continue;
                          y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                          x1 = axisx.max;
                      }
                      else if (x2 >= x1 && x2 > axisx.max) {
                          if (x1 > axisx.max)
                              continue;
                          y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                          x2 = axisx.max;
                      }
  
                      if (x1 != prevx || y1 != prevy)
                          ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);
  
                      prevx = x2;
                      prevy = y2;
                      ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);
                  }
                  ctx.stroke();
              }
  
              function plotLineArea(datapoints, axisx, axisy) {
                  var points = datapoints.points,
                      ps = datapoints.pointsize,
                      bottom = Math.min(Math.max(0, axisy.min), axisy.max),
                      i = 0, top, areaOpen = false,
                      ypos = 1, segmentStart = 0, segmentEnd = 0;
  
                  // we process each segment in two turns, first forward
                  // direction to sketch out top, then once we hit the
                  // end we go backwards to sketch the bottom
                  while (true) {
                      if (ps > 0 && i > points.length + ps)
                          break;
  
                      i += ps; // ps is negative if going backwards
  
                      var x1 = points[i - ps],
                          y1 = points[i - ps + ypos],
                          x2 = points[i], y2 = points[i + ypos];
  
                      if (areaOpen) {
                          if (ps > 0 && x1 != null && x2 == null) {
                              // at turning point
                              segmentEnd = i;
                              ps = -ps;
                              ypos = 2;
                              continue;
                          }
  
                          if (ps < 0 && i == segmentStart + ps) {
                              // done with the reverse sweep
                              ctx.fill();
                              areaOpen = false;
                              ps = -ps;
                              ypos = 1;
                              i = segmentStart = segmentEnd + ps;
                              continue;
                          }
                      }
  
                      if (x1 == null || x2 == null)
                          continue;
  
                      // clip x values
  
                      // clip with xmin
                      if (x1 <= x2 && x1 < axisx.min) {
                          if (x2 < axisx.min)
                              continue;
                          y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                          x1 = axisx.min;
                      }
                      else if (x2 <= x1 && x2 < axisx.min) {
                          if (x1 < axisx.min)
                              continue;
                          y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                          x2 = axisx.min;
                      }
  
                      // clip with xmax
                      if (x1 >= x2 && x1 > axisx.max) {
                          if (x2 > axisx.max)
                              continue;
                          y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                          x1 = axisx.max;
                      }
                      else if (x2 >= x1 && x2 > axisx.max) {
                          if (x1 > axisx.max)
                              continue;
                          y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                          x2 = axisx.max;
                      }
  
                      if (!areaOpen) {
                          // open area
                          ctx.beginPath();
                          ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));
                          areaOpen = true;
                      }
  
                      // now first check the case where both is outside
                      if (y1 >= axisy.max && y2 >= axisy.max) {
                          ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));
                          ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));
                          continue;
                      }
                      else if (y1 <= axisy.min && y2 <= axisy.min) {
                          ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));
                          ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));
                          continue;
                      }
  
                      // else it's a bit more complicated, there might
                      // be a flat maxed out rectangle first, then a
                      // triangular cutout or reverse; to find these
                      // keep track of the current x values
                      var x1old = x1, x2old = x2;
  
                      // clip the y values, without shortcutting, we
                      // go through all cases in turn
  
                      // clip with ymin
                      if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {
                          x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                          y1 = axisy.min;
                      }
                      else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {
                          x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                          y2 = axisy.min;
                      }
  
                      // clip with ymax
                      if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {
                          x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                          y1 = axisy.max;
                      }
                      else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {
                          x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                          y2 = axisy.max;
                      }
  
                      // if the x value was changed we got a rectangle
                      // to fill
                      if (x1 != x1old) {
                          ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));
                          // it goes to (x1, y1), but we fill that below
                      }
  
                      // fill triangular section, this sometimes result
                      // in redundant points if (x1, y1) hasn't changed
                      // from previous line to, but we just ignore that
                      ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));
                      ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));
  
                      // fill the other rectangle if it's there
                      if (x2 != x2old) {
                          ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));
                          ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));
                      }
                  }
              }
  
              ctx.save();
              ctx.translate(plotOffset.left, plotOffset.top);
              ctx.lineJoin = "round";
  
              var lw = series.lines.lineWidth,
                  sw = series.shadowSize;
              // FIXME: consider another form of shadow when filling is turned on
              if (lw > 0 && sw > 0) {
                  // draw shadow as a thick and thin line with transparency
                  ctx.lineWidth = sw;
                  ctx.strokeStyle = "rgba(0,0,0,0.1)";
                  // position shadow at angle from the mid of line
                  var angle = Math.PI/18;
                  plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/2), Math.cos(angle) * (lw/2 + sw/2), series.xaxis, series.yaxis);
                  ctx.lineWidth = sw/2;
                  plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/4), Math.cos(angle) * (lw/2 + sw/4), series.xaxis, series.yaxis);
              }
  
              ctx.lineWidth = lw;
              ctx.strokeStyle = series.color;
              var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);
              if (fillStyle) {
                  ctx.fillStyle = fillStyle;
                  plotLineArea(series.datapoints, series.xaxis, series.yaxis);
              }
  
              if (lw > 0)
                  plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);
              ctx.restore();
          }
  
          function drawSeriesPoints(series) {
              function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {
                  var points = datapoints.points, ps = datapoints.pointsize;
  
                  for (var i = 0; i < points.length; i += ps) {
                      var x = points[i], y = points[i + 1];
                      if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)
                          continue;
  
                      ctx.beginPath();
                      x = axisx.p2c(x);
                      y = axisy.p2c(y) + offset;
                      if (symbol == "circle")
                          ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);
                      else
                          symbol(ctx, x, y, radius, shadow);
                      ctx.closePath();
  
                      if (fillStyle) {
                          ctx.fillStyle = fillStyle;
                          ctx.fill();
                      }
                      ctx.stroke();
                  }
              }
  
              ctx.save();
              ctx.translate(plotOffset.left, plotOffset.top);
  
              var lw = series.points.lineWidth,
                  sw = series.shadowSize,
                  radius = series.points.radius,
                  symbol = series.points.symbol;
  
              // If the user sets the line width to 0, we change it to a very 
              // small value. A line width of 0 seems to force the default of 1.
              // Doing the conditional here allows the shadow setting to still be 
              // optional even with a lineWidth of 0.
  
              if( lw == 0 )
                  lw = 0.0001;
  
              if (lw > 0 && sw > 0) {
                  // draw shadow in two steps
                  var w = sw / 2;
                  ctx.lineWidth = w;
                  ctx.strokeStyle = "rgba(0,0,0,0.1)";
                  plotPoints(series.datapoints, radius, null, w + w/2, true,
                             series.xaxis, series.yaxis, symbol);
  
                  ctx.strokeStyle = "rgba(0,0,0,0.2)";
                  plotPoints(series.datapoints, radius, null, w/2, true,
                             series.xaxis, series.yaxis, symbol);
              }
  
              ctx.lineWidth = lw;
              ctx.strokeStyle = series.color;
              plotPoints(series.datapoints, radius,
                         getFillStyle(series.points, series.color), 0, false,
                         series.xaxis, series.yaxis, symbol);
              ctx.restore();
          }
  
          function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {
              var left, right, bottom, top,
                  drawLeft, drawRight, drawTop, drawBottom,
                  tmp;
  
              // in horizontal mode, we start the bar from the left
              // instead of from the bottom so it appears to be
              // horizontal rather than vertical
              if (horizontal) {
                  drawBottom = drawRight = drawTop = true;
                  drawLeft = false;
                  left = b;
                  right = x;
                  top = y + barLeft;
                  bottom = y + barRight;
  
                  // account for negative bars
                  if (right < left) {
                      tmp = right;
                      right = left;
                      left = tmp;
                      drawLeft = true;
                      drawRight = false;
                  }
              }
              else {
                  drawLeft = drawRight = drawTop = true;
                  drawBottom = false;
                  left = x + barLeft;
                  right = x + barRight;
                  bottom = b;
                  top = y;
  
                  // account for negative bars
                  if (top < bottom) {
                      tmp = top;
                      top = bottom;
                      bottom = tmp;
                      drawBottom = true;
                      drawTop = false;
                  }
              }
  
              // clip
              if (right < axisx.min || left > axisx.max ||
                  top < axisy.min || bottom > axisy.max)
                  return;
  
              if (left < axisx.min) {
                  left = axisx.min;
                  drawLeft = false;
              }
  
              if (right > axisx.max) {
                  right = axisx.max;
                  drawRight = false;
              }
  
              if (bottom < axisy.min) {
                  bottom = axisy.min;
                  drawBottom = false;
              }
  
              if (top > axisy.max) {
                  top = axisy.max;
                  drawTop = false;
              }
  
              left = axisx.p2c(left);
              bottom = axisy.p2c(bottom);
              right = axisx.p2c(right);
              top = axisy.p2c(top);
  
              // fill the bar
              if (fillStyleCallback) {
                  c.fillStyle = fillStyleCallback(bottom, top);
                  c.fillRect(left, top, right - left, bottom - top)
              }
  
              // draw outline
              if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {
                  c.beginPath();
  
                  // FIXME: inline moveTo is buggy with excanvas
                  c.moveTo(left, bottom);
                  if (drawLeft)
                      c.lineTo(left, top);
                  else
                      c.moveTo(left, top);
                  if (drawTop)
                      c.lineTo(right, top);
                  else
                      c.moveTo(right, top);
                  if (drawRight)
                      c.lineTo(right, bottom);
                  else
                      c.moveTo(right, bottom);
                  if (drawBottom)
                      c.lineTo(left, bottom);
                  else
                      c.moveTo(left, bottom);
                  c.stroke();
              }
          }
  
          function drawSeriesBars(series) {
              function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {
                  var points = datapoints.points, ps = datapoints.pointsize;
  
                  for (var i = 0; i < points.length; i += ps) {
                      if (points[i] == null)
                          continue;
                      drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);
                  }
              }
  
              ctx.save();
              ctx.translate(plotOffset.left, plotOffset.top);
  
              // FIXME: figure out a way to add shadows (for instance along the right edge)
              ctx.lineWidth = series.bars.lineWidth;
              ctx.strokeStyle = series.color;
  
              var barLeft;
  
              switch (series.bars.align) {
                  case "left":
                      barLeft = 0;
                      break;
                  case "right":
                      barLeft = -series.bars.barWidth;
                      break;
                  default:
                      barLeft = -series.bars.barWidth / 2;
              }
  
              var fillStyleCallback = series.bars.fill ? function (bottom, top) { return getFillStyle(series.bars, series.color, bottom, top); } : null;
              plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);
              ctx.restore();
          }
  
          function getFillStyle(filloptions, seriesColor, bottom, top) {
              var fill = filloptions.fill;
              if (!fill)
                  return null;
  
              if (filloptions.fillColor)
                  return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);
  
              var c = $.color.parse(seriesColor);
              c.a = typeof fill == "number" ? fill : 0.4;
              c.normalize();
              return c.toString();
          }
  
          function insertLegend() {
  
              if (options.legend.container != null) {
                  $(options.legend.container).html("");
              } else {
                  placeholder.find(".legend").remove();
              }
  
              if (!options.legend.show) {
                  return;
              }
  
              var fragments = [], entries = [], rowStarted = false,
                  lf = options.legend.labelFormatter, s, label;
  
              // Build a list of legend entries, with each having a label and a color
  
              for (var i = 0; i < series.length; ++i) {
                  s = series[i];
                  if (s.label) {
                      label = lf ? lf(s.label, s) : s.label;
                      if (label) {
                          entries.push({
                              label: label,
                              color: s.color
                          });
                      }
                  }
              }
  
              // Sort the legend using either the default or a custom comparator
  
              if (options.legend.sorted) {
                  if ($.isFunction(options.legend.sorted)) {
                      entries.sort(options.legend.sorted);
                  } else if (options.legend.sorted == "reverse") {
                      entries.reverse();
                  } else {
                      var ascending = options.legend.sorted != "descending";
                      entries.sort(function(a, b) {
                          return a.label == b.label ? 0 : (
                              (a.label < b.label) != ascending ? 1 : -1   // Logical XOR
                          );
                      });
                  }
              }
  
              // Generate markup for the list of entries, in their final order
  
              for (var i = 0; i < entries.length; ++i) {
  
                  var entry = entries[i];
  
                  if (i % options.legend.noColumns == 0) {
                      if (rowStarted)
                          fragments.push('</tr>');
                      fragments.push('<tr>');
                      rowStarted = true;
                  }
  
                  fragments.push(
                      '<td class="legendColorBox"><div style="border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px"><div style="width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden"></div></div></td>' +
                      '<td class="legendLabel">' + entry.label + '</td>'
                  );
              }
  
              if (rowStarted)
                  fragments.push('</tr>');
  
              if (fragments.length == 0)
                  return;
  
              var table = '<table style="font-size:smaller;color:' + options.grid.color + '">' + fragments.join("") + '</table>';
              if (options.legend.container != null)
                  $(options.legend.container).html(table);
              else {
                  var pos = "",
                      p = options.legend.position,
                      m = options.legend.margin;
                  if (m[0] == null)
                      m = [m, m];
                  if (p.charAt(0) == "n")
                      pos += 'top:' + (m[1] + plotOffset.top) + 'px;';
                  else if (p.charAt(0) == "s")
                      pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';
                  if (p.charAt(1) == "e")
                      pos += 'right:' + (m[0] + plotOffset.right) + 'px;';
                  else if (p.charAt(1) == "w")
                      pos += 'left:' + (m[0] + plotOffset.left) + 'px;';
                  var legend = $('<div class="legend">' + table.replace('style="', 'style="position:absolute;' + pos +';') + '</div>').appendTo(placeholder);
                  if (options.legend.backgroundOpacity != 0.0) {
                      // put in the transparent background
                      // separately to avoid blended labels and
                      // label boxes
                      var c = options.legend.backgroundColor;
                      if (c == null) {
                          c = options.grid.backgroundColor;
                          if (c && typeof c == "string")
                              c = $.color.parse(c);
                          else
                              c = $.color.extract(legend, 'background-color');
                          c.a = 1;
                          c = c.toString();
                      }
                      var div = legend.children();
                      $('<div style="position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos +'background-color:' + c + ';"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);
                  }
              }
          }
  
  
          // interactive features
  
          var highlights = [],
              redrawTimeout = null;
  
          // returns the data item the mouse is over, or null if none is found
          function findNearbyItem(mouseX, mouseY, seriesFilter) {
              var maxDistance = options.grid.mouseActiveRadius,
                  smallestDistance = maxDistance * maxDistance + 1,
                  item = null, foundPoint = false, i, j, ps;
  
              for (i = series.length - 1; i >= 0; --i) {
                  if (!seriesFilter(series[i]))
                      continue;
  
                  var s = series[i],
                      axisx = s.xaxis,
                      axisy = s.yaxis,
                      points = s.datapoints.points,
                      mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster
                      my = axisy.c2p(mouseY),
                      maxx = maxDistance / axisx.scale,
                      maxy = maxDistance / axisy.scale;
  
                  ps = s.datapoints.pointsize;
                  // with inverse transforms, we can't use the maxx/maxy
                  // optimization, sadly
                  if (axisx.options.inverseTransform)
                      maxx = Number.MAX_VALUE;
                  if (axisy.options.inverseTransform)
                      maxy = Number.MAX_VALUE;
  
                  if (s.lines.show || s.points.show) {
                      for (j = 0; j < points.length; j += ps) {
                          var x = points[j], y = points[j + 1];
                          if (x == null)
                              continue;
  
                          // For points and lines, the cursor must be within a
                          // certain distance to the data point
                          if (x - mx > maxx || x - mx < -maxx ||
                              y - my > maxy || y - my < -maxy)
                              continue;
  
                          // We have to calculate distances in pixels, not in
                          // data units, because the scales of the axes may be different
                          var dx = Math.abs(axisx.p2c(x) - mouseX),
                              dy = Math.abs(axisy.p2c(y) - mouseY),
                              dist = dx * dx + dy * dy; // we save the sqrt
  
                          // use <= to ensure last point takes precedence
                          // (last generally means on top of)
                          if (dist < smallestDistance) {
                              smallestDistance = dist;
                              item = [i, j / ps];
                          }
                      }
                  }
  
                  if (s.bars.show && !item) { // no other point can be nearby
  
                      var barLeft, barRight;
  
                      switch (s.bars.align) {
                          case "left":
                              barLeft = 0;
                              break;
                          case "right":
                              barLeft = -s.bars.barWidth;
                              break;
                          default:
                              barLeft = -s.bars.barWidth / 2;
                      }
  
                      barRight = barLeft + s.bars.barWidth;
  
                      for (j = 0; j < points.length; j += ps) {
                          var x = points[j], y = points[j + 1], b = points[j + 2];
                          if (x == null)
                              continue;
  
                          // for a bar graph, the cursor must be inside the bar
                          if (series[i].bars.horizontal ?
                              (mx <= Math.max(b, x) && mx >= Math.min(b, x) &&
                               my >= y + barLeft && my <= y + barRight) :
                              (mx >= x + barLeft && mx <= x + barRight &&
                               my >= Math.min(b, y) && my <= Math.max(b, y)))
                                  item = [i, j / ps];
                      }
                  }
              }
  
              if (item) {
                  i = item[0];
                  j = item[1];
                  ps = series[i].datapoints.pointsize;
  
                  return { datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),
                           dataIndex: j,
                           series: series[i],
                           seriesIndex: i };
              }
  
              return null;
          }
  
          function onMouseMove(e) {
              if (options.grid.hoverable)
                  triggerClickHoverEvent("plothover", e,
                                         function (s) { return s["hoverable"] != false; });
          }
  
          function onMouseLeave(e) {
              if (options.grid.hoverable)
                  triggerClickHoverEvent("plothover", e,
                                         function (s) { return false; });
          }
  
          function onClick(e) {
              triggerClickHoverEvent("plotclick", e,
                                     function (s) { return s["clickable"] != false; });
          }
  
          // trigger click or hover event (they send the same parameters
          // so we share their code)
          function triggerClickHoverEvent(eventname, event, seriesFilter) {
              var offset = eventHolder.offset(),
                  canvasX = event.pageX - offset.left - plotOffset.left,
                  canvasY = event.pageY - offset.top - plotOffset.top,
              pos = canvasToAxisCoords({ left: canvasX, top: canvasY });
  
              pos.pageX = event.pageX;
              pos.pageY = event.pageY;
  
              var item = findNearbyItem(canvasX, canvasY, seriesFilter);
  
              if (item) {
                  // fill in mouse pos for any listeners out there
                  item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);
                  item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);
              }
  
              if (options.grid.autoHighlight) {
                  // clear auto-highlights
                  for (var i = 0; i < highlights.length; ++i) {
                      var h = highlights[i];
                      if (h.auto == eventname &&
                          !(item && h.series == item.series &&
                            h.point[0] == item.datapoint[0] &&
                            h.point[1] == item.datapoint[1]))
                          unhighlight(h.series, h.point);
                  }
  
                  if (item)
                      highlight(item.series, item.datapoint, eventname);
              }
  
              placeholder.trigger(eventname, [ pos, item ]);
          }
  
          function triggerRedrawOverlay() {
              var t = options.interaction.redrawOverlayInterval;
              if (t == -1) {      // skip event queue
                  drawOverlay();
                  return;
              }
  
              if (!redrawTimeout)
                  redrawTimeout = setTimeout(drawOverlay, t);
          }
  
          function drawOverlay() {
              redrawTimeout = null;
  
              // draw highlights
              octx.save();
              overlay.clear();
              octx.translate(plotOffset.left, plotOffset.top);
  
              var i, hi;
              for (i = 0; i < highlights.length; ++i) {
                  hi = highlights[i];
  
                  if (hi.series.bars.show)
                      drawBarHighlight(hi.series, hi.point);
                  else
                      drawPointHighlight(hi.series, hi.point);
              }
              octx.restore();
  
              executeHooks(hooks.drawOverlay, [octx]);
          }
  
          function highlight(s, point, auto) {
              if (typeof s == "number")
                  s = series[s];
  
              if (typeof point == "number") {
                  var ps = s.datapoints.pointsize;
                  point = s.datapoints.points.slice(ps * point, ps * (point + 1));
              }
  
              var i = indexOfHighlight(s, point);
              if (i == -1) {
                  highlights.push({ series: s, point: point, auto: auto });
  
                  triggerRedrawOverlay();
              }
              else if (!auto)
                  highlights[i].auto = false;
          }
  
          function unhighlight(s, point) {
              if (s == null && point == null) {
                  highlights = [];
                  triggerRedrawOverlay();
                  return;
              }
  
              if (typeof s == "number")
                  s = series[s];
  
              if (typeof point == "number") {
                  var ps = s.datapoints.pointsize;
                  point = s.datapoints.points.slice(ps * point, ps * (point + 1));
              }
  
              var i = indexOfHighlight(s, point);
              if (i != -1) {
                  highlights.splice(i, 1);
  
                  triggerRedrawOverlay();
              }
          }
  
          function indexOfHighlight(s, p) {
              for (var i = 0; i < highlights.length; ++i) {
                  var h = highlights[i];
                  if (h.series == s && h.point[0] == p[0]
                      && h.point[1] == p[1])
                      return i;
              }
              return -1;
          }
  
          function drawPointHighlight(series, point) {
              var x = point[0], y = point[1],
                  axisx = series.xaxis, axisy = series.yaxis,
                  highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();
  
              if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)
                  return;
  
              var pointRadius = series.points.radius + series.points.lineWidth / 2;
              octx.lineWidth = pointRadius;
              octx.strokeStyle = highlightColor;
              var radius = 1.5 * pointRadius;
              x = axisx.p2c(x);
              y = axisy.p2c(y);
  
              octx.beginPath();
              if (series.points.symbol == "circle")
                  octx.arc(x, y, radius, 0, 2 * Math.PI, false);
              else
                  series.points.symbol(octx, x, y, radius, false);
              octx.closePath();
              octx.stroke();
          }
  
          function drawBarHighlight(series, point) {
              var highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),
                  fillStyle = highlightColor,
                  barLeft;
  
              switch (series.bars.align) {
                  case "left":
                      barLeft = 0;
                      break;
                  case "right":
                      barLeft = -series.bars.barWidth;
                      break;
                  default:
                      barLeft = -series.bars.barWidth / 2;
              }
  
              octx.lineWidth = series.bars.lineWidth;
              octx.strokeStyle = highlightColor;
  
              drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,
                      function () { return fillStyle; }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);
          }
  
          function getColorOrGradient(spec, bottom, top, defaultColor) {
              if (typeof spec == "string")
                  return spec;
              else {
                  // assume this is a gradient spec; IE currently only
                  // supports a simple vertical gradient properly, so that's
                  // what we support too
                  var gradient = ctx.createLinearGradient(0, top, 0, bottom);
  
                  for (var i = 0, l = spec.colors.length; i < l; ++i) {
                      var c = spec.colors[i];
                      if (typeof c != "string") {
                          var co = $.color.parse(defaultColor);
                          if (c.brightness != null)
                              co = co.scale('rgb', c.brightness);
                          if (c.opacity != null)
                              co.a *= c.opacity;
                          c = co.toString();
                      }
                      gradient.addColorStop(i / (l - 1), c);
                  }
  
                  return gradient;
              }
          }
      }
  
      // Add the plot function to the top level of the jQuery object
  
      $.plot = function(placeholder, data, options) {
          //var t0 = new Date();
          var plot = new Plot($(placeholder), data, options, $.plot.plugins);
          //(window.console ? console.log : alert)("time used (msecs): " + ((new Date()).getTime() - t0.getTime()));
          return plot;
      };
  
      $.plot.version = "0.8.2";
  
      $.plot.plugins = [];
  
      // Also add the plot function as a chainable property
  
      $.fn.plot = function(data, options) {
          return this.each(function() {
              $.plot(this, data, options);
          });
      };
  
      // round to nearby lower multiple of base
      function floorInBase(n, base) {
          return base * Math.floor(n / base);
      }
  
  })(jQuery);
  /* Flot plugin for selecting regions of a plot.
  
  Copyright (c) 2007-2013 IOLA and Ole Laursen.
  Licensed under the MIT license.
  
  The plugin supports these options:
  
  selection: {
      mode: null or "x" or "y" or "xy",
      color: color,
      shape: "round" or "miter" or "bevel",
      minSize: number of pixels
  }
  
  Selection support is enabled by setting the mode to one of "x", "y" or "xy".
  In "x" mode, the user will only be able to specify the x range, similarly for
  "y" mode. For "xy", the selection becomes a rectangle where both ranges can be
  specified. "color" is color of the selection (if you need to change the color
  later on, you can get to it with plot.getOptions().selection.color). "shape"
  is the shape of the corners of the selection.
  
  "minSize" is the minimum size a selection can be in pixels. This value can
  be customized to determine the smallest size a selection can be and still
  have the selection rectangle be displayed. When customizing this value, the
  fact that it refers to pixels, not axis units must be taken into account.
  Thus, for example, if there is a bar graph in time mode with BarWidth set to 1
  minute, setting "minSize" to 1 will not make the minimum selection size 1
  minute, but rather 1 pixel. Note also that setting "minSize" to 0 will prevent
  "plotunselected" events from being fired when the user clicks the mouse without
  dragging.
  
  When selection support is enabled, a "plotselected" event will be emitted on
  the DOM element you passed into the plot function. The event handler gets a
  parameter with the ranges selected on the axes, like this:
  
      placeholder.bind( "plotselected", function( event, ranges ) {
          alert("You selected " + ranges.xaxis.from + " to " + ranges.xaxis.to)
          // similar for yaxis - with multiple axes, the extra ones are in
          // x2axis, x3axis, ...
      });
  
  The "plotselected" event is only fired when the user has finished making the
  selection. A "plotselecting" event is fired during the process with the same
  parameters as the "plotselected" event, in case you want to know what's
  happening while it's happening,
  
  A "plotunselected" event with no arguments is emitted when the user clicks the
  mouse to remove the selection. As stated above, setting "minSize" to 0 will
  destroy this behavior.
  
  The plugin allso adds the following methods to the plot object:
  
  - setSelection( ranges, preventEvent )
  
    Set the selection rectangle. The passed in ranges is on the same form as
    returned in the "plotselected" event. If the selection mode is "x", you
    should put in either an xaxis range, if the mode is "y" you need to put in
    an yaxis range and both xaxis and yaxis if the selection mode is "xy", like
    this:
  
      setSelection({ xaxis: { from: 0, to: 10 }, yaxis: { from: 40, to: 60 } });
  
    setSelection will trigger the "plotselected" event when called. If you don't
    want that to happen, e.g. if you're inside a "plotselected" handler, pass
    true as the second parameter. If you are using multiple axes, you can
    specify the ranges on any of those, e.g. as x2axis/x3axis/... instead of
    xaxis, the plugin picks the first one it sees.
  
  - clearSelection( preventEvent )
  
    Clear the selection rectangle. Pass in true to avoid getting a
    "plotunselected" event.
  
  - getSelection()
  
    Returns the current selection in the same format as the "plotselected"
    event. If there's currently no selection, the function returns null.
  
  */
  
  
  (function ($) {
      function init(plot) {
          var selection = {
                  first: { x: -1, y: -1}, second: { x: -1, y: -1},
                  show: false,
                  active: false
              };
  
          // FIXME: The drag handling implemented here should be
          // abstracted out, there's some similar code from a library in
          // the navigation plugin, this should be massaged a bit to fit
          // the Flot cases here better and reused. Doing this would
          // make this plugin much slimmer.
          var savedhandlers = {};
  
          var mouseUpHandler = null;
          
          function onMouseMove(e) {
              if (selection.active) {
                  updateSelection(e);
                  
                  plot.getPlaceholder().trigger("plotselecting", [ getSelection() ]);
              }
          }
  
          function onMouseDown(e) {
              if (e.which != 1)  // only accept left-click
                  return;
              
              // cancel out any text selections
              document.body.focus();
  
              // prevent text selection and drag in old-school browsers
              if (document.onselectstart !== undefined && savedhandlers.onselectstart == null) {
                  savedhandlers.onselectstart = document.onselectstart;
                  document.onselectstart = function () { return false; };
              }
              if (document.ondrag !== undefined && savedhandlers.ondrag == null) {
                  savedhandlers.ondrag = document.ondrag;
                  document.ondrag = function () { return false; };
              }
  
              setSelectionPos(selection.first, e);
  
              selection.active = true;
  
              // this is a bit silly, but we have to use a closure to be
              // able to whack the same handler again
              mouseUpHandler = function (e) { onMouseUp(e); };
              
              $(document).one("mouseup", mouseUpHandler);
          }
  
          function onMouseUp(e) {
              mouseUpHandler = null;
              
              // revert drag stuff for old-school browsers
              if (document.onselectstart !== undefined)
                  document.onselectstart = savedhandlers.onselectstart;
              if (document.ondrag !== undefined)
                  document.ondrag = savedhandlers.ondrag;
  
              // no more dragging
              selection.active = false;
              updateSelection(e);
  
              if (selectionIsSane())
                  triggerSelectedEvent();
              else {
                  // this counts as a clear
                  plot.getPlaceholder().trigger("plotunselected", [ ]);
                  plot.getPlaceholder().trigger("plotselecting", [ null ]);
              }
  
              return false;
          }
  
          function getSelection() {
              if (!selectionIsSane())
                  return null;
              
              if (!selection.show) return null;
  
              var r = {}, c1 = selection.first, c2 = selection.second;
              $.each(plot.getAxes(), function (name, axis) {
                  if (axis.used) {
                      var p1 = axis.c2p(c1[axis.direction]), p2 = axis.c2p(c2[axis.direction]); 
                      r[name] = { from: Math.min(p1, p2), to: Math.max(p1, p2) };
                  }
              });
              return r;
          }
  
          function triggerSelectedEvent() {
              var r = getSelection();
  
              plot.getPlaceholder().trigger("plotselected", [ r ]);
  
              // backwards-compat stuff, to be removed in future
              if (r.xaxis && r.yaxis)
                  plot.getPlaceholder().trigger("selected", [ { x1: r.xaxis.from, y1: r.yaxis.from, x2: r.xaxis.to, y2: r.yaxis.to } ]);
          }
  
          function clamp(min, value, max) {
              return value < min ? min: (value > max ? max: value);
          }
  
          function setSelectionPos(pos, e) {
              var o = plot.getOptions();
              var offset = plot.getPlaceholder().offset();
              var plotOffset = plot.getPlotOffset();
              pos.x = clamp(0, e.pageX - offset.left - plotOffset.left, plot.width());
              pos.y = clamp(0, e.pageY - offset.top - plotOffset.top, plot.height());
  
              if (o.selection.mode == "y")
                  pos.x = pos == selection.first ? 0 : plot.width();
  
              if (o.selection.mode == "x")
                  pos.y = pos == selection.first ? 0 : plot.height();
          }
  
          function updateSelection(pos) {
              if (pos.pageX == null)
                  return;
  
              setSelectionPos(selection.second, pos);
              if (selectionIsSane()) {
                  selection.show = true;
                  plot.triggerRedrawOverlay();
              }
              else
                  clearSelection(true);
          }
  
          function clearSelection(preventEvent) {
              if (selection.show) {
                  selection.show = false;
                  plot.triggerRedrawOverlay();
                  if (!preventEvent)
                      plot.getPlaceholder().trigger("plotunselected", [ ]);
              }
          }
  
          // function taken from markings support in Flot
          function extractRange(ranges, coord) {
              var axis, from, to, key, axes = plot.getAxes();
  
              for (var k in axes) {
                  axis = axes[k];
                  if (axis.direction == coord) {
                      key = coord + axis.n + "axis";
                      if (!ranges[key] && axis.n == 1)
                          key = coord + "axis"; // support x1axis as xaxis
                      if (ranges[key]) {
                          from = ranges[key].from;
                          to = ranges[key].to;
                          break;
                      }
                  }
              }
  
              // backwards-compat stuff - to be removed in future
              if (!ranges[key]) {
                  axis = coord == "x" ? plot.getXAxes()[0] : plot.getYAxes()[0];
                  from = ranges[coord + "1"];
                  to = ranges[coord + "2"];
              }
  
              // auto-reverse as an added bonus
              if (from != null && to != null && from > to) {
                  var tmp = from;
                  from = to;
                  to = tmp;
              }
              
              return { from: from, to: to, axis: axis };
          }
          
          function setSelection(ranges, preventEvent) {
              var axis, range, o = plot.getOptions();
  
              if (o.selection.mode == "y") {
                  selection.first.x = 0;
                  selection.second.x = plot.width();
              }
              else {
                  range = extractRange(ranges, "x");
  
                  selection.first.x = range.axis.p2c(range.from);
                  selection.second.x = range.axis.p2c(range.to);
              }
  
              if (o.selection.mode == "x") {
                  selection.first.y = 0;
                  selection.second.y = plot.height();
              }
              else {
                  range = extractRange(ranges, "y");
  
                  selection.first.y = range.axis.p2c(range.from);
                  selection.second.y = range.axis.p2c(range.to);
              }
  
              selection.show = true;
              plot.triggerRedrawOverlay();
              if (!preventEvent && selectionIsSane())
                  triggerSelectedEvent();
          }
  
          function selectionIsSane() {
              var minSize = plot.getOptions().selection.minSize;
              return Math.abs(selection.second.x - selection.first.x) >= minSize &&
                  Math.abs(selection.second.y - selection.first.y) >= minSize;
          }
  
          plot.clearSelection = clearSelection;
          plot.setSelection = setSelection;
          plot.getSelection = getSelection;
  
          plot.hooks.bindEvents.push(function(plot, eventHolder) {
              var o = plot.getOptions();
              if (o.selection.mode != null) {
                  eventHolder.mousemove(onMouseMove);
                  eventHolder.mousedown(onMouseDown);
              }
          });
  
  
          plot.hooks.drawOverlay.push(function (plot, ctx) {
              // draw selection
              if (selection.show && selectionIsSane()) {
                  var plotOffset = plot.getPlotOffset();
                  var o = plot.getOptions();
  
                  ctx.save();
                  ctx.translate(plotOffset.left, plotOffset.top);
  
                  var c = $.color.parse(o.selection.color);
  
                  ctx.strokeStyle = c.scale('a', 0.8).toString();
                  ctx.lineWidth = 1;
                  ctx.lineJoin = o.selection.shape;
                  ctx.fillStyle = c.scale('a', 0.4).toString();
  
                  var x = Math.min(selection.first.x, selection.second.x) + 0.5,
                      y = Math.min(selection.first.y, selection.second.y) + 0.5,
                      w = Math.abs(selection.second.x - selection.first.x) - 1,
                      h = Math.abs(selection.second.y - selection.first.y) - 1;
  
                  ctx.fillRect(x, y, w, h);
                  ctx.strokeRect(x, y, w, h);
  
                  ctx.restore();
              }
          });
          
          plot.hooks.shutdown.push(function (plot, eventHolder) {
              eventHolder.unbind("mousemove", onMouseMove);
              eventHolder.unbind("mousedown", onMouseDown);
              
              if (mouseUpHandler)
                  $(document).unbind("mouseup", mouseUpHandler);
          });
  
      }
  
      $.plot.plugins.push({
          init: init,
          options: {
              selection: {
                  mode: null, // one of null, "x", "y" or "xy"
                  color: "#e8cfac",
                  shape: "round", // one of "round", "miter", or "bevel"
                  minSize: 5 // minimum number of pixels
              }
          },
          name: 'selection',
          version: '1.1'
      });
  })(jQuery);
  /* =========================================================
   * bootstrap-slider.js v2.0.0
   * http://www.eyecon.ro/bootstrap-slider
   * =========================================================
   * Copyright 2012 Stefan Petre
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * ========================================================= */
  
   
  !function( $ ) {
  
    var Slider = function(element, options) {
      this.element = $(element);
      this.picker = $('<div class="slider">'+
                '<div class="slider-track">'+
                  '<div class="slider-selection"></div>'+
                  '<div class="slider-handle"></div>'+
                  '<div class="slider-handle"></div>'+
                '</div>'+
                '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'+
              '</div>')
                .insertBefore(this.element)
                .append(this.element);
      this.id = this.element.data('slider-id')||options.id;
      if (this.id) {
        this.picker[0].id = this.id;
      }
  
      if (typeof Modernizr !== 'undefined' && Modernizr.touch) {
        this.touchCapable = true;
      }
  
      var tooltip = this.element.data('slider-tooltip')||options.tooltip;
  
      this.tooltip = this.picker.find('.tooltip');
      this.tooltipInner = this.tooltip.find('div.tooltip-inner');
  
      this.orientation = this.element.data('slider-orientation')||options.orientation;
      switch(this.orientation) {
        case 'vertical':
          this.picker.addClass('slider-vertical');
          this.stylePos = 'top';
          this.mousePos = 'pageY';
          this.sizePos = 'offsetHeight';
          this.tooltip.addClass('right')[0].style.left = '100%';
          break;
        default:
          this.picker
            .addClass('slider-horizontal')
            .css('width', this.element.outerWidth());
          this.orientation = 'horizontal';
          this.stylePos = 'left';
          this.mousePos = 'pageX';
          this.sizePos = 'offsetWidth';
          this.tooltip.addClass('top')[0].style.top = -this.tooltip.outerHeight() - 14 + 'px';
          break;
      }
  
      this.min = this.element.data('slider-min')||options.min;
      this.max = this.element.data('slider-max')||options.max;
      this.step = this.element.data('slider-step')||options.step;
      this.value = this.element.data('slider-value')||options.value;
      if (this.value[1]) {
        this.range = true;
      }
  
      this.selection = this.element.data('slider-selection')||options.selection;
      this.selectionEl = this.picker.find('.slider-selection');
      if (this.selection === 'none') {
        this.selectionEl.addClass('hide');
      }
      this.selectionElStyle = this.selectionEl[0].style;
  
  
      this.handle1 = this.picker.find('.slider-handle:first');
      this.handle1Stype = this.handle1[0].style;
      this.handle2 = this.picker.find('.slider-handle:last');
      this.handle2Stype = this.handle2[0].style;
  
      var handle = this.element.data('slider-handle')||options.handle;
      switch(handle) {
        case 'round':
          this.handle1.addClass('round');
          this.handle2.addClass('round');
          break
        case 'triangle':
          this.handle1.addClass('triangle');
          this.handle2.addClass('triangle');
          break
      }
  
      if (this.range) {
        this.value[0] = Math.max(this.min, Math.min(this.max, this.value[0]));
        this.value[1] = Math.max(this.min, Math.min(this.max, this.value[1]));
      } else {
        this.value = [ Math.max(this.min, Math.min(this.max, this.value))];
        this.handle2.addClass('hide');
        if (this.selection == 'after') {
          this.value[1] = this.max;
        } else {
          this.value[1] = this.min;
        }
      }
      this.diff = this.max - this.min;
      this.percentage = [
        (this.value[0]-this.min)*100/this.diff,
        (this.value[1]-this.min)*100/this.diff,
        this.step*100/this.diff
      ];
  
      this.offset = this.picker.offset();
      this.size = this.picker[0][this.sizePos];
  
      this.formater = options.formater;
  
      this.layout();
  
      if (this.touchCapable) {
        // Touch: Bind touch events:
        this.picker.on({
          touchstart: $.proxy(this.mousedown, this)
        });
      } else {
        this.picker.on({
          mousedown: $.proxy(this.mousedown, this)
        });
      }
  
      if (tooltip === 'show') {
        this.picker.on({
          mouseenter: $.proxy(this.showTooltip, this),
          mouseleave: $.proxy(this.hideTooltip, this)
        });
      } else {
        this.tooltip.addClass('hide');
      }
    };
  
    Slider.prototype = {
      constructor: Slider,
  
      over: false,
      inDrag: false,
      
      showTooltip: function(){
        this.tooltip.addClass('in');
        //var left = Math.round(this.percent*this.width);
        //this.tooltip.css('left', left - this.tooltip.outerWidth()/2);
        this.over = true;
      },
      
      hideTooltip: function(){
        if (this.inDrag === false) {
          this.tooltip.removeClass('in');
        }
        this.over = false;
      },
  
      layout: function(){
        this.handle1Stype[this.stylePos] = this.percentage[0]+'%';
        this.handle2Stype[this.stylePos] = this.percentage[1]+'%';
        if (this.orientation == 'vertical') {
          this.selectionElStyle.top = Math.min(this.percentage[0], this.percentage[1]) +'%';
          this.selectionElStyle.height = Math.abs(this.percentage[0] - this.percentage[1]) +'%';
        } else {
          this.selectionElStyle.left = Math.min(this.percentage[0], this.percentage[1]) +'%';
          this.selectionElStyle.width = Math.abs(this.percentage[0] - this.percentage[1]) +'%';
        }
        if (this.range) {
          this.tooltipInner.text(
            this.formater(this.value[0]) + 
            ' : ' + 
            this.formater(this.value[1])
          );
          this.tooltip[0].style[this.stylePos] = this.size * (this.percentage[0] + (this.percentage[1] - this.percentage[0])/2)/100 - (this.orientation === 'vertical' ? this.tooltip.outerHeight()/2 : this.tooltip.outerWidth()/2) +'px';
        } else {
          this.tooltipInner.text(
            this.formater(this.value[0])
          );
          this.tooltip[0].style[this.stylePos] = this.size * this.percentage[0]/100 - (this.orientation === 'vertical' ? this.tooltip.outerHeight()/2 : this.tooltip.outerWidth()/2) +'px';
        }
      },
  
      mousedown: function(ev) {
  
        // Touch: Get the original event:
        if (this.touchCapable && ev.type === 'touchstart') {
          ev = ev.originalEvent;
        }
  
        this.offset = this.picker.offset();
        this.size = this.picker[0][this.sizePos];
  
        var percentage = this.getPercentage(ev);
  
        if (this.range) {
          var diff1 = Math.abs(this.percentage[0] - percentage);
          var diff2 = Math.abs(this.percentage[1] - percentage);
          this.dragged = (diff1 < diff2) ? 0 : 1;
        } else {
          this.dragged = 0;
        }
  
        this.percentage[this.dragged] = percentage;
        this.layout();
  
        if (this.touchCapable) {
          // Touch: Bind touch events:
          $(document).on({
            touchmove: $.proxy(this.mousemove, this),
            touchend: $.proxy(this.mouseup, this)
          });
        } else {
          $(document).on({
            mousemove: $.proxy(this.mousemove, this),
            mouseup: $.proxy(this.mouseup, this)
          });
        }
  
        this.inDrag = true;
        var val = this.calculateValue();
        this.element.trigger({
            type: 'slideStart',
            value: val
          }).trigger({
            type: 'slide',
            value: val
          });
        return false;
      },
  
      mousemove: function(ev) {
        
        // Touch: Get the original event:
        if (this.touchCapable && ev.type === 'touchmove') {
          ev = ev.originalEvent;
        }
  
        var percentage = this.getPercentage(ev);
        if (this.range) {
          if (this.dragged === 0 && this.percentage[1] < percentage) {
            this.percentage[0] = this.percentage[1];
            this.dragged = 1;
          } else if (this.dragged === 1 && this.percentage[0] > percentage) {
            this.percentage[1] = this.percentage[0];
            this.dragged = 0;
          }
        }
        this.percentage[this.dragged] = percentage;
        this.layout();
        var val = this.calculateValue();
        this.element
          .trigger({
            type: 'slide',
            value: val
          })
          .data('value', val)
          .prop('value', val);
        return false;
      },
  
      mouseup: function(ev) {
        if (this.touchCapable) {
          // Touch: Bind touch events:
          $(document).off({
            touchmove: this.mousemove,
            touchend: this.mouseup
          });
        } else {
          $(document).off({
            mousemove: this.mousemove,
            mouseup: this.mouseup
          });
        }
  
        this.inDrag = false;
        if (this.over == false) {
          this.hideTooltip();
        }
        this.element;
        var val = this.calculateValue();
        this.element
          .trigger({
            type: 'slideStop',
            value: val
          })
          .data('value', val)
          .prop('value', val);
        return false;
      },
  
      calculateValue: function() {
        var val;
        if (this.range) {
          val = [
            (this.min + Math.round((this.diff * this.percentage[0]/100)/this.step)*this.step),
            (this.min + Math.round((this.diff * this.percentage[1]/100)/this.step)*this.step)
          ];
          this.value = val;
        } else {
          val = (this.min + Math.round((this.diff * this.percentage[0]/100)/this.step)*this.step);
          this.value = [val, this.value[1]];
        }
        return val;
      },
  
      getPercentage: function(ev) {
        if (this.touchCapable) {
          ev = ev.touches[0];
        }
        var percentage = (ev[this.mousePos] - this.offset[this.stylePos])*100/this.size;
        percentage = Math.round(percentage/this.percentage[2])*this.percentage[2];
        return Math.max(0, Math.min(100, percentage));
      },
  
      getValue: function() {
        if (this.range) {
          return this.value;
        }
        return this.value[0];
      },
  
      setValue: function(val) {
        this.value = val;
  
        if (this.range) {
          this.value[0] = Math.max(this.min, Math.min(this.max, this.value[0]));
          this.value[1] = Math.max(this.min, Math.min(this.max, this.value[1]));
        } else {
          this.value = [ Math.max(this.min, Math.min(this.max, this.value))];
          this.handle2.addClass('hide');
          if (this.selection == 'after') {
            this.value[1] = this.max;
          } else {
            this.value[1] = this.min;
          }
        }
        this.diff = this.max - this.min;
        this.percentage = [
          (this.value[0]-this.min)*100/this.diff,
          (this.value[1]-this.min)*100/this.diff,
          this.step*100/this.diff
        ];
        this.layout();
      }
    };
  
    $.fn.slider = function ( option, val ) {
      return this.each(function () {
        var $this = $(this),
          data = $this.data('slider'),
          options = typeof option === 'object' && option;
        if (!data)  {
          $this.data('slider', (data = new Slider(this, $.extend({}, $.fn.slider.defaults,options))));
        }
        if (typeof option == 'string') {
          data[option](val);
        }
      })
    };
  
    $.fn.slider.defaults = {
      min: 0,
      max: 10,
      step: 1,
      orientation: 'horizontal',
      value: 5,
      selection: 'before',
      tooltip: 'show',
      handle: 'round',
      formater: function(value) {
        return value;
      }
    };
  
    $.fn.slider.Constructor = Slider;
  
  }( window.jQuery );
  // for Blacklight.onLoad:
  
  /* A custom event "plotDrawn.blacklight.rangeLimit" will be sent when flot plot
     is (re-)drawn on screen possibly with a new size. target of event will be the DOM element
     containing the plot.  Used to resize slider to match. */
  
  
  Blacklight.onLoad(function() {
    // ratio of width to height for desired display, multiply width by this ratio
    // to get height. hard-coded in for now.
    var display_ratio = 1/(1.618 * 2); // half a golden rectangle, why not
    var redrawnEvent = "plotDrawn.blacklight.rangeLimit";
  
  
  
    // Facets already on the page? Turn em into a chart.
    $(".range_limit .profile .distribution.chart_js ul").each(function() {
        turnIntoPlot($(this).parent());
    });
  
  
    // Add AJAX fetched range facets if needed, and add a chart to em
    $(".range_limit .profile .distribution a.load_distribution").each(function() {
        var container = $(this).parent('div.distribution');
  
        $(container).load($(this).attr('href'), function(response, status) {
            if ($(container).hasClass("chart_js") && status == "success" ) {
              turnIntoPlot(container);
            }
        });
    });
  
    // Listen for twitter bootstrap collapsible open events, to render flot
    // in previously hidden divs on open, if needed.
    $("body").on("show.bs.collapse", function(event) {
      // Was the target a .facet-content including a .chart-js?
      var container =  $(event.target).filter(".facet-content").find(".chart_js");
  
      // only if it doesn't already have a canvas, it isn't already drawn
      if (container && container.find("canvas").length == 0) {
        // be willing to wait up to 1100ms for container to
        // have width -- right away on show.bs is too soon, but
        // shown.bs is later than we want, we want to start rendering
        // while animation is still in progress.
        turnIntoPlot(container, 1100);
      }
    });
  
  
  
    // after a collapsible facet contents is fully shown,
    // resize the flot chart to current conditions. This way, if you change
    // browser window size, you can get chart resized to fit by closing and opening
    // again, if needed.
  
    function redrawPlot(container) {
      if (container && container.width() > 0) {
        // resize the container's height, since width may have changed.
        container.height( container.width() * display_ratio  );
  
        // redraw the chart.
        var plot = container.data("plot");
        if (plot) {
          // how to redraw after possible resize?
          // Cribbed from https://github.com/flot/flot/blob/master/jquery.flot.resize.js
          plot.resize();
          plot.setupGrid();
          plot.draw();
          // plus trigger redraw of the selection, which otherwise ain't always right
          // we'll trigger a fake event on one of the boxes
          var form = $(container).closest(".limit_content").find("form.range_limit");
          form.find("input.range_begin").trigger("change");
  
          // send our custom event to trigger redraw of slider
          $(container).trigger(redrawnEvent);
        }
      }
    }
  
    $("body").on("shown.bs.collapse", function(event) {
      var container =  $(event.target).filter(".facet-content").find(".chart_js");
      redrawPlot(container);
    });
  
    // debouce borrowed from underscore
    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    debounce = function(func, wait, immediate) {
      var timeout;
      return function() {
        var context = this, args = arguments;
        var later = function() {
          timeout = null;
          if (!immediate) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
      };
    };
  
    $(window).on("resize", debounce(function() {
      $(".chart_js").each(function(i, container) {
        redrawPlot($(container));
      });
    }, 350));
  
    // second arg, if provided, is a number of ms we're willing to
    // wait for the container to have width before giving up -- we'll
    // set 50ms timers to check back until timeout is expired or the
    // container is finally visible. The timeout is used when we catch
    // bootstrap show event, but the animation hasn't barely begun yet -- but
    // we don't want to wait until it's finished, we want to start rendering
    // as soon as we can.
    //
    // We also will
    function turnIntoPlot(container, wait_for_visible) {
      // flot can only render in a a div with a defined width.
      // for instance, a hidden div can't generally be rendered in (although if you set
      // an explicit width on it, it might work)
      //
      // We'll count on later code that catch bootstrap collapse open to render
      // on show, for currently hidden divs.
  
      // for some reason width sometimes return negative, not sure
      // why but it's some kind of hidden.
      if (container.width() > 0) {
        var height = container.width() * display_ratio;
  
        // Need an explicit height to make flot happy.
        container.height( height )
  
        areaChart($(container));
  
        $(container).trigger(redrawnEvent);
      }
      else if (wait_for_visible > 0) {
        setTimeout(function() {
          turnIntoPlot(container, wait_for_visible - 50);
        }, 50);
      }
    }
  
       // Takes a div holding a ul of distribution segments produced by
      // blacklight_range_limit/_range_facets and makes it into
      // a flot area chart.
      function areaChart(container) {
        //flot loaded? And canvas element supported.
        if (  domDependenciesMet()  ) {
  
          // Grab the data from the ul div
          var series_data = new Array();
          var pointer_lookup = new Array();
          var x_ticks = new Array();
          var min = BlacklightRangeLimit.parseNum($(container).find("ul li:first-child span.from").text());
          var max = BlacklightRangeLimit.parseNum($(container).find("ul li:last-child span.to").text());
  
          $(container).find("ul li").each(function() {
              var from = BlacklightRangeLimit.parseNum($(this).find("span.from").text());
              var to = BlacklightRangeLimit.parseNum($(this).find("span.to").text());
              var count = BlacklightRangeLimit.parseNum($(this).find("span.count").text());
              var avg = (count / (to - from + 1));
  
  
              //We use the avg as the y-coord, to make the area of each
              //segment proportional to how many documents it holds.
              series_data.push( [from, avg ] );
              series_data.push( [to+1, avg] );
  
              x_ticks.push(from);
  
              pointer_lookup.push({'from': from, 'to': to, 'count': count, 'label': $(this).find(".facet_select").text() });
          });
          var max_plus_one = BlacklightRangeLimit.parseNum($(container).find("ul li:last-child span.to").text())+1;
          x_ticks.push( max_plus_one );
  
  
  
          var plot;
          var config = $(container).closest('.facet_limit').data('plot-config') || {};
  
          try {
            plot = $.plot($(container), [series_data],
                $.extend(true, config, {
                yaxis: {  ticks: [], min: 0, autoscaleMargin: 0.1},
              //xaxis: { ticks: x_ticks },
              xaxis: { tickDecimals: 0 }, // force integer ticks
              series: { lines: { fill: true, steps: true }},
              grid: {clickable: true, hoverable: true, autoHighlight: false},
              selection: {mode: "x"}
            }));
          }
          catch(err) {
            alert(err);
          }
  
          find_segment_for = function_for_find_segment(pointer_lookup);
          var last_segment = null;
          $(container).tooltip({'placement': 'bottom', 'trigger': 'manual', 'delay': { show: 0, hide: 100}});
  
          $(container).bind("plothover", function (event, pos, item) {
            segment = find_segment_for(pos.x);
  
            if(segment != last_segment) {
              var title = find_segment_for(pos.x).label  + ' (' + BlacklightRangeLimit.parseNum(segment.count) + ')';
              $(container).attr("title", title).tooltip("_fixTitle").tooltip("show");
  
              last_segment  = segment;
             }
          });
  
          $(container).bind("mouseout", function() {
            last_segment = null;
            $(container).tooltip('hide');
          });
          $(container).bind("plotclick", function (event, pos, item) {
              if ( plot.getSelection() == null) {
                segment = find_segment_for(pos.x);
                plot.setSelection( normalized_selection(segment.from, segment.to));
              }
          });
          $(container).bind("plotselected plotselecting", function(event, ranges) {
              if (ranges != null ) {
                var from = Math.floor(ranges.xaxis.from);
                var to = Math.floor(ranges.xaxis.to);
  
                var form = $(container).closest(".limit_content").find("form.range_limit");
                form.find("input.range_begin").val(from);
                form.find("input.range_end").val(to);
  
                var slider_placeholder = $(container).closest(".limit_content").find("[data-slider-placeholder]");
                if (slider_placeholder) {
                  slider_placeholder.slider("setValue", [from, to+1]);
                }
              }
          });
  
          var form = $(container).closest(".limit_content").find("form.range_limit");
          form.find("input.range_begin, input.range_end").change(function () {
             plot.setSelection( form_selection(form, min, max) , true );
          });
          $(container).closest(".limit_content").find(".profile .range").on("slide", function(event, ui) {
            var values = $(event.target).data("slider").getValue();
            form.find("input.range_begin").val(values[0]);
            form.find("input.range_end").val(values[1]);
            plot.setSelection( normalized_selection(values[0], Math.max(values[0], values[1]-1)), true);
          });
  
          // initially entirely selected, to match slider
          plot.setSelection( {xaxis: { from:min, to:max+0.9999}}  );
        }
      }
  
  
      // Send endpoint to endpoint+0.99999 to have display
      // more closely approximate limiting behavior esp
      // at small resolutions. (Since we search on whole numbers,
      // inclusive, but flot chart is decimal.)
      function normalized_selection(min, max) {
        max += 0.99999;
  
        return {xaxis: { 'from':min, 'to':max}}
      }
  
      function form_selection(form, min, max) {
        var begin_val = BlacklightRangeLimit.parseNum($(form).find("input.range_begin").val());
        if (isNaN(begin_val) || begin_val < min) {
          begin_val = min;
        }
        var end_val = BlacklightRangeLimit.parseNum($(form).find("input.range_end").val());
        if (isNaN(end_val) || end_val > max) {
          end_val = max;
        }
  
        return normalized_selection(begin_val, end_val);
      }
  
      function function_for_find_segment(pointer_lookup_arr) {
        return function(x_coord) {
          for (var i = pointer_lookup_arr.length-1 ; i >= 0 ; i--) {
            var hash = pointer_lookup_arr[i];
            if (x_coord >= hash.from)
              return hash;
          }
          return pointer_lookup_arr[0];
        };
      }
  
      // Check if Flot is loaded, and if browser has support for
      // canvas object, either natively or via IE excanvas.
      function domDependenciesMet() {
        var flotLoaded = (typeof $.plot != "undefined");
        var canvasAvailable = ((typeof(document.createElement('canvas').getContext) != "undefined") || (typeof  window.CanvasRenderingContext2D != 'undefined' || typeof G_vmlCanvasManager != 'undefined'));
  
        return (flotLoaded && canvasAvailable);
      }
  });
  
  // takes a string and parses into an integer, but throws away commas first, to avoid truncation when there is a comma
  // use in place of javascript's native parseInt
  !function(global) {
    'use strict';
  
    var previousBlacklightRangeLimit = global.BlacklightRangeLimit;
  
    function BlacklightRangeLimit(options) {
      this.options = options || {};
    }
  
    BlacklightRangeLimit.parseNum = function parseNum(str) {
      str = String(str).replace(/[^0-9]/g, '');
      return parseInt(str, 10);
    };
  
    BlacklightRangeLimit.noConflict = function noConflict() {
      global.BlacklightRangeLimit = previousBlacklightRangeLimit;
      return BlacklightRangeLimit;
    };
  
    global.BlacklightRangeLimit = BlacklightRangeLimit;
  }(this);
  // for Blacklight.onLoad:
  
  Blacklight.onLoad(function() {
          
  $(".range_limit .profile .range.slider_js").each(function() {
     var range_element = $(this);
      
     var boundaries = min_max(this);
     var min = boundaries[0];
     var max = boundaries[1];
  
     if (isInt(min) && isInt(max)) {
       $(this).contents().wrapAll('<div style="display:none" />');
       
       var range_element = $(this);
       var form = $(range_element).closest(".range_limit").find("form.range_limit");
       var begin_el = form.find("input.range_begin");
       var end_el = form.find("input.range_end");
  
       var placeholder_input = $('<input type="text" data-slider-placeholder="true" style="width:100%;">').appendTo(range_element);
       
       // make sure slider is loaded
       if (placeholder_input.slider !== undefined) {
        placeholder_input.slider({
          min: min,
          max: max+1,
          value: [min, max+1],
          tooltip: "hide"
        });
  
        // try to make slider width/orientation match chart's
        var container      = range_element.closest(".range_limit");
        var plot           = container.find(".chart_js").data("plot");
        var slider_el      = container.find(".slider");
         
        if (plot && slider_el) { 
          slider_el.width(plot.width());
          slider_el.css("display", "block")
          slider_el.css('margin-right', 'auto');
          slider_el.css('margin-left', 'auto'); 
        }
        else if (slider_el) {
          slider_el.css("width", "100%");
        }
       }
      
       // Slider change should update text input values.
       var parent = $(this).parent();
       var form = $(parent).closest(".limit_content").find("form.range_limit");
       $(parent).closest(".limit_content").find(".profile .range").on("slide", function(event, ui) {
        var values = $(event.target).data("slider").getValue();
        form.find("input.range_begin").val(values[0]);
        form.find("input.range_end").val(values[1]);
       });
     }
  
    begin_el.val(min);
    end_el.val(max);
          
    begin_el.change( function() {
      var val = BlacklightRangeLimit.parseNum($(this).val());
      if ( isNaN(val)  || val < min) {
        //for weird data, set slider at min           
        val = min;
      }
      var values = placeholder_input.data("slider").getValue();
      values[0] = val;
      placeholder_input.slider("setValue", values);
    });
          
    end_el.change( function() {
       var val = BlacklightRangeLimit.parseNum($(this).val());
       if ( isNaN(val) || val > max ) {
         //weird entry, set slider to max
         val = max;
       }
      var values = placeholder_input.data("slider").getValue();
      values[1] = val;
      placeholder_input.slider("setValue", values);
    });    
     
  });
  
  // catch event for redrawing chart, to redraw slider to match width
  $("body").on("plotDrawn.blacklight.rangeLimit", function(event) {
    var area       = $(event.target).closest(".limit_content.range_limit");
    var plot       = area.find(".chart_js").data("plot");
    var slider_el  = area.find(".slider");
  
    if (plot && slider_el) {
        slider_el.width(plot.width());
        slider_el.css("display", "block")
        slider_el.css('margin-right', 'auto');
        slider_el.css('margin-left', 'auto'); 
    }
  });
  
  // returns two element array min/max as numbers. If there is a limit applied,
  // it's boundaries are are limits. Otherwise, min/max in current result
  // set as sniffed from HTML. Pass in a DOM element for a div.range
  // Will return NaN as min or max in case of error or other weirdness. 
  function min_max(range_element) {
     var current_limit =  $(range_element).closest(".limit_content.range_limit").find(".current")
     
     
     
     var min = max = BlacklightRangeLimit.parseNum(current_limit.find(".single").text())
     if ( isNaN(min)) {
       min = BlacklightRangeLimit.parseNum(current_limit.find(".from").first().text());
       max = BlacklightRangeLimit.parseNum(current_limit.find(".to").first().text());
     }
    
     if (isNaN(min) || isNaN(max)) {
        //no current limit, take from results min max included in spans
        min = BlacklightRangeLimit.parseNum($(range_element).find(".min").first().text());
        max = BlacklightRangeLimit.parseNum($(range_element).find(".max").first().text());
     }
     
     return [min, max]
  }
  
  
  // Check to see if a value is an Integer
  // see: http://stackoverflow.com/questions/3885817/how-to-check-if-a-number-is-float-or-integer
  function isInt(n) {
    return n % 1 === 0;
  }
  
  });
  // Master manifest file for engine, so local app can require
  // this one file, but get all our files -- and local app
  // require does not need to change if we change file list.
  
  
  
  
  
  
  
  
  ;
  (function() {
    this.API = (function() {
      function API() {}
  
      API.utilities = function(callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/personal_research_assistant/utilities',
          method: 'GET',
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.topic_models = function(callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/personal_research_assistant/topic_models',
          method: 'GET',
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.user_tasks = function(utilities, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/personal_research_assistant/user_tasks',
          method: 'POST',
          data: {
            utilities: utilities
          },
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.render_utility = function(utility, topic_models, user_tasks, callback) {
        if (user_tasks.size === 0) {
          user_tasks = [""];
        }
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/personal_research_assistant/render_utility',
          method: 'POST',
          data: {
            utility: utility,
            topic_models: topic_models,
            user_tasks: user_tasks
          },
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.np_stats = function(callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/get_stats',
          method: 'GET',
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.task_results = function(parent_task_uuid, task_uuid, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/personal_workspace/get_task_results',
          method: 'POST',
          data: {
            parent_task_uuid: parent_task_uuid,
            task_uuid: task_uuid
          },
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.query_task_results = function(task_uuid, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/personal_workspace/query_task_results',
          method: 'POST',
          data: {
            task_uuid: task_uuid
          },
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.topic_query_results = function(task_uuid, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/topic_models/query_results',
          method: 'POST',
          data: {
            task_uuid: task_uuid
          },
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.run_report = function(run_uuid, language, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/personal_workspace/get_run_report',
          method: 'POST',
          data: {
            run_uuid: run_uuid,
            language: language
          },
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.task_report = function(task_uuid, language, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/personal_workspace/get_task_report',
          method: 'POST',
          data: {
            task_uuid: task_uuid,
            language: language
          },
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.task_explanation = function(run_uuid, task_uuid, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/personal_workspace/get_task_explanation',
          method: 'POST',
          data: {
            run_uuid: run_uuid,
            task_uuid: task_uuid
          },
          complete: function(data) {
            return callback(data);
          }
        });
      };
  
      API.get_run_id_from_experiment_id = function(experiment_id, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/experiment/get_run_id',
          method: 'POST',
          data: {
            experiment_id: experiment_id
          },
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.working_dataset = function(callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/catalog/set_working_dataset',
          method: 'GET',
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.get_article_images = function(article_id, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/catalog/article_parts',
          method: 'POST',
          data: {
            article_id: article_id
          },
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.get_topic_description = function(model_type, model_name, topic_number, year, callback) {
        var params;
        if (year !== null) {
          params = {
            model_type: model_type,
            model_name: model_name,
            topic_number: topic_number,
            year: year
          };
        } else {
          params = {
            model_type: model_type,
            model_name: model_name,
            topic_number: topic_number
          };
        }
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/topic_models/describe',
          method: 'POST',
          data: params,
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.get_mirador_config = function(doc_id, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/catalog/get_mirador_config',
          method: 'POST',
          data: {
            id: doc_id
          },
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.get_min_max_dates = function(callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/get_min_max_dates',
          method: 'GET',
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.get_datasets_with_doc = function(doc_id, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/datasets/get_datasets_with_doc',
          method: 'POST',
          data: {
            id: doc_id
          },
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.load_graph = function(experiment_id, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/experiment/load',
          method: 'POST',
          data: {
            experiment_id: experiment_id
          },
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.save_graph = function(elements, experiment_id, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/experiment/save',
          method: 'POST',
          data: {
            experiment_id: experiment_id,
            elements: elements
          },
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.add_query_to_dataset = function(params, dataset_id, relevancy, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/add_query_to_dataset',
          method: 'POST',
          data: {
            params: params,
            dataset_id: dataset_id,
            relevancy: relevancy
          },
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.get_random_sample = function(query_params, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/get_random_sample',
          method: 'POST',
          data: {
            query_params: query_params
          },
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.delete_compound_article = function(compound_id, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/delete_compound_article',
          method: 'POST',
          data: {
            compound_id: compound_id
          },
          success: function(data) {
            return callback(data);
          }
        });
      };
  
      API.get_named_entities_kburl_label = function(linked_ids, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/catalog/get_named_entities_kburl_label',
          method: 'POST',
          data: {
            linked_ids: linked_ids
          },
          complete: function(data) {
            return callback(data);
          }
        });
      };
  
      API.get_experiment_status = function(experiment_id, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/experiment/get_status',
          method: 'POST',
          data: {
            experiment_id: experiment_id
          },
          complete: function(data) {
            return callback(data);
          }
        });
      };
  
      API.get_locale = function(callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + '/get_locale',
          method: 'GET',
          complete: function(data) {
            return callback(data);
          }
        });
      };
  
      API.paginate_dataset = function(dataset_id, page, per_page, sort, sort_order, doctypes, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + "/datasets/paginate",
          method: 'POST',
          data: {
            dataset_id: dataset_id,
            page: page,
            per_page: per_page,
            sort: sort,
            sort_order: sort_order,
            doctypes: doctypes
          },
          complete: function(data) {
            return callback(data);
          }
        });
      };
  
      API.get_dataset_named_entities = function(dataset_id, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + "/datasets/get_named_entities",
          method: 'POST',
          data: {
            dataset_id: dataset_id
          },
          complete: function(data) {
            return callback(data);
          }
        });
      };
  
      API.set_dataset_sharing = function(dataset_id, is_public, callback) {
        return $.ajax({
          url: window.location.protocol + "//" + window.location.host + "/datasets/set_sharing_option",
          method: 'POST',
          data: {
            dataset_id: dataset_id,
            is_public: is_public
          },
          complete: function(data) {
            return callback(data);
          }
        });
      };
  
      return API;
  
    })();
  
  }).call(this);
  /*!
   * Chart.js v2.8.0
   * https://www.chartjs.org
   * (c) 2019 Chart.js Contributors
   * Released under the MIT License
   */
  
  !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(function(){try{return require("moment")}catch(t){}}()):"function"==typeof define&&define.amd?define(["require"],function(t){return e(function(){try{return t("moment")}catch(t){}}())}):t.Chart=e(t.moment)}(this,function(t){"use strict";t=t&&t.hasOwnProperty("default")?t.default:t;var e={rgb2hsl:i,rgb2hsv:n,rgb2hwb:a,rgb2cmyk:o,rgb2keyword:s,rgb2xyz:l,rgb2lab:d,rgb2lch:function(t){return x(d(t))},hsl2rgb:u,hsl2hsv:function(t){var e=t[0],i=t[1]/100,n=t[2]/100;if(0===n)return[0,0,0];return[e,100*(2*(i*=(n*=2)<=1?n:2-n)/(n+i)),100*((n+i)/2)]},hsl2hwb:function(t){return a(u(t))},hsl2cmyk:function(t){return o(u(t))},hsl2keyword:function(t){return s(u(t))},hsv2rgb:h,hsv2hsl:function(t){var e,i,n=t[0],a=t[1]/100,o=t[2]/100;return e=a*o,[n,100*(e=(e/=(i=(2-a)*o)<=1?i:2-i)||0),100*(i/=2)]},hsv2hwb:function(t){return a(h(t))},hsv2cmyk:function(t){return o(h(t))},hsv2keyword:function(t){return s(h(t))},hwb2rgb:c,hwb2hsl:function(t){return i(c(t))},hwb2hsv:function(t){return n(c(t))},hwb2cmyk:function(t){return o(c(t))},hwb2keyword:function(t){return s(c(t))},cmyk2rgb:f,cmyk2hsl:function(t){return i(f(t))},cmyk2hsv:function(t){return n(f(t))},cmyk2hwb:function(t){return a(f(t))},cmyk2keyword:function(t){return s(f(t))},keyword2rgb:w,keyword2hsl:function(t){return i(w(t))},keyword2hsv:function(t){return n(w(t))},keyword2hwb:function(t){return a(w(t))},keyword2cmyk:function(t){return o(w(t))},keyword2lab:function(t){return d(w(t))},keyword2xyz:function(t){return l(w(t))},xyz2rgb:p,xyz2lab:m,xyz2lch:function(t){return x(m(t))},lab2xyz:v,lab2rgb:y,lab2lch:x,lch2lab:k,lch2xyz:function(t){return v(k(t))},lch2rgb:function(t){return y(k(t))}};function i(t){var e,i,n=t[0]/255,a=t[1]/255,o=t[2]/255,r=Math.min(n,a,o),s=Math.max(n,a,o),l=s-r;return s==r?e=0:n==s?e=(a-o)/l:a==s?e=2+(o-n)/l:o==s&&(e=4+(n-a)/l),(e=Math.min(60*e,360))<0&&(e+=360),i=(r+s)/2,[e,100*(s==r?0:i<=.5?l/(s+r):l/(2-s-r)),100*i]}function n(t){var e,i,n=t[0],a=t[1],o=t[2],r=Math.min(n,a,o),s=Math.max(n,a,o),l=s-r;return i=0==s?0:l/s*1e3/10,s==r?e=0:n==s?e=(a-o)/l:a==s?e=2+(o-n)/l:o==s&&(e=4+(n-a)/l),(e=Math.min(60*e,360))<0&&(e+=360),[e,i,s/255*1e3/10]}function a(t){var e=t[0],n=t[1],a=t[2];return[i(t)[0],100*(1/255*Math.min(e,Math.min(n,a))),100*(a=1-1/255*Math.max(e,Math.max(n,a)))]}function o(t){var e,i=t[0]/255,n=t[1]/255,a=t[2]/255;return[100*((1-i-(e=Math.min(1-i,1-n,1-a)))/(1-e)||0),100*((1-n-e)/(1-e)||0),100*((1-a-e)/(1-e)||0),100*e]}function s(t){return _[JSON.stringify(t)]}function l(t){var e=t[0]/255,i=t[1]/255,n=t[2]/255;return[100*(.4124*(e=e>.04045?Math.pow((e+.055)/1.055,2.4):e/12.92)+.3576*(i=i>.04045?Math.pow((i+.055)/1.055,2.4):i/12.92)+.1805*(n=n>.04045?Math.pow((n+.055)/1.055,2.4):n/12.92)),100*(.2126*e+.7152*i+.0722*n),100*(.0193*e+.1192*i+.9505*n)]}function d(t){var e=l(t),i=e[0],n=e[1],a=e[2];return n/=100,a/=108.883,i=(i/=95.047)>.008856?Math.pow(i,1/3):7.787*i+16/116,[116*(n=n>.008856?Math.pow(n,1/3):7.787*n+16/116)-16,500*(i-n),200*(n-(a=a>.008856?Math.pow(a,1/3):7.787*a+16/116))]}function u(t){var e,i,n,a,o,r=t[0]/360,s=t[1]/100,l=t[2]/100;if(0==s)return[o=255*l,o,o];e=2*l-(i=l<.5?l*(1+s):l+s-l*s),a=[0,0,0];for(var d=0;d<3;d++)(n=r+1/3*-(d-1))<0&&n++,n>1&&n--,o=6*n<1?e+6*(i-e)*n:2*n<1?i:3*n<2?e+(i-e)*(2/3-n)*6:e,a[d]=255*o;return a}function h(t){var e=t[0]/60,i=t[1]/100,n=t[2]/100,a=Math.floor(e)%6,o=e-Math.floor(e),r=255*n*(1-i),s=255*n*(1-i*o),l=255*n*(1-i*(1-o));n*=255;switch(a){case 0:return[n,l,r];case 1:return[s,n,r];case 2:return[r,n,l];case 3:return[r,s,n];case 4:return[l,r,n];case 5:return[n,r,s]}}function c(t){var e,i,n,a,o=t[0]/360,s=t[1]/100,l=t[2]/100,d=s+l;switch(d>1&&(s/=d,l/=d),n=6*o-(e=Math.floor(6*o)),0!=(1&e)&&(n=1-n),a=s+n*((i=1-l)-s),e){default:case 6:case 0:r=i,g=a,b=s;break;case 1:r=a,g=i,b=s;break;case 2:r=s,g=i,b=a;break;case 3:r=s,g=a,b=i;break;case 4:r=a,g=s,b=i;break;case 5:r=i,g=s,b=a}return[255*r,255*g,255*b]}function f(t){var e=t[0]/100,i=t[1]/100,n=t[2]/100,a=t[3]/100;return[255*(1-Math.min(1,e*(1-a)+a)),255*(1-Math.min(1,i*(1-a)+a)),255*(1-Math.min(1,n*(1-a)+a))]}function p(t){var e,i,n,a=t[0]/100,o=t[1]/100,r=t[2]/100;return i=-.9689*a+1.8758*o+.0415*r,n=.0557*a+-.204*o+1.057*r,e=(e=3.2406*a+-1.5372*o+-.4986*r)>.0031308?1.055*Math.pow(e,1/2.4)-.055:e*=12.92,i=i>.0031308?1.055*Math.pow(i,1/2.4)-.055:i*=12.92,n=n>.0031308?1.055*Math.pow(n,1/2.4)-.055:n*=12.92,[255*(e=Math.min(Math.max(0,e),1)),255*(i=Math.min(Math.max(0,i),1)),255*(n=Math.min(Math.max(0,n),1))]}function m(t){var e=t[0],i=t[1],n=t[2];return i/=100,n/=108.883,e=(e/=95.047)>.008856?Math.pow(e,1/3):7.787*e+16/116,[116*(i=i>.008856?Math.pow(i,1/3):7.787*i+16/116)-16,500*(e-i),200*(i-(n=n>.008856?Math.pow(n,1/3):7.787*n+16/116))]}function v(t){var e,i,n,a,o=t[0],r=t[1],s=t[2];return o<=8?a=(i=100*o/903.3)/100*7.787+16/116:(i=100*Math.pow((o+16)/116,3),a=Math.pow(i/100,1/3)),[e=e/95.047<=.008856?e=95.047*(r/500+a-16/116)/7.787:95.047*Math.pow(r/500+a,3),i,n=n/108.883<=.008859?n=108.883*(a-s/200-16/116)/7.787:108.883*Math.pow(a-s/200,3)]}function x(t){var e,i=t[0],n=t[1],a=t[2];return(e=360*Math.atan2(a,n)/2/Math.PI)<0&&(e+=360),[i,Math.sqrt(n*n+a*a),e]}function y(t){return p(v(t))}function k(t){var e,i=t[0],n=t[1];return e=t[2]/360*2*Math.PI,[i,n*Math.cos(e),n*Math.sin(e)]}function w(t){return M[t]}var M={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},_={};for(var C in M)_[JSON.stringify(M[C])]=C;var S=function(){return new T};for(var P in e){S[P+"Raw"]=function(t){return function(i){return"number"==typeof i&&(i=Array.prototype.slice.call(arguments)),e[t](i)}}(P);var I=/(\w+)2(\w+)/.exec(P),A=I[1],D=I[2];(S[A]=S[A]||{})[D]=S[P]=function(t){return function(i){"number"==typeof i&&(i=Array.prototype.slice.call(arguments));var n=e[t](i);if("string"==typeof n||void 0===n)return n;for(var a=0;a<n.length;a++)n[a]=Math.round(n[a]);return n}}(P)}var T=function(){this.convs={}};T.prototype.routeSpace=function(t,e){var i=e[0];return void 0===i?this.getValues(t):("number"==typeof i&&(i=Array.prototype.slice.call(e)),this.setValues(t,i))},T.prototype.setValues=function(t,e){return this.space=t,this.convs={},this.convs[t]=e,this},T.prototype.getValues=function(t){var e=this.convs[t];if(!e){var i=this.space,n=this.convs[i];e=S[i][t](n),this.convs[t]=e}return e},["rgb","hsl","hsv","cmyk","keyword"].forEach(function(t){T.prototype[t]=function(e){return this.routeSpace(t,arguments)}});var F=S,L={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},R={getRgba:O,getHsla:z,getRgb:function(t){var e=O(t);return e&&e.slice(0,3)},getHsl:function(t){var e=z(t);return e&&e.slice(0,3)},getHwb:B,getAlpha:function(t){var e=O(t);if(e)return e[3];if(e=z(t))return e[3];if(e=B(t))return e[3]},hexString:function(t,e){var e=void 0!==e&&3===t.length?e:t[3];return"#"+H(t[0])+H(t[1])+H(t[2])+(e>=0&&e<1?H(Math.round(255*e)):"")},rgbString:function(t,e){if(e<1||t[3]&&t[3]<1)return N(t,e);return"rgb("+t[0]+", "+t[1]+", "+t[2]+")"},rgbaString:N,percentString:function(t,e){if(e<1||t[3]&&t[3]<1)return W(t,e);var i=Math.round(t[0]/255*100),n=Math.round(t[1]/255*100),a=Math.round(t[2]/255*100);return"rgb("+i+"%, "+n+"%, "+a+"%)"},percentaString:W,hslString:function(t,e){if(e<1||t[3]&&t[3]<1)return V(t,e);return"hsl("+t[0]+", "+t[1]+"%, "+t[2]+"%)"},hslaString:V,hwbString:function(t,e){void 0===e&&(e=void 0!==t[3]?t[3]:1);return"hwb("+t[0]+", "+t[1]+"%, "+t[2]+"%"+(void 0!==e&&1!==e?", "+e:"")+")"},keyword:function(t){return j[t.slice(0,3)]}};function O(t){if(t){var e=[0,0,0],i=1,n=t.match(/^#([a-fA-F0-9]{3,4})$/i),a="";if(n){a=(n=n[1])[3];for(var o=0;o<e.length;o++)e[o]=parseInt(n[o]+n[o],16);a&&(i=Math.round(parseInt(a+a,16)/255*100)/100)}else if(n=t.match(/^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i)){a=n[2],n=n[1];for(o=0;o<e.length;o++)e[o]=parseInt(n.slice(2*o,2*o+2),16);a&&(i=Math.round(parseInt(a,16)/255*100)/100)}else if(n=t.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)){for(o=0;o<e.length;o++)e[o]=parseInt(n[o+1]);i=parseFloat(n[4])}else if(n=t.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)){for(o=0;o<e.length;o++)e[o]=Math.round(2.55*parseFloat(n[o+1]));i=parseFloat(n[4])}else if(n=t.match(/(\w+)/)){if("transparent"==n[1])return[0,0,0,0];if(!(e=L[n[1]]))return}for(o=0;o<e.length;o++)e[o]=E(e[o],0,255);return i=i||0==i?E(i,0,1):1,e[3]=i,e}}function z(t){if(t){var e=t.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);if(e){var i=parseFloat(e[4]);return[E(parseInt(e[1]),0,360),E(parseFloat(e[2]),0,100),E(parseFloat(e[3]),0,100),E(isNaN(i)?1:i,0,1)]}}}function B(t){if(t){var e=t.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);if(e){var i=parseFloat(e[4]);return[E(parseInt(e[1]),0,360),E(parseFloat(e[2]),0,100),E(parseFloat(e[3]),0,100),E(isNaN(i)?1:i,0,1)]}}}function N(t,e){return void 0===e&&(e=void 0!==t[3]?t[3]:1),"rgba("+t[0]+", "+t[1]+", "+t[2]+", "+e+")"}function W(t,e){return"rgba("+Math.round(t[0]/255*100)+"%, "+Math.round(t[1]/255*100)+"%, "+Math.round(t[2]/255*100)+"%, "+(e||t[3]||1)+")"}function V(t,e){return void 0===e&&(e=void 0!==t[3]?t[3]:1),"hsla("+t[0]+", "+t[1]+"%, "+t[2]+"%, "+e+")"}function E(t,e,i){return Math.min(Math.max(e,t),i)}function H(t){var e=t.toString(16).toUpperCase();return e.length<2?"0"+e:e}var j={};for(var q in L)j[L[q]]=q;var Y=function(t){return t instanceof Y?t:this instanceof Y?(this.valid=!1,this.values={rgb:[0,0,0],hsl:[0,0,0],hsv:[0,0,0],hwb:[0,0,0],cmyk:[0,0,0,0],alpha:1},void("string"==typeof t?(e=R.getRgba(t))?this.setValues("rgb",e):(e=R.getHsla(t))?this.setValues("hsl",e):(e=R.getHwb(t))&&this.setValues("hwb",e):"object"==typeof t&&(void 0!==(e=t).r||void 0!==e.red?this.setValues("rgb",e):void 0!==e.l||void 0!==e.lightness?this.setValues("hsl",e):void 0!==e.v||void 0!==e.value?this.setValues("hsv",e):void 0!==e.w||void 0!==e.whiteness?this.setValues("hwb",e):void 0===e.c&&void 0===e.cyan||this.setValues("cmyk",e)))):new Y(t);var e};Y.prototype={isValid:function(){return this.valid},rgb:function(){return this.setSpace("rgb",arguments)},hsl:function(){return this.setSpace("hsl",arguments)},hsv:function(){return this.setSpace("hsv",arguments)},hwb:function(){return this.setSpace("hwb",arguments)},cmyk:function(){return this.setSpace("cmyk",arguments)},rgbArray:function(){return this.values.rgb},hslArray:function(){return this.values.hsl},hsvArray:function(){return this.values.hsv},hwbArray:function(){var t=this.values;return 1!==t.alpha?t.hwb.concat([t.alpha]):t.hwb},cmykArray:function(){return this.values.cmyk},rgbaArray:function(){var t=this.values;return t.rgb.concat([t.alpha])},hslaArray:function(){var t=this.values;return t.hsl.concat([t.alpha])},alpha:function(t){return void 0===t?this.values.alpha:(this.setValues("alpha",t),this)},red:function(t){return this.setChannel("rgb",0,t)},green:function(t){return this.setChannel("rgb",1,t)},blue:function(t){return this.setChannel("rgb",2,t)},hue:function(t){return t&&(t=(t%=360)<0?360+t:t),this.setChannel("hsl",0,t)},saturation:function(t){return this.setChannel("hsl",1,t)},lightness:function(t){return this.setChannel("hsl",2,t)},saturationv:function(t){return this.setChannel("hsv",1,t)},whiteness:function(t){return this.setChannel("hwb",1,t)},blackness:function(t){return this.setChannel("hwb",2,t)},value:function(t){return this.setChannel("hsv",2,t)},cyan:function(t){return this.setChannel("cmyk",0,t)},magenta:function(t){return this.setChannel("cmyk",1,t)},yellow:function(t){return this.setChannel("cmyk",2,t)},black:function(t){return this.setChannel("cmyk",3,t)},hexString:function(){return R.hexString(this.values.rgb)},rgbString:function(){return R.rgbString(this.values.rgb,this.values.alpha)},rgbaString:function(){return R.rgbaString(this.values.rgb,this.values.alpha)},percentString:function(){return R.percentString(this.values.rgb,this.values.alpha)},hslString:function(){return R.hslString(this.values.hsl,this.values.alpha)},hslaString:function(){return R.hslaString(this.values.hsl,this.values.alpha)},hwbString:function(){return R.hwbString(this.values.hwb,this.values.alpha)},keyword:function(){return R.keyword(this.values.rgb,this.values.alpha)},rgbNumber:function(){var t=this.values.rgb;return t[0]<<16|t[1]<<8|t[2]},luminosity:function(){for(var t=this.values.rgb,e=[],i=0;i<t.length;i++){var n=t[i]/255;e[i]=n<=.03928?n/12.92:Math.pow((n+.055)/1.055,2.4)}return.2126*e[0]+.7152*e[1]+.0722*e[2]},contrast:function(t){var e=this.luminosity(),i=t.luminosity();return e>i?(e+.05)/(i+.05):(i+.05)/(e+.05)},level:function(t){var e=this.contrast(t);return e>=7.1?"AAA":e>=4.5?"AA":""},dark:function(){var t=this.values.rgb;return(299*t[0]+587*t[1]+114*t[2])/1e3<128},light:function(){return!this.dark()},negate:function(){for(var t=[],e=0;e<3;e++)t[e]=255-this.values.rgb[e];return this.setValues("rgb",t),this},lighten:function(t){var e=this.values.hsl;return e[2]+=e[2]*t,this.setValues("hsl",e),this},darken:function(t){var e=this.values.hsl;return e[2]-=e[2]*t,this.setValues("hsl",e),this},saturate:function(t){var e=this.values.hsl;return e[1]+=e[1]*t,this.setValues("hsl",e),this},desaturate:function(t){var e=this.values.hsl;return e[1]-=e[1]*t,this.setValues("hsl",e),this},whiten:function(t){var e=this.values.hwb;return e[1]+=e[1]*t,this.setValues("hwb",e),this},blacken:function(t){var e=this.values.hwb;return e[2]+=e[2]*t,this.setValues("hwb",e),this},greyscale:function(){var t=this.values.rgb,e=.3*t[0]+.59*t[1]+.11*t[2];return this.setValues("rgb",[e,e,e]),this},clearer:function(t){var e=this.values.alpha;return this.setValues("alpha",e-e*t),this},opaquer:function(t){var e=this.values.alpha;return this.setValues("alpha",e+e*t),this},rotate:function(t){var e=this.values.hsl,i=(e[0]+t)%360;return e[0]=i<0?360+i:i,this.setValues("hsl",e),this},mix:function(t,e){var i=t,n=void 0===e?.5:e,a=2*n-1,o=this.alpha()-i.alpha(),r=((a*o==-1?a:(a+o)/(1+a*o))+1)/2,s=1-r;return this.rgb(r*this.red()+s*i.red(),r*this.green()+s*i.green(),r*this.blue()+s*i.blue()).alpha(this.alpha()*n+i.alpha()*(1-n))},toJSON:function(){return this.rgb()},clone:function(){var t,e,i=new Y,n=this.values,a=i.values;for(var o in n)n.hasOwnProperty(o)&&(t=n[o],"[object Array]"===(e={}.toString.call(t))?a[o]=t.slice(0):"[object Number]"===e?a[o]=t:console.error("unexpected color value:",t));return i}},Y.prototype.spaces={rgb:["red","green","blue"],hsl:["hue","saturation","lightness"],hsv:["hue","saturation","value"],hwb:["hue","whiteness","blackness"],cmyk:["cyan","magenta","yellow","black"]},Y.prototype.maxes={rgb:[255,255,255],hsl:[360,100,100],hsv:[360,100,100],hwb:[360,100,100],cmyk:[100,100,100,100]},Y.prototype.getValues=function(t){for(var e=this.values,i={},n=0;n<t.length;n++)i[t.charAt(n)]=e[t][n];return 1!==e.alpha&&(i.a=e.alpha),i},Y.prototype.setValues=function(t,e){var i,n,a=this.values,o=this.spaces,r=this.maxes,s=1;if(this.valid=!0,"alpha"===t)s=e;else if(e.length)a[t]=e.slice(0,t.length),s=e[t.length];else if(void 0!==e[t.charAt(0)]){for(i=0;i<t.length;i++)a[t][i]=e[t.charAt(i)];s=e.a}else if(void 0!==e[o[t][0]]){var l=o[t];for(i=0;i<t.length;i++)a[t][i]=e[l[i]];s=e.alpha}if(a.alpha=Math.max(0,Math.min(1,void 0===s?a.alpha:s)),"alpha"===t)return!1;for(i=0;i<t.length;i++)n=Math.max(0,Math.min(r[t][i],a[t][i])),a[t][i]=Math.round(n);for(var d in o)d!==t&&(a[d]=F[t][d](a[t]));return!0},Y.prototype.setSpace=function(t,e){var i=e[0];return void 0===i?this.getValues(t):("number"==typeof i&&(i=Array.prototype.slice.call(e)),this.setValues(t,i),this)},Y.prototype.setChannel=function(t,e,i){var n=this.values[t];return void 0===i?n[e]:i===n[e]?this:(n[e]=i,this.setValues(t,n),this)},"undefined"!=typeof window&&(window.Color=Y);var U,X=Y,K={noop:function(){},uid:(U=0,function(){return U++}),isNullOrUndef:function(t){return null==t},isArray:function(t){if(Array.isArray&&Array.isArray(t))return!0;var e=Object.prototype.toString.call(t);return"[object"===e.substr(0,7)&&"Array]"===e.substr(-6)},isObject:function(t){return null!==t&&"[object Object]"===Object.prototype.toString.call(t)},isFinite:function(t){return("number"==typeof t||t instanceof Number)&&isFinite(t)},valueOrDefault:function(t,e){return void 0===t?e:t},valueAtIndexOrDefault:function(t,e,i){return K.valueOrDefault(K.isArray(t)?t[e]:t,i)},callback:function(t,e,i){if(t&&"function"==typeof t.call)return t.apply(i,e)},each:function(t,e,i,n){var a,o,r;if(K.isArray(t))if(o=t.length,n)for(a=o-1;a>=0;a--)e.call(i,t[a],a);else for(a=0;a<o;a++)e.call(i,t[a],a);else if(K.isObject(t))for(o=(r=Object.keys(t)).length,a=0;a<o;a++)e.call(i,t[r[a]],r[a])},arrayEquals:function(t,e){var i,n,a,o;if(!t||!e||t.length!==e.length)return!1;for(i=0,n=t.length;i<n;++i)if(a=t[i],o=e[i],a instanceof Array&&o instanceof Array){if(!K.arrayEquals(a,o))return!1}else if(a!==o)return!1;return!0},clone:function(t){if(K.isArray(t))return t.map(K.clone);if(K.isObject(t)){for(var e={},i=Object.keys(t),n=i.length,a=0;a<n;++a)e[i[a]]=K.clone(t[i[a]]);return e}return t},_merger:function(t,e,i,n){var a=e[t],o=i[t];K.isObject(a)&&K.isObject(o)?K.merge(a,o,n):e[t]=K.clone(o)},_mergerIf:function(t,e,i){var n=e[t],a=i[t];K.isObject(n)&&K.isObject(a)?K.mergeIf(n,a):e.hasOwnProperty(t)||(e[t]=K.clone(a))},merge:function(t,e,i){var n,a,o,r,s,l=K.isArray(e)?e:[e],d=l.length;if(!K.isObject(t))return t;for(n=(i=i||{}).merger||K._merger,a=0;a<d;++a)if(e=l[a],K.isObject(e))for(s=0,r=(o=Object.keys(e)).length;s<r;++s)n(o[s],t,e,i);return t},mergeIf:function(t,e){return K.merge(t,e,{merger:K._mergerIf})},extend:function(t){for(var e=function(e,i){t[i]=e},i=1,n=arguments.length;i<n;++i)K.each(arguments[i],e);return t},inherits:function(t){var e=this,i=t&&t.hasOwnProperty("constructor")?t.constructor:function(){return e.apply(this,arguments)},n=function(){this.constructor=i};return n.prototype=e.prototype,i.prototype=new n,i.extend=K.inherits,t&&K.extend(i.prototype,t),i.__super__=e.prototype,i}},G=K;K.callCallback=K.callback,K.indexOf=function(t,e,i){return Array.prototype.indexOf.call(t,e,i)},K.getValueOrDefault=K.valueOrDefault,K.getValueAtIndexOrDefault=K.valueAtIndexOrDefault;var Z={linear:function(t){return t},easeInQuad:function(t){return t*t},easeOutQuad:function(t){return-t*(t-2)},easeInOutQuad:function(t){return(t/=.5)<1?.5*t*t:-.5*(--t*(t-2)-1)},easeInCubic:function(t){return t*t*t},easeOutCubic:function(t){return(t-=1)*t*t+1},easeInOutCubic:function(t){return(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2)},easeInQuart:function(t){return t*t*t*t},easeOutQuart:function(t){return-((t-=1)*t*t*t-1)},easeInOutQuart:function(t){return(t/=.5)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)},easeInQuint:function(t){return t*t*t*t*t},easeOutQuint:function(t){return(t-=1)*t*t*t*t+1},easeInOutQuint:function(t){return(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)},easeInSine:function(t){return 1-Math.cos(t*(Math.PI/2))},easeOutSine:function(t){return Math.sin(t*(Math.PI/2))},easeInOutSine:function(t){return-.5*(Math.cos(Math.PI*t)-1)},easeInExpo:function(t){return 0===t?0:Math.pow(2,10*(t-1))},easeOutExpo:function(t){return 1===t?1:1-Math.pow(2,-10*t)},easeInOutExpo:function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(2-Math.pow(2,-10*--t))},easeInCirc:function(t){return t>=1?t:-(Math.sqrt(1-t*t)-1)},easeOutCirc:function(t){return Math.sqrt(1-(t-=1)*t)},easeInOutCirc:function(t){return(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},easeInElastic:function(t){var e=1.70158,i=0,n=1;return 0===t?0:1===t?1:(i||(i=.3),n<1?(n=1,e=i/4):e=i/(2*Math.PI)*Math.asin(1/n),-n*Math.pow(2,10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/i))},easeOutElastic:function(t){var e=1.70158,i=0,n=1;return 0===t?0:1===t?1:(i||(i=.3),n<1?(n=1,e=i/4):e=i/(2*Math.PI)*Math.asin(1/n),n*Math.pow(2,-10*t)*Math.sin((t-e)*(2*Math.PI)/i)+1)},easeInOutElastic:function(t){var e=1.70158,i=0,n=1;return 0===t?0:2==(t/=.5)?1:(i||(i=.45),n<1?(n=1,e=i/4):e=i/(2*Math.PI)*Math.asin(1/n),t<1?n*Math.pow(2,10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/i)*-.5:n*Math.pow(2,-10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/i)*.5+1)},easeInBack:function(t){var e=1.70158;return t*t*((e+1)*t-e)},easeOutBack:function(t){var e=1.70158;return(t-=1)*t*((e+1)*t+e)+1},easeInOutBack:function(t){var e=1.70158;return(t/=.5)<1?t*t*((1+(e*=1.525))*t-e)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)},easeInBounce:function(t){return 1-Z.easeOutBounce(1-t)},easeOutBounce:function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},easeInOutBounce:function(t){return t<.5?.5*Z.easeInBounce(2*t):.5*Z.easeOutBounce(2*t-1)+.5}},$={effects:Z};G.easingEffects=Z;var J=Math.PI,Q=J/180,tt=2*J,et=J/2,it=J/4,nt=2*J/3,at={clear:function(t){t.ctx.clearRect(0,0,t.width,t.height)},roundedRect:function(t,e,i,n,a,o){if(o){var r=Math.min(o,a/2,n/2),s=e+r,l=i+r,d=e+n-r,u=i+a-r;t.moveTo(e,l),s<d&&l<u?(t.arc(s,l,r,-J,-et),t.arc(d,l,r,-et,0),t.arc(d,u,r,0,et),t.arc(s,u,r,et,J)):s<d?(t.moveTo(s,i),t.arc(d,l,r,-et,et),t.arc(s,l,r,et,J+et)):l<u?(t.arc(s,l,r,-J,0),t.arc(s,u,r,0,J)):t.arc(s,l,r,-J,J),t.closePath(),t.moveTo(e,i)}else t.rect(e,i,n,a)},drawPoint:function(t,e,i,n,a,o){var r,s,l,d,u,h=(o||0)*Q;if(!e||"object"!=typeof e||"[object HTMLImageElement]"!==(r=e.toString())&&"[object HTMLCanvasElement]"!==r){if(!(isNaN(i)||i<=0)){switch(t.beginPath(),e){default:t.arc(n,a,i,0,tt),t.closePath();break;case"triangle":t.moveTo(n+Math.sin(h)*i,a-Math.cos(h)*i),h+=nt,t.lineTo(n+Math.sin(h)*i,a-Math.cos(h)*i),h+=nt,t.lineTo(n+Math.sin(h)*i,a-Math.cos(h)*i),t.closePath();break;case"rectRounded":d=i-(u=.516*i),s=Math.cos(h+it)*d,l=Math.sin(h+it)*d,t.arc(n-s,a-l,u,h-J,h-et),t.arc(n+l,a-s,u,h-et,h),t.arc(n+s,a+l,u,h,h+et),t.arc(n-l,a+s,u,h+et,h+J),t.closePath();break;case"rect":if(!o){d=Math.SQRT1_2*i,t.rect(n-d,a-d,2*d,2*d);break}h+=it;case"rectRot":s=Math.cos(h)*i,l=Math.sin(h)*i,t.moveTo(n-s,a-l),t.lineTo(n+l,a-s),t.lineTo(n+s,a+l),t.lineTo(n-l,a+s),t.closePath();break;case"crossRot":h+=it;case"cross":s=Math.cos(h)*i,l=Math.sin(h)*i,t.moveTo(n-s,a-l),t.lineTo(n+s,a+l),t.moveTo(n+l,a-s),t.lineTo(n-l,a+s);break;case"star":s=Math.cos(h)*i,l=Math.sin(h)*i,t.moveTo(n-s,a-l),t.lineTo(n+s,a+l),t.moveTo(n+l,a-s),t.lineTo(n-l,a+s),h+=it,s=Math.cos(h)*i,l=Math.sin(h)*i,t.moveTo(n-s,a-l),t.lineTo(n+s,a+l),t.moveTo(n+l,a-s),t.lineTo(n-l,a+s);break;case"line":s=Math.cos(h)*i,l=Math.sin(h)*i,t.moveTo(n-s,a-l),t.lineTo(n+s,a+l);break;case"dash":t.moveTo(n,a),t.lineTo(n+Math.cos(h)*i,a+Math.sin(h)*i)}t.fill(),t.stroke()}}else t.drawImage(e,n-e.width/2,a-e.height/2,e.width,e.height)},_isPointInArea:function(t,e){return t.x>e.left-1e-6&&t.x<e.right+1e-6&&t.y>e.top-1e-6&&t.y<e.bottom+1e-6},clipArea:function(t,e){t.save(),t.beginPath(),t.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),t.clip()},unclipArea:function(t){t.restore()},lineTo:function(t,e,i,n){var a=i.steppedLine;if(a){if("middle"===a){var o=(e.x+i.x)/2;t.lineTo(o,n?i.y:e.y),t.lineTo(o,n?e.y:i.y)}else"after"===a&&!n||"after"!==a&&n?t.lineTo(e.x,i.y):t.lineTo(i.x,e.y);t.lineTo(i.x,i.y)}else i.tension?t.bezierCurveTo(n?e.controlPointPreviousX:e.controlPointNextX,n?e.controlPointPreviousY:e.controlPointNextY,n?i.controlPointNextX:i.controlPointPreviousX,n?i.controlPointNextY:i.controlPointPreviousY,i.x,i.y):t.lineTo(i.x,i.y)}},ot=at;G.clear=at.clear,G.drawRoundedRectangle=function(t){t.beginPath(),at.roundedRect.apply(at,arguments)};var rt={_set:function(t,e){return G.merge(this[t]||(this[t]={}),e)}};rt._set("global",{defaultColor:"rgba(0,0,0,0.1)",defaultFontColor:"#666",defaultFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",defaultFontSize:12,defaultFontStyle:"normal",defaultLineHeight:1.2,showLines:!0});var st=rt,lt=G.valueOrDefault;var dt={toLineHeight:function(t,e){var i=(""+t).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);if(!i||"normal"===i[1])return 1.2*e;switch(t=+i[2],i[3]){case"px":return t;case"%":t/=100}return e*t},toPadding:function(t){var e,i,n,a;return G.isObject(t)?(e=+t.top||0,i=+t.right||0,n=+t.bottom||0,a=+t.left||0):e=i=n=a=+t||0,{top:e,right:i,bottom:n,left:a,height:e+n,width:a+i}},_parseFont:function(t){var e=st.global,i=lt(t.fontSize,e.defaultFontSize),n={family:lt(t.fontFamily,e.defaultFontFamily),lineHeight:G.options.toLineHeight(lt(t.lineHeight,e.defaultLineHeight),i),size:i,style:lt(t.fontStyle,e.defaultFontStyle),weight:null,string:""};return n.string=function(t){return!t||G.isNullOrUndef(t.size)||G.isNullOrUndef(t.family)?null:(t.style?t.style+" ":"")+(t.weight?t.weight+" ":"")+t.size+"px "+t.family}(n),n},resolve:function(t,e,i){var n,a,o;for(n=0,a=t.length;n<a;++n)if(void 0!==(o=t[n])&&(void 0!==e&&"function"==typeof o&&(o=o(e)),void 0!==i&&G.isArray(o)&&(o=o[i]),void 0!==o))return o}},ut=G,ht=$,ct=ot,ft=dt;ut.easing=ht,ut.canvas=ct,ut.options=ft;var gt=function(t){ut.extend(this,t),this.initialize.apply(this,arguments)};ut.extend(gt.prototype,{initialize:function(){this.hidden=!1},pivot:function(){var t=this;return t._view||(t._view=ut.clone(t._model)),t._start={},t},transition:function(t){var e=this,i=e._model,n=e._start,a=e._view;return i&&1!==t?(a||(a=e._view={}),n||(n=e._start={}),function(t,e,i,n){var a,o,r,s,l,d,u,h,c,f=Object.keys(i);for(a=0,o=f.length;a<o;++a)if(d=i[r=f[a]],e.hasOwnProperty(r)||(e[r]=d),(s=e[r])!==d&&"_"!==r[0]){if(t.hasOwnProperty(r)||(t[r]=s),(u=typeof d)==typeof(l=t[r]))if("string"===u){if((h=X(l)).valid&&(c=X(d)).valid){e[r]=c.mix(h,n).rgbString();continue}}else if(ut.isFinite(l)&&ut.isFinite(d)){e[r]=l+(d-l)*n;continue}e[r]=d}}(n,a,i,t),e):(e._view=i,e._start=null,e)},tooltipPosition:function(){return{x:this._model.x,y:this._model.y}},hasValue:function(){return ut.isNumber(this._model.x)&&ut.isNumber(this._model.y)}}),gt.extend=ut.inherits;var pt=gt,mt=pt.extend({chart:null,currentStep:0,numSteps:60,easing:"",render:null,onAnimationProgress:null,onAnimationComplete:null}),vt=mt;Object.defineProperty(mt.prototype,"animationObject",{get:function(){return this}}),Object.defineProperty(mt.prototype,"chartInstance",{get:function(){return this.chart},set:function(t){this.chart=t}}),st._set("global",{animation:{duration:1e3,easing:"easeOutQuart",onProgress:ut.noop,onComplete:ut.noop}});var bt={animations:[],request:null,addAnimation:function(t,e,i,n){var a,o,r=this.animations;for(e.chart=t,e.startTime=Date.now(),e.duration=i,n||(t.animating=!0),a=0,o=r.length;a<o;++a)if(r[a].chart===t)return void(r[a]=e);r.push(e),1===r.length&&this.requestAnimationFrame()},cancelAnimation:function(t){var e=ut.findIndex(this.animations,function(e){return e.chart===t});-1!==e&&(this.animations.splice(e,1),t.animating=!1)},requestAnimationFrame:function(){var t=this;null===t.request&&(t.request=ut.requestAnimFrame.call(window,function(){t.request=null,t.startDigest()}))},startDigest:function(){this.advance(),this.animations.length>0&&this.requestAnimationFrame()},advance:function(){for(var t,e,i,n,a=this.animations,o=0;o<a.length;)e=(t=a[o]).chart,i=t.numSteps,n=Math.floor((Date.now()-t.startTime)/t.duration*i)+1,t.currentStep=Math.min(n,i),ut.callback(t.render,[e,t],e),ut.callback(t.onAnimationProgress,[t],e),t.currentStep>=i?(ut.callback(t.onAnimationComplete,[t],e),e.animating=!1,a.splice(o,1)):++o}},xt=ut.options.resolve,yt=["push","pop","shift","splice","unshift"];function kt(t,e){var i=t._chartjs;if(i){var n=i.listeners,a=n.indexOf(e);-1!==a&&n.splice(a,1),n.length>0||(yt.forEach(function(e){delete t[e]}),delete t._chartjs)}}var wt=function(t,e){this.initialize(t,e)};ut.extend(wt.prototype,{datasetElementType:null,dataElementType:null,initialize:function(t,e){this.chart=t,this.index=e,this.linkScales(),this.addElements()},updateIndex:function(t){this.index=t},linkScales:function(){var t=this,e=t.getMeta(),i=t.getDataset();null!==e.xAxisID&&e.xAxisID in t.chart.scales||(e.xAxisID=i.xAxisID||t.chart.options.scales.xAxes[0].id),null!==e.yAxisID&&e.yAxisID in t.chart.scales||(e.yAxisID=i.yAxisID||t.chart.options.scales.yAxes[0].id)},getDataset:function(){return this.chart.data.datasets[this.index]},getMeta:function(){return this.chart.getDatasetMeta(this.index)},getScaleForId:function(t){return this.chart.scales[t]},_getValueScaleId:function(){return this.getMeta().yAxisID},_getIndexScaleId:function(){return this.getMeta().xAxisID},_getValueScale:function(){return this.getScaleForId(this._getValueScaleId())},_getIndexScale:function(){return this.getScaleForId(this._getIndexScaleId())},reset:function(){this.update(!0)},destroy:function(){this._data&&kt(this._data,this)},createMetaDataset:function(){var t=this.datasetElementType;return t&&new t({_chart:this.chart,_datasetIndex:this.index})},createMetaData:function(t){var e=this.dataElementType;return e&&new e({_chart:this.chart,_datasetIndex:this.index,_index:t})},addElements:function(){var t,e,i=this.getMeta(),n=this.getDataset().data||[],a=i.data;for(t=0,e=n.length;t<e;++t)a[t]=a[t]||this.createMetaData(t);i.dataset=i.dataset||this.createMetaDataset()},addElementAndReset:function(t){var e=this.createMetaData(t);this.getMeta().data.splice(t,0,e),this.updateElement(e,t,!0)},buildOrUpdateElements:function(){var t,e,i=this,n=i.getDataset(),a=n.data||(n.data=[]);i._data!==a&&(i._data&&kt(i._data,i),a&&Object.isExtensible(a)&&(e=i,(t=a)._chartjs?t._chartjs.listeners.push(e):(Object.defineProperty(t,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[e]}}),yt.forEach(function(e){var i="onData"+e.charAt(0).toUpperCase()+e.slice(1),n=t[e];Object.defineProperty(t,e,{configurable:!0,enumerable:!1,value:function(){var e=Array.prototype.slice.call(arguments),a=n.apply(this,e);return ut.each(t._chartjs.listeners,function(t){"function"==typeof t[i]&&t[i].apply(t,e)}),a}})}))),i._data=a),i.resyncElements()},update:ut.noop,transition:function(t){for(var e=this.getMeta(),i=e.data||[],n=i.length,a=0;a<n;++a)i[a].transition(t);e.dataset&&e.dataset.transition(t)},draw:function(){var t=this.getMeta(),e=t.data||[],i=e.length,n=0;for(t.dataset&&t.dataset.draw();n<i;++n)e[n].draw()},removeHoverStyle:function(t){ut.merge(t._model,t.$previousStyle||{}),delete t.$previousStyle},setHoverStyle:function(t){var e=this.chart.data.datasets[t._datasetIndex],i=t._index,n=t.custom||{},a=t._model,o=ut.getHoverColor;t.$previousStyle={backgroundColor:a.backgroundColor,borderColor:a.borderColor,borderWidth:a.borderWidth},a.backgroundColor=xt([n.hoverBackgroundColor,e.hoverBackgroundColor,o(a.backgroundColor)],void 0,i),a.borderColor=xt([n.hoverBorderColor,e.hoverBorderColor,o(a.borderColor)],void 0,i),a.borderWidth=xt([n.hoverBorderWidth,e.hoverBorderWidth,a.borderWidth],void 0,i)},resyncElements:function(){var t=this.getMeta(),e=this.getDataset().data,i=t.data.length,n=e.length;n<i?t.data.splice(n,i-n):n>i&&this.insertElements(i,n-i)},insertElements:function(t,e){for(var i=0;i<e;++i)this.addElementAndReset(t+i)},onDataPush:function(){var t=arguments.length;this.insertElements(this.getDataset().data.length-t,t)},onDataPop:function(){this.getMeta().data.pop()},onDataShift:function(){this.getMeta().data.shift()},onDataSplice:function(t,e){this.getMeta().data.splice(t,e),this.insertElements(t,arguments.length-2)},onDataUnshift:function(){this.insertElements(0,arguments.length)}}),wt.extend=ut.inherits;var Mt=wt;st._set("global",{elements:{arc:{backgroundColor:st.global.defaultColor,borderColor:"#fff",borderWidth:2,borderAlign:"center"}}});var _t=pt.extend({inLabelRange:function(t){var e=this._view;return!!e&&Math.pow(t-e.x,2)<Math.pow(e.radius+e.hoverRadius,2)},inRange:function(t,e){var i=this._view;if(i){for(var n=ut.getAngleFromPoint(i,{x:t,y:e}),a=n.angle,o=n.distance,r=i.startAngle,s=i.endAngle;s<r;)s+=2*Math.PI;for(;a>s;)a-=2*Math.PI;for(;a<r;)a+=2*Math.PI;var l=a>=r&&a<=s,d=o>=i.innerRadius&&o<=i.outerRadius;return l&&d}return!1},getCenterPoint:function(){var t=this._view,e=(t.startAngle+t.endAngle)/2,i=(t.innerRadius+t.outerRadius)/2;return{x:t.x+Math.cos(e)*i,y:t.y+Math.sin(e)*i}},getArea:function(){var t=this._view;return Math.PI*((t.endAngle-t.startAngle)/(2*Math.PI))*(Math.pow(t.outerRadius,2)-Math.pow(t.innerRadius,2))},tooltipPosition:function(){var t=this._view,e=t.startAngle+(t.endAngle-t.startAngle)/2,i=(t.outerRadius-t.innerRadius)/2+t.innerRadius;return{x:t.x+Math.cos(e)*i,y:t.y+Math.sin(e)*i}},draw:function(){var t,e=this._chart.ctx,i=this._view,n=i.startAngle,a=i.endAngle,o="inner"===i.borderAlign?.33:0;e.save(),e.beginPath(),e.arc(i.x,i.y,Math.max(i.outerRadius-o,0),n,a),e.arc(i.x,i.y,i.innerRadius,a,n,!0),e.closePath(),e.fillStyle=i.backgroundColor,e.fill(),i.borderWidth&&("inner"===i.borderAlign?(e.beginPath(),t=o/i.outerRadius,e.arc(i.x,i.y,i.outerRadius,n-t,a+t),i.innerRadius>o?(t=o/i.innerRadius,e.arc(i.x,i.y,i.innerRadius-o,a+t,n-t,!0)):e.arc(i.x,i.y,o,a+Math.PI/2,n-Math.PI/2),e.closePath(),e.clip(),e.beginPath(),e.arc(i.x,i.y,i.outerRadius,n,a),e.arc(i.x,i.y,i.innerRadius,a,n,!0),e.closePath(),e.lineWidth=2*i.borderWidth,e.lineJoin="round"):(e.lineWidth=i.borderWidth,e.lineJoin="bevel"),e.strokeStyle=i.borderColor,e.stroke()),e.restore()}}),Ct=ut.valueOrDefault,St=st.global.defaultColor;st._set("global",{elements:{line:{tension:.4,backgroundColor:St,borderWidth:3,borderColor:St,borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",capBezierPoints:!0,fill:!0}}});var Pt=pt.extend({draw:function(){var t,e,i,n,a=this._view,o=this._chart.ctx,r=a.spanGaps,s=this._children.slice(),l=st.global,d=l.elements.line,u=-1;for(this._loop&&s.length&&s.push(s[0]),o.save(),o.lineCap=a.borderCapStyle||d.borderCapStyle,o.setLineDash&&o.setLineDash(a.borderDash||d.borderDash),o.lineDashOffset=Ct(a.borderDashOffset,d.borderDashOffset),o.lineJoin=a.borderJoinStyle||d.borderJoinStyle,o.lineWidth=Ct(a.borderWidth,d.borderWidth),o.strokeStyle=a.borderColor||l.defaultColor,o.beginPath(),u=-1,t=0;t<s.length;++t)e=s[t],i=ut.previousItem(s,t),n=e._view,0===t?n.skip||(o.moveTo(n.x,n.y),u=t):(i=-1===u?i:s[u],n.skip||(u!==t-1&&!r||-1===u?o.moveTo(n.x,n.y):ut.canvas.lineTo(o,i._view,e._view),u=t));o.stroke(),o.restore()}}),It=ut.valueOrDefault,At=st.global.defaultColor;function Dt(t){var e=this._view;return!!e&&Math.abs(t-e.x)<e.radius+e.hitRadius}st._set("global",{elements:{point:{radius:3,pointStyle:"circle",backgroundColor:At,borderColor:At,borderWidth:1,hitRadius:1,hoverRadius:4,hoverBorderWidth:1}}});var Tt=pt.extend({inRange:function(t,e){var i=this._view;return!!i&&Math.pow(t-i.x,2)+Math.pow(e-i.y,2)<Math.pow(i.hitRadius+i.radius,2)},inLabelRange:Dt,inXRange:Dt,inYRange:function(t){var e=this._view;return!!e&&Math.abs(t-e.y)<e.radius+e.hitRadius},getCenterPoint:function(){var t=this._view;return{x:t.x,y:t.y}},getArea:function(){return Math.PI*Math.pow(this._view.radius,2)},tooltipPosition:function(){var t=this._view;return{x:t.x,y:t.y,padding:t.radius+t.borderWidth}},draw:function(t){var e=this._view,i=this._chart.ctx,n=e.pointStyle,a=e.rotation,o=e.radius,r=e.x,s=e.y,l=st.global,d=l.defaultColor;e.skip||(void 0===t||ut.canvas._isPointInArea(e,t))&&(i.strokeStyle=e.borderColor||d,i.lineWidth=It(e.borderWidth,l.elements.point.borderWidth),i.fillStyle=e.backgroundColor||d,ut.canvas.drawPoint(i,n,o,r,s,a))}}),Ft=st.global.defaultColor;function Lt(t){return t&&void 0!==t.width}function Rt(t){var e,i,n,a,o;return Lt(t)?(o=t.width/2,e=t.x-o,i=t.x+o,n=Math.min(t.y,t.base),a=Math.max(t.y,t.base)):(o=t.height/2,e=Math.min(t.x,t.base),i=Math.max(t.x,t.base),n=t.y-o,a=t.y+o),{left:e,top:n,right:i,bottom:a}}function Ot(t,e,i){return t===e?i:t===i?e:t}function zt(t,e,i){var n,a,o,r,s=t.borderWidth,l=function(t){var e=t.borderSkipped,i={};return e?(t.horizontal?t.base>t.x&&(e=Ot(e,"left","right")):t.base<t.y&&(e=Ot(e,"bottom","top")),i[e]=!0,i):i}(t);return ut.isObject(s)?(n=+s.top||0,a=+s.right||0,o=+s.bottom||0,r=+s.left||0):n=a=o=r=+s||0,{t:l.top||n<0?0:n>i?i:n,r:l.right||a<0?0:a>e?e:a,b:l.bottom||o<0?0:o>i?i:o,l:l.left||r<0?0:r>e?e:r}}function Bt(t,e,i){var n=null===e,a=null===i,o=!(!t||n&&a)&&Rt(t);return o&&(n||e>=o.left&&e<=o.right)&&(a||i>=o.top&&i<=o.bottom)}st._set("global",{elements:{rectangle:{backgroundColor:Ft,borderColor:Ft,borderSkipped:"bottom",borderWidth:0}}});var Nt=pt.extend({draw:function(){var t=this._chart.ctx,e=this._view,i=function(t){var e=Rt(t),i=e.right-e.left,n=e.bottom-e.top,a=zt(t,i/2,n/2);return{outer:{x:e.left,y:e.top,w:i,h:n},inner:{x:e.left+a.l,y:e.top+a.t,w:i-a.l-a.r,h:n-a.t-a.b}}}(e),n=i.outer,a=i.inner;t.fillStyle=e.backgroundColor,t.fillRect(n.x,n.y,n.w,n.h),n.w===a.w&&n.h===a.h||(t.save(),t.beginPath(),t.rect(n.x,n.y,n.w,n.h),t.clip(),t.fillStyle=e.borderColor,t.rect(a.x,a.y,a.w,a.h),t.fill("evenodd"),t.restore())},height:function(){var t=this._view;return t.base-t.y},inRange:function(t,e){return Bt(this._view,t,e)},inLabelRange:function(t,e){var i=this._view;return Lt(i)?Bt(i,t,null):Bt(i,null,e)},inXRange:function(t){return Bt(this._view,t,null)},inYRange:function(t){return Bt(this._view,null,t)},getCenterPoint:function(){var t,e,i=this._view;return Lt(i)?(t=i.x,e=(i.y+i.base)/2):(t=(i.x+i.base)/2,e=i.y),{x:t,y:e}},getArea:function(){var t=this._view;return Lt(t)?t.width*Math.abs(t.y-t.base):t.height*Math.abs(t.x-t.base)},tooltipPosition:function(){var t=this._view;return{x:t.x,y:t.y}}}),Wt={},Vt=_t,Et=Pt,Ht=Tt,jt=Nt;Wt.Arc=Vt,Wt.Line=Et,Wt.Point=Ht,Wt.Rectangle=jt;var qt=ut.options.resolve;st._set("bar",{hover:{mode:"label"},scales:{xAxes:[{type:"category",categoryPercentage:.8,barPercentage:.9,offset:!0,gridLines:{offsetGridLines:!0}}],yAxes:[{type:"linear"}]}});var Yt=Mt.extend({dataElementType:Wt.Rectangle,initialize:function(){var t;Mt.prototype.initialize.apply(this,arguments),(t=this.getMeta()).stack=this.getDataset().stack,t.bar=!0},update:function(t){var e,i,n=this.getMeta().data;for(this._ruler=this.getRuler(),e=0,i=n.length;e<i;++e)this.updateElement(n[e],e,t)},updateElement:function(t,e,i){var n=this,a=n.getMeta(),o=n.getDataset(),r=n._resolveElementOptions(t,e);t._xScale=n.getScaleForId(a.xAxisID),t._yScale=n.getScaleForId(a.yAxisID),t._datasetIndex=n.index,t._index=e,t._model={backgroundColor:r.backgroundColor,borderColor:r.borderColor,borderSkipped:r.borderSkipped,borderWidth:r.borderWidth,datasetLabel:o.label,label:n.chart.data.labels[e]},n._updateElementGeometry(t,e,i),t.pivot()},_updateElementGeometry:function(t,e,i){var n=this,a=t._model,o=n._getValueScale(),r=o.getBasePixel(),s=o.isHorizontal(),l=n._ruler||n.getRuler(),d=n.calculateBarValuePixels(n.index,e),u=n.calculateBarIndexPixels(n.index,e,l);a.horizontal=s,a.base=i?r:d.base,a.x=s?i?r:d.head:u.center,a.y=s?u.center:i?r:d.head,a.height=s?u.size:void 0,a.width=s?void 0:u.size},_getStacks:function(t){var e,i,n=this.chart,a=this._getIndexScale().options.stacked,o=void 0===t?n.data.datasets.length:t+1,r=[];for(e=0;e<o;++e)(i=n.getDatasetMeta(e)).bar&&n.isDatasetVisible(e)&&(!1===a||!0===a&&-1===r.indexOf(i.stack)||void 0===a&&(void 0===i.stack||-1===r.indexOf(i.stack)))&&r.push(i.stack);return r},getStackCount:function(){return this._getStacks().length},getStackIndex:function(t,e){var i=this._getStacks(t),n=void 0!==e?i.indexOf(e):-1;return-1===n?i.length-1:n},getRuler:function(){var t,e,i=this._getIndexScale(),n=this.getStackCount(),a=this.index,o=i.isHorizontal(),r=o?i.left:i.top,s=r+(o?i.width:i.height),l=[];for(t=0,e=this.getMeta().data.length;t<e;++t)l.push(i.getPixelForValue(null,t,a));return{min:ut.isNullOrUndef(i.options.barThickness)?function(t,e){var i,n,a,o,r=t.isHorizontal()?t.width:t.height,s=t.getTicks();for(a=1,o=e.length;a<o;++a)r=Math.min(r,Math.abs(e[a]-e[a-1]));for(a=0,o=s.length;a<o;++a)n=t.getPixelForTick(a),r=a>0?Math.min(r,n-i):r,i=n;return r}(i,l):-1,pixels:l,start:r,end:s,stackCount:n,scale:i}},calculateBarValuePixels:function(t,e){var i,n,a,o,r,s,l=this.chart,d=this.getMeta(),u=this._getValueScale(),h=u.isHorizontal(),c=l.data.datasets,f=+u.getRightValue(c[t].data[e]),g=u.options.minBarLength,p=u.options.stacked,m=d.stack,v=0;if(p||void 0===p&&void 0!==m)for(i=0;i<t;++i)(n=l.getDatasetMeta(i)).bar&&n.stack===m&&n.controller._getValueScaleId()===u.id&&l.isDatasetVisible(i)&&(a=+u.getRightValue(c[i].data[e]),(f<0&&a<0||f>=0&&a>0)&&(v+=a));return o=u.getPixelForValue(v),s=(r=u.getPixelForValue(v+f))-o,void 0!==g&&Math.abs(s)<g&&(s=g,r=f>=0&&!h||f<0&&h?o-g:o+g),{size:s,base:o,head:r,center:r+s/2}},calculateBarIndexPixels:function(t,e,i){var n=i.scale.options,a="flex"===n.barThickness?function(t,e,i){var n,a=e.pixels,o=a[t],r=t>0?a[t-1]:null,s=t<a.length-1?a[t+1]:null,l=i.categoryPercentage;return null===r&&(r=o-(null===s?e.end-e.start:s-o)),null===s&&(s=o+o-r),n=o-(o-Math.min(r,s))/2*l,{chunk:Math.abs(s-r)/2*l/e.stackCount,ratio:i.barPercentage,start:n}}(e,i,n):function(t,e,i){var n,a,o=i.barThickness,r=e.stackCount,s=e.pixels[t];return ut.isNullOrUndef(o)?(n=e.min*i.categoryPercentage,a=i.barPercentage):(n=o*r,a=1),{chunk:n/r,ratio:a,start:s-n/2}}(e,i,n),o=this.getStackIndex(t,this.getMeta().stack),r=a.start+a.chunk*o+a.chunk/2,s=Math.min(ut.valueOrDefault(n.maxBarThickness,1/0),a.chunk*a.ratio);return{base:r-s/2,head:r+s/2,center:r,size:s}},draw:function(){var t=this.chart,e=this._getValueScale(),i=this.getMeta().data,n=this.getDataset(),a=i.length,o=0;for(ut.canvas.clipArea(t.ctx,t.chartArea);o<a;++o)isNaN(e.getRightValue(n.data[o]))||i[o].draw();ut.canvas.unclipArea(t.ctx)},_resolveElementOptions:function(t,e){var i,n,a,o=this.chart,r=o.data.datasets[this.index],s=t.custom||{},l=o.options.elements.rectangle,d={},u={chart:o,dataIndex:e,dataset:r,datasetIndex:this.index},h=["backgroundColor","borderColor","borderSkipped","borderWidth"];for(i=0,n=h.length;i<n;++i)d[a=h[i]]=qt([s[a],r[a],l[a]],u,e);return d}}),Ut=ut.valueOrDefault,Xt=ut.options.resolve;st._set("bubble",{hover:{mode:"single"},scales:{xAxes:[{type:"linear",position:"bottom",id:"x-axis-0"}],yAxes:[{type:"linear",position:"left",id:"y-axis-0"}]},tooltips:{callbacks:{title:function(){return""},label:function(t,e){var i=e.datasets[t.datasetIndex].label||"",n=e.datasets[t.datasetIndex].data[t.index];return i+": ("+t.xLabel+", "+t.yLabel+", "+n.r+")"}}}});var Kt=Mt.extend({dataElementType:Wt.Point,update:function(t){var e=this,i=e.getMeta().data;ut.each(i,function(i,n){e.updateElement(i,n,t)})},updateElement:function(t,e,i){var n=this,a=n.getMeta(),o=t.custom||{},r=n.getScaleForId(a.xAxisID),s=n.getScaleForId(a.yAxisID),l=n._resolveElementOptions(t,e),d=n.getDataset().data[e],u=n.index,h=i?r.getPixelForDecimal(.5):r.getPixelForValue("object"==typeof d?d:NaN,e,u),c=i?s.getBasePixel():s.getPixelForValue(d,e,u);t._xScale=r,t._yScale=s,t._options=l,t._datasetIndex=u,t._index=e,t._model={backgroundColor:l.backgroundColor,borderColor:l.borderColor,borderWidth:l.borderWidth,hitRadius:l.hitRadius,pointStyle:l.pointStyle,rotation:l.rotation,radius:i?0:l.radius,skip:o.skip||isNaN(h)||isNaN(c),x:h,y:c},t.pivot()},setHoverStyle:function(t){var e=t._model,i=t._options,n=ut.getHoverColor;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth,radius:e.radius},e.backgroundColor=Ut(i.hoverBackgroundColor,n(i.backgroundColor)),e.borderColor=Ut(i.hoverBorderColor,n(i.borderColor)),e.borderWidth=Ut(i.hoverBorderWidth,i.borderWidth),e.radius=i.radius+i.hoverRadius},_resolveElementOptions:function(t,e){var i,n,a,o=this.chart,r=o.data.datasets[this.index],s=t.custom||{},l=o.options.elements.point,d=r.data[e],u={},h={chart:o,dataIndex:e,dataset:r,datasetIndex:this.index},c=["backgroundColor","borderColor","borderWidth","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth","hoverRadius","hitRadius","pointStyle","rotation"];for(i=0,n=c.length;i<n;++i)u[a=c[i]]=Xt([s[a],r[a],l[a]],h,e);return u.radius=Xt([s.radius,d?d.r:void 0,r.radius,l.radius],h,e),u}}),Gt=ut.options.resolve,Zt=ut.valueOrDefault;st._set("doughnut",{animation:{animateRotate:!0,animateScale:!1},hover:{mode:"single"},legendCallback:function(t){var e=[];e.push('<ul class="'+t.id+'-legend">');var i=t.data,n=i.datasets,a=i.labels;if(n.length)for(var o=0;o<n[0].data.length;++o)e.push('<li><span style="background-color:'+n[0].backgroundColor[o]+'"></span>'),a[o]&&e.push(a[o]),e.push("</li>");return e.push("</ul>"),e.join("")},legend:{labels:{generateLabels:function(t){var e=t.data;return e.labels.length&&e.datasets.length?e.labels.map(function(i,n){var a=t.getDatasetMeta(0),o=e.datasets[0],r=a.data[n],s=r&&r.custom||{},l=t.options.elements.arc;return{text:i,fillStyle:Gt([s.backgroundColor,o.backgroundColor,l.backgroundColor],void 0,n),strokeStyle:Gt([s.borderColor,o.borderColor,l.borderColor],void 0,n),lineWidth:Gt([s.borderWidth,o.borderWidth,l.borderWidth],void 0,n),hidden:isNaN(o.data[n])||a.data[n].hidden,index:n}}):[]}},onClick:function(t,e){var i,n,a,o=e.index,r=this.chart;for(i=0,n=(r.data.datasets||[]).length;i<n;++i)(a=r.getDatasetMeta(i)).data[o]&&(a.data[o].hidden=!a.data[o].hidden);r.update()}},cutoutPercentage:50,rotation:-.5*Math.PI,circumference:2*Math.PI,tooltips:{callbacks:{title:function(){return""},label:function(t,e){var i=e.labels[t.index],n=": "+e.datasets[t.datasetIndex].data[t.index];return ut.isArray(i)?(i=i.slice())[0]+=n:i+=n,i}}}});var $t=Mt.extend({dataElementType:Wt.Arc,linkScales:ut.noop,getRingIndex:function(t){for(var e=0,i=0;i<t;++i)this.chart.isDatasetVisible(i)&&++e;return e},update:function(t){var e,i,n=this,a=n.chart,o=a.chartArea,r=a.options,s=o.right-o.left,l=o.bottom-o.top,d=Math.min(s,l),u={x:0,y:0},h=n.getMeta(),c=h.data,f=r.cutoutPercentage,g=r.circumference,p=n._getRingWeight(n.index);if(g<2*Math.PI){var m=r.rotation%(2*Math.PI),v=(m+=2*Math.PI*(m>=Math.PI?-1:m<-Math.PI?1:0))+g,b={x:Math.cos(m),y:Math.sin(m)},x={x:Math.cos(v),y:Math.sin(v)},y=m<=0&&v>=0||m<=2*Math.PI&&2*Math.PI<=v,k=m<=.5*Math.PI&&.5*Math.PI<=v||m<=2.5*Math.PI&&2.5*Math.PI<=v,w=m<=-Math.PI&&-Math.PI<=v||m<=Math.PI&&Math.PI<=v,M=m<=.5*-Math.PI&&.5*-Math.PI<=v||m<=1.5*Math.PI&&1.5*Math.PI<=v,_=f/100,C={x:w?-1:Math.min(b.x*(b.x<0?1:_),x.x*(x.x<0?1:_)),y:M?-1:Math.min(b.y*(b.y<0?1:_),x.y*(x.y<0?1:_))},S={x:y?1:Math.max(b.x*(b.x>0?1:_),x.x*(x.x>0?1:_)),y:k?1:Math.max(b.y*(b.y>0?1:_),x.y*(x.y>0?1:_))},P={width:.5*(S.x-C.x),height:.5*(S.y-C.y)};d=Math.min(s/P.width,l/P.height),u={x:-.5*(S.x+C.x),y:-.5*(S.y+C.y)}}for(e=0,i=c.length;e<i;++e)c[e]._options=n._resolveElementOptions(c[e],e);for(a.borderWidth=n.getMaxBorderWidth(),a.outerRadius=Math.max((d-a.borderWidth)/2,0),a.innerRadius=Math.max(f?a.outerRadius/100*f:0,0),a.radiusLength=(a.outerRadius-a.innerRadius)/(n._getVisibleDatasetWeightTotal()||1),a.offsetX=u.x*a.outerRadius,a.offsetY=u.y*a.outerRadius,h.total=n.calculateTotal(),n.outerRadius=a.outerRadius-a.radiusLength*n._getRingWeightOffset(n.index),n.innerRadius=Math.max(n.outerRadius-a.radiusLength*p,0),e=0,i=c.length;e<i;++e)n.updateElement(c[e],e,t)},updateElement:function(t,e,i){var n=this,a=n.chart,o=a.chartArea,r=a.options,s=r.animation,l=(o.left+o.right)/2,d=(o.top+o.bottom)/2,u=r.rotation,h=r.rotation,c=n.getDataset(),f=i&&s.animateRotate?0:t.hidden?0:n.calculateCircumference(c.data[e])*(r.circumference/(2*Math.PI)),g=i&&s.animateScale?0:n.innerRadius,p=i&&s.animateScale?0:n.outerRadius,m=t._options||{};ut.extend(t,{_datasetIndex:n.index,_index:e,_model:{backgroundColor:m.backgroundColor,borderColor:m.borderColor,borderWidth:m.borderWidth,borderAlign:m.borderAlign,x:l+a.offsetX,y:d+a.offsetY,startAngle:u,endAngle:h,circumference:f,outerRadius:p,innerRadius:g,label:ut.valueAtIndexOrDefault(c.label,e,a.data.labels[e])}});var v=t._model;i&&s.animateRotate||(v.startAngle=0===e?r.rotation:n.getMeta().data[e-1]._model.endAngle,v.endAngle=v.startAngle+v.circumference),t.pivot()},calculateTotal:function(){var t,e=this.getDataset(),i=this.getMeta(),n=0;return ut.each(i.data,function(i,a){t=e.data[a],isNaN(t)||i.hidden||(n+=Math.abs(t))}),n},calculateCircumference:function(t){var e=this.getMeta().total;return e>0&&!isNaN(t)?2*Math.PI*(Math.abs(t)/e):0},getMaxBorderWidth:function(t){var e,i,n,a,o,r,s,l,d=0,u=this.chart;if(!t)for(e=0,i=u.data.datasets.length;e<i;++e)if(u.isDatasetVisible(e)){t=(n=u.getDatasetMeta(e)).data,e!==this.index&&(o=n.controller);break}if(!t)return 0;for(e=0,i=t.length;e<i;++e)a=t[e],"inner"!==(r=o?o._resolveElementOptions(a,e):a._options).borderAlign&&(s=r.borderWidth,d=(l=r.hoverBorderWidth)>(d=s>d?s:d)?l:d);return d},setHoverStyle:function(t){var e=t._model,i=t._options,n=ut.getHoverColor;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth},e.backgroundColor=Zt(i.hoverBackgroundColor,n(i.backgroundColor)),e.borderColor=Zt(i.hoverBorderColor,n(i.borderColor)),e.borderWidth=Zt(i.hoverBorderWidth,i.borderWidth)},_resolveElementOptions:function(t,e){var i,n,a,o=this.chart,r=this.getDataset(),s=t.custom||{},l=o.options.elements.arc,d={},u={chart:o,dataIndex:e,dataset:r,datasetIndex:this.index},h=["backgroundColor","borderColor","borderWidth","borderAlign","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth"];for(i=0,n=h.length;i<n;++i)d[a=h[i]]=Gt([s[a],r[a],l[a]],u,e);return d},_getRingWeightOffset:function(t){for(var e=0,i=0;i<t;++i)this.chart.isDatasetVisible(i)&&(e+=this._getRingWeight(i));return e},_getRingWeight:function(t){return Math.max(Zt(this.chart.data.datasets[t].weight,1),0)},_getVisibleDatasetWeightTotal:function(){return this._getRingWeightOffset(this.chart.data.datasets.length)}});st._set("horizontalBar",{hover:{mode:"index",axis:"y"},scales:{xAxes:[{type:"linear",position:"bottom"}],yAxes:[{type:"category",position:"left",categoryPercentage:.8,barPercentage:.9,offset:!0,gridLines:{offsetGridLines:!0}}]},elements:{rectangle:{borderSkipped:"left"}},tooltips:{mode:"index",axis:"y"}});var Jt=Yt.extend({_getValueScaleId:function(){return this.getMeta().xAxisID},_getIndexScaleId:function(){return this.getMeta().yAxisID}}),Qt=ut.valueOrDefault,te=ut.options.resolve,ee=ut.canvas._isPointInArea;function ie(t,e){return Qt(t.showLine,e.showLines)}st._set("line",{showLines:!0,spanGaps:!1,hover:{mode:"label"},scales:{xAxes:[{type:"category",id:"x-axis-0"}],yAxes:[{type:"linear",id:"y-axis-0"}]}});var ne=Mt.extend({datasetElementType:Wt.Line,dataElementType:Wt.Point,update:function(t){var e,i,n=this,a=n.getMeta(),o=a.dataset,r=a.data||[],s=n.getScaleForId(a.yAxisID),l=n.getDataset(),d=ie(l,n.chart.options);for(d&&(void 0!==l.tension&&void 0===l.lineTension&&(l.lineTension=l.tension),o._scale=s,o._datasetIndex=n.index,o._children=r,o._model=n._resolveLineOptions(o),o.pivot()),e=0,i=r.length;e<i;++e)n.updateElement(r[e],e,t);for(d&&0!==o._model.tension&&n.updateBezierControlPoints(),e=0,i=r.length;e<i;++e)r[e].pivot()},updateElement:function(t,e,i){var n,a,o=this,r=o.getMeta(),s=t.custom||{},l=o.getDataset(),d=o.index,u=l.data[e],h=o.getScaleForId(r.yAxisID),c=o.getScaleForId(r.xAxisID),f=r.dataset._model,g=o._resolvePointOptions(t,e);n=c.getPixelForValue("object"==typeof u?u:NaN,e,d),a=i?h.getBasePixel():o.calculatePointY(u,e,d),t._xScale=c,t._yScale=h,t._options=g,t._datasetIndex=d,t._index=e,t._model={x:n,y:a,skip:s.skip||isNaN(n)||isNaN(a),radius:g.radius,pointStyle:g.pointStyle,rotation:g.rotation,backgroundColor:g.backgroundColor,borderColor:g.borderColor,borderWidth:g.borderWidth,tension:Qt(s.tension,f?f.tension:0),steppedLine:!!f&&f.steppedLine,hitRadius:g.hitRadius}},_resolvePointOptions:function(t,e){var i,n,a,o=this.chart,r=o.data.datasets[this.index],s=t.custom||{},l=o.options.elements.point,d={},u={chart:o,dataIndex:e,dataset:r,datasetIndex:this.index},h={backgroundColor:"pointBackgroundColor",borderColor:"pointBorderColor",borderWidth:"pointBorderWidth",hitRadius:"pointHitRadius",hoverBackgroundColor:"pointHoverBackgroundColor",hoverBorderColor:"pointHoverBorderColor",hoverBorderWidth:"pointHoverBorderWidth",hoverRadius:"pointHoverRadius",pointStyle:"pointStyle",radius:"pointRadius",rotation:"pointRotation"},c=Object.keys(h);for(i=0,n=c.length;i<n;++i)d[a=c[i]]=te([s[a],r[h[a]],r[a],l[a]],u,e);return d},_resolveLineOptions:function(t){var e,i,n,a=this.chart,o=a.data.datasets[this.index],r=t.custom||{},s=a.options,l=s.elements.line,d={},u=["backgroundColor","borderWidth","borderColor","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","fill","cubicInterpolationMode"];for(e=0,i=u.length;e<i;++e)d[n=u[e]]=te([r[n],o[n],l[n]]);return d.spanGaps=Qt(o.spanGaps,s.spanGaps),d.tension=Qt(o.lineTension,l.tension),d.steppedLine=te([r.steppedLine,o.steppedLine,l.stepped]),d},calculatePointY:function(t,e,i){var n,a,o,r=this.chart,s=this.getMeta(),l=this.getScaleForId(s.yAxisID),d=0,u=0;if(l.options.stacked){for(n=0;n<i;n++)if(a=r.data.datasets[n],"line"===(o=r.getDatasetMeta(n)).type&&o.yAxisID===l.id&&r.isDatasetVisible(n)){var h=Number(l.getRightValue(a.data[e]));h<0?u+=h||0:d+=h||0}var c=Number(l.getRightValue(t));return c<0?l.getPixelForValue(u+c):l.getPixelForValue(d+c)}return l.getPixelForValue(t)},updateBezierControlPoints:function(){var t,e,i,n,a=this.chart,o=this.getMeta(),r=o.dataset._model,s=a.chartArea,l=o.data||[];function d(t,e,i){return Math.max(Math.min(t,i),e)}if(r.spanGaps&&(l=l.filter(function(t){return!t._model.skip})),"monotone"===r.cubicInterpolationMode)ut.splineCurveMonotone(l);else for(t=0,e=l.length;t<e;++t)i=l[t]._model,n=ut.splineCurve(ut.previousItem(l,t)._model,i,ut.nextItem(l,t)._model,r.tension),i.controlPointPreviousX=n.previous.x,i.controlPointPreviousY=n.previous.y,i.controlPointNextX=n.next.x,i.controlPointNextY=n.next.y;if(a.options.elements.line.capBezierPoints)for(t=0,e=l.length;t<e;++t)i=l[t]._model,ee(i,s)&&(t>0&&ee(l[t-1]._model,s)&&(i.controlPointPreviousX=d(i.controlPointPreviousX,s.left,s.right),i.controlPointPreviousY=d(i.controlPointPreviousY,s.top,s.bottom)),t<l.length-1&&ee(l[t+1]._model,s)&&(i.controlPointNextX=d(i.controlPointNextX,s.left,s.right),i.controlPointNextY=d(i.controlPointNextY,s.top,s.bottom)))},draw:function(){var t,e=this.chart,i=this.getMeta(),n=i.data||[],a=e.chartArea,o=n.length,r=0;for(ie(this.getDataset(),e.options)&&(t=(i.dataset._model.borderWidth||0)/2,ut.canvas.clipArea(e.ctx,{left:a.left,right:a.right,top:a.top-t,bottom:a.bottom+t}),i.dataset.draw(),ut.canvas.unclipArea(e.ctx));r<o;++r)n[r].draw(a)},setHoverStyle:function(t){var e=t._model,i=t._options,n=ut.getHoverColor;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth,radius:e.radius},e.backgroundColor=Qt(i.hoverBackgroundColor,n(i.backgroundColor)),e.borderColor=Qt(i.hoverBorderColor,n(i.borderColor)),e.borderWidth=Qt(i.hoverBorderWidth,i.borderWidth),e.radius=Qt(i.hoverRadius,i.radius)}}),ae=ut.options.resolve;st._set("polarArea",{scale:{type:"radialLinear",angleLines:{display:!1},gridLines:{circular:!0},pointLabels:{display:!1},ticks:{beginAtZero:!0}},animation:{animateRotate:!0,animateScale:!0},startAngle:-.5*Math.PI,legendCallback:function(t){var e=[];e.push('<ul class="'+t.id+'-legend">');var i=t.data,n=i.datasets,a=i.labels;if(n.length)for(var o=0;o<n[0].data.length;++o)e.push('<li><span style="background-color:'+n[0].backgroundColor[o]+'"></span>'),a[o]&&e.push(a[o]),e.push("</li>");return e.push("</ul>"),e.join("")},legend:{labels:{generateLabels:function(t){var e=t.data;return e.labels.length&&e.datasets.length?e.labels.map(function(i,n){var a=t.getDatasetMeta(0),o=e.datasets[0],r=a.data[n].custom||{},s=t.options.elements.arc;return{text:i,fillStyle:ae([r.backgroundColor,o.backgroundColor,s.backgroundColor],void 0,n),strokeStyle:ae([r.borderColor,o.borderColor,s.borderColor],void 0,n),lineWidth:ae([r.borderWidth,o.borderWidth,s.borderWidth],void 0,n),hidden:isNaN(o.data[n])||a.data[n].hidden,index:n}}):[]}},onClick:function(t,e){var i,n,a,o=e.index,r=this.chart;for(i=0,n=(r.data.datasets||[]).length;i<n;++i)(a=r.getDatasetMeta(i)).data[o].hidden=!a.data[o].hidden;r.update()}},tooltips:{callbacks:{title:function(){return""},label:function(t,e){return e.labels[t.index]+": "+t.yLabel}}}});var oe=Mt.extend({dataElementType:Wt.Arc,linkScales:ut.noop,update:function(t){var e,i,n,a=this,o=a.getDataset(),r=a.getMeta(),s=a.chart.options.startAngle||0,l=a._starts=[],d=a._angles=[],u=r.data;for(a._updateRadius(),r.count=a.countVisibleElements(),e=0,i=o.data.length;e<i;e++)l[e]=s,n=a._computeAngle(e),d[e]=n,s+=n;for(e=0,i=u.length;e<i;++e)u[e]._options=a._resolveElementOptions(u[e],e),a.updateElement(u[e],e,t)},_updateRadius:function(){var t=this,e=t.chart,i=e.chartArea,n=e.options,a=Math.min(i.right-i.left,i.bottom-i.top);e.outerRadius=Math.max(a/2,0),e.innerRadius=Math.max(n.cutoutPercentage?e.outerRadius/100*n.cutoutPercentage:1,0),e.radiusLength=(e.outerRadius-e.innerRadius)/e.getVisibleDatasetCount(),t.outerRadius=e.outerRadius-e.radiusLength*t.index,t.innerRadius=t.outerRadius-e.radiusLength},updateElement:function(t,e,i){var n=this,a=n.chart,o=n.getDataset(),r=a.options,s=r.animation,l=a.scale,d=a.data.labels,u=l.xCenter,h=l.yCenter,c=r.startAngle,f=t.hidden?0:l.getDistanceFromCenterForValue(o.data[e]),g=n._starts[e],p=g+(t.hidden?0:n._angles[e]),m=s.animateScale?0:l.getDistanceFromCenterForValue(o.data[e]),v=t._options||{};ut.extend(t,{_datasetIndex:n.index,_index:e,_scale:l,_model:{backgroundColor:v.backgroundColor,borderColor:v.borderColor,borderWidth:v.borderWidth,borderAlign:v.borderAlign,x:u,y:h,innerRadius:0,outerRadius:i?m:f,startAngle:i&&s.animateRotate?c:g,endAngle:i&&s.animateRotate?c:p,label:ut.valueAtIndexOrDefault(d,e,d[e])}}),t.pivot()},countVisibleElements:function(){var t=this.getDataset(),e=this.getMeta(),i=0;return ut.each(e.data,function(e,n){isNaN(t.data[n])||e.hidden||i++}),i},setHoverStyle:function(t){var e=t._model,i=t._options,n=ut.getHoverColor,a=ut.valueOrDefault;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth},e.backgroundColor=a(i.hoverBackgroundColor,n(i.backgroundColor)),e.borderColor=a(i.hoverBorderColor,n(i.borderColor)),e.borderWidth=a(i.hoverBorderWidth,i.borderWidth)},_resolveElementOptions:function(t,e){var i,n,a,o=this.chart,r=this.getDataset(),s=t.custom||{},l=o.options.elements.arc,d={},u={chart:o,dataIndex:e,dataset:r,datasetIndex:this.index},h=["backgroundColor","borderColor","borderWidth","borderAlign","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth"];for(i=0,n=h.length;i<n;++i)d[a=h[i]]=ae([s[a],r[a],l[a]],u,e);return d},_computeAngle:function(t){var e=this,i=this.getMeta().count,n=e.getDataset(),a=e.getMeta();if(isNaN(n.data[t])||a.data[t].hidden)return 0;var o={chart:e.chart,dataIndex:t,dataset:n,datasetIndex:e.index};return ae([e.chart.options.elements.arc.angle,2*Math.PI/i],o,t)}});st._set("pie",ut.clone(st.doughnut)),st._set("pie",{cutoutPercentage:0});var re=$t,se=ut.valueOrDefault,le=ut.options.resolve;st._set("radar",{scale:{type:"radialLinear"},elements:{line:{tension:0}}});var de=Mt.extend({datasetElementType:Wt.Line,dataElementType:Wt.Point,linkScales:ut.noop,update:function(t){var e,i,n=this,a=n.getMeta(),o=a.dataset,r=a.data||[],s=n.chart.scale,l=n.getDataset();for(void 0!==l.tension&&void 0===l.lineTension&&(l.lineTension=l.tension),o._scale=s,o._datasetIndex=n.index,o._children=r,o._loop=!0,o._model=n._resolveLineOptions(o),o.pivot(),e=0,i=r.length;e<i;++e)n.updateElement(r[e],e,t);for(n.updateBezierControlPoints(),e=0,i=r.length;e<i;++e)r[e].pivot()},updateElement:function(t,e,i){var n=this,a=t.custom||{},o=n.getDataset(),r=n.chart.scale,s=r.getPointPositionForValue(e,o.data[e]),l=n._resolvePointOptions(t,e),d=n.getMeta().dataset._model,u=i?r.xCenter:s.x,h=i?r.yCenter:s.y;t._scale=r,t._options=l,t._datasetIndex=n.index,t._index=e,t._model={x:u,y:h,skip:a.skip||isNaN(u)||isNaN(h),radius:l.radius,pointStyle:l.pointStyle,rotation:l.rotation,backgroundColor:l.backgroundColor,borderColor:l.borderColor,borderWidth:l.borderWidth,tension:se(a.tension,d?d.tension:0),hitRadius:l.hitRadius}},_resolvePointOptions:function(t,e){var i,n,a,o=this.chart,r=o.data.datasets[this.index],s=t.custom||{},l=o.options.elements.point,d={},u={chart:o,dataIndex:e,dataset:r,datasetIndex:this.index},h={backgroundColor:"pointBackgroundColor",borderColor:"pointBorderColor",borderWidth:"pointBorderWidth",hitRadius:"pointHitRadius",hoverBackgroundColor:"pointHoverBackgroundColor",hoverBorderColor:"pointHoverBorderColor",hoverBorderWidth:"pointHoverBorderWidth",hoverRadius:"pointHoverRadius",pointStyle:"pointStyle",radius:"pointRadius",rotation:"pointRotation"},c=Object.keys(h);for(i=0,n=c.length;i<n;++i)d[a=c[i]]=le([s[a],r[h[a]],r[a],l[a]],u,e);return d},_resolveLineOptions:function(t){var e,i,n,a=this.chart,o=a.data.datasets[this.index],r=t.custom||{},s=a.options.elements.line,l={},d=["backgroundColor","borderWidth","borderColor","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","fill"];for(e=0,i=d.length;e<i;++e)l[n=d[e]]=le([r[n],o[n],s[n]]);return l.tension=se(o.lineTension,s.tension),l},updateBezierControlPoints:function(){var t,e,i,n,a=this.getMeta(),o=this.chart.chartArea,r=a.data||[];function s(t,e,i){return Math.max(Math.min(t,i),e)}for(t=0,e=r.length;t<e;++t)i=r[t]._model,n=ut.splineCurve(ut.previousItem(r,t,!0)._model,i,ut.nextItem(r,t,!0)._model,i.tension),i.controlPointPreviousX=s(n.previous.x,o.left,o.right),i.controlPointPreviousY=s(n.previous.y,o.top,o.bottom),i.controlPointNextX=s(n.next.x,o.left,o.right),i.controlPointNextY=s(n.next.y,o.top,o.bottom)},setHoverStyle:function(t){var e=t._model,i=t._options,n=ut.getHoverColor;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth,radius:e.radius},e.backgroundColor=se(i.hoverBackgroundColor,n(i.backgroundColor)),e.borderColor=se(i.hoverBorderColor,n(i.borderColor)),e.borderWidth=se(i.hoverBorderWidth,i.borderWidth),e.radius=se(i.hoverRadius,i.radius)}});st._set("scatter",{hover:{mode:"single"},scales:{xAxes:[{id:"x-axis-1",type:"linear",position:"bottom"}],yAxes:[{id:"y-axis-1",type:"linear",position:"left"}]},showLines:!1,tooltips:{callbacks:{title:function(){return""},label:function(t){return"("+t.xLabel+", "+t.yLabel+")"}}}});var ue={bar:Yt,bubble:Kt,doughnut:$t,horizontalBar:Jt,line:ne,polarArea:oe,pie:re,radar:de,scatter:ne};function he(t,e){return t.native?{x:t.x,y:t.y}:ut.getRelativePosition(t,e)}function ce(t,e){var i,n,a,o,r;for(n=0,o=t.data.datasets.length;n<o;++n)if(t.isDatasetVisible(n))for(a=0,r=(i=t.getDatasetMeta(n)).data.length;a<r;++a){var s=i.data[a];s._view.skip||e(s)}}function fe(t,e){var i=[];return ce(t,function(t){t.inRange(e.x,e.y)&&i.push(t)}),i}function ge(t,e,i,n){var a=Number.POSITIVE_INFINITY,o=[];return ce(t,function(t){if(!i||t.inRange(e.x,e.y)){var r=t.getCenterPoint(),s=n(e,r);s<a?(o=[t],a=s):s===a&&o.push(t)}}),o}function pe(t){var e=-1!==t.indexOf("x"),i=-1!==t.indexOf("y");return function(t,n){var a=e?Math.abs(t.x-n.x):0,o=i?Math.abs(t.y-n.y):0;return Math.sqrt(Math.pow(a,2)+Math.pow(o,2))}}function me(t,e,i){var n=he(e,t);i.axis=i.axis||"x";var a=pe(i.axis),o=i.intersect?fe(t,n):ge(t,n,!1,a),r=[];return o.length?(t.data.datasets.forEach(function(e,i){if(t.isDatasetVisible(i)){var n=t.getDatasetMeta(i).data[o[0]._index];n&&!n._view.skip&&r.push(n)}}),r):[]}var ve={modes:{single:function(t,e){var i=he(e,t),n=[];return ce(t,function(t){if(t.inRange(i.x,i.y))return n.push(t),n}),n.slice(0,1)},label:me,index:me,dataset:function(t,e,i){var n=he(e,t);i.axis=i.axis||"xy";var a=pe(i.axis),o=i.intersect?fe(t,n):ge(t,n,!1,a);return o.length>0&&(o=t.getDatasetMeta(o[0]._datasetIndex).data),o},"x-axis":function(t,e){return me(t,e,{intersect:!1})},point:function(t,e){return fe(t,he(e,t))},nearest:function(t,e,i){var n=he(e,t);i.axis=i.axis||"xy";var a=pe(i.axis);return ge(t,n,i.intersect,a)},x:function(t,e,i){var n=he(e,t),a=[],o=!1;return ce(t,function(t){t.inXRange(n.x)&&a.push(t),t.inRange(n.x,n.y)&&(o=!0)}),i.intersect&&!o&&(a=[]),a},y:function(t,e,i){var n=he(e,t),a=[],o=!1;return ce(t,function(t){t.inYRange(n.y)&&a.push(t),t.inRange(n.x,n.y)&&(o=!0)}),i.intersect&&!o&&(a=[]),a}}};function be(t,e){return ut.where(t,function(t){return t.position===e})}function xe(t,e){t.forEach(function(t,e){return t._tmpIndex_=e,t}),t.sort(function(t,i){var n=e?i:t,a=e?t:i;return n.weight===a.weight?n._tmpIndex_-a._tmpIndex_:n.weight-a.weight}),t.forEach(function(t){delete t._tmpIndex_})}function ye(t,e){ut.each(t,function(t){e[t.position]+=t.isHorizontal()?t.height:t.width})}st._set("global",{layout:{padding:{top:0,right:0,bottom:0,left:0}}});var ke={defaults:{},addBox:function(t,e){t.boxes||(t.boxes=[]),e.fullWidth=e.fullWidth||!1,e.position=e.position||"top",e.weight=e.weight||0,t.boxes.push(e)},removeBox:function(t,e){var i=t.boxes?t.boxes.indexOf(e):-1;-1!==i&&t.boxes.splice(i,1)},configure:function(t,e,i){for(var n,a=["fullWidth","position","weight"],o=a.length,r=0;r<o;++r)n=a[r],i.hasOwnProperty(n)&&(e[n]=i[n])},update:function(t,e,i){if(t){var n=t.options.layout||{},a=ut.options.toPadding(n.padding),o=a.left,r=a.right,s=a.top,l=a.bottom,d=be(t.boxes,"left"),u=be(t.boxes,"right"),h=be(t.boxes,"top"),c=be(t.boxes,"bottom"),f=be(t.boxes,"chartArea");xe(d,!0),xe(u,!1),xe(h,!0),xe(c,!1);var g,p=d.concat(u),m=h.concat(c),v=p.concat(m),b=e-o-r,x=i-s-l,y=(e-b/2)/p.length,k=b,w=x,M={top:s,left:o,bottom:l,right:r},_=[];ut.each(v,function(t){var e,i=t.isHorizontal();i?(e=t.update(t.fullWidth?b:k,x/2),w-=e.height):(e=t.update(y,w),k-=e.width),_.push({horizontal:i,width:e.width,box:t})}),g=function(t){var e=0,i=0,n=0,a=0;return ut.each(t,function(t){if(t.getPadding){var o=t.getPadding();e=Math.max(e,o.top),i=Math.max(i,o.left),n=Math.max(n,o.bottom),a=Math.max(a,o.right)}}),{top:e,left:i,bottom:n,right:a}}(v),ut.each(p,T),ye(p,M),ut.each(m,T),ye(m,M),ut.each(p,function(t){var e=ut.findNextWhere(_,function(e){return e.box===t}),i={left:0,right:0,top:M.top,bottom:M.bottom};e&&t.update(e.width,w,i)}),ye(v,M={top:s,left:o,bottom:l,right:r});var C=Math.max(g.left-M.left,0);M.left+=C,M.right+=Math.max(g.right-M.right,0);var S=Math.max(g.top-M.top,0);M.top+=S,M.bottom+=Math.max(g.bottom-M.bottom,0);var P=i-M.top-M.bottom,I=e-M.left-M.right;I===k&&P===w||(ut.each(p,function(t){t.height=P}),ut.each(m,function(t){t.fullWidth||(t.width=I)}),w=P,k=I);var A=o+C,D=s+S;ut.each(d.concat(h),F),A+=k,D+=w,ut.each(u,F),ut.each(c,F),t.chartArea={left:M.left,top:M.top,right:M.left+k,bottom:M.top+w},ut.each(f,function(e){e.left=t.chartArea.left,e.top=t.chartArea.top,e.right=t.chartArea.right,e.bottom=t.chartArea.bottom,e.update(k,w)})}function T(t){var e=ut.findNextWhere(_,function(e){return e.box===t});if(e)if(e.horizontal){var i={left:Math.max(M.left,g.left),right:Math.max(M.right,g.right),top:0,bottom:0};t.update(t.fullWidth?b:k,x/2,i)}else t.update(e.width,w)}function F(t){t.isHorizontal()?(t.left=t.fullWidth?o:M.left,t.right=t.fullWidth?e-r:M.left+k,t.top=D,t.bottom=D+t.height,D=t.bottom):(t.left=A,t.right=A+t.width,t.top=M.top,t.bottom=M.top+w,A=t.right)}}};var we,Me=(we=Object.freeze({default:"@keyframes chartjs-render-animation{from{opacity:.99}to{opacity:1}}.chartjs-render-monitor{animation:chartjs-render-animation 1ms}.chartjs-size-monitor,.chartjs-size-monitor-expand,.chartjs-size-monitor-shrink{position:absolute;direction:ltr;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1}.chartjs-size-monitor-expand>div{position:absolute;width:1000000px;height:1000000px;left:0;top:0}.chartjs-size-monitor-shrink>div{position:absolute;width:200%;height:200%;left:0;top:0}"}))&&we.default||we,_e="$chartjs",Ce="chartjs-size-monitor",Se="chartjs-render-monitor",Pe="chartjs-render-animation",Ie=["animationstart","webkitAnimationStart"],Ae={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"};function De(t,e){var i=ut.getStyle(t,e),n=i&&i.match(/^(\d+)(\.\d+)?px$/);return n?Number(n[1]):void 0}var Te=!!function(){var t=!1;try{var e=Object.defineProperty({},"passive",{get:function(){t=!0}});window.addEventListener("e",null,e)}catch(t){}return t}()&&{passive:!0};function Fe(t,e,i){t.addEventListener(e,i,Te)}function Le(t,e,i){t.removeEventListener(e,i,Te)}function Re(t,e,i,n,a){return{type:t,chart:e,native:a||null,x:void 0!==i?i:null,y:void 0!==n?n:null}}function Oe(t){var e=document.createElement("div");return e.className=t||"",e}function ze(t,e,i){var n,a,o,r,s=t[_e]||(t[_e]={}),l=s.resizer=function(t){var e=Oe(Ce),i=Oe(Ce+"-expand"),n=Oe(Ce+"-shrink");i.appendChild(Oe()),n.appendChild(Oe()),e.appendChild(i),e.appendChild(n),e._reset=function(){i.scrollLeft=1e6,i.scrollTop=1e6,n.scrollLeft=1e6,n.scrollTop=1e6};var a=function(){e._reset(),t()};return Fe(i,"scroll",a.bind(i,"expand")),Fe(n,"scroll",a.bind(n,"shrink")),e}((n=function(){if(s.resizer){var n=i.options.maintainAspectRatio&&t.parentNode,a=n?n.clientWidth:0;e(Re("resize",i)),n&&n.clientWidth<a&&i.canvas&&e(Re("resize",i))}},o=!1,r=[],function(){r=Array.prototype.slice.call(arguments),a=a||this,o||(o=!0,ut.requestAnimFrame.call(window,function(){o=!1,n.apply(a,r)}))}));!function(t,e){var i=t[_e]||(t[_e]={}),n=i.renderProxy=function(t){t.animationName===Pe&&e()};ut.each(Ie,function(e){Fe(t,e,n)}),i.reflow=!!t.offsetParent,t.classList.add(Se)}(t,function(){if(s.resizer){var e=t.parentNode;e&&e!==l.parentNode&&e.insertBefore(l,e.firstChild),l._reset()}})}function Be(t){var e=t[_e]||{},i=e.resizer;delete e.resizer,function(t){var e=t[_e]||{},i=e.renderProxy;i&&(ut.each(Ie,function(e){Le(t,e,i)}),delete e.renderProxy),t.classList.remove(Se)}(t),i&&i.parentNode&&i.parentNode.removeChild(i)}var Ne={disableCSSInjection:!1,_enabled:"undefined"!=typeof window&&"undefined"!=typeof document,_ensureLoaded:function(){var t,e,i;this._loaded||(this._loaded=!0,this.disableCSSInjection||(e=Me,i=(t=this)._style||document.createElement("style"),t._style||(t._style=i,e="/* Chart.js */\n"+e,i.setAttribute("type","text/css"),document.getElementsByTagName("head")[0].appendChild(i)),i.appendChild(document.createTextNode(e))))},acquireContext:function(t,e){"string"==typeof t?t=document.getElementById(t):t.length&&(t=t[0]),t&&t.canvas&&(t=t.canvas);var i=t&&t.getContext&&t.getContext("2d");return this._ensureLoaded(),i&&i.canvas===t?(function(t,e){var i=t.style,n=t.getAttribute("height"),a=t.getAttribute("width");if(t[_e]={initial:{height:n,width:a,style:{display:i.display,height:i.height,width:i.width}}},i.display=i.display||"block",null===a||""===a){var o=De(t,"width");void 0!==o&&(t.width=o)}if(null===n||""===n)if(""===t.style.height)t.height=t.width/(e.options.aspectRatio||2);else{var r=De(t,"height");void 0!==o&&(t.height=r)}}(t,e),i):null},releaseContext:function(t){var e=t.canvas;if(e[_e]){var i=e[_e].initial;["height","width"].forEach(function(t){var n=i[t];ut.isNullOrUndef(n)?e.removeAttribute(t):e.setAttribute(t,n)}),ut.each(i.style||{},function(t,i){e.style[i]=t}),e.width=e.width,delete e[_e]}},addEventListener:function(t,e,i){var n=t.canvas;if("resize"!==e){var a=i[_e]||(i[_e]={});Fe(n,e,(a.proxies||(a.proxies={}))[t.id+"_"+e]=function(e){i(function(t,e){var i=Ae[t.type]||t.type,n=ut.getRelativePosition(t,e);return Re(i,e,n.x,n.y,t)}(e,t))})}else ze(n,i,t)},removeEventListener:function(t,e,i){var n=t.canvas;if("resize"!==e){var a=((i[_e]||{}).proxies||{})[t.id+"_"+e];a&&Le(n,e,a)}else Be(n)}};ut.addEvent=Fe,ut.removeEvent=Le;var We=Ne._enabled?Ne:{acquireContext:function(t){return t&&t.canvas&&(t=t.canvas),t&&t.getContext("2d")||null}},Ve=ut.extend({initialize:function(){},acquireContext:function(){},releaseContext:function(){},addEventListener:function(){},removeEventListener:function(){}},We);st._set("global",{plugins:{}});var Ee={_plugins:[],_cacheId:0,register:function(t){var e=this._plugins;[].concat(t).forEach(function(t){-1===e.indexOf(t)&&e.push(t)}),this._cacheId++},unregister:function(t){var e=this._plugins;[].concat(t).forEach(function(t){var i=e.indexOf(t);-1!==i&&e.splice(i,1)}),this._cacheId++},clear:function(){this._plugins=[],this._cacheId++},count:function(){return this._plugins.length},getAll:function(){return this._plugins},notify:function(t,e,i){var n,a,o,r,s,l=this.descriptors(t),d=l.length;for(n=0;n<d;++n)if("function"==typeof(s=(o=(a=l[n]).plugin)[e])&&((r=[t].concat(i||[])).push(a.options),!1===s.apply(o,r)))return!1;return!0},descriptors:function(t){var e=t.$plugins||(t.$plugins={});if(e.id===this._cacheId)return e.descriptors;var i=[],n=[],a=t&&t.config||{},o=a.options&&a.options.plugins||{};return this._plugins.concat(a.plugins||[]).forEach(function(t){if(-1===i.indexOf(t)){var e=t.id,a=o[e];!1!==a&&(!0===a&&(a=ut.clone(st.global.plugins[e])),i.push(t),n.push({plugin:t,options:a||{}}))}}),e.descriptors=n,e.id=this._cacheId,n},_invalidate:function(t){delete t.$plugins}},He={constructors:{},defaults:{},registerScaleType:function(t,e,i){this.constructors[t]=e,this.defaults[t]=ut.clone(i)},getScaleConstructor:function(t){return this.constructors.hasOwnProperty(t)?this.constructors[t]:void 0},getScaleDefaults:function(t){return this.defaults.hasOwnProperty(t)?ut.merge({},[st.scale,this.defaults[t]]):{}},updateScaleDefaults:function(t,e){this.defaults.hasOwnProperty(t)&&(this.defaults[t]=ut.extend(this.defaults[t],e))},addScalesToLayout:function(t){ut.each(t.scales,function(e){e.fullWidth=e.options.fullWidth,e.position=e.options.position,e.weight=e.options.weight,ke.addBox(t,e)})}},je=ut.valueOrDefault;st._set("global",{tooltips:{enabled:!0,custom:null,mode:"nearest",position:"average",intersect:!0,backgroundColor:"rgba(0,0,0,0.8)",titleFontStyle:"bold",titleSpacing:2,titleMarginBottom:6,titleFontColor:"#fff",titleAlign:"left",bodySpacing:2,bodyFontColor:"#fff",bodyAlign:"left",footerFontStyle:"bold",footerSpacing:2,footerMarginTop:6,footerFontColor:"#fff",footerAlign:"left",yPadding:6,xPadding:6,caretPadding:2,caretSize:5,cornerRadius:6,multiKeyBackground:"#fff",displayColors:!0,borderColor:"rgba(0,0,0,0)",borderWidth:0,callbacks:{beforeTitle:ut.noop,title:function(t,e){var i="",n=e.labels,a=n?n.length:0;if(t.length>0){var o=t[0];o.label?i=o.label:o.xLabel?i=o.xLabel:a>0&&o.index<a&&(i=n[o.index])}return i},afterTitle:ut.noop,beforeBody:ut.noop,beforeLabel:ut.noop,label:function(t,e){var i=e.datasets[t.datasetIndex].label||"";return i&&(i+=": "),ut.isNullOrUndef(t.value)?i+=t.yLabel:i+=t.value,i},labelColor:function(t,e){var i=e.getDatasetMeta(t.datasetIndex).data[t.index]._view;return{borderColor:i.borderColor,backgroundColor:i.backgroundColor}},labelTextColor:function(){return this._options.bodyFontColor},afterLabel:ut.noop,afterBody:ut.noop,beforeFooter:ut.noop,footer:ut.noop,afterFooter:ut.noop}}});var qe={average:function(t){if(!t.length)return!1;var e,i,n=0,a=0,o=0;for(e=0,i=t.length;e<i;++e){var r=t[e];if(r&&r.hasValue()){var s=r.tooltipPosition();n+=s.x,a+=s.y,++o}}return{x:n/o,y:a/o}},nearest:function(t,e){var i,n,a,o=e.x,r=e.y,s=Number.POSITIVE_INFINITY;for(i=0,n=t.length;i<n;++i){var l=t[i];if(l&&l.hasValue()){var d=l.getCenterPoint(),u=ut.distanceBetweenPoints(e,d);u<s&&(s=u,a=l)}}if(a){var h=a.tooltipPosition();o=h.x,r=h.y}return{x:o,y:r}}};function Ye(t,e){return e&&(ut.isArray(e)?Array.prototype.push.apply(t,e):t.push(e)),t}function Ue(t){return("string"==typeof t||t instanceof String)&&t.indexOf("\n")>-1?t.split("\n"):t}function Xe(t){var e=st.global;return{xPadding:t.xPadding,yPadding:t.yPadding,xAlign:t.xAlign,yAlign:t.yAlign,bodyFontColor:t.bodyFontColor,_bodyFontFamily:je(t.bodyFontFamily,e.defaultFontFamily),_bodyFontStyle:je(t.bodyFontStyle,e.defaultFontStyle),_bodyAlign:t.bodyAlign,bodyFontSize:je(t.bodyFontSize,e.defaultFontSize),bodySpacing:t.bodySpacing,titleFontColor:t.titleFontColor,_titleFontFamily:je(t.titleFontFamily,e.defaultFontFamily),_titleFontStyle:je(t.titleFontStyle,e.defaultFontStyle),titleFontSize:je(t.titleFontSize,e.defaultFontSize),_titleAlign:t.titleAlign,titleSpacing:t.titleSpacing,titleMarginBottom:t.titleMarginBottom,footerFontColor:t.footerFontColor,_footerFontFamily:je(t.footerFontFamily,e.defaultFontFamily),_footerFontStyle:je(t.footerFontStyle,e.defaultFontStyle),footerFontSize:je(t.footerFontSize,e.defaultFontSize),_footerAlign:t.footerAlign,footerSpacing:t.footerSpacing,footerMarginTop:t.footerMarginTop,caretSize:t.caretSize,cornerRadius:t.cornerRadius,backgroundColor:t.backgroundColor,opacity:0,legendColorBackground:t.multiKeyBackground,displayColors:t.displayColors,borderColor:t.borderColor,borderWidth:t.borderWidth}}function Ke(t,e){return"center"===e?t.x+t.width/2:"right"===e?t.x+t.width-t.xPadding:t.x+t.xPadding}function Ge(t){return Ye([],Ue(t))}var Ze=pt.extend({initialize:function(){this._model=Xe(this._options),this._lastActive=[]},getTitle:function(){var t=this._options.callbacks,e=t.beforeTitle.apply(this,arguments),i=t.title.apply(this,arguments),n=t.afterTitle.apply(this,arguments),a=[];return a=Ye(a,Ue(e)),a=Ye(a,Ue(i)),a=Ye(a,Ue(n))},getBeforeBody:function(){return Ge(this._options.callbacks.beforeBody.apply(this,arguments))},getBody:function(t,e){var i=this,n=i._options.callbacks,a=[];return ut.each(t,function(t){var o={before:[],lines:[],after:[]};Ye(o.before,Ue(n.beforeLabel.call(i,t,e))),Ye(o.lines,n.label.call(i,t,e)),Ye(o.after,Ue(n.afterLabel.call(i,t,e))),a.push(o)}),a},getAfterBody:function(){return Ge(this._options.callbacks.afterBody.apply(this,arguments))},getFooter:function(){var t=this._options.callbacks,e=t.beforeFooter.apply(this,arguments),i=t.footer.apply(this,arguments),n=t.afterFooter.apply(this,arguments),a=[];return a=Ye(a,Ue(e)),a=Ye(a,Ue(i)),a=Ye(a,Ue(n))},update:function(t){var e,i,n,a,o,r,s,l,d,u,h=this,c=h._options,f=h._model,g=h._model=Xe(c),p=h._active,m=h._data,v={xAlign:f.xAlign,yAlign:f.yAlign},b={x:f.x,y:f.y},x={width:f.width,height:f.height},y={x:f.caretX,y:f.caretY};if(p.length){g.opacity=1;var k=[],w=[];y=qe[c.position].call(h,p,h._eventPosition);var M=[];for(e=0,i=p.length;e<i;++e)M.push((n=p[e],a=void 0,o=void 0,r=void 0,s=void 0,l=void 0,d=void 0,u=void 0,a=n._xScale,o=n._yScale||n._scale,r=n._index,s=n._datasetIndex,l=n._chart.getDatasetMeta(s).controller,d=l._getIndexScale(),u=l._getValueScale(),{xLabel:a?a.getLabelForIndex(r,s):"",yLabel:o?o.getLabelForIndex(r,s):"",label:d?""+d.getLabelForIndex(r,s):"",value:u?""+u.getLabelForIndex(r,s):"",index:r,datasetIndex:s,x:n._model.x,y:n._model.y}));c.filter&&(M=M.filter(function(t){return c.filter(t,m)})),c.itemSort&&(M=M.sort(function(t,e){return c.itemSort(t,e,m)})),ut.each(M,function(t){k.push(c.callbacks.labelColor.call(h,t,h._chart)),w.push(c.callbacks.labelTextColor.call(h,t,h._chart))}),g.title=h.getTitle(M,m),g.beforeBody=h.getBeforeBody(M,m),g.body=h.getBody(M,m),g.afterBody=h.getAfterBody(M,m),g.footer=h.getFooter(M,m),g.x=y.x,g.y=y.y,g.caretPadding=c.caretPadding,g.labelColors=k,g.labelTextColors=w,g.dataPoints=M,x=function(t,e){var i=t._chart.ctx,n=2*e.yPadding,a=0,o=e.body,r=o.reduce(function(t,e){return t+e.before.length+e.lines.length+e.after.length},0);r+=e.beforeBody.length+e.afterBody.length;var s=e.title.length,l=e.footer.length,d=e.titleFontSize,u=e.bodyFontSize,h=e.footerFontSize;n+=s*d,n+=s?(s-1)*e.titleSpacing:0,n+=s?e.titleMarginBottom:0,n+=r*u,n+=r?(r-1)*e.bodySpacing:0,n+=l?e.footerMarginTop:0,n+=l*h,n+=l?(l-1)*e.footerSpacing:0;var c=0,f=function(t){a=Math.max(a,i.measureText(t).width+c)};return i.font=ut.fontString(d,e._titleFontStyle,e._titleFontFamily),ut.each(e.title,f),i.font=ut.fontString(u,e._bodyFontStyle,e._bodyFontFamily),ut.each(e.beforeBody.concat(e.afterBody),f),c=e.displayColors?u+2:0,ut.each(o,function(t){ut.each(t.before,f),ut.each(t.lines,f),ut.each(t.after,f)}),c=0,i.font=ut.fontString(h,e._footerFontStyle,e._footerFontFamily),ut.each(e.footer,f),{width:a+=2*e.xPadding,height:n}}(this,g),b=function(t,e,i,n){var a=t.x,o=t.y,r=t.caretSize,s=t.caretPadding,l=t.cornerRadius,d=i.xAlign,u=i.yAlign,h=r+s,c=l+s;return"right"===d?a-=e.width:"center"===d&&((a-=e.width/2)+e.width>n.width&&(a=n.width-e.width),a<0&&(a=0)),"top"===u?o+=h:o-="bottom"===u?e.height+h:e.height/2,"center"===u?"left"===d?a+=h:"right"===d&&(a-=h):"left"===d?a-=c:"right"===d&&(a+=c),{x:a,y:o}}(g,x,v=function(t,e){var i,n,a,o,r,s=t._model,l=t._chart,d=t._chart.chartArea,u="center",h="center";s.y<e.height?h="top":s.y>l.height-e.height&&(h="bottom");var c=(d.left+d.right)/2,f=(d.top+d.bottom)/2;"center"===h?(i=function(t){return t<=c},n=function(t){return t>c}):(i=function(t){return t<=e.width/2},n=function(t){return t>=l.width-e.width/2}),a=function(t){return t+e.width+s.caretSize+s.caretPadding>l.width},o=function(t){return t-e.width-s.caretSize-s.caretPadding<0},r=function(t){return t<=f?"top":"bottom"},i(s.x)?(u="left",a(s.x)&&(u="center",h=r(s.y))):n(s.x)&&(u="right",o(s.x)&&(u="center",h=r(s.y)));var g=t._options;return{xAlign:g.xAlign?g.xAlign:u,yAlign:g.yAlign?g.yAlign:h}}(this,x),h._chart)}else g.opacity=0;return g.xAlign=v.xAlign,g.yAlign=v.yAlign,g.x=b.x,g.y=b.y,g.width=x.width,g.height=x.height,g.caretX=y.x,g.caretY=y.y,h._model=g,t&&c.custom&&c.custom.call(h,g),h},drawCaret:function(t,e){var i=this._chart.ctx,n=this._view,a=this.getCaretPosition(t,e,n);i.lineTo(a.x1,a.y1),i.lineTo(a.x2,a.y2),i.lineTo(a.x3,a.y3)},getCaretPosition:function(t,e,i){var n,a,o,r,s,l,d=i.caretSize,u=i.cornerRadius,h=i.xAlign,c=i.yAlign,f=t.x,g=t.y,p=e.width,m=e.height;if("center"===c)s=g+m/2,"left"===h?(a=(n=f)-d,o=n,r=s+d,l=s-d):(a=(n=f+p)+d,o=n,r=s-d,l=s+d);else if("left"===h?(n=(a=f+u+d)-d,o=a+d):"right"===h?(n=(a=f+p-u-d)-d,o=a+d):(n=(a=i.caretX)-d,o=a+d),"top"===c)s=(r=g)-d,l=r;else{s=(r=g+m)+d,l=r;var v=o;o=n,n=v}return{x1:n,x2:a,x3:o,y1:r,y2:s,y3:l}},drawTitle:function(t,e,i){var n=e.title;if(n.length){t.x=Ke(e,e._titleAlign),i.textAlign=e._titleAlign,i.textBaseline="top";var a,o,r=e.titleFontSize,s=e.titleSpacing;for(i.fillStyle=e.titleFontColor,i.font=ut.fontString(r,e._titleFontStyle,e._titleFontFamily),a=0,o=n.length;a<o;++a)i.fillText(n[a],t.x,t.y),t.y+=r+s,a+1===n.length&&(t.y+=e.titleMarginBottom-s)}},drawBody:function(t,e,i){var n,a=e.bodyFontSize,o=e.bodySpacing,r=e._bodyAlign,s=e.body,l=e.displayColors,d=e.labelColors,u=0,h=l?Ke(e,"left"):0;i.textAlign=r,i.textBaseline="top",i.font=ut.fontString(a,e._bodyFontStyle,e._bodyFontFamily),t.x=Ke(e,r);var c=function(e){i.fillText(e,t.x+u,t.y),t.y+=a+o};i.fillStyle=e.bodyFontColor,ut.each(e.beforeBody,c),u=l&&"right"!==r?"center"===r?a/2+1:a+2:0,ut.each(s,function(o,r){n=e.labelTextColors[r],i.fillStyle=n,ut.each(o.before,c),ut.each(o.lines,function(o){l&&(i.fillStyle=e.legendColorBackground,i.fillRect(h,t.y,a,a),i.lineWidth=1,i.strokeStyle=d[r].borderColor,i.strokeRect(h,t.y,a,a),i.fillStyle=d[r].backgroundColor,i.fillRect(h+1,t.y+1,a-2,a-2),i.fillStyle=n),c(o)}),ut.each(o.after,c)}),u=0,ut.each(e.afterBody,c),t.y-=o},drawFooter:function(t,e,i){var n=e.footer;n.length&&(t.x=Ke(e,e._footerAlign),t.y+=e.footerMarginTop,i.textAlign=e._footerAlign,i.textBaseline="top",i.fillStyle=e.footerFontColor,i.font=ut.fontString(e.footerFontSize,e._footerFontStyle,e._footerFontFamily),ut.each(n,function(n){i.fillText(n,t.x,t.y),t.y+=e.footerFontSize+e.footerSpacing}))},drawBackground:function(t,e,i,n){i.fillStyle=e.backgroundColor,i.strokeStyle=e.borderColor,i.lineWidth=e.borderWidth;var a=e.xAlign,o=e.yAlign,r=t.x,s=t.y,l=n.width,d=n.height,u=e.cornerRadius;i.beginPath(),i.moveTo(r+u,s),"top"===o&&this.drawCaret(t,n),i.lineTo(r+l-u,s),i.quadraticCurveTo(r+l,s,r+l,s+u),"center"===o&&"right"===a&&this.drawCaret(t,n),i.lineTo(r+l,s+d-u),i.quadraticCurveTo(r+l,s+d,r+l-u,s+d),"bottom"===o&&this.drawCaret(t,n),i.lineTo(r+u,s+d),i.quadraticCurveTo(r,s+d,r,s+d-u),"center"===o&&"left"===a&&this.drawCaret(t,n),i.lineTo(r,s+u),i.quadraticCurveTo(r,s,r+u,s),i.closePath(),i.fill(),e.borderWidth>0&&i.stroke()},draw:function(){var t=this._chart.ctx,e=this._view;if(0!==e.opacity){var i={width:e.width,height:e.height},n={x:e.x,y:e.y},a=Math.abs(e.opacity<.001)?0:e.opacity,o=e.title.length||e.beforeBody.length||e.body.length||e.afterBody.length||e.footer.length;this._options.enabled&&o&&(t.save(),t.globalAlpha=a,this.drawBackground(n,e,t,i),n.y+=e.yPadding,this.drawTitle(n,e,t),this.drawBody(n,e,t),this.drawFooter(n,e,t),t.restore())}},handleEvent:function(t){var e,i=this,n=i._options;return i._lastActive=i._lastActive||[],"mouseout"===t.type?i._active=[]:i._active=i._chart.getElementsAtEventForMode(t,n.mode,n),(e=!ut.arrayEquals(i._active,i._lastActive))&&(i._lastActive=i._active,(n.enabled||n.custom)&&(i._eventPosition={x:t.x,y:t.y},i.update(!0),i.pivot())),e}}),$e=qe,Je=Ze;Je.positioners=$e;var Qe=ut.valueOrDefault;function ti(){return ut.merge({},[].slice.call(arguments),{merger:function(t,e,i,n){if("xAxes"===t||"yAxes"===t){var a,o,r,s=i[t].length;for(e[t]||(e[t]=[]),a=0;a<s;++a)r=i[t][a],o=Qe(r.type,"xAxes"===t?"category":"linear"),a>=e[t].length&&e[t].push({}),!e[t][a].type||r.type&&r.type!==e[t][a].type?ut.merge(e[t][a],[He.getScaleDefaults(o),r]):ut.merge(e[t][a],r)}else ut._merger(t,e,i,n)}})}function ei(){return ut.merge({},[].slice.call(arguments),{merger:function(t,e,i,n){var a=e[t]||{},o=i[t];"scales"===t?e[t]=ti(a,o):"scale"===t?e[t]=ut.merge(a,[He.getScaleDefaults(o.type),o]):ut._merger(t,e,i,n)}})}function ii(t){return"top"===t||"bottom"===t}st._set("global",{elements:{},events:["mousemove","mouseout","click","touchstart","touchmove"],hover:{onHover:null,mode:"nearest",intersect:!0,animationDuration:400},onClick:null,maintainAspectRatio:!0,responsive:!0,responsiveAnimationDuration:0});var ni=function(t,e){return this.construct(t,e),this};ut.extend(ni.prototype,{construct:function(t,e){var i=this;e=function(t){var e=(t=t||{}).data=t.data||{};return e.datasets=e.datasets||[],e.labels=e.labels||[],t.options=ei(st.global,st[t.type],t.options||{}),t}(e);var n=Ve.acquireContext(t,e),a=n&&n.canvas,o=a&&a.height,r=a&&a.width;i.id=ut.uid(),i.ctx=n,i.canvas=a,i.config=e,i.width=r,i.height=o,i.aspectRatio=o?r/o:null,i.options=e.options,i._bufferedRender=!1,i.chart=i,i.controller=i,ni.instances[i.id]=i,Object.defineProperty(i,"data",{get:function(){return i.config.data},set:function(t){i.config.data=t}}),n&&a?(i.initialize(),i.update()):console.error("Failed to create chart: can't acquire context from the given item")},initialize:function(){var t=this;return Ee.notify(t,"beforeInit"),ut.retinaScale(t,t.options.devicePixelRatio),t.bindEvents(),t.options.responsive&&t.resize(!0),t.ensureScalesHaveIDs(),t.buildOrUpdateScales(),t.initToolTip(),Ee.notify(t,"afterInit"),t},clear:function(){return ut.canvas.clear(this),this},stop:function(){return bt.cancelAnimation(this),this},resize:function(t){var e=this,i=e.options,n=e.canvas,a=i.maintainAspectRatio&&e.aspectRatio||null,o=Math.max(0,Math.floor(ut.getMaximumWidth(n))),r=Math.max(0,Math.floor(a?o/a:ut.getMaximumHeight(n)));if((e.width!==o||e.height!==r)&&(n.width=e.width=o,n.height=e.height=r,n.style.width=o+"px",n.style.height=r+"px",ut.retinaScale(e,i.devicePixelRatio),!t)){var s={width:o,height:r};Ee.notify(e,"resize",[s]),i.onResize&&i.onResize(e,s),e.stop(),e.update({duration:i.responsiveAnimationDuration})}},ensureScalesHaveIDs:function(){var t=this.options,e=t.scales||{},i=t.scale;ut.each(e.xAxes,function(t,e){t.id=t.id||"x-axis-"+e}),ut.each(e.yAxes,function(t,e){t.id=t.id||"y-axis-"+e}),i&&(i.id=i.id||"scale")},buildOrUpdateScales:function(){var t=this,e=t.options,i=t.scales||{},n=[],a=Object.keys(i).reduce(function(t,e){return t[e]=!1,t},{});e.scales&&(n=n.concat((e.scales.xAxes||[]).map(function(t){return{options:t,dtype:"category",dposition:"bottom"}}),(e.scales.yAxes||[]).map(function(t){return{options:t,dtype:"linear",dposition:"left"}}))),e.scale&&n.push({options:e.scale,dtype:"radialLinear",isDefault:!0,dposition:"chartArea"}),ut.each(n,function(e){var n=e.options,o=n.id,r=Qe(n.type,e.dtype);ii(n.position)!==ii(e.dposition)&&(n.position=e.dposition),a[o]=!0;var s=null;if(o in i&&i[o].type===r)(s=i[o]).options=n,s.ctx=t.ctx,s.chart=t;else{var l=He.getScaleConstructor(r);if(!l)return;s=new l({id:o,type:r,options:n,ctx:t.ctx,chart:t}),i[s.id]=s}s.mergeTicksOptions(),e.isDefault&&(t.scale=s)}),ut.each(a,function(t,e){t||delete i[e]}),t.scales=i,He.addScalesToLayout(this)},buildOrUpdateControllers:function(){var t=this,e=[];return ut.each(t.data.datasets,function(i,n){var a=t.getDatasetMeta(n),o=i.type||t.config.type;if(a.type&&a.type!==o&&(t.destroyDatasetMeta(n),a=t.getDatasetMeta(n)),a.type=o,a.controller)a.controller.updateIndex(n),a.controller.linkScales();else{var r=ue[a.type];if(void 0===r)throw new Error('"'+a.type+'" is not a chart type.');a.controller=new r(t,n),e.push(a.controller)}},t),e},resetElements:function(){var t=this;ut.each(t.data.datasets,function(e,i){t.getDatasetMeta(i).controller.reset()},t)},reset:function(){this.resetElements(),this.tooltip.initialize()},update:function(t){var e,i,n=this;if(t&&"object"==typeof t||(t={duration:t,lazy:arguments[1]}),i=(e=n).options,ut.each(e.scales,function(t){ke.removeBox(e,t)}),i=ei(st.global,st[e.config.type],i),e.options=e.config.options=i,e.ensureScalesHaveIDs(),e.buildOrUpdateScales(),e.tooltip._options=i.tooltips,e.tooltip.initialize(),Ee._invalidate(n),!1!==Ee.notify(n,"beforeUpdate")){n.tooltip._data=n.data;var a=n.buildOrUpdateControllers();ut.each(n.data.datasets,function(t,e){n.getDatasetMeta(e).controller.buildOrUpdateElements()},n),n.updateLayout(),n.options.animation&&n.options.animation.duration&&ut.each(a,function(t){t.reset()}),n.updateDatasets(),n.tooltip.initialize(),n.lastActive=[],Ee.notify(n,"afterUpdate"),n._bufferedRender?n._bufferedRequest={duration:t.duration,easing:t.easing,lazy:t.lazy}:n.render(t)}},updateLayout:function(){!1!==Ee.notify(this,"beforeLayout")&&(ke.update(this,this.width,this.height),Ee.notify(this,"afterScaleUpdate"),Ee.notify(this,"afterLayout"))},updateDatasets:function(){if(!1!==Ee.notify(this,"beforeDatasetsUpdate")){for(var t=0,e=this.data.datasets.length;t<e;++t)this.updateDataset(t);Ee.notify(this,"afterDatasetsUpdate")}},updateDataset:function(t){var e=this.getDatasetMeta(t),i={meta:e,index:t};!1!==Ee.notify(this,"beforeDatasetUpdate",[i])&&(e.controller.update(),Ee.notify(this,"afterDatasetUpdate",[i]))},render:function(t){var e=this;t&&"object"==typeof t||(t={duration:t,lazy:arguments[1]});var i=e.options.animation,n=Qe(t.duration,i&&i.duration),a=t.lazy;if(!1!==Ee.notify(e,"beforeRender")){var o=function(t){Ee.notify(e,"afterRender"),ut.callback(i&&i.onComplete,[t],e)};if(i&&n){var r=new vt({numSteps:n/16.66,easing:t.easing||i.easing,render:function(t,e){var i=ut.easing.effects[e.easing],n=e.currentStep,a=n/e.numSteps;t.draw(i(a),a,n)},onAnimationProgress:i.onProgress,onAnimationComplete:o});bt.addAnimation(e,r,n,a)}else e.draw(),o(new vt({numSteps:0,chart:e}));return e}},draw:function(t){var e=this;e.clear(),ut.isNullOrUndef(t)&&(t=1),e.transition(t),e.width<=0||e.height<=0||!1!==Ee.notify(e,"beforeDraw",[t])&&(ut.each(e.boxes,function(t){t.draw(e.chartArea)},e),e.drawDatasets(t),e._drawTooltip(t),Ee.notify(e,"afterDraw",[t]))},transition:function(t){for(var e=0,i=(this.data.datasets||[]).length;e<i;++e)this.isDatasetVisible(e)&&this.getDatasetMeta(e).controller.transition(t);this.tooltip.transition(t)},drawDatasets:function(t){var e=this;if(!1!==Ee.notify(e,"beforeDatasetsDraw",[t])){for(var i=(e.data.datasets||[]).length-1;i>=0;--i)e.isDatasetVisible(i)&&e.drawDataset(i,t);Ee.notify(e,"afterDatasetsDraw",[t])}},drawDataset:function(t,e){var i=this.getDatasetMeta(t),n={meta:i,index:t,easingValue:e};!1!==Ee.notify(this,"beforeDatasetDraw",[n])&&(i.controller.draw(e),Ee.notify(this,"afterDatasetDraw",[n]))},_drawTooltip:function(t){var e=this.tooltip,i={tooltip:e,easingValue:t};!1!==Ee.notify(this,"beforeTooltipDraw",[i])&&(e.draw(),Ee.notify(this,"afterTooltipDraw",[i]))},getElementAtEvent:function(t){return ve.modes.single(this,t)},getElementsAtEvent:function(t){return ve.modes.label(this,t,{intersect:!0})},getElementsAtXAxis:function(t){return ve.modes["x-axis"](this,t,{intersect:!0})},getElementsAtEventForMode:function(t,e,i){var n=ve.modes[e];return"function"==typeof n?n(this,t,i):[]},getDatasetAtEvent:function(t){return ve.modes.dataset(this,t,{intersect:!0})},getDatasetMeta:function(t){var e=this.data.datasets[t];e._meta||(e._meta={});var i=e._meta[this.id];return i||(i=e._meta[this.id]={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null}),i},getVisibleDatasetCount:function(){for(var t=0,e=0,i=this.data.datasets.length;e<i;++e)this.isDatasetVisible(e)&&t++;return t},isDatasetVisible:function(t){var e=this.getDatasetMeta(t);return"boolean"==typeof e.hidden?!e.hidden:!this.data.datasets[t].hidden},generateLegend:function(){return this.options.legendCallback(this)},destroyDatasetMeta:function(t){var e=this.id,i=this.data.datasets[t],n=i._meta&&i._meta[e];n&&(n.controller.destroy(),delete i._meta[e])},destroy:function(){var t,e,i=this,n=i.canvas;for(i.stop(),t=0,e=i.data.datasets.length;t<e;++t)i.destroyDatasetMeta(t);n&&(i.unbindEvents(),ut.canvas.clear(i),Ve.releaseContext(i.ctx),i.canvas=null,i.ctx=null),Ee.notify(i,"destroy"),delete ni.instances[i.id]},toBase64Image:function(){return this.canvas.toDataURL.apply(this.canvas,arguments)},initToolTip:function(){var t=this;t.tooltip=new Je({_chart:t,_chartInstance:t,_data:t.data,_options:t.options.tooltips},t)},bindEvents:function(){var t=this,e=t._listeners={},i=function(){t.eventHandler.apply(t,arguments)};ut.each(t.options.events,function(n){Ve.addEventListener(t,n,i),e[n]=i}),t.options.responsive&&(i=function(){t.resize()},Ve.addEventListener(t,"resize",i),e.resize=i)},unbindEvents:function(){var t=this,e=t._listeners;e&&(delete t._listeners,ut.each(e,function(e,i){Ve.removeEventListener(t,i,e)}))},updateHoverStyle:function(t,e,i){var n,a,o,r=i?"setHoverStyle":"removeHoverStyle";for(a=0,o=t.length;a<o;++a)(n=t[a])&&this.getDatasetMeta(n._datasetIndex).controller[r](n)},eventHandler:function(t){var e=this,i=e.tooltip;if(!1!==Ee.notify(e,"beforeEvent",[t])){e._bufferedRender=!0,e._bufferedRequest=null;var n=e.handleEvent(t);i&&(n=i._start?i.handleEvent(t):n|i.handleEvent(t)),Ee.notify(e,"afterEvent",[t]);var a=e._bufferedRequest;return a?e.render(a):n&&!e.animating&&(e.stop(),e.render({duration:e.options.hover.animationDuration,lazy:!0})),e._bufferedRender=!1,e._bufferedRequest=null,e}},handleEvent:function(t){var e,i=this,n=i.options||{},a=n.hover;return i.lastActive=i.lastActive||[],"mouseout"===t.type?i.active=[]:i.active=i.getElementsAtEventForMode(t,a.mode,a),ut.callback(n.onHover||n.hover.onHover,[t.native,i.active],i),"mouseup"!==t.type&&"click"!==t.type||n.onClick&&n.onClick.call(i,t.native,i.active),i.lastActive.length&&i.updateHoverStyle(i.lastActive,a.mode,!1),i.active.length&&a.mode&&i.updateHoverStyle(i.active,a.mode,!0),e=!ut.arrayEquals(i.active,i.lastActive),i.lastActive=i.active,e}}),ni.instances={};var ai=ni;ni.Controller=ni,ni.types={},ut.configMerge=ei,ut.scaleMerge=ti;function oi(){throw new Error("This method is not implemented: either no adapter can be found or an incomplete integration was provided.")}function ri(t){this.options=t||{}}ut.extend(ri.prototype,{formats:oi,parse:oi,format:oi,add:oi,diff:oi,startOf:oi,endOf:oi,_create:function(t){return t}}),ri.override=function(t){ut.extend(ri.prototype,t)};var si={_date:ri},li={formatters:{values:function(t){return ut.isArray(t)?t:""+t},linear:function(t,e,i){var n=i.length>3?i[2]-i[1]:i[1]-i[0];Math.abs(n)>1&&t!==Math.floor(t)&&(n=t-Math.floor(t));var a=ut.log10(Math.abs(n)),o="";if(0!==t)if(Math.max(Math.abs(i[0]),Math.abs(i[i.length-1]))<1e-4){var r=ut.log10(Math.abs(t));o=t.toExponential(Math.floor(r)-Math.floor(a))}else{var s=-1*Math.floor(a);s=Math.max(Math.min(s,20),0),o=t.toFixed(s)}else o="0";return o},logarithmic:function(t,e,i){var n=t/Math.pow(10,Math.floor(ut.log10(t)));return 0===t?"0":1===n||2===n||5===n||0===e||e===i.length-1?t.toExponential():""}}},di=ut.valueOrDefault,ui=ut.valueAtIndexOrDefault;function hi(t){var e,i,n=[];for(e=0,i=t.length;e<i;++e)n.push(t[e].label);return n}function ci(t,e,i){return ut.isArray(e)?ut.longestText(t,i,e):t.measureText(e).width}st._set("scale",{display:!0,position:"left",offset:!1,gridLines:{display:!0,color:"rgba(0, 0, 0, 0.1)",lineWidth:1,drawBorder:!0,drawOnChartArea:!0,drawTicks:!0,tickMarkLength:10,zeroLineWidth:1,zeroLineColor:"rgba(0,0,0,0.25)",zeroLineBorderDash:[],zeroLineBorderDashOffset:0,offsetGridLines:!1,borderDash:[],borderDashOffset:0},scaleLabel:{display:!1,labelString:"",padding:{top:4,bottom:4}},ticks:{beginAtZero:!1,minRotation:0,maxRotation:50,mirror:!1,padding:0,reverse:!1,display:!0,autoSkip:!0,autoSkipPadding:0,labelOffset:0,callback:li.formatters.values,minor:{},major:{}}});var fi=pt.extend({getPadding:function(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}},getTicks:function(){return this._ticks},mergeTicksOptions:function(){var t=this.options.ticks;for(var e in!1===t.minor&&(t.minor={display:!1}),!1===t.major&&(t.major={display:!1}),t)"major"!==e&&"minor"!==e&&(void 0===t.minor[e]&&(t.minor[e]=t[e]),void 0===t.major[e]&&(t.major[e]=t[e]))},beforeUpdate:function(){ut.callback(this.options.beforeUpdate,[this])},update:function(t,e,i){var n,a,o,r,s,l,d=this;for(d.beforeUpdate(),d.maxWidth=t,d.maxHeight=e,d.margins=ut.extend({left:0,right:0,top:0,bottom:0},i),d._maxLabelLines=0,d.longestLabelWidth=0,d.longestTextCache=d.longestTextCache||{},d.beforeSetDimensions(),d.setDimensions(),d.afterSetDimensions(),d.beforeDataLimits(),d.determineDataLimits(),d.afterDataLimits(),d.beforeBuildTicks(),s=d.buildTicks()||[],s=d.afterBuildTicks(s)||s,d.beforeTickToLabelConversion(),o=d.convertTicksToLabels(s)||d.ticks,d.afterTickToLabelConversion(),d.ticks=o,n=0,a=o.length;n<a;++n)r=o[n],(l=s[n])?l.label=r:s.push(l={label:r,major:!1});return d._ticks=s,d.beforeCalculateTickRotation(),d.calculateTickRotation(),d.afterCalculateTickRotation(),d.beforeFit(),d.fit(),d.afterFit(),d.afterUpdate(),d.minSize},afterUpdate:function(){ut.callback(this.options.afterUpdate,[this])},beforeSetDimensions:function(){ut.callback(this.options.beforeSetDimensions,[this])},setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0},afterSetDimensions:function(){ut.callback(this.options.afterSetDimensions,[this])},beforeDataLimits:function(){ut.callback(this.options.beforeDataLimits,[this])},determineDataLimits:ut.noop,afterDataLimits:function(){ut.callback(this.options.afterDataLimits,[this])},beforeBuildTicks:function(){ut.callback(this.options.beforeBuildTicks,[this])},buildTicks:ut.noop,afterBuildTicks:function(t){var e=this;return ut.isArray(t)&&t.length?ut.callback(e.options.afterBuildTicks,[e,t]):(e.ticks=ut.callback(e.options.afterBuildTicks,[e,e.ticks])||e.ticks,t)},beforeTickToLabelConversion:function(){ut.callback(this.options.beforeTickToLabelConversion,[this])},convertTicksToLabels:function(){var t=this.options.ticks;this.ticks=this.ticks.map(t.userCallback||t.callback,this)},afterTickToLabelConversion:function(){ut.callback(this.options.afterTickToLabelConversion,[this])},beforeCalculateTickRotation:function(){ut.callback(this.options.beforeCalculateTickRotation,[this])},calculateTickRotation:function(){var t=this,e=t.ctx,i=t.options.ticks,n=hi(t._ticks),a=ut.options._parseFont(i);e.font=a.string;var o=i.minRotation||0;if(n.length&&t.options.display&&t.isHorizontal())for(var r,s=ut.longestText(e,a.string,n,t.longestTextCache),l=s,d=t.getPixelForTick(1)-t.getPixelForTick(0)-6;l>d&&o<i.maxRotation;){var u=ut.toRadians(o);if(r=Math.cos(u),Math.sin(u)*s>t.maxHeight){o--;break}o++,l=r*s}t.labelRotation=o},afterCalculateTickRotation:function(){ut.callback(this.options.afterCalculateTickRotation,[this])},beforeFit:function(){ut.callback(this.options.beforeFit,[this])},fit:function(){var t=this,e=t.minSize={width:0,height:0},i=hi(t._ticks),n=t.options,a=n.ticks,o=n.scaleLabel,r=n.gridLines,s=t._isVisible(),l=n.position,d=t.isHorizontal(),u=ut.options._parseFont,h=u(a),c=n.gridLines.tickMarkLength;if(e.width=d?t.isFullWidth()?t.maxWidth-t.margins.left-t.margins.right:t.maxWidth:s&&r.drawTicks?c:0,e.height=d?s&&r.drawTicks?c:0:t.maxHeight,o.display&&s){var f=u(o),g=ut.options.toPadding(o.padding),p=f.lineHeight+g.height;d?e.height+=p:e.width+=p}if(a.display&&s){var m=ut.longestText(t.ctx,h.string,i,t.longestTextCache),v=ut.numberOfLabelLines(i),b=.5*h.size,x=t.options.ticks.padding;if(t._maxLabelLines=v,t.longestLabelWidth=m,d){var y=ut.toRadians(t.labelRotation),k=Math.cos(y),w=Math.sin(y)*m+h.lineHeight*v+b;e.height=Math.min(t.maxHeight,e.height+w+x),t.ctx.font=h.string;var M,_,C=ci(t.ctx,i[0],h.string),S=ci(t.ctx,i[i.length-1],h.string),P=t.getPixelForTick(0)-t.left,I=t.right-t.getPixelForTick(i.length-1);0!==t.labelRotation?(M="bottom"===l?k*C:k*b,_="bottom"===l?k*b:k*S):(M=C/2,_=S/2),t.paddingLeft=Math.max(M-P,0)+3,t.paddingRight=Math.max(_-I,0)+3}else a.mirror?m=0:m+=x+b,e.width=Math.min(t.maxWidth,e.width+m),t.paddingTop=h.size/2,t.paddingBottom=h.size/2}t.handleMargins(),t.width=e.width,t.height=e.height},handleMargins:function(){var t=this;t.margins&&(t.paddingLeft=Math.max(t.paddingLeft-t.margins.left,0),t.paddingTop=Math.max(t.paddingTop-t.margins.top,0),t.paddingRight=Math.max(t.paddingRight-t.margins.right,0),t.paddingBottom=Math.max(t.paddingBottom-t.margins.bottom,0))},afterFit:function(){ut.callback(this.options.afterFit,[this])},isHorizontal:function(){return"top"===this.options.position||"bottom"===this.options.position},isFullWidth:function(){return this.options.fullWidth},getRightValue:function(t){if(ut.isNullOrUndef(t))return NaN;if(("number"==typeof t||t instanceof Number)&&!isFinite(t))return NaN;if(t)if(this.isHorizontal()){if(void 0!==t.x)return this.getRightValue(t.x)}else if(void 0!==t.y)return this.getRightValue(t.y);return t},getLabelForIndex:ut.noop,getPixelForValue:ut.noop,getValueForPixel:ut.noop,getPixelForTick:function(t){var e=this,i=e.options.offset;if(e.isHorizontal()){var n=(e.width-(e.paddingLeft+e.paddingRight))/Math.max(e._ticks.length-(i?0:1),1),a=n*t+e.paddingLeft;i&&(a+=n/2);var o=e.left+a;return o+=e.isFullWidth()?e.margins.left:0}var r=e.height-(e.paddingTop+e.paddingBottom);return e.top+t*(r/(e._ticks.length-1))},getPixelForDecimal:function(t){var e=this;if(e.isHorizontal()){var i=(e.width-(e.paddingLeft+e.paddingRight))*t+e.paddingLeft,n=e.left+i;return n+=e.isFullWidth()?e.margins.left:0}return e.top+t*e.height},getBasePixel:function(){return this.getPixelForValue(this.getBaseValue())},getBaseValue:function(){var t=this.min,e=this.max;return this.beginAtZero?0:t<0&&e<0?e:t>0&&e>0?t:0},_autoSkip:function(t){var e,i,n=this,a=n.isHorizontal(),o=n.options.ticks.minor,r=t.length,s=!1,l=o.maxTicksLimit,d=n._tickSize()*(r-1),u=a?n.width-(n.paddingLeft+n.paddingRight):n.height-(n.paddingTop+n.PaddingBottom),h=[];for(d>u&&(s=1+Math.floor(d/u)),r>l&&(s=Math.max(s,1+Math.floor(r/l))),e=0;e<r;e++)i=t[e],s>1&&e%s>0&&delete i.label,h.push(i);return h},_tickSize:function(){var t=this,e=t.isHorizontal(),i=t.options.ticks.minor,n=ut.toRadians(t.labelRotation),a=Math.abs(Math.cos(n)),o=Math.abs(Math.sin(n)),r=i.autoSkipPadding||0,s=t.longestLabelWidth+r||0,l=ut.options._parseFont(i),d=t._maxLabelLines*l.lineHeight+r||0;return e?d*a>s*o?s/a:d/o:d*o<s*a?d/a:s/o},_isVisible:function(){var t,e,i,n=this.chart,a=this.options.display;if("auto"!==a)return!!a;for(t=0,e=n.data.datasets.length;t<e;++t)if(n.isDatasetVisible(t)&&((i=n.getDatasetMeta(t)).xAxisID===this.id||i.yAxisID===this.id))return!0;return!1},draw:function(t){var e=this,i=e.options;if(e._isVisible()){var n,a,o,r=e.chart,s=e.ctx,l=st.global.defaultFontColor,d=i.ticks.minor,u=i.ticks.major||d,h=i.gridLines,c=i.scaleLabel,f=i.position,g=0!==e.labelRotation,p=d.mirror,m=e.isHorizontal(),v=ut.options._parseFont,b=d.display&&d.autoSkip?e._autoSkip(e.getTicks()):e.getTicks(),x=di(d.fontColor,l),y=v(d),k=y.lineHeight,w=di(u.fontColor,l),M=v(u),_=d.padding,C=d.labelOffset,S=h.drawTicks?h.tickMarkLength:0,P=di(c.fontColor,l),I=v(c),A=ut.options.toPadding(c.padding),D=ut.toRadians(e.labelRotation),T=[],F=h.drawBorder?ui(h.lineWidth,0,0):0,L=ut._alignPixel;"top"===f?(n=L(r,e.bottom,F),a=e.bottom-S,o=n-F/2):"bottom"===f?(n=L(r,e.top,F),a=n+F/2,o=e.top+S):"left"===f?(n=L(r,e.right,F),a=e.right-S,o=n-F/2):(n=L(r,e.left,F),a=n+F/2,o=e.left+S);if(ut.each(b,function(n,s){if(!ut.isNullOrUndef(n.label)){var l,d,u,c,v,b,x,y,w,M,P,I,A,R,O,z,B=n.label;s===e.zeroLineIndex&&i.offset===h.offsetGridLines?(l=h.zeroLineWidth,d=h.zeroLineColor,u=h.zeroLineBorderDash||[],c=h.zeroLineBorderDashOffset||0):(l=ui(h.lineWidth,s),d=ui(h.color,s),u=h.borderDash||[],c=h.borderDashOffset||0);var N=ut.isArray(B)?B.length:1,W=function(t,e,i){var n=t.getPixelForTick(e);return i&&(1===t.getTicks().length?n-=t.isHorizontal()?Math.max(n-t.left,t.right-n):Math.max(n-t.top,t.bottom-n):n-=0===e?(t.getPixelForTick(1)-n)/2:(n-t.getPixelForTick(e-1))/2),n}(e,s,h.offsetGridLines);if(m){var V=S+_;W<e.left-1e-7&&(d="rgba(0,0,0,0)"),v=x=w=P=L(r,W,l),b=a,y=o,A=e.getPixelForTick(s)+C,"top"===f?(M=L(r,t.top,F)+F/2,I=t.bottom,O=((g?1:.5)-N)*k,z=g?"left":"center",R=e.bottom-V):(M=t.top,I=L(r,t.bottom,F)-F/2,O=(g?0:.5)*k,z=g?"right":"center",R=e.top+V)}else{var E=(p?0:S)+_;W<e.top-1e-7&&(d="rgba(0,0,0,0)"),v=a,x=o,b=y=M=I=L(r,W,l),R=e.getPixelForTick(s)+C,O=(1-N)*k/2,"left"===f?(w=L(r,t.left,F)+F/2,P=t.right,z=p?"left":"right",A=e.right-E):(w=t.left,P=L(r,t.right,F)-F/2,z=p?"right":"left",A=e.left+E)}T.push({tx1:v,ty1:b,tx2:x,ty2:y,x1:w,y1:M,x2:P,y2:I,labelX:A,labelY:R,glWidth:l,glColor:d,glBorderDash:u,glBorderDashOffset:c,rotation:-1*D,label:B,major:n.major,textOffset:O,textAlign:z})}}),ut.each(T,function(t){var e=t.glWidth,i=t.glColor;if(h.display&&e&&i&&(s.save(),s.lineWidth=e,s.strokeStyle=i,s.setLineDash&&(s.setLineDash(t.glBorderDash),s.lineDashOffset=t.glBorderDashOffset),s.beginPath(),h.drawTicks&&(s.moveTo(t.tx1,t.ty1),s.lineTo(t.tx2,t.ty2)),h.drawOnChartArea&&(s.moveTo(t.x1,t.y1),s.lineTo(t.x2,t.y2)),s.stroke(),s.restore()),d.display){s.save(),s.translate(t.labelX,t.labelY),s.rotate(t.rotation),s.font=t.major?M.string:y.string,s.fillStyle=t.major?w:x,s.textBaseline="middle",s.textAlign=t.textAlign;var n=t.label,a=t.textOffset;if(ut.isArray(n))for(var o=0;o<n.length;++o)s.fillText(""+n[o],0,a),a+=k;else s.fillText(n,0,a);s.restore()}}),c.display){var R,O,z=0,B=I.lineHeight/2;if(m)R=e.left+(e.right-e.left)/2,O="bottom"===f?e.bottom-B-A.bottom:e.top+B+A.top;else{var N="left"===f;R=N?e.left+B+A.top:e.right-B-A.top,O=e.top+(e.bottom-e.top)/2,z=N?-.5*Math.PI:.5*Math.PI}s.save(),s.translate(R,O),s.rotate(z),s.textAlign="center",s.textBaseline="middle",s.fillStyle=P,s.font=I.string,s.fillText(c.labelString,0,0),s.restore()}if(F){var W,V,E,H,j=F,q=ui(h.lineWidth,b.length-1,0);m?(W=L(r,e.left,j)-j/2,V=L(r,e.right,q)+q/2,E=H=n):(E=L(r,e.top,j)-j/2,H=L(r,e.bottom,q)+q/2,W=V=n),s.lineWidth=F,s.strokeStyle=ui(h.color,0),s.beginPath(),s.moveTo(W,E),s.lineTo(V,H),s.stroke()}}}}),gi=fi.extend({getLabels:function(){var t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels},determineDataLimits:function(){var t,e=this,i=e.getLabels();e.minIndex=0,e.maxIndex=i.length-1,void 0!==e.options.ticks.min&&(t=i.indexOf(e.options.ticks.min),e.minIndex=-1!==t?t:e.minIndex),void 0!==e.options.ticks.max&&(t=i.indexOf(e.options.ticks.max),e.maxIndex=-1!==t?t:e.maxIndex),e.min=i[e.minIndex],e.max=i[e.maxIndex]},buildTicks:function(){var t=this,e=t.getLabels();t.ticks=0===t.minIndex&&t.maxIndex===e.length-1?e:e.slice(t.minIndex,t.maxIndex+1)},getLabelForIndex:function(t,e){var i=this,n=i.chart;return n.getDatasetMeta(e).controller._getValueScaleId()===i.id?i.getRightValue(n.data.datasets[e].data[t]):i.ticks[t-i.minIndex]},getPixelForValue:function(t,e){var i,n=this,a=n.options.offset,o=Math.max(n.maxIndex+1-n.minIndex-(a?0:1),1);if(null!=t&&(i=n.isHorizontal()?t.x:t.y),void 0!==i||void 0!==t&&isNaN(e)){t=i||t;var r=n.getLabels().indexOf(t);e=-1!==r?r:e}if(n.isHorizontal()){var s=n.width/o,l=s*(e-n.minIndex);return a&&(l+=s/2),n.left+l}var d=n.height/o,u=d*(e-n.minIndex);return a&&(u+=d/2),n.top+u},getPixelForTick:function(t){return this.getPixelForValue(this.ticks[t],t+this.minIndex,null)},getValueForPixel:function(t){var e=this,i=e.options.offset,n=Math.max(e._ticks.length-(i?0:1),1),a=e.isHorizontal(),o=(a?e.width:e.height)/n;return t-=a?e.left:e.top,i&&(t-=o/2),(t<=0?0:Math.round(t/o))+e.minIndex},getBasePixel:function(){return this.bottom}}),pi={position:"bottom"};gi._defaults=pi;var mi=ut.noop,vi=ut.isNullOrUndef;var bi=fi.extend({getRightValue:function(t){return"string"==typeof t?+t:fi.prototype.getRightValue.call(this,t)},handleTickRangeOptions:function(){var t=this,e=t.options.ticks;if(e.beginAtZero){var i=ut.sign(t.min),n=ut.sign(t.max);i<0&&n<0?t.max=0:i>0&&n>0&&(t.min=0)}var a=void 0!==e.min||void 0!==e.suggestedMin,o=void 0!==e.max||void 0!==e.suggestedMax;void 0!==e.min?t.min=e.min:void 0!==e.suggestedMin&&(null===t.min?t.min=e.suggestedMin:t.min=Math.min(t.min,e.suggestedMin)),void 0!==e.max?t.max=e.max:void 0!==e.suggestedMax&&(null===t.max?t.max=e.suggestedMax:t.max=Math.max(t.max,e.suggestedMax)),a!==o&&t.min>=t.max&&(a?t.max=t.min+1:t.min=t.max-1),t.min===t.max&&(t.max++,e.beginAtZero||t.min--)},getTickLimit:function(){var t,e=this.options.ticks,i=e.stepSize,n=e.maxTicksLimit;return i?t=Math.ceil(this.max/i)-Math.floor(this.min/i)+1:(t=this._computeTickLimit(),n=n||11),n&&(t=Math.min(n,t)),t},_computeTickLimit:function(){return Number.POSITIVE_INFINITY},handleDirectionalChanges:mi,buildTicks:function(){var t=this,e=t.options.ticks,i=t.getTickLimit(),n={maxTicks:i=Math.max(2,i),min:e.min,max:e.max,precision:e.precision,stepSize:ut.valueOrDefault(e.fixedStepSize,e.stepSize)},a=t.ticks=function(t,e){var i,n,a,o,r=[],s=t.stepSize,l=s||1,d=t.maxTicks-1,u=t.min,h=t.max,c=t.precision,f=e.min,g=e.max,p=ut.niceNum((g-f)/d/l)*l;if(p<1e-14&&vi(u)&&vi(h))return[f,g];(o=Math.ceil(g/p)-Math.floor(f/p))>d&&(p=ut.niceNum(o*p/d/l)*l),s||vi(c)?i=Math.pow(10,ut._decimalPlaces(p)):(i=Math.pow(10,c),p=Math.ceil(p*i)/i),n=Math.floor(f/p)*p,a=Math.ceil(g/p)*p,s&&(!vi(u)&&ut.almostWhole(u/p,p/1e3)&&(n=u),!vi(h)&&ut.almostWhole(h/p,p/1e3)&&(a=h)),o=(a-n)/p,o=ut.almostEquals(o,Math.round(o),p/1e3)?Math.round(o):Math.ceil(o),n=Math.round(n*i)/i,a=Math.round(a*i)/i,r.push(vi(u)?n:u);for(var m=1;m<o;++m)r.push(Math.round((n+m*p)*i)/i);return r.push(vi(h)?a:h),r}(n,t);t.handleDirectionalChanges(),t.max=ut.max(a),t.min=ut.min(a),e.reverse?(a.reverse(),t.start=t.max,t.end=t.min):(t.start=t.min,t.end=t.max)},convertTicksToLabels:function(){var t=this;t.ticksAsNumbers=t.ticks.slice(),t.zeroLineIndex=t.ticks.indexOf(0),fi.prototype.convertTicksToLabels.call(t)}}),xi={position:"left",ticks:{callback:li.formatters.linear}},yi=bi.extend({determineDataLimits:function(){var t=this,e=t.options,i=t.chart,n=i.data.datasets,a=t.isHorizontal();function o(e){return a?e.xAxisID===t.id:e.yAxisID===t.id}t.min=null,t.max=null;var r=e.stacked;if(void 0===r&&ut.each(n,function(t,e){if(!r){var n=i.getDatasetMeta(e);i.isDatasetVisible(e)&&o(n)&&void 0!==n.stack&&(r=!0)}}),e.stacked||r){var s={};ut.each(n,function(n,a){var r=i.getDatasetMeta(a),l=[r.type,void 0===e.stacked&&void 0===r.stack?a:"",r.stack].join(".");void 0===s[l]&&(s[l]={positiveValues:[],negativeValues:[]});var d=s[l].positiveValues,u=s[l].negativeValues;i.isDatasetVisible(a)&&o(r)&&ut.each(n.data,function(i,n){var a=+t.getRightValue(i);isNaN(a)||r.data[n].hidden||(d[n]=d[n]||0,u[n]=u[n]||0,e.relativePoints?d[n]=100:a<0?u[n]+=a:d[n]+=a)})}),ut.each(s,function(e){var i=e.positiveValues.concat(e.negativeValues),n=ut.min(i),a=ut.max(i);t.min=null===t.min?n:Math.min(t.min,n),t.max=null===t.max?a:Math.max(t.max,a)})}else ut.each(n,function(e,n){var a=i.getDatasetMeta(n);i.isDatasetVisible(n)&&o(a)&&ut.each(e.data,function(e,i){var n=+t.getRightValue(e);isNaN(n)||a.data[i].hidden||(null===t.min?t.min=n:n<t.min&&(t.min=n),null===t.max?t.max=n:n>t.max&&(t.max=n))})});t.min=isFinite(t.min)&&!isNaN(t.min)?t.min:0,t.max=isFinite(t.max)&&!isNaN(t.max)?t.max:1,this.handleTickRangeOptions()},_computeTickLimit:function(){var t;return this.isHorizontal()?Math.ceil(this.width/40):(t=ut.options._parseFont(this.options.ticks),Math.ceil(this.height/t.lineHeight))},handleDirectionalChanges:function(){this.isHorizontal()||this.ticks.reverse()},getLabelForIndex:function(t,e){return+this.getRightValue(this.chart.data.datasets[e].data[t])},getPixelForValue:function(t){var e=this,i=e.start,n=+e.getRightValue(t),a=e.end-i;return e.isHorizontal()?e.left+e.width/a*(n-i):e.bottom-e.height/a*(n-i)},getValueForPixel:function(t){var e=this,i=e.isHorizontal(),n=i?e.width:e.height,a=(i?t-e.left:e.bottom-t)/n;return e.start+(e.end-e.start)*a},getPixelForTick:function(t){return this.getPixelForValue(this.ticksAsNumbers[t])}}),ki=xi;yi._defaults=ki;var wi=ut.valueOrDefault;var Mi={position:"left",ticks:{callback:li.formatters.logarithmic}};function _i(t,e){return ut.isFinite(t)&&t>=0?t:e}var Ci=fi.extend({determineDataLimits:function(){var t=this,e=t.options,i=t.chart,n=i.data.datasets,a=t.isHorizontal();function o(e){return a?e.xAxisID===t.id:e.yAxisID===t.id}t.min=null,t.max=null,t.minNotZero=null;var r=e.stacked;if(void 0===r&&ut.each(n,function(t,e){if(!r){var n=i.getDatasetMeta(e);i.isDatasetVisible(e)&&o(n)&&void 0!==n.stack&&(r=!0)}}),e.stacked||r){var s={};ut.each(n,function(n,a){var r=i.getDatasetMeta(a),l=[r.type,void 0===e.stacked&&void 0===r.stack?a:"",r.stack].join(".");i.isDatasetVisible(a)&&o(r)&&(void 0===s[l]&&(s[l]=[]),ut.each(n.data,function(e,i){var n=s[l],a=+t.getRightValue(e);isNaN(a)||r.data[i].hidden||a<0||(n[i]=n[i]||0,n[i]+=a)}))}),ut.each(s,function(e){if(e.length>0){var i=ut.min(e),n=ut.max(e);t.min=null===t.min?i:Math.min(t.min,i),t.max=null===t.max?n:Math.max(t.max,n)}})}else ut.each(n,function(e,n){var a=i.getDatasetMeta(n);i.isDatasetVisible(n)&&o(a)&&ut.each(e.data,function(e,i){var n=+t.getRightValue(e);isNaN(n)||a.data[i].hidden||n<0||(null===t.min?t.min=n:n<t.min&&(t.min=n),null===t.max?t.max=n:n>t.max&&(t.max=n),0!==n&&(null===t.minNotZero||n<t.minNotZero)&&(t.minNotZero=n))})});this.handleTickRangeOptions()},handleTickRangeOptions:function(){var t=this,e=t.options.ticks;t.min=_i(e.min,t.min),t.max=_i(e.max,t.max),t.min===t.max&&(0!==t.min&&null!==t.min?(t.min=Math.pow(10,Math.floor(ut.log10(t.min))-1),t.max=Math.pow(10,Math.floor(ut.log10(t.max))+1)):(t.min=1,t.max=10)),null===t.min&&(t.min=Math.pow(10,Math.floor(ut.log10(t.max))-1)),null===t.max&&(t.max=0!==t.min?Math.pow(10,Math.floor(ut.log10(t.min))+1):10),null===t.minNotZero&&(t.min>0?t.minNotZero=t.min:t.max<1?t.minNotZero=Math.pow(10,Math.floor(ut.log10(t.max))):t.minNotZero=1)},buildTicks:function(){var t=this,e=t.options.ticks,i=!t.isHorizontal(),n={min:_i(e.min),max:_i(e.max)},a=t.ticks=function(t,e){var i,n,a=[],o=wi(t.min,Math.pow(10,Math.floor(ut.log10(e.min)))),r=Math.floor(ut.log10(e.max)),s=Math.ceil(e.max/Math.pow(10,r));0===o?(i=Math.floor(ut.log10(e.minNotZero)),n=Math.floor(e.minNotZero/Math.pow(10,i)),a.push(o),o=n*Math.pow(10,i)):(i=Math.floor(ut.log10(o)),n=Math.floor(o/Math.pow(10,i)));var l=i<0?Math.pow(10,Math.abs(i)):1;do{a.push(o),10==++n&&(n=1,l=++i>=0?1:l),o=Math.round(n*Math.pow(10,i)*l)/l}while(i<r||i===r&&n<s);var d=wi(t.max,o);return a.push(d),a}(n,t);t.max=ut.max(a),t.min=ut.min(a),e.reverse?(i=!i,t.start=t.max,t.end=t.min):(t.start=t.min,t.end=t.max),i&&a.reverse()},convertTicksToLabels:function(){this.tickValues=this.ticks.slice(),fi.prototype.convertTicksToLabels.call(this)},getLabelForIndex:function(t,e){return+this.getRightValue(this.chart.data.datasets[e].data[t])},getPixelForTick:function(t){return this.getPixelForValue(this.tickValues[t])},_getFirstTickValue:function(t){var e=Math.floor(ut.log10(t));return Math.floor(t/Math.pow(10,e))*Math.pow(10,e)},getPixelForValue:function(t){var e,i,n,a,o,r=this,s=r.options.ticks,l=s.reverse,d=ut.log10,u=r._getFirstTickValue(r.minNotZero),h=0;return t=+r.getRightValue(t),l?(n=r.end,a=r.start,o=-1):(n=r.start,a=r.end,o=1),r.isHorizontal()?(e=r.width,i=l?r.right:r.left):(e=r.height,o*=-1,i=l?r.top:r.bottom),t!==n&&(0===n&&(e-=h=wi(s.fontSize,st.global.defaultFontSize),n=u),0!==t&&(h+=e/(d(a)-d(n))*(d(t)-d(n))),i+=o*h),i},getValueForPixel:function(t){var e,i,n,a,o=this,r=o.options.ticks,s=r.reverse,l=ut.log10,d=o._getFirstTickValue(o.minNotZero);if(s?(i=o.end,n=o.start):(i=o.start,n=o.end),o.isHorizontal()?(e=o.width,a=s?o.right-t:t-o.left):(e=o.height,a=s?t-o.top:o.bottom-t),a!==i){if(0===i){var u=wi(r.fontSize,st.global.defaultFontSize);a-=u,e-=u,i=d}a*=l(n)-l(i),a/=e,a=Math.pow(10,l(i)+a)}return a}}),Si=Mi;Ci._defaults=Si;var Pi=ut.valueOrDefault,Ii=ut.valueAtIndexOrDefault,Ai=ut.options.resolve,Di={display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,color:"rgba(0, 0, 0, 0.1)",lineWidth:1,borderDash:[],borderDashOffset:0},gridLines:{circular:!1},ticks:{showLabelBackdrop:!0,backdropColor:"rgba(255,255,255,0.75)",backdropPaddingY:2,backdropPaddingX:2,callback:li.formatters.linear},pointLabels:{display:!0,fontSize:10,callback:function(t){return t}}};function Ti(t){var e=t.options;return e.angleLines.display||e.pointLabels.display?t.chart.data.labels.length:0}function Fi(t){var e=t.ticks;return e.display&&t.display?Pi(e.fontSize,st.global.defaultFontSize)+2*e.backdropPaddingY:0}function Li(t,e,i,n,a){return t===n||t===a?{start:e-i/2,end:e+i/2}:t<n||t>a?{start:e-i,end:e}:{start:e,end:e+i}}function Ri(t){return 0===t||180===t?"center":t<180?"left":"right"}function Oi(t,e,i,n){var a,o,r=i.y+n/2;if(ut.isArray(e))for(a=0,o=e.length;a<o;++a)t.fillText(e[a],i.x,r),r+=n;else t.fillText(e,i.x,r)}function zi(t,e,i){90===t||270===t?i.y-=e.h/2:(t>270||t<90)&&(i.y-=e.h)}function Bi(t){return ut.isNumber(t)?t:0}var Ni=bi.extend({setDimensions:function(){var t=this;t.width=t.maxWidth,t.height=t.maxHeight,t.paddingTop=Fi(t.options)/2,t.xCenter=Math.floor(t.width/2),t.yCenter=Math.floor((t.height-t.paddingTop)/2),t.drawingArea=Math.min(t.height-t.paddingTop,t.width)/2},determineDataLimits:function(){var t=this,e=t.chart,i=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;ut.each(e.data.datasets,function(a,o){if(e.isDatasetVisible(o)){var r=e.getDatasetMeta(o);ut.each(a.data,function(e,a){var o=+t.getRightValue(e);isNaN(o)||r.data[a].hidden||(i=Math.min(o,i),n=Math.max(o,n))})}}),t.min=i===Number.POSITIVE_INFINITY?0:i,t.max=n===Number.NEGATIVE_INFINITY?0:n,t.handleTickRangeOptions()},_computeTickLimit:function(){return Math.ceil(this.drawingArea/Fi(this.options))},convertTicksToLabels:function(){var t=this;bi.prototype.convertTicksToLabels.call(t),t.pointLabels=t.chart.data.labels.map(t.options.pointLabels.callback,t)},getLabelForIndex:function(t,e){return+this.getRightValue(this.chart.data.datasets[e].data[t])},fit:function(){var t=this.options;t.display&&t.pointLabels.display?function(t){var e,i,n,a=ut.options._parseFont(t.options.pointLabels),o={l:0,r:t.width,t:0,b:t.height-t.paddingTop},r={};t.ctx.font=a.string,t._pointLabelSizes=[];var s,l,d,u=Ti(t);for(e=0;e<u;e++){n=t.getPointPosition(e,t.drawingArea+5),s=t.ctx,l=a.lineHeight,d=t.pointLabels[e]||"",i=ut.isArray(d)?{w:ut.longestText(s,s.font,d),h:d.length*l}:{w:s.measureText(d).width,h:l},t._pointLabelSizes[e]=i;var h=t.getIndexAngle(e),c=ut.toDegrees(h)%360,f=Li(c,n.x,i.w,0,180),g=Li(c,n.y,i.h,90,270);f.start<o.l&&(o.l=f.start,r.l=h),f.end>o.r&&(o.r=f.end,r.r=h),g.start<o.t&&(o.t=g.start,r.t=h),g.end>o.b&&(o.b=g.end,r.b=h)}t.setReductions(t.drawingArea,o,r)}(this):this.setCenterPoint(0,0,0,0)},setReductions:function(t,e,i){var n=this,a=e.l/Math.sin(i.l),o=Math.max(e.r-n.width,0)/Math.sin(i.r),r=-e.t/Math.cos(i.t),s=-Math.max(e.b-(n.height-n.paddingTop),0)/Math.cos(i.b);a=Bi(a),o=Bi(o),r=Bi(r),s=Bi(s),n.drawingArea=Math.min(Math.floor(t-(a+o)/2),Math.floor(t-(r+s)/2)),n.setCenterPoint(a,o,r,s)},setCenterPoint:function(t,e,i,n){var a=this,o=a.width-e-a.drawingArea,r=t+a.drawingArea,s=i+a.drawingArea,l=a.height-a.paddingTop-n-a.drawingArea;a.xCenter=Math.floor((r+o)/2+a.left),a.yCenter=Math.floor((s+l)/2+a.top+a.paddingTop)},getIndexAngle:function(t){return t*(2*Math.PI/Ti(this))+(this.chart.options&&this.chart.options.startAngle?this.chart.options.startAngle:0)*Math.PI*2/360},getDistanceFromCenterForValue:function(t){var e=this;if(null===t)return 0;var i=e.drawingArea/(e.max-e.min);return e.options.ticks.reverse?(e.max-t)*i:(t-e.min)*i},getPointPosition:function(t,e){var i=this.getIndexAngle(t)-Math.PI/2;return{x:Math.cos(i)*e+this.xCenter,y:Math.sin(i)*e+this.yCenter}},getPointPositionForValue:function(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))},getBasePosition:function(){var t=this.min,e=this.max;return this.getPointPositionForValue(0,this.beginAtZero?0:t<0&&e<0?e:t>0&&e>0?t:0)},draw:function(){var t=this,e=t.options,i=e.gridLines,n=e.ticks;if(e.display){var a=t.ctx,o=this.getIndexAngle(0),r=ut.options._parseFont(n);(e.angleLines.display||e.pointLabels.display)&&function(t){var e=t.ctx,i=t.options,n=i.angleLines,a=i.gridLines,o=i.pointLabels,r=Pi(n.lineWidth,a.lineWidth),s=Pi(n.color,a.color),l=Fi(i);e.save(),e.lineWidth=r,e.strokeStyle=s,e.setLineDash&&(e.setLineDash(Ai([n.borderDash,a.borderDash,[]])),e.lineDashOffset=Ai([n.borderDashOffset,a.borderDashOffset,0]));var d=t.getDistanceFromCenterForValue(i.ticks.reverse?t.min:t.max),u=ut.options._parseFont(o);e.font=u.string,e.textBaseline="middle";for(var h=Ti(t)-1;h>=0;h--){if(n.display&&r&&s){var c=t.getPointPosition(h,d);e.beginPath(),e.moveTo(t.xCenter,t.yCenter),e.lineTo(c.x,c.y),e.stroke()}if(o.display){var f=0===h?l/2:0,g=t.getPointPosition(h,d+f+5),p=Ii(o.fontColor,h,st.global.defaultFontColor);e.fillStyle=p;var m=t.getIndexAngle(h),v=ut.toDegrees(m);e.textAlign=Ri(v),zi(v,t._pointLabelSizes[h],g),Oi(e,t.pointLabels[h]||"",g,u.lineHeight)}}e.restore()}(t),ut.each(t.ticks,function(e,s){if(s>0||n.reverse){var l=t.getDistanceFromCenterForValue(t.ticksAsNumbers[s]);if(i.display&&0!==s&&function(t,e,i,n){var a,o=t.ctx,r=e.circular,s=Ti(t),l=Ii(e.color,n-1),d=Ii(e.lineWidth,n-1);if((r||s)&&l&&d){if(o.save(),o.strokeStyle=l,o.lineWidth=d,o.setLineDash&&(o.setLineDash(e.borderDash||[]),o.lineDashOffset=e.borderDashOffset||0),o.beginPath(),r)o.arc(t.xCenter,t.yCenter,i,0,2*Math.PI);else{a=t.getPointPosition(0,i),o.moveTo(a.x,a.y);for(var u=1;u<s;u++)a=t.getPointPosition(u,i),o.lineTo(a.x,a.y)}o.closePath(),o.stroke(),o.restore()}}(t,i,l,s),n.display){var d=Pi(n.fontColor,st.global.defaultFontColor);if(a.font=r.string,a.save(),a.translate(t.xCenter,t.yCenter),a.rotate(o),n.showLabelBackdrop){var u=a.measureText(e).width;a.fillStyle=n.backdropColor,a.fillRect(-u/2-n.backdropPaddingX,-l-r.size/2-n.backdropPaddingY,u+2*n.backdropPaddingX,r.size+2*n.backdropPaddingY)}a.textAlign="center",a.textBaseline="middle",a.fillStyle=d,a.fillText(e,0,-l),a.restore()}}})}}}),Wi=Di;Ni._defaults=Wi;var Vi=ut.valueOrDefault,Ei=Number.MIN_SAFE_INTEGER||-9007199254740991,Hi=Number.MAX_SAFE_INTEGER||9007199254740991,ji={millisecond:{common:!0,size:1,steps:[1,2,5,10,20,50,100,250,500]},second:{common:!0,size:1e3,steps:[1,2,5,10,15,30]},minute:{common:!0,size:6e4,steps:[1,2,5,10,15,30]},hour:{common:!0,size:36e5,steps:[1,2,3,6,12]},day:{common:!0,size:864e5,steps:[1,2,5]},week:{common:!1,size:6048e5,steps:[1,2,3,4]},month:{common:!0,size:2628e6,steps:[1,2,3]},quarter:{common:!1,size:7884e6,steps:[1,2,3,4]},year:{common:!0,size:3154e7}},qi=Object.keys(ji);function Yi(t,e){return t-e}function Ui(t){var e,i,n,a={},o=[];for(e=0,i=t.length;e<i;++e)a[n=t[e]]||(a[n]=!0,o.push(n));return o}function Xi(t,e,i,n){var a=function(t,e,i){for(var n,a,o,r=0,s=t.length-1;r>=0&&r<=s;){if(a=t[(n=r+s>>1)-1]||null,o=t[n],!a)return{lo:null,hi:o};if(o[e]<i)r=n+1;else{if(!(a[e]>i))return{lo:a,hi:o};s=n-1}}return{lo:o,hi:null}}(t,e,i),o=a.lo?a.hi?a.lo:t[t.length-2]:t[0],r=a.lo?a.hi?a.hi:t[t.length-1]:t[1],s=r[e]-o[e],l=s?(i-o[e])/s:0,d=(r[n]-o[n])*l;return o[n]+d}function Ki(t,e){var i=t._adapter,n=t.options.time,a=n.parser,o=a||n.format,r=e;return"function"==typeof a&&(r=a(r)),ut.isFinite(r)||(r="string"==typeof o?i.parse(r,o):i.parse(r)),null!==r?+r:(a||"function"!=typeof o||(r=o(e),ut.isFinite(r)||(r=i.parse(r))),r)}function Gi(t,e){if(ut.isNullOrUndef(e))return null;var i=t.options.time,n=Ki(t,t.getRightValue(e));return null===n?n:(i.round&&(n=+t._adapter.startOf(n,i.round)),n)}function Zi(t){for(var e=qi.indexOf(t)+1,i=qi.length;e<i;++e)if(ji[qi[e]].common)return qi[e]}function $i(t,e,i,n){var a,o=t._adapter,r=t.options,s=r.time,l=s.unit||function(t,e,i,n){var a,o,r,s=qi.length;for(a=qi.indexOf(t);a<s-1;++a)if(r=(o=ji[qi[a]]).steps?o.steps[o.steps.length-1]:Hi,o.common&&Math.ceil((i-e)/(r*o.size))<=n)return qi[a];return qi[s-1]}(s.minUnit,e,i,n),d=Zi(l),u=Vi(s.stepSize,s.unitStepSize),h="week"===l&&s.isoWeekday,c=r.ticks.major.enabled,f=ji[l],g=e,p=i,m=[];for(u||(u=function(t,e,i,n){var a,o,r,s=e-t,l=ji[i],d=l.size,u=l.steps;if(!u)return Math.ceil(s/(n*d));for(a=0,o=u.length;a<o&&(r=u[a],!(Math.ceil(s/(d*r))<=n));++a);return r}(e,i,l,n)),h&&(g=+o.startOf(g,"isoWeek",h),p=+o.startOf(p,"isoWeek",h)),g=+o.startOf(g,h?"day":l),(p=+o.startOf(p,h?"day":l))<i&&(p=+o.add(p,1,l)),a=g,c&&d&&!h&&!s.round&&(a=+o.startOf(a,d),a=+o.add(a,~~((g-a)/(f.size*u))*u,l));a<p;a=+o.add(a,u,l))m.push(+a);return m.push(+a),m}var Ji=fi.extend({initialize:function(){this.mergeTicksOptions(),fi.prototype.initialize.call(this)},update:function(){var t=this.options,e=t.time||(t.time={}),i=this._adapter=new si._date(t.adapters.date);return e.format&&console.warn("options.time.format is deprecated and replaced by options.time.parser."),ut.mergeIf(e.displayFormats,i.formats()),fi.prototype.update.apply(this,arguments)},getRightValue:function(t){return t&&void 0!==t.t&&(t=t.t),fi.prototype.getRightValue.call(this,t)},determineDataLimits:function(){var t,e,i,n,a,o,r=this,s=r.chart,l=r._adapter,d=r.options.time,u=d.unit||"day",h=Hi,c=Ei,f=[],g=[],p=[],m=s.data.labels||[];for(t=0,i=m.length;t<i;++t)p.push(Gi(r,m[t]));for(t=0,i=(s.data.datasets||[]).length;t<i;++t)if(s.isDatasetVisible(t))if(a=s.data.datasets[t].data,ut.isObject(a[0]))for(g[t]=[],e=0,n=a.length;e<n;++e)o=Gi(r,a[e]),f.push(o),g[t][e]=o;else{for(e=0,n=p.length;e<n;++e)f.push(p[e]);g[t]=p.slice(0)}else g[t]=[];p.length&&(p=Ui(p).sort(Yi),h=Math.min(h,p[0]),c=Math.max(c,p[p.length-1])),f.length&&(f=Ui(f).sort(Yi),h=Math.min(h,f[0]),c=Math.max(c,f[f.length-1])),h=Gi(r,d.min)||h,c=Gi(r,d.max)||c,h=h===Hi?+l.startOf(Date.now(),u):h,c=c===Ei?+l.endOf(Date.now(),u)+1:c,r.min=Math.min(h,c),r.max=Math.max(h+1,c),r._horizontal=r.isHorizontal(),r._table=[],r._timestamps={data:f,datasets:g,labels:p}},buildTicks:function(){var t,e,i,n=this,a=n.min,o=n.max,r=n.options,s=r.time,l=[],d=[];switch(r.ticks.source){case"data":l=n._timestamps.data;break;case"labels":l=n._timestamps.labels;break;case"auto":default:l=$i(n,a,o,n.getLabelCapacity(a))}for("ticks"===r.bounds&&l.length&&(a=l[0],o=l[l.length-1]),a=Gi(n,s.min)||a,o=Gi(n,s.max)||o,t=0,e=l.length;t<e;++t)(i=l[t])>=a&&i<=o&&d.push(i);return n.min=a,n.max=o,n._unit=s.unit||function(t,e,i,n,a){var o,r;for(o=qi.length-1;o>=qi.indexOf(i);o--)if(r=qi[o],ji[r].common&&t._adapter.diff(a,n,r)>=e.length)return r;return qi[i?qi.indexOf(i):0]}(n,d,s.minUnit,n.min,n.max),n._majorUnit=Zi(n._unit),n._table=function(t,e,i,n){if("linear"===n||!t.length)return[{time:e,pos:0},{time:i,pos:1}];var a,o,r,s,l,d=[],u=[e];for(a=0,o=t.length;a<o;++a)(s=t[a])>e&&s<i&&u.push(s);for(u.push(i),a=0,o=u.length;a<o;++a)l=u[a+1],r=u[a-1],s=u[a],void 0!==r&&void 0!==l&&Math.round((l+r)/2)===s||d.push({time:s,pos:a/(o-1)});return d}(n._timestamps.data,a,o,r.distribution),n._offsets=function(t,e,i,n,a){var o,r,s=0,l=0;return a.offset&&e.length&&(a.time.min||(o=Xi(t,"time",e[0],"pos"),s=1===e.length?1-o:(Xi(t,"time",e[1],"pos")-o)/2),a.time.max||(r=Xi(t,"time",e[e.length-1],"pos"),l=1===e.length?r:(r-Xi(t,"time",e[e.length-2],"pos"))/2)),{start:s,end:l}}(n._table,d,0,0,r),r.ticks.reverse&&d.reverse(),function(t,e,i){var n,a,o,r,s=[];for(n=0,a=e.length;n<a;++n)o=e[n],r=!!i&&o===+t._adapter.startOf(o,i),s.push({value:o,major:r});return s}(n,d,n._majorUnit)},getLabelForIndex:function(t,e){var i=this,n=i._adapter,a=i.chart.data,o=i.options.time,r=a.labels&&t<a.labels.length?a.labels[t]:"",s=a.datasets[e].data[t];return ut.isObject(s)&&(r=i.getRightValue(s)),o.tooltipFormat?n.format(Ki(i,r),o.tooltipFormat):"string"==typeof r?r:n.format(Ki(i,r),o.displayFormats.datetime)},tickFormatFunction:function(t,e,i,n){var a=this._adapter,o=this.options,r=o.time.displayFormats,s=r[this._unit],l=this._majorUnit,d=r[l],u=+a.startOf(t,l),h=o.ticks.major,c=h.enabled&&l&&d&&t===u,f=a.format(t,n||(c?d:s)),g=c?h:o.ticks.minor,p=Vi(g.callback,g.userCallback);return p?p(f,e,i):f},convertTicksToLabels:function(t){var e,i,n=[];for(e=0,i=t.length;e<i;++e)n.push(this.tickFormatFunction(t[e].value,e,t));return n},getPixelForOffset:function(t){var e=this,i=e.options.ticks.reverse,n=e._horizontal?e.width:e.height,a=e._horizontal?i?e.right:e.left:i?e.bottom:e.top,o=Xi(e._table,"time",t,"pos"),r=n*(e._offsets.start+o)/(e._offsets.start+1+e._offsets.end);return i?a-r:a+r},getPixelForValue:function(t,e,i){var n=null;if(void 0!==e&&void 0!==i&&(n=this._timestamps.datasets[i][e]),null===n&&(n=Gi(this,t)),null!==n)return this.getPixelForOffset(n)},getPixelForTick:function(t){var e=this.getTicks();return t>=0&&t<e.length?this.getPixelForOffset(e[t].value):null},getValueForPixel:function(t){var e=this,i=e._horizontal?e.width:e.height,n=e._horizontal?e.left:e.top,a=(i?(t-n)/i:0)*(e._offsets.start+1+e._offsets.start)-e._offsets.end,o=Xi(e._table,"pos",a,"time");return e._adapter._create(o)},getLabelWidth:function(t){var e=this.options.ticks,i=this.ctx.measureText(t).width,n=ut.toRadians(e.maxRotation),a=Math.cos(n),o=Math.sin(n);return i*a+Vi(e.fontSize,st.global.defaultFontSize)*o},getLabelCapacity:function(t){var e=this,i=e.options.time.displayFormats.millisecond,n=e.tickFormatFunction(t,0,[],i),a=e.getLabelWidth(n),o=e.isHorizontal()?e.width:e.height,r=Math.floor(o/a);return r>0?r:1}}),Qi={position:"bottom",distribution:"linear",bounds:"data",adapters:{},time:{parser:!1,format:!1,unit:!1,round:!1,displayFormat:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{autoSkip:!1,source:"auto",major:{enabled:!1}}};Ji._defaults=Qi;var tn={category:gi,linear:yi,logarithmic:Ci,radialLinear:Ni,time:Ji},en={datetime:"MMM D, YYYY, h:mm:ss a",millisecond:"h:mm:ss.SSS a",second:"h:mm:ss a",minute:"h:mm a",hour:"hA",day:"MMM D",week:"ll",month:"MMM YYYY",quarter:"[Q]Q - YYYY",year:"YYYY"};si._date.override("function"==typeof t?{_id:"moment",formats:function(){return en},parse:function(e,i){return"string"==typeof e&&"string"==typeof i?e=t(e,i):e instanceof t||(e=t(e)),e.isValid()?e.valueOf():null},format:function(e,i){return t(e).format(i)},add:function(e,i,n){return t(e).add(i,n).valueOf()},diff:function(e,i,n){return t.duration(t(e).diff(t(i))).as(n)},startOf:function(e,i,n){return e=t(e),"isoWeek"===i?e.isoWeekday(n).valueOf():e.startOf(i).valueOf()},endOf:function(e,i){return t(e).endOf(i).valueOf()},_create:function(e){return t(e)}}:{}),st._set("global",{plugins:{filler:{propagate:!0}}});var nn={dataset:function(t){var e=t.fill,i=t.chart,n=i.getDatasetMeta(e),a=n&&i.isDatasetVisible(e)&&n.dataset._children||[],o=a.length||0;return o?function(t,e){return e<o&&a[e]._view||null}:null},boundary:function(t){var e=t.boundary,i=e?e.x:null,n=e?e.y:null;return function(t){return{x:null===i?t.x:i,y:null===n?t.y:n}}}};function an(t,e,i){var n,a=t._model||{},o=a.fill;if(void 0===o&&(o=!!a.backgroundColor),!1===o||null===o)return!1;if(!0===o)return"origin";if(n=parseFloat(o,10),isFinite(n)&&Math.floor(n)===n)return"-"!==o[0]&&"+"!==o[0]||(n=e+n),!(n===e||n<0||n>=i)&&n;switch(o){case"bottom":return"start";case"top":return"end";case"zero":return"origin";case"origin":case"start":case"end":return o;default:return!1}}function on(t){var e,i=t.el._model||{},n=t.el._scale||{},a=t.fill,o=null;if(isFinite(a))return null;if("start"===a?o=void 0===i.scaleBottom?n.bottom:i.scaleBottom:"end"===a?o=void 0===i.scaleTop?n.top:i.scaleTop:void 0!==i.scaleZero?o=i.scaleZero:n.getBasePosition?o=n.getBasePosition():n.getBasePixel&&(o=n.getBasePixel()),null!=o){if(void 0!==o.x&&void 0!==o.y)return o;if(ut.isFinite(o))return{x:(e=n.isHorizontal())?o:null,y:e?null:o}}return null}function rn(t,e,i){var n,a=t[e].fill,o=[e];if(!i)return a;for(;!1!==a&&-1===o.indexOf(a);){if(!isFinite(a))return a;if(!(n=t[a]))return!1;if(n.visible)return a;o.push(a),a=n.fill}return!1}function sn(t){var e=t.fill,i="dataset";return!1===e?null:(isFinite(e)||(i="boundary"),nn[i](t))}function ln(t){return t&&!t.skip}function dn(t,e,i,n,a){var o;if(n&&a){for(t.moveTo(e[0].x,e[0].y),o=1;o<n;++o)ut.canvas.lineTo(t,e[o-1],e[o]);for(t.lineTo(i[a-1].x,i[a-1].y),o=a-1;o>0;--o)ut.canvas.lineTo(t,i[o],i[o-1],!0)}}var un={id:"filler",afterDatasetsUpdate:function(t,e){var i,n,a,o,r=(t.data.datasets||[]).length,s=e.propagate,l=[];for(n=0;n<r;++n)o=null,(a=(i=t.getDatasetMeta(n)).dataset)&&a._model&&a instanceof Wt.Line&&(o={visible:t.isDatasetVisible(n),fill:an(a,n,r),chart:t,el:a}),i.$filler=o,l.push(o);for(n=0;n<r;++n)(o=l[n])&&(o.fill=rn(l,n,s),o.boundary=on(o),o.mapper=sn(o))},beforeDatasetDraw:function(t,e){var i=e.meta.$filler;if(i){var n=t.ctx,a=i.el,o=a._view,r=a._children||[],s=i.mapper,l=o.backgroundColor||st.global.defaultColor;s&&l&&r.length&&(ut.canvas.clipArea(n,t.chartArea),function(t,e,i,n,a,o){var r,s,l,d,u,h,c,f=e.length,g=n.spanGaps,p=[],m=[],v=0,b=0;for(t.beginPath(),r=0,s=f+!!o;r<s;++r)u=i(d=e[l=r%f]._view,l,n),h=ln(d),c=ln(u),h&&c?(v=p.push(d),b=m.push(u)):v&&b&&(g?(h&&p.push(d),c&&m.push(u)):(dn(t,p,m,v,b),v=b=0,p=[],m=[]));dn(t,p,m,v,b),t.closePath(),t.fillStyle=a,t.fill()}(n,r,s,o,l,a._loop),ut.canvas.unclipArea(n))}}},hn=ut.noop,cn=ut.valueOrDefault;function fn(t,e){return t.usePointStyle&&t.boxWidth>e?e:t.boxWidth}st._set("global",{legend:{display:!0,position:"top",fullWidth:!0,reverse:!1,weight:1e3,onClick:function(t,e){var i=e.datasetIndex,n=this.chart,a=n.getDatasetMeta(i);a.hidden=null===a.hidden?!n.data.datasets[i].hidden:null,n.update()},onHover:null,onLeave:null,labels:{boxWidth:40,padding:10,generateLabels:function(t){var e=t.data;return ut.isArray(e.datasets)?e.datasets.map(function(e,i){return{text:e.label,fillStyle:ut.isArray(e.backgroundColor)?e.backgroundColor[0]:e.backgroundColor,hidden:!t.isDatasetVisible(i),lineCap:e.borderCapStyle,lineDash:e.borderDash,lineDashOffset:e.borderDashOffset,lineJoin:e.borderJoinStyle,lineWidth:e.borderWidth,strokeStyle:e.borderColor,pointStyle:e.pointStyle,datasetIndex:i}},this):[]}}},legendCallback:function(t){var e=[];e.push('<ul class="'+t.id+'-legend">');for(var i=0;i<t.data.datasets.length;i++)e.push('<li><span style="background-color:'+t.data.datasets[i].backgroundColor+'"></span>'),t.data.datasets[i].label&&e.push(t.data.datasets[i].label),e.push("</li>");return e.push("</ul>"),e.join("")}});var gn=pt.extend({initialize:function(t){ut.extend(this,t),this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1},beforeUpdate:hn,update:function(t,e,i){var n=this;return n.beforeUpdate(),n.maxWidth=t,n.maxHeight=e,n.margins=i,n.beforeSetDimensions(),n.setDimensions(),n.afterSetDimensions(),n.beforeBuildLabels(),n.buildLabels(),n.afterBuildLabels(),n.beforeFit(),n.fit(),n.afterFit(),n.afterUpdate(),n.minSize},afterUpdate:hn,beforeSetDimensions:hn,setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0,t.minSize={width:0,height:0}},afterSetDimensions:hn,beforeBuildLabels:hn,buildLabels:function(){var t=this,e=t.options.labels||{},i=ut.callback(e.generateLabels,[t.chart],t)||[];e.filter&&(i=i.filter(function(i){return e.filter(i,t.chart.data)})),t.options.reverse&&i.reverse(),t.legendItems=i},afterBuildLabels:hn,beforeFit:hn,fit:function(){var t=this,e=t.options,i=e.labels,n=e.display,a=t.ctx,o=ut.options._parseFont(i),r=o.size,s=t.legendHitBoxes=[],l=t.minSize,d=t.isHorizontal();if(d?(l.width=t.maxWidth,l.height=n?10:0):(l.width=n?10:0,l.height=t.maxHeight),n)if(a.font=o.string,d){var u=t.lineWidths=[0],h=0;a.textAlign="left",a.textBaseline="top",ut.each(t.legendItems,function(t,e){var n=fn(i,r)+r/2+a.measureText(t.text).width;(0===e||u[u.length-1]+n+i.padding>l.width)&&(h+=r+i.padding,u[u.length-(e>0?0:1)]=i.padding),s[e]={left:0,top:0,width:n,height:r},u[u.length-1]+=n+i.padding}),l.height+=h}else{var c=i.padding,f=t.columnWidths=[],g=i.padding,p=0,m=0,v=r+c;ut.each(t.legendItems,function(t,e){var n=fn(i,r)+r/2+a.measureText(t.text).width;e>0&&m+v>l.height-c&&(g+=p+i.padding,f.push(p),p=0,m=0),p=Math.max(p,n),m+=v,s[e]={left:0,top:0,width:n,height:r}}),g+=p,f.push(p),l.width+=g}t.width=l.width,t.height=l.height},afterFit:hn,isHorizontal:function(){return"top"===this.options.position||"bottom"===this.options.position},draw:function(){var t=this,e=t.options,i=e.labels,n=st.global,a=n.defaultColor,o=n.elements.line,r=t.width,s=t.lineWidths;if(e.display){var l,d=t.ctx,u=cn(i.fontColor,n.defaultFontColor),h=ut.options._parseFont(i),c=h.size;d.textAlign="left",d.textBaseline="middle",d.lineWidth=.5,d.strokeStyle=u,d.fillStyle=u,d.font=h.string;var f=fn(i,c),g=t.legendHitBoxes,p=t.isHorizontal();l=p?{x:t.left+(r-s[0])/2+i.padding,y:t.top+i.padding,line:0}:{x:t.left+i.padding,y:t.top+i.padding,line:0};var m=c+i.padding;ut.each(t.legendItems,function(n,u){var h=d.measureText(n.text).width,v=f+c/2+h,b=l.x,x=l.y;p?u>0&&b+v+i.padding>t.left+t.minSize.width&&(x=l.y+=m,l.line++,b=l.x=t.left+(r-s[l.line])/2+i.padding):u>0&&x+m>t.top+t.minSize.height&&(b=l.x=b+t.columnWidths[l.line]+i.padding,x=l.y=t.top+i.padding,l.line++),function(t,i,n){if(!(isNaN(f)||f<=0)){d.save();var r=cn(n.lineWidth,o.borderWidth);if(d.fillStyle=cn(n.fillStyle,a),d.lineCap=cn(n.lineCap,o.borderCapStyle),d.lineDashOffset=cn(n.lineDashOffset,o.borderDashOffset),d.lineJoin=cn(n.lineJoin,o.borderJoinStyle),d.lineWidth=r,d.strokeStyle=cn(n.strokeStyle,a),d.setLineDash&&d.setLineDash(cn(n.lineDash,o.borderDash)),e.labels&&e.labels.usePointStyle){var s=f*Math.SQRT2/2,l=t+f/2,u=i+c/2;ut.canvas.drawPoint(d,n.pointStyle,s,l,u)}else 0!==r&&d.strokeRect(t,i,f,c),d.fillRect(t,i,f,c);d.restore()}}(b,x,n),g[u].left=b,g[u].top=x,function(t,e,i,n){var a=c/2,o=f+a+t,r=e+a;d.fillText(i.text,o,r),i.hidden&&(d.beginPath(),d.lineWidth=2,d.moveTo(o,r),d.lineTo(o+n,r),d.stroke())}(b,x,n,h),p?l.x+=v+i.padding:l.y+=m})}},_getLegendItemAt:function(t,e){var i,n,a,o=this;if(t>=o.left&&t<=o.right&&e>=o.top&&e<=o.bottom)for(a=o.legendHitBoxes,i=0;i<a.length;++i)if(t>=(n=a[i]).left&&t<=n.left+n.width&&e>=n.top&&e<=n.top+n.height)return o.legendItems[i];return null},handleEvent:function(t){var e,i=this,n=i.options,a="mouseup"===t.type?"click":t.type;if("mousemove"===a){if(!n.onHover&&!n.onLeave)return}else{if("click"!==a)return;if(!n.onClick)return}e=i._getLegendItemAt(t.x,t.y),"click"===a?e&&n.onClick&&n.onClick.call(i,t.native,e):(n.onLeave&&e!==i._hoveredItem&&(i._hoveredItem&&n.onLeave.call(i,t.native,i._hoveredItem),i._hoveredItem=e),n.onHover&&e&&n.onHover.call(i,t.native,e))}});function pn(t,e){var i=new gn({ctx:t.ctx,options:e,chart:t});ke.configure(t,i,e),ke.addBox(t,i),t.legend=i}var mn={id:"legend",_element:gn,beforeInit:function(t){var e=t.options.legend;e&&pn(t,e)},beforeUpdate:function(t){var e=t.options.legend,i=t.legend;e?(ut.mergeIf(e,st.global.legend),i?(ke.configure(t,i,e),i.options=e):pn(t,e)):i&&(ke.removeBox(t,i),delete t.legend)},afterEvent:function(t,e){var i=t.legend;i&&i.handleEvent(e)}},vn=ut.noop;st._set("global",{title:{display:!1,fontStyle:"bold",fullWidth:!0,padding:10,position:"top",text:"",weight:2e3}});var bn=pt.extend({initialize:function(t){ut.extend(this,t),this.legendHitBoxes=[]},beforeUpdate:vn,update:function(t,e,i){var n=this;return n.beforeUpdate(),n.maxWidth=t,n.maxHeight=e,n.margins=i,n.beforeSetDimensions(),n.setDimensions(),n.afterSetDimensions(),n.beforeBuildLabels(),n.buildLabels(),n.afterBuildLabels(),n.beforeFit(),n.fit(),n.afterFit(),n.afterUpdate(),n.minSize},afterUpdate:vn,beforeSetDimensions:vn,setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0,t.minSize={width:0,height:0}},afterSetDimensions:vn,beforeBuildLabels:vn,buildLabels:vn,afterBuildLabels:vn,beforeFit:vn,fit:function(){var t=this,e=t.options,i=e.display,n=t.minSize,a=ut.isArray(e.text)?e.text.length:1,o=ut.options._parseFont(e),r=i?a*o.lineHeight+2*e.padding:0;t.isHorizontal()?(n.width=t.maxWidth,n.height=r):(n.width=r,n.height=t.maxHeight),t.width=n.width,t.height=n.height},afterFit:vn,isHorizontal:function(){var t=this.options.position;return"top"===t||"bottom"===t},draw:function(){var t=this,e=t.ctx,i=t.options;if(i.display){var n,a,o,r=ut.options._parseFont(i),s=r.lineHeight,l=s/2+i.padding,d=0,u=t.top,h=t.left,c=t.bottom,f=t.right;e.fillStyle=ut.valueOrDefault(i.fontColor,st.global.defaultFontColor),e.font=r.string,t.isHorizontal()?(a=h+(f-h)/2,o=u+l,n=f-h):(a="left"===i.position?h+l:f-l,o=u+(c-u)/2,n=c-u,d=Math.PI*("left"===i.position?-.5:.5)),e.save(),e.translate(a,o),e.rotate(d),e.textAlign="center",e.textBaseline="middle";var g=i.text;if(ut.isArray(g))for(var p=0,m=0;m<g.length;++m)e.fillText(g[m],0,p,n),p+=s;else e.fillText(g,0,0,n);e.restore()}}});function xn(t,e){var i=new bn({ctx:t.ctx,options:e,chart:t});ke.configure(t,i,e),ke.addBox(t,i),t.titleBlock=i}var yn={},kn=un,wn=mn,Mn={id:"title",_element:bn,beforeInit:function(t){var e=t.options.title;e&&xn(t,e)},beforeUpdate:function(t){var e=t.options.title,i=t.titleBlock;e?(ut.mergeIf(e,st.global.title),i?(ke.configure(t,i,e),i.options=e):xn(t,e)):i&&(ke.removeBox(t,i),delete t.titleBlock)}};for(var _n in yn.filler=kn,yn.legend=wn,yn.title=Mn,ai.helpers=ut,function(){function t(t,e,i){var n;return"string"==typeof t?(n=parseInt(t,10),-1!==t.indexOf("%")&&(n=n/100*e.parentNode[i])):n=t,n}function e(t){return null!=t&&"none"!==t}function i(i,n,a){var o=document.defaultView,r=ut._getParentNode(i),s=o.getComputedStyle(i)[n],l=o.getComputedStyle(r)[n],d=e(s),u=e(l),h=Number.POSITIVE_INFINITY;return d||u?Math.min(d?t(s,i,a):h,u?t(l,r,a):h):"none"}ut.where=function(t,e){if(ut.isArray(t)&&Array.prototype.filter)return t.filter(e);var i=[];return ut.each(t,function(t){e(t)&&i.push(t)}),i},ut.findIndex=Array.prototype.findIndex?function(t,e,i){return t.findIndex(e,i)}:function(t,e,i){i=void 0===i?t:i;for(var n=0,a=t.length;n<a;++n)if(e.call(i,t[n],n,t))return n;return-1},ut.findNextWhere=function(t,e,i){ut.isNullOrUndef(i)&&(i=-1);for(var n=i+1;n<t.length;n++){var a=t[n];if(e(a))return a}},ut.findPreviousWhere=function(t,e,i){ut.isNullOrUndef(i)&&(i=t.length);for(var n=i-1;n>=0;n--){var a=t[n];if(e(a))return a}},ut.isNumber=function(t){return!isNaN(parseFloat(t))&&isFinite(t)},ut.almostEquals=function(t,e,i){return Math.abs(t-e)<i},ut.almostWhole=function(t,e){var i=Math.round(t);return i-e<t&&i+e>t},ut.max=function(t){return t.reduce(function(t,e){return isNaN(e)?t:Math.max(t,e)},Number.NEGATIVE_INFINITY)},ut.min=function(t){return t.reduce(function(t,e){return isNaN(e)?t:Math.min(t,e)},Number.POSITIVE_INFINITY)},ut.sign=Math.sign?function(t){return Math.sign(t)}:function(t){return 0==(t=+t)||isNaN(t)?t:t>0?1:-1},ut.log10=Math.log10?function(t){return Math.log10(t)}:function(t){var e=Math.log(t)*Math.LOG10E,i=Math.round(e);return t===Math.pow(10,i)?i:e},ut.toRadians=function(t){return t*(Math.PI/180)},ut.toDegrees=function(t){return t*(180/Math.PI)},ut._decimalPlaces=function(t){if(ut.isFinite(t)){for(var e=1,i=0;Math.round(t*e)/e!==t;)e*=10,i++;return i}},ut.getAngleFromPoint=function(t,e){var i=e.x-t.x,n=e.y-t.y,a=Math.sqrt(i*i+n*n),o=Math.atan2(n,i);return o<-.5*Math.PI&&(o+=2*Math.PI),{angle:o,distance:a}},ut.distanceBetweenPoints=function(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))},ut.aliasPixel=function(t){return t%2==0?0:.5},ut._alignPixel=function(t,e,i){var n=t.currentDevicePixelRatio,a=i/2;return Math.round((e-a)*n)/n+a},ut.splineCurve=function(t,e,i,n){var a=t.skip?e:t,o=e,r=i.skip?e:i,s=Math.sqrt(Math.pow(o.x-a.x,2)+Math.pow(o.y-a.y,2)),l=Math.sqrt(Math.pow(r.x-o.x,2)+Math.pow(r.y-o.y,2)),d=s/(s+l),u=l/(s+l),h=n*(d=isNaN(d)?0:d),c=n*(u=isNaN(u)?0:u);return{previous:{x:o.x-h*(r.x-a.x),y:o.y-h*(r.y-a.y)},next:{x:o.x+c*(r.x-a.x),y:o.y+c*(r.y-a.y)}}},ut.EPSILON=Number.EPSILON||1e-14,ut.splineCurveMonotone=function(t){var e,i,n,a,o,r,s,l,d,u=(t||[]).map(function(t){return{model:t._model,deltaK:0,mK:0}}),h=u.length;for(e=0;e<h;++e)if(!(n=u[e]).model.skip){if(i=e>0?u[e-1]:null,(a=e<h-1?u[e+1]:null)&&!a.model.skip){var c=a.model.x-n.model.x;n.deltaK=0!==c?(a.model.y-n.model.y)/c:0}!i||i.model.skip?n.mK=n.deltaK:!a||a.model.skip?n.mK=i.deltaK:this.sign(i.deltaK)!==this.sign(n.deltaK)?n.mK=0:n.mK=(i.deltaK+n.deltaK)/2}for(e=0;e<h-1;++e)n=u[e],a=u[e+1],n.model.skip||a.model.skip||(ut.almostEquals(n.deltaK,0,this.EPSILON)?n.mK=a.mK=0:(o=n.mK/n.deltaK,r=a.mK/n.deltaK,(l=Math.pow(o,2)+Math.pow(r,2))<=9||(s=3/Math.sqrt(l),n.mK=o*s*n.deltaK,a.mK=r*s*n.deltaK)));for(e=0;e<h;++e)(n=u[e]).model.skip||(i=e>0?u[e-1]:null,a=e<h-1?u[e+1]:null,i&&!i.model.skip&&(d=(n.model.x-i.model.x)/3,n.model.controlPointPreviousX=n.model.x-d,n.model.controlPointPreviousY=n.model.y-d*n.mK),a&&!a.model.skip&&(d=(a.model.x-n.model.x)/3,n.model.controlPointNextX=n.model.x+d,n.model.controlPointNextY=n.model.y+d*n.mK))},ut.nextItem=function(t,e,i){return i?e>=t.length-1?t[0]:t[e+1]:e>=t.length-1?t[t.length-1]:t[e+1]},ut.previousItem=function(t,e,i){return i?e<=0?t[t.length-1]:t[e-1]:e<=0?t[0]:t[e-1]},ut.niceNum=function(t,e){var i=Math.floor(ut.log10(t)),n=t/Math.pow(10,i);return(e?n<1.5?1:n<3?2:n<7?5:10:n<=1?1:n<=2?2:n<=5?5:10)*Math.pow(10,i)},ut.requestAnimFrame="undefined"==typeof window?function(t){t()}:window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(t){return window.setTimeout(t,1e3/60)},ut.getRelativePosition=function(t,e){var i,n,a=t.originalEvent||t,o=t.target||t.srcElement,r=o.getBoundingClientRect(),s=a.touches;s&&s.length>0?(i=s[0].clientX,n=s[0].clientY):(i=a.clientX,n=a.clientY);var l=parseFloat(ut.getStyle(o,"padding-left")),d=parseFloat(ut.getStyle(o,"padding-top")),u=parseFloat(ut.getStyle(o,"padding-right")),h=parseFloat(ut.getStyle(o,"padding-bottom")),c=r.right-r.left-l-u,f=r.bottom-r.top-d-h;return{x:i=Math.round((i-r.left-l)/c*o.width/e.currentDevicePixelRatio),y:n=Math.round((n-r.top-d)/f*o.height/e.currentDevicePixelRatio)}},ut.getConstraintWidth=function(t){return i(t,"max-width","clientWidth")},ut.getConstraintHeight=function(t){return i(t,"max-height","clientHeight")},ut._calculatePadding=function(t,e,i){return(e=ut.getStyle(t,e)).indexOf("%")>-1?i*parseInt(e,10)/100:parseInt(e,10)},ut._getParentNode=function(t){var e=t.parentNode;return e&&"[object ShadowRoot]"===e.toString()&&(e=e.host),e},ut.getMaximumWidth=function(t){var e=ut._getParentNode(t);if(!e)return t.clientWidth;var i=e.clientWidth,n=i-ut._calculatePadding(e,"padding-left",i)-ut._calculatePadding(e,"padding-right",i),a=ut.getConstraintWidth(t);return isNaN(a)?n:Math.min(n,a)},ut.getMaximumHeight=function(t){var e=ut._getParentNode(t);if(!e)return t.clientHeight;var i=e.clientHeight,n=i-ut._calculatePadding(e,"padding-top",i)-ut._calculatePadding(e,"padding-bottom",i),a=ut.getConstraintHeight(t);return isNaN(a)?n:Math.min(n,a)},ut.getStyle=function(t,e){return t.currentStyle?t.currentStyle[e]:document.defaultView.getComputedStyle(t,null).getPropertyValue(e)},ut.retinaScale=function(t,e){var i=t.currentDevicePixelRatio=e||"undefined"!=typeof window&&window.devicePixelRatio||1;if(1!==i){var n=t.canvas,a=t.height,o=t.width;n.height=a*i,n.width=o*i,t.ctx.scale(i,i),n.style.height||n.style.width||(n.style.height=a+"px",n.style.width=o+"px")}},ut.fontString=function(t,e,i){return e+" "+t+"px "+i},ut.longestText=function(t,e,i,n){var a=(n=n||{}).data=n.data||{},o=n.garbageCollect=n.garbageCollect||[];n.font!==e&&(a=n.data={},o=n.garbageCollect=[],n.font=e),t.font=e;var r=0;ut.each(i,function(e){null!=e&&!0!==ut.isArray(e)?r=ut.measureText(t,a,o,r,e):ut.isArray(e)&&ut.each(e,function(e){null==e||ut.isArray(e)||(r=ut.measureText(t,a,o,r,e))})});var s=o.length/2;if(s>i.length){for(var l=0;l<s;l++)delete a[o[l]];o.splice(0,s)}return r},ut.measureText=function(t,e,i,n,a){var o=e[a];return o||(o=e[a]=t.measureText(a).width,i.push(a)),o>n&&(n=o),n},ut.numberOfLabelLines=function(t){var e=1;return ut.each(t,function(t){ut.isArray(t)&&t.length>e&&(e=t.length)}),e},ut.color=X?function(t){return t instanceof CanvasGradient&&(t=st.global.defaultColor),X(t)}:function(t){return console.error("Color.js not found!"),t},ut.getHoverColor=function(t){return t instanceof CanvasPattern||t instanceof CanvasGradient?t:ut.color(t).saturate(.5).darken(.1).rgbString()}}(),ai._adapters=si,ai.Animation=vt,ai.animationService=bt,ai.controllers=ue,ai.DatasetController=Mt,ai.defaults=st,ai.Element=pt,ai.elements=Wt,ai.Interaction=ve,ai.layouts=ke,ai.platform=Ve,ai.plugins=Ee,ai.Scale=fi,ai.scaleService=He,ai.Ticks=li,ai.Tooltip=Je,ai.helpers.each(tn,function(t,e){ai.scaleService.registerScaleType(e,t,t._defaults)}),yn)yn.hasOwnProperty(_n)&&ai.plugins.register(yn[_n]);ai.platform.initialize();var Cn=ai;return"undefined"!=typeof window&&(window.Chart=ai),ai.Chart=ai,ai.Legend=yn.legend._element,ai.Title=yn.title._element,ai.pluginService=ai.plugins,ai.PluginBase=ai.Element.extend({}),ai.canvasHelpers=ai.helpers.canvas,ai.layoutService=ai.layouts,ai.LinearScaleBase=bi,ai.helpers.each(["Bar","Bubble","Doughnut","Line","PolarArea","Radar","Scatter"],function(t){ai[t]=function(e,i){return new ai(e,ai.helpers.merge(i||{},{type:t.charAt(0).toLowerCase()+t.slice(1)}))}}),Cn});
  /*! Hammer.JS - v2.0.8 - 2016-04-23
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license */

  !function(e,o){"object"==typeof exports&&"undefined"!=typeof module?module.exports=o(require("chart.js"),require("hammerjs")):"function"==typeof define&&define.amd?define(["chart.js","hammerjs"],o):(e=e||self).ChartZoom=o(e.Chart,e.Hammer)}(this,(function(e,o){"use strict";e=e&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e,o=o&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o;var t=e.helpers,n=e.Zoom=e.Zoom||{},a=n.zoomFunctions=n.zoomFunctions||{},i=n.panFunctions=n.panFunctions||{};function m(e,o){var n={};void 0!==e.options.pan&&(n.pan=e.options.pan),void 0!==e.options.zoom&&(n.zoom=e.options.zoom);var a=e.$zoom;o=a._options=t.merge({},[o,n]);var i=a._node,m=o.zoom&&o.zoom.enabled,r=o.zoom.drag;m&&!r?i.addEventListener("wheel",a._wheelHandler):i.removeEventListener("wheel",a._wheelHandler),m&&r?(i.addEventListener("mousedown",a._mouseDownHandler),i.ownerDocument.addEventListener("mouseup",a._mouseUpHandler)):(i.removeEventListener("mousedown",a._mouseDownHandler),i.removeEventListener("mousemove",a._mouseMoveHandler),i.ownerDocument.removeEventListener("mouseup",a._mouseUpHandler))}function r(e){var o=e.$zoom._originalOptions;t.each(e.scales,(function(e){o[e.id]||(o[e.id]=t.clone(e.options))})),t.each(o,(function(t,n){e.scales[n]||delete o[n]}))}function l(e,o,t){return void 0===e||("string"==typeof e?-1!==e.indexOf(o):"function"==typeof e&&-1!==e({chart:t}).indexOf(o))}function s(e,o){if(e.scaleAxes&&e.rangeMax&&!t.isNullOrUndef(e.rangeMax[e.scaleAxes])){var n=e.rangeMax[e.scaleAxes];o>n&&(o=n)}return o}function c(e,o){if(e.scaleAxes&&e.rangeMin&&!t.isNullOrUndef(e.rangeMin[e.scaleAxes])){var n=e.rangeMin[e.scaleAxes];o<n&&(o=n)}return o}function u(e,o,t,n){var a=e.max-e.min,i=a*(o-1),m=e.isHorizontal()?t.x:t.y,r=(e.getValueForPixel(m)-e.min)/a,l=i*r,u=i*(1-r);e.options.ticks.min=c(n,e.min+l),e.options.ticks.max=s(n,e.max-u)}function d(e,o,t,n){var i=a[e.type];i&&i(e,o,t,n)}function p(e,o,n,a,i,m){var s=e.chartArea;a||(a={x:(s.left+s.right)/2,y:(s.top+s.bottom)/2});var c=e.$zoom._options.zoom;if(c.enabled){r(e);var u,p="function"==typeof c.mode?c.mode({chart:e}):c.mode;u="xy"===p&&void 0!==i?i:"xy",t.each(e.scales,(function(t){t.isHorizontal()&&l(p,"x",e)&&l(u,"x",e)?(c.scaleAxes="x",d(t,o,a,c)):!t.isHorizontal()&&l(p,"y",e)&&l(u,"y",e)&&(c.scaleAxes="y",d(t,n,a,c))})),m?e.update({duration:m,easing:"easeOutQuad"}):e.update(0),"function"==typeof c.onZoom&&c.onZoom({chart:e})}}function f(e,o,n){var a,i=e.options.ticks,m=e.min,r=e.max,l=e.getValueForPixel(e.getPixelForValue(m)-o),s=e.getValueForPixel(e.getPixelForValue(r)-o),c=l=l.valueOf?l.valueOf():l,u=s=s.valueOf?s.valueOf():s;n.scaleAxes&&n.rangeMin&&!t.isNullOrUndef(n.rangeMin[n.scaleAxes])&&(c=n.rangeMin[n.scaleAxes]),n.scaleAxes&&n.rangeMax&&!t.isNullOrUndef(n.rangeMax[n.scaleAxes])&&(u=n.rangeMax[n.scaleAxes]),l>=c&&s<=u?(i.min=l,i.max=s):l<c?(a=m-c,i.min=c,i.max=r-a):s>u&&(a=u-r,i.max=u,i.min=m+a)}function v(e,o,t){var n=i[e.type];n&&n(e,o,t)}e.Zoom.defaults=e.defaults.global.plugins.zoom={pan:{enabled:!1,mode:"xy",speed:20,threshold:10},zoom:{enabled:!1,mode:"xy",sensitivity:3,speed:.1}},n.zoomFunctions.category=function(e,o,t,a){var i=e.chart.data.labels,m=e.minIndex,r=i.length-1,l=e.maxIndex,u=a.sensitivity,d=e.isHorizontal()?e.left+e.width/2:e.top+e.height/2,p=e.isHorizontal()?t.x:t.y;n.zoomCumulativeDelta=o>1?n.zoomCumulativeDelta+1:n.zoomCumulativeDelta-1,Math.abs(n.zoomCumulativeDelta)>u&&(n.zoomCumulativeDelta<0?(p>=d?m<=0?l=Math.min(r,l+1):m=Math.max(0,m-1):p<d&&(l>=r?m=Math.max(0,m-1):l=Math.min(r,l+1)),n.zoomCumulativeDelta=0):n.zoomCumulativeDelta>0&&(p>=d?m=m<l?m=Math.min(l,m+1):m:p<d&&(l=l>m?l=Math.max(m,l-1):l),n.zoomCumulativeDelta=0),e.options.ticks.min=c(a,i[m]),e.options.ticks.max=s(a,i[l]))},n.zoomFunctions.time=function(e,o,t,n){u(e,o,t,n);var a=e.options;a.time&&(a.time.min&&(a.time.min=a.ticks.min),a.time.max&&(a.time.max=a.ticks.max))},n.zoomFunctions.linear=u,n.zoomFunctions.logarithmic=u,n.panFunctions.category=function(e,o,t){var a,i=e.chart.data.labels,m=i.length-1,r=Math.max(e.ticks.length,1),l=t.speed,u=e.minIndex,d=Math.round(e.width/(r*l));n.panCumulativeDelta+=o,u=n.panCumulativeDelta>d?Math.max(0,u-1):n.panCumulativeDelta<-d?Math.min(m-r+1,u+1):u,n.panCumulativeDelta=u!==e.minIndex?0:n.panCumulativeDelta,a=Math.min(m,u+r-1),e.options.ticks.min=c(t,i[u]),e.options.ticks.max=s(t,i[a])},n.panFunctions.time=function(e,o,t){f(e,o,t);var n=e.options;n.time&&(n.time.min&&(n.time.min=n.ticks.min),n.time.max&&(n.time.max=n.ticks.max))},n.panFunctions.linear=f,n.panFunctions.logarithmic=f,n.panCumulativeDelta=0,n.zoomCumulativeDelta=0;var h={id:"zoom",afterInit:function(e){e.resetZoom=function(){r(e);var o=e.$zoom._originalOptions;t.each(e.scales,(function(e){var t=e.options.time,n=e.options.ticks;o[e.id]?(t&&(t.min=o[e.id].time.min,t.max=o[e.id].time.max),n&&(n.min=o[e.id].ticks.min,n.max=o[e.id].ticks.max)):(t&&(delete t.min,delete t.max),n&&(delete n.min,delete n.max))})),e.update()}},beforeUpdate:function(e,o){m(e,o)},beforeInit:function(e,a){e.$zoom={_originalOptions:{}};var i=e.$zoom._node=e.ctx.canvas;m(e,a);var s=e.$zoom._options,c=s.pan&&s.pan.threshold;e.$zoom._mouseDownHandler=function(o){i.addEventListener("mousemove",e.$zoom._mouseMoveHandler),e.$zoom._dragZoomStart=o},e.$zoom._mouseMoveHandler=function(o){e.$zoom._dragZoomStart&&(e.$zoom._dragZoomEnd=o,e.update(0))},e.$zoom._mouseUpHandler=function(o){if(e.$zoom._dragZoomStart){i.removeEventListener("mousemove",e.$zoom._mouseMoveHandler);var t=e.$zoom._dragZoomStart,n=t.target.getBoundingClientRect().left,a=Math.min(t.clientX,o.clientX)-n,m=Math.max(t.clientX,o.clientX)-n,r=t.target.getBoundingClientRect().top,c=Math.min(t.clientY,o.clientY)-r,u=m-a,d=Math.max(t.clientY,o.clientY)-r-c;e.$zoom._dragZoomStart=null,e.$zoom._dragZoomEnd=null;var f=s.zoom&&s.zoom.threshold||0;if(!(u<=f&&d<=f)){var v=e.chartArea,h=e.$zoom._options.zoom,x=v.right-v.left,g=l(h.mode,"x",e)&&u?1+(x-u)/x:1,z=v.bottom-v.top,y=l(h.mode,"y",e);p(e,g,y&&d?1+(z-d)/z:1,{x:(a-v.left)/(1-u/x)+v.left,y:(c-v.top)/(1-d/z)+v.top},void 0,h.drag.animationDuration),"function"==typeof h.onZoomComplete&&h.onZoomComplete({chart:e})}}};var u=null;if(e.$zoom._wheelHandler=function(o){if(o.cancelable&&o.preventDefault(),void 0!==o.deltaY){var t=o.target.getBoundingClientRect(),n={x:o.clientX-t.left,y:o.clientY-t.top},a=e.$zoom._options.zoom,i=a.speed;o.deltaY>=0&&(i=-i),p(e,1+i,1+i,n),clearTimeout(u),u=setTimeout((function(){"function"==typeof a.onZoomComplete&&a.onZoomComplete({chart:e})}),250)}},o){var d,f=new o.Manager(i);f.add(new o.Pinch),f.add(new o.Pan({threshold:c}));var h=function(o){var t=1/d*o.scale,n=o.target.getBoundingClientRect(),a={x:o.center.x-n.left,y:o.center.y-n.top},i=Math.abs(o.pointers[0].clientX-o.pointers[1].clientX),m=Math.abs(o.pointers[0].clientY-o.pointers[1].clientY),r=i/m;p(e,t,t,a,r>.3&&r<1.7?"xy":i>m?"x":"y");var l=e.$zoom._options.zoom;"function"==typeof l.onZoomComplete&&l.onZoomComplete({chart:e}),d=o.scale};f.on("pinchstart",(function(){d=1})),f.on("pinch",h),f.on("pinchend",(function(e){h(e),d=null,n.zoomCumulativeDelta=0}));var x=null,g=null,z=!1,y=function(o){if(null!==x&&null!==g){z=!0;var n=o.deltaX-x,a=o.deltaY-g;x=o.deltaX,g=o.deltaY,function(e,o,n){r(e);var a=e.$zoom._options.pan;if(a.enabled){var i="function"==typeof a.mode?a.mode({chart:e}):a.mode;t.each(e.scales,(function(t){t.isHorizontal()&&l(i,"x",e)&&0!==o?(a.scaleAxes="x",v(t,o,a)):!t.isHorizontal()&&l(i,"y",e)&&0!==n&&(a.scaleAxes="y",v(t,n,a))})),e.update(0),"function"==typeof a.onPan&&a.onPan({chart:e})}}(e,n,a)}};f.on("panstart",(function(e){x=0,g=0,y(e)})),f.on("panmove",y),f.on("panend",(function(){x=null,g=null,n.panCumulativeDelta=0,setTimeout((function(){z=!1}),500);var o=e.$zoom._options.pan;"function"==typeof o.onPanComplete&&o.onPanComplete({chart:e})})),e.$zoom._ghostClickHandler=function(e){z&&e.cancelable&&(e.stopImmediatePropagation(),e.preventDefault())},i.addEventListener("click",e.$zoom._ghostClickHandler),e._mc=f}},beforeDatasetsDraw:function(e){var o=e.ctx;if(e.$zoom._dragZoomEnd){var t=function(e){for(var o=e.scales,t=Object.keys(o),n=0;n<t.length;n++){var a=o[t[n]];if(a.isHorizontal())return a}}(e),n=function(e){for(var o=e.scales,t=Object.keys(o),n=0;n<t.length;n++){var a=o[t[n]];if(!a.isHorizontal())return a}}(e),a=e.$zoom._dragZoomStart,i=e.$zoom._dragZoomEnd,m=t.left,r=t.right,s=n.top,c=n.bottom;if(l(e.$zoom._options.zoom.mode,"x",e)){var u=a.target.getBoundingClientRect().left;m=Math.min(a.clientX,i.clientX)-u,r=Math.max(a.clientX,i.clientX)-u}if(l(e.$zoom._options.zoom.mode,"y",e)){var d=a.target.getBoundingClientRect().top;s=Math.min(a.clientY,i.clientY)-d,c=Math.max(a.clientY,i.clientY)-d}var p=r-m,f=c-s,v=e.$zoom._options.zoom.drag;o.save(),o.beginPath(),o.fillStyle=v.backgroundColor||"rgba(225,225,225,0.3)",o.fillRect(m,s,p,f),v.borderWidth>0&&(o.lineWidth=v.borderWidth,o.strokeStyle=v.borderColor||"rgba(225,225,225)",o.strokeRect(m,s,p,f)),o.restore()}},destroy:function(e){if(e.$zoom){var o=e.$zoom,t=o._node;t.removeEventListener("mousedown",o._mouseDownHandler),t.removeEventListener("mousemove",o._mouseMoveHandler),t.ownerDocument.removeEventListener("mouseup",o._mouseUpHandler),t.removeEventListener("wheel",o._wheelHandler),t.removeEventListener("click",o._ghostClickHandler),delete e.$zoom;var n=e._mc;n&&(n.remove("pinchstart"),n.remove("pinch"),n.remove("pinchend"),n.remove("panstart"),n.remove("pan"),n.remove("panend"),n.destroy())}}};return e.plugins.register(h),h}));
  /*!
   * chartjs-chart-matrix v1.0.0-alpha4
   * https://github.com/kurkle/chartjs-chart-matrix#readme
   * (c) 2019 Jukka Kurkela
   * Released under the MIT license
   */
  
  !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(require("chart.js")):"function"==typeof define&&define.amd?define(["chart.js"],t):t((e=e||self).Chart)}(this,function(e){"use strict";var t=(e=e&&e.hasOwnProperty("default")?e.default:e).helpers.options.resolve,r=e.DatasetController.extend({dataElementType:e.elements.Rectangle,update:function(e){var t,r,a=this,o=a.getMeta(),d=o.data||[];for(a._xScale=a.getScaleForId(o.xAxisID),a._yScale=a.getScaleForId(o.yAxisID),t=0,r=d.length;t<r;++t)a.updateElement(d[t],t,e)},updateElement:function(e,t,r){var a=this,o=a.getDataset(),d=a.index,n=o.data[t],i=a._xScale,l=a._yScale,s=a._resolveElementOptions(e,t),h=r?i.getBasePixel():i.getPixelForValue(n,t,d),c=r?l.getBasePixel():l.getPixelForValue(n,t,d),p=s.height,x=s.width,u=p/2;e._xScale=i,e._yScale=l,e._options=s,e._datasetIndex=d,e._index=t,e._model={x:h,base:c-u,y:c+u,width:x,height:p,backgroundColor:s.backgroundColor,borderColor:s.borderColor,borderSkipped:s.borderSkipped,borderWidth:s.borderWidth},e.pivot()},draw:function(){var e,t,r=this.getMeta().data||[];for(e=0,t=r.length;e<t;++e)r[e].draw()},_resolveElementOptions:function(e,r){var a,o,d,n=this.chart,i=n.data.datasets[this.index],l=n.options.elements.rectangle,s={},h={chart:n,dataIndex:r,dataset:i,datasetIndex:this.index},c=["backgroundColor","borderColor","borderSkipped","borderWidth","width","height"];for(a=0,o=c.length;a<o;++a)s[d=c[a]]=t([i[d],l[d]],h,r);return s}});e.controllers.matrix=r,e.defaults.matrix={hover:{mode:"nearest",intersect:!0},tooltips:{mode:"nearest",intersect:!0},scales:{xAxes:[{type:"linear"}],yAxes:[{type:"linear"}]},elements:{rectangle:{borderSkipped:!1,width:20,height:20}}}});
  /*! Sortable 1.10.2 - MIT | git://github.com/SortableJS/Sortable.git */
  

  /** @license
   *
   *     Colour Palette Generator script.
   *     Copyright (c) 2014 Google Inc.
   *
   *     Licensed under the Apache License, Version 2.0 (the "License"); you may
   *     not use this file except in compliance with the License.  You may
   *     obtain a copy of the License at
   *
   *         http://www.apache.org/licenses/LICENSE-2.0
   *
   *     Unless required by applicable law or agreed to in writing, software
   *     distributed under the License is distributed on an "AS IS" BASIS,
   *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   *     implied.  See the License for the specific language governing
   *     permissions and limitations under the License.
   *
   * Furthermore, ColorBrewer colour schemes are covered by the following:
   *
   *     Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and
   *                        The Pennsylvania State University.
   *
   *     Licensed under the Apache License, Version 2.0 (the "License"); you may
   *     not use this file except in compliance with the License. You may obtain
   *     a copy of the License at
   *
   *         http://www.apache.org/licenses/LICENSE-2.0
   *
   *     Unless required by applicable law or agreed to in writing, software
   *     distributed under the License is distributed on an "AS IS" BASIS,
   *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   *     implied. See the License for the specific language governing
   *     permissions and limitations under the License.
   *
   *     Redistribution and use in source and binary forms, with or without
   *     modification, are permitted provided that the following conditions are
   *     met:
   *
   *     1. Redistributions as source code must retain the above copyright
   *     notice, this list of conditions and the following disclaimer.
   *
   *     2. The end-user documentation included with the redistribution, if any,
   *     must include the following acknowledgment: "This product includes color
   *     specifications and designs developed by Cynthia Brewer
   *     (http://colorbrewer.org/)." Alternately, this acknowledgment may appear
   *     in the software itself, if and wherever such third-party
   *     acknowledgments normally appear.
   *
   *     4. The name "ColorBrewer" must not be used to endorse or promote products
   *     derived from this software without prior written permission. For written
   *     permission, please contact Cynthia Brewer at cbrewer@psu.edu.
   *
   *     5. Products derived from this software may not be called "ColorBrewer",
   *     nor may "ColorBrewer" appear in their name, without prior written
   *     permission of Cynthia Brewer.
   *
   * Furthermore, Solarized colour schemes are covered by the following:
   *
   *     Copyright (c) 2011 Ethan Schoonover
   *
   *     Permission is hereby granted, free of charge, to any person obtaining
   *     a copy of this software and associated documentation files (the
   *     "Software"), to deal in the Software without restriction, including
   *     without limitation the rights to use, copy, modify, merge, publish,
   *     distribute, sublicense, and/or sell copies of the Software, and to
   *     permit persons to whom the Software is furnished to do so, subject to
   *     the following conditions:
   *
   *     The above copyright notice and this permission notice shall be included
   *     in all copies or substantial portions of the Software.
   *
   *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   *     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   *     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   *     LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   *     OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   *     WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */
  
  
  'use strict';
  
  var palette = (function() {
  
    var proto = Array.prototype;
    var slice = function(arr, opt_begin, opt_end) {
      return proto.slice.apply(arr, proto.slice.call(arguments, 1));
    };
  
    var extend = function(arr, arr2) {
      return proto.push.apply(arr, arr2);
    };
  
    var function_type = typeof function() {};
  
    var INF = 1000000000;  // As far as we're concerned, that's infinity. ;)
  
  
    /**
     * Generate a colour palette from given scheme.
     *
     * If scheme argument is not a function it is passed to palettes.listSchemes
     * function (along with the number argument).  This may result in an array
     * of more than one available scheme.  If that is the case, scheme at
     * opt_index position is taken.
     *
     * This allows using different palettes for different data without having to
     * name the schemes specifically, for example:
     *
     *     palette_for_foo = palette('sequential', 10, 0);
     *     palette_for_bar = palette('sequential', 10, 1);
     *     palette_for_baz = palette('sequential', 10, 2);
     *
     * @param {!palette.SchemeType|string|palette.Palette} scheme Scheme to
     *     generate palette for.  Either a function constructed with
     *     palette.Scheme object, or anything that palette.listSchemes accepts
     *     as name argument.
     * @param {number} number Number of colours to return.  If negative, absolute
     *     value is taken and colours will be returned in reverse order.
     * @param {number=} opt_index If scheme is a name of a group or an array and
     *     results in more than one scheme, index of the scheme to use.  The
     *     index wraps around.
     * @param {...*} varargs Additional arguments to pass to palette or colour
     *     generator (if the chosen scheme uses those).
     * @return {Array<string>} Array of abs(number) 'RRGGBB' strings or null if
     *     no matching scheme was found.
     */
    var palette = function(scheme, number, opt_index, varargs) {
      number |= 0;
      if (number == 0) {
        return [];
      }
  
      if (typeof scheme !== function_type) {
        var arr = palette.listSchemes(
            /** @type {string|palette.Palette} */ (scheme), number);
        if (!arr.length) {
          return null;
        }
        scheme = arr[(opt_index || 0) % arr.length];
      }
  
      var args = slice(arguments, 2);
      args[0] = number;
      return scheme.apply(scheme, args);
    };
  
  
    /**
     * Returns a callable colour scheme object.
     *
     * Just after being created, the scheme has no colour palettes and no way of
     * generating any, thus generate method will return null.  To turn scheme
     * into a useful object, addPalette, addPalettes or setColorFunction methods
     * need to be used.
     *
     * To generate a colour palette with given number colours using function
     * returned by this method, just call it with desired number of colours.
     *
     * Since this function *returns* a callable object, it must *not* be used
     * with the new operator.
     *
     * @param {string} name Name of the scheme.
     * @param {string|!Array<string>=} opt_groups A group name or list of
     *     groups the scheme should be categorised under.  Three typical groups
     *     to use are 'qualitative', 'sequential' and 'diverging', but any
     *     groups may be created.
     * @return {!palette.SchemeType} A colour palette generator function, which
     *     in addition has methods and properties like a regular object.  Think
     *     of it as a callable object.
     */
    palette.Scheme = function(name, opt_groups) {
      /**
       * A map from a number to a colour palettes with given number of colours.
       * @type {!Object<number, palette.Palette>}
       */
      var palettes = {};
  
      /**
       * The biggest palette in palettes map.
       * @type {number}
       */
      var palettes_max = 0;
  
      /**
       * The smallest palette in palettes map.
       * @type {number}
       */
      var palettes_min = INF;
  
      var makeGenerator = function() {
        if (arguments.length <= 1) {
          return self.color_func.bind(self);
        } else {
          var args = slice(arguments);
          return function(x) {
            args[0] = x;
            return self.color_func.apply(self, args);
          };
        }
      };
  
      /**
       * Generate a colour palette from the scheme.
       *
       * If there was a palette added with addPalette (or addPalettes) with
       * enough colours, that palette will be used.  Otherwise, if colour
       * function has been set using setColorFunction method, that function will
       * be used to generate the palette.  Otherwise null is returned.
       *
       * @param {number} number Number of colours to return.  If negative,
       *     absolute value is taken and colours will be returned in reverse
       *     order.
       * @param {...*} varargs Additional arguments to pass to palette or colour
       *     generator (if the chosen scheme uses those).
       */
      var self = function(number, varargs) {
        number |= 0;
        if (!number) {
          return [];
        }
  
        var _number = number;
        number = Math.abs(number);
  
        if (number <= palettes_max) {
          for (var i = Math.max(number, palettes_min); !(i in palettes); ++i) {
            /* nop */
          }
          var colors = palettes[i];
          if (i > number) {
            var take_head =
                'shrinking_takes_head' in colors ?
                colors.shrinking_takes_head : self.shrinking_takes_head;
            if (take_head) {
              colors = colors.slice(0, number);
              i = number;
            } else {
              return palette.generate(
                  function(x) { return colors[Math.round(x)]; },
                  _number, 0, colors.length - 1);
            }
          }
          colors = colors.slice();
          if (_number < 0) {
            colors.reverse();
          }
          return colors;
  
        } else if (self.color_func) {
          return palette.generate(makeGenerator.apply(self, arguments),
                                  _number, 0, 1, self.color_func_cyclic);
  
        } else {
          return null;
        }
      };
  
      /**
       * The name of the palette.
       * @type {string}
       */
      self.scheme_name = name;
  
      /**
       * A list of groups the palette belongs to.
       * @type {!Array<string>}
       */
      self.groups = opt_groups ?
        typeof opt_groups === 'string' ? [opt_groups] : opt_groups : [];
  
      /**
       * The biggest palette this scheme can generate.
       * @type {number}
       */
      self.max = 0;
  
      /**
       * The biggest palette this scheme can generate that is colour-blind
       * friendly.
       * @type {number}
       */
      self.cbf_max = INF;
  
  
      /**
       * Adds a colour palette to the colour scheme.
       *
       * @param {palette.Palette} palette An array of 'RRGGBB' strings
       *     representing the palette to add.
       * @param {boolean=} opt_is_cbf Whether the palette is colourblind friendly.
       */
      self.addPalette = function(palette, opt_is_cbf) {
        var len = palette.length;
        if (len) {
          palettes[len] = palette;
          palettes_min = Math.min(palettes_min, len);
          palettes_max = Math.max(palettes_max, len);
          self.max = Math.max(self.max, len);
          if (!opt_is_cbf && len != 1) {
            self.cbf_max = Math.min(self.cbf_max, len - 1);
          }
        }
      };
  
      /**
       * Adds number of colour palettes to the colour scheme.
       *
       * @param {palette.PalettesList} palettes A map or an array of colour
       *     palettes to add.  If map, i.e.  object, is used, properties should
       *     use integer property names.
       * @param {number=} opt_max Size of the biggest palette in palettes set.
       *     If not set, palettes must have a length property which will be used.
       * @param {number=} opt_cbf_max Size of the biggest palette which is still
       *     colourblind friendly.  1 by default.
       */
      self.addPalettes = function(palettes, opt_max, opt_cbf_max) {
        opt_max = opt_max || palettes.length;
        for (var i = 0; i < opt_max; ++i) {
          if (i in palettes) {
            self.addPalette(palettes[i], true);
          }
        }
        self.cbf_max = Math.min(self.cbf_max, opt_cbf_max || 1);
      };
  
      /**
       * Enable shrinking palettes taking head of the list of colours.
       *
       * When user requests n-colour palette but the smallest palette added with
       * addPalette (or addPalettes) is m-colour one (where n < m), n colours
       * across the palette will be returned.  For example:
       *     var ex = palette.Scheme('ex');
       *     ex.addPalette(['000000', 'bcbcbc', 'ffffff']);
       *     var pal = ex(2);
       *     // pal == ['000000', 'ffffff']
       *
       * This works for palettes where the distance between colours is
       * correlated to distance in the palette array, which is true in gradients
       * such as the one above.
       *
       * To turn this feature off shrinkByTakingHead can be set to true either
       * for all palettes in the scheme (if opt_idx is not given) or for palette
       * with given number of colours only.  In general, setting the option for
       * given palette overwrites whatever has been set for the scheme.  The
       * default, as described above, is false.
       *
       * Alternatively, the feature can be enabled by setting shrinking_takes_head
       * property for the palette Array or the scheme object.
       *
       * For example, all of the below give equivalent results:
       *     var pal = ['ff0000', '00ff00', '0000ff'];
       *
       *     var ex = palette.Scheme('ex');
       *     ex.addPalette(pal);               // ex(2) == ['ff0000', '0000ff']
       *     ex.shrinkByTakingHead(true);      // ex(2) == ['ff0000', '00ff00']
       *
       *     ex = palette.Scheme('ex');
       *     ex.addPalette(pal);               // ex(2) == ['ff0000', '0000ff']
       *     ex.shrinkByTakingHead(true, 3);   // ex(2) == ['ff0000', '00ff00']
       *
       *     ex = palette.Scheme('ex');
       *     ex.addPalette(pal);
       *     ex.addPalette(pal);               // ex(2) == ['ff0000', '0000ff']
       *     pal.shrinking_takes_head = true;  // ex(2) == ['ff0000', '00ff00']
       *
       * @param {boolean} enabled Whether to enable or disable the “shrinking
       *     takes head” feature.  It is disabled by default.
       * @param {number=} opt_idx If given, the “shrinking takes head” option
       *     for palette with given number of colours is set.  If such palette
       *     does not exist, nothing happens.
       */
      self.shrinkByTakingHead = function(enabled, opt_idx) {
        if (opt_idx !== void(0)) {
          if (opt_idx in palettes) {
            palettes[opt_idx].shrinking_takes_head = !!enabled;
          }
        } else {
          self.shrinking_takes_head = !!enabled;
        }
      };
  
      /**
       * Sets a colour generation function of the colour scheme.
       *
       * The function must accept a singe number argument whose value can be from
       * 0.0 to 1.0, and return a colour as an 'RRGGBB' string.  This function
       * will be used when generating palettes, i.e. if 11-colour palette is
       * requested, this function will be called with arguments 0.0, 0.1, …, 1.0.
       *
       * If the palette generated by the function is colourblind friendly,
       * opt_is_cbf should be set to true.
       *
       * In some cases, it is not desirable to reach 1.0 when generating
       * a palette.  This happens for hue-rainbows where the 0–1 range corresponds
       * to a 0°–360° range in hues, and since hue at 0° is the same as at 360°,
       * it's desired to stop short the end of the range when generating
       * a palette.  To accomplish this, opt_cyclic should be set to true.
       *
       * @param {palette.ColorFunction} func A colour generator function.
       * @param {boolean=} opt_is_cbf Whether palette generate with the function
       *     is colour-blind friendly.
       * @param {boolean=} opt_cyclic Whether colour at 0.0 is the same as the
       *     one at 1.0.
       */
      self.setColorFunction = function(func, opt_is_cbf, opt_cyclic) {
        self.color_func = func;
        self.color_func_cyclic = !!opt_cyclic;
        self.max = INF;
        if (!opt_is_cbf && self.cbf_max === INF) {
          self.cbf_max = 1;
        }
      };
  
      self.color = function(x, varargs) {
        if (self.color_func) {
          return self.color_func.apply(this, arguments);
        } else {
          return null;
        }
      };
  
      return self;
    };
  
  
    /**
     * Creates a new palette.Scheme and initialises it by calling addPalettes
     * method with the rest of the arguments.
     *
     * @param {string} name Name of the scheme.
     * @param {string|!Array<string>} groups A group name or list of group
     *     names the scheme belongs to.
     * @param {!Object<number, palette.Palette>|!Array<palette.Palette>}
     *     palettes A map or an array of colour palettes to add.  If map, i.e.
     *     object, is used, properties should use integer property names.
     * @param {number=} opt_max Size of the biggest palette in palettes set.
     *     If not set, palettes must have a length property which will be used.
     * @param {number=} opt_cbf_max Size of the biggest palette which is still
     *     colourblind friendly.  1 by default.
     * @return {!palette.SchemeType} A colour palette generator function, which
     *     in addition has methods and properties like a regular object.  Think
     *     of it as a callable object.
     */
    palette.Scheme.fromPalettes = function(name, groups,
                                           palettes, opt_max, opt_cbf_max) {
      var scheme = palette.Scheme(name, groups);
      scheme.addPalettes.apply(scheme, slice(arguments, 2));
      return scheme;
    };
  
  
    /**
     * Creates a new palette.Scheme and initialises it by calling
     * setColorFunction method with the rest of the arguments.
     *
     * @param {string} name Name of the scheme.
     * @param {string|!Array<string>} groups A group name or list of group
     *     names the scheme belongs to.
     * @param {palette.ColorFunction} func A colour generator function.
     * @param {boolean=} opt_is_cbf Whether palette generate with the function
     *     is colour-blind friendly.
     * @param {boolean=} opt_cyclic Whether colour at 0.0 is the same as the
     *     one at 1.0.
     * @return {!palette.SchemeType} A colour palette generator function, which
     *     in addition has methods and properties like a regular object.  Think
     *     of it as a callable object.
     */
    palette.Scheme.withColorFunction = function(name, groups,
                                                func, opt_is_cbf, opt_cyclic) {
      var scheme = palette.Scheme(name, groups);
      scheme.setColorFunction.apply(scheme, slice(arguments, 2));
      return scheme;
    };
  
  
    /**
     * A map of registered schemes.  Maps a scheme or group name to a list of
     * scheme objects.  Property name is either 'n-<name>' for single scheme
     * names or 'g-<name>' for scheme group names.
     *
     * @type {!Object<string, !Array<!Object>>}
     */
    var registered_schemes = {};
  
  
    /**
     * Registers a new colour scheme.
     *
     * @param {!palette.SchemeType} scheme The scheme to add.
     */
    palette.register = function(scheme) {
      registered_schemes['n-' + scheme.scheme_name] = [scheme];
      scheme.groups.forEach(function(g) {
        (registered_schemes['g-' + g] =
         registered_schemes['g-' + g] || []).push(scheme);
      });
      (registered_schemes['g-all'] =
         registered_schemes['g-all'] || []).push(scheme);
    };
  
  
    /**
     * List all schemes that match given name and number of colours.
     *
     * name argument can be either a string or an array of strings.  In the
     * former case, the function acts as if the argument was an array with name
     * as a single argument (i.e. “palette.listSchemes('foo')” is exactly the same
     * as “palette.listSchemes(['foo'])”).
     *
     * Each name can be either name of a palette (e.g. 'tol-sq' for Paul Tol's
     * sequential palette), or a name of a group (e.g. 'sequential' for all
     * sequential palettes).  Name can therefore map to a single scheme or
     * several schemes.
     *
     * Furthermore, name can be suffixed with '-cbf' to indicate that only
     * schemes that are colourblind friendly should be returned.  For example,
     * 'rainbow' returns a HSV rainbow scheme, but because it is not colourblind
     * friendly, 'rainbow-cbf' returns no schemes.
     *
     * Some schemes may produce colourblind friendly palettes for some number of
     * colours.  For example ColorBrewer's Dark2 scheme is colourblind friendly
     * if no more than 3 colours are generated.  If opt_number is not specified,
     * 'qualitative-cbf' will include 'cb-Dark2' but if opt_number is given as,
     * say, 5 it won't.
     *
     * Name can also be 'all' which will return all registered schemes.
     * Naturally, 'all-cbf' will return all colourblind friendly schemes.
     *
     * Schemes are added to the library using palette.register.  Schemes are
     * created using palette.Scheme function.  By default, the following schemes
     * are available:
     *
     *     Name            Description
     *     --------------  -----------------------------------------------------
     *     tol             Paul Tol's qualitative scheme, cbf, max 12 colours.
     *     tol-dv          Paul Tol's diverging scheme, cbf.
     *     tol-sq          Paul Tol's sequential scheme, cbf.
     *     tol-rainbow     Paul Tol's qualitative scheme, cbf.
     *
     *     rainbow         A rainbow palette.
     *
     *     cb-YlGn         ColorBrewer sequential schemes.
     *     cb-YlGnBu
     *     cb-GnBu
     *     cb-BuGn
     *     cb-PuBuGn
     *     cb-PuBu
     *     cb-BuPu
     *     cb-RdPu
     *     cb-PuRd
     *     cb-OrRd
     *     cb-YlOrRd
     *     cb-YlOrBr
     *     cb-Purples
     *     cb-Blues
     *     cb-Greens
     *     cb-Oranges
     *     cb-Reds
     *     cb-Greys
     *
     *     cb-PuOr         ColorBrewer diverging schemes.
     *     cb-BrBG
     *     cb-PRGn
     *     cb-PiYG
     *     cb-RdBu
     *     cb-RdGy
     *     cb-RdYlBu
     *     cb-Spectral
     *     cb-RdYlGn
     *
     *     cb-Accent       ColorBrewer qualitative schemes.
     *     cb-Dark2
     *     cb-Paired
     *     cb-Pastel1
     *     cb-Pastel2
     *     cb-Set1
     *     cb-Set2
     *     cb-Set3
     *
     *     sol-base        Solarized base colours.
     *     sol-accent      Solarized accent colours.
     *
     * The following groups are also available by default:
     *
     *     Name            Description
     *     --------------  -----------------------------------------------------
     *     all             All registered schemes.
     *     sequential      All sequential schemes.
     *     diverging       All diverging schemes.
     *     qualitative     All qualitative schemes.
     *     cb-sequential   All ColorBrewer sequential schemes.
     *     cb-diverging    All ColorBrewer diverging schemes.
     *     cb-qualitative  All ColorBrewer qualitative schemes.
     *
     * You can read more about Paul Tol's palettes at http://www.sron.nl/~pault/.
     * You can read more about ColorBrewer at http://colorbrewer2.org.
     *
     * @param {string|!Array<string>} name A name of a colour scheme, of
     *     a group of colour schemes, or an array of any of those.
     * @param {number=} opt_number When requesting only colourblind friendly
     *     schemes, number of colours the scheme must provide generating such
     *     that the palette is still colourblind friendly.  2 by default.
     * @return {!Array<!palette.SchemeType>} An array of colour scheme objects
     *     matching the criteria.  Sorted by scheme name.
     */
    palette.listSchemes = function(name, opt_number) {
      if (!opt_number) {
        opt_number = 2;
      } else if (opt_number < 0) {
        opt_number = -opt_number;
      }
  
      var ret = [];
      (typeof name === 'string' ? [name] : name).forEach(function(n) {
        var cbf = n.substring(n.length - 4) === '-cbf';
        if (cbf) {
          n = n.substring(0, n.length - 4);
        }
        var schemes =
            registered_schemes['g-' + n] ||
            registered_schemes['n-' + n] ||
            [];
        for (var i = 0, scheme; (scheme = schemes[i]); ++i) {
          if ((cbf ? scheme.cbf : scheme.max) >= opt_number) {
            ret.push(scheme);
          }
        }
      });
  
      ret.sort(function(a, b) {
        return a.scheme_name >= b.scheme_name ?
          a.scheme_name > b.scheme_name ? 1 : 0 : -1;
      });
      return ret;
    };
  
  
    /**
     * Generates a palette using given colour generating function.
     *
     * The color_func callback must accept a singe number argument whose value
     * can vary from 0.0 to 1.0 (or in general from opt_start to opt_end), and
     * return a colour as an 'RRGGBB' string.  This function will be used when
     * generating palettes, i.e. if 11-colour palette is requested, this
     * function will be called with arguments 0.0, 0.1, …, 1.0.
     *
     * In some cases, it is not desirable to reach 1.0 when generating
     * a palette.  This happens for hue-rainbows where the 0–1 range corresponds
     * to a 0°–360° range in hues, and since hue at 0° is the same as at 360°,
     * it's desired to stop short the end of the range when generating
     * a palette.  To accomplish this, opt_cyclic should be set to true.
     *
     * opt_start and opt_end may be used to change the range the colour
     * generation function is called with.  opt_end may be less than opt_start
     * which will case to traverse the range in reverse.  Another way to reverse
     * the palette is requesting negative number of colours.  The two methods do
     * not always lead to the same results (especially if opt_cyclic is set).
     *
     * @param {palette.ColorFunction} color_func A colours generating callback
     *     function.
     * @param {number} number Number of colours to generate in the palette.  If
     *     number is negative, colours in the palette will be reversed.  If only
     *     one colour is requested, colour at opt_start will be returned.
     * @param {number=} opt_start Optional starting point for the palette
     *     generation function.  Zero by default.
     * @param {number=} opt_end Optional ending point for the palette generation
     *     function.  One by default.
     * @param {boolean=} opt_cyclic If true, function will assume colour at
     *     point opt_start is the same as one at opt_end.
     * @return {palette.Palette} An array of 'RRGGBB' colours.
     */
    palette.generate = function(color_func, number, opt_start, opt_end,
                                opt_cyclic) {
      if (Math.abs(number) < 1) {
        return [];
      }
  
      opt_start = opt_start === void(0) ? 0 : opt_start;
      opt_end = opt_end === void(0) ? 1 : opt_end;
  
      if (Math.abs(number) < 2) {
        return [color_func(opt_start)];
      }
  
      var i = Math.abs(number);
      var x = opt_start;
      var ret = [];
      var step = (opt_end - opt_start) / (opt_cyclic ? i : (i - 1));
  
      for (; --i >= 0; x += step) {
        ret.push(color_func(x));
      }
      if (number < 0) {
        ret.reverse();
      }
      return ret;
    };
  
  
    /**
     * Clamps value to [0, 1] range.
     * @param {number} v Number to limit value of.
     * @return {number} If v is inside of [0, 1] range returns v, otherwise
     *     returns 0 or 1 depending which side of the range v is closer to.
     */
    var clamp = function(v) {
      return v > 0 ? (v < 1 ? v : 1) : 0;
    };
  
    /**
     * Converts r, g, b triple into RRGGBB hex representation.
     * @param {number} r Red value of the colour in the range [0, 1].
     * @param {number} g Green value of the colour in the range [0, 1].
     * @param {number} b Blue value of the colour in the range [0, 1].
     * @return {string} A lower-case RRGGBB representation of the colour.
     */
    palette.rgbColor = function(r, g, b) {
      return [r, g, b].map(function(v) {
        v = Number(Math.round(clamp(v) * 255)).toString(16);
        return v.length == 1 ? '0' + v : v;
      }).join('');
    };
  
    /**
     * Converts a linear r, g, b triple into RRGGBB hex representation.
     * @param {number} r Linear red value of the colour in the range [0, 1].
     * @param {number} g Linear green value of the colour in the range [0, 1].
     * @param {number} b Linear blue value of the colour in the range [0, 1].
     * @return {string} A lower-case RRGGBB representation of the colour.
     */
    palette.linearRgbColor = function(r, g, b) {
      // http://www.brucelindbloom.com/index.html?Eqn_XYZ_to_RGB.html
      return [r, g, b].map(function(v) {
        v = clamp(v);
        if (v <= 0.0031308) {
          v = 12.92 * v;
        } else {
          v = 1.055 * Math.pow(v, 1 / 2.4) - 0.055;
        }
        v = Number(Math.round(v * 255)).toString(16);
        return v.length == 1 ? '0' + v : v;
      }).join('');
    };
  
    /**
     * Converts an HSV colours to RRGGBB hex representation.
     * @param {number} h Hue in the range [0, 1].
     * @param {number=} opt_s Saturation in the range [0, 1].  One by default.
     * @param {number=} opt_v Value in the range [0, 1].  One by default.
     * @return {string} An RRGGBB representation of the colour.
     */
    palette.hsvColor = function(h, opt_s, opt_v) {
      h *= 6;
      var s = opt_s === void(0) ? 1 : clamp(opt_s);
      var v = opt_v === void(0) ? 1 : clamp(opt_v);
      var x = v * (1 - s * Math.abs(h % 2 - 1));
      var m = v * (1 - s);
      switch (Math.floor(h) % 6) {
      case 0: return palette.rgbColor(v, x, m);
      case 1: return palette.rgbColor(x, v, m);
      case 2: return palette.rgbColor(m, v, x);
      case 3: return palette.rgbColor(m, x, v);
      case 4: return palette.rgbColor(x, m, v);
      default: return palette.rgbColor(v, m, x);
      }
    };
  
    palette.register(palette.Scheme.withColorFunction(
      'rainbow', 'qualitative', palette.hsvColor, false, true));
  
    return palette;
  })();
  
  
  /** @typedef {function(number): string} */
  palette.ColorFunction;
  
  /** @typedef {!Array<string>} */
  palette.Palette;
  
  /** @typedef {!Object<number, palette.Palette>|!Array<palette.Palette>} */
  palette.PalettesList;
  
  /**
   * @typedef {
   *   function(number, ...?): Array<string>|
   *   {
   *     scheme_name: string,
   *     groups: !Array<string>,
   *     max: number,
   *     cbf_max: number,
   *     addPalette: function(!Array<string>, boolean=),
   *     addPalettes: function(palette.PalettesList, number=, number=),
   *     shrinkByTakingHead: function(boolean, number=),
   *     setColorFunction: function(palette.ColorFunction, boolean=, boolean=),
   *     color: function(number, ...?): ?string}}
   */
  palette.SchemeType;
  
  
  /* mpn65 palette start here. ************************************************/
  
  /* The ‘mpn65’ palette is designed for systems which show many graphs which
     don’t have custom colour palettes chosen by humans or if number of necessary
     colours isn’t know a priori. */
  
  (function() {
    var scheme = palette.Scheme.fromPalettes('mpn65', 'qualitative', [[
      'ff0029', '377eb8', '66a61e', '984ea3', '00d2d5', 'ff7f00', 'af8d00',
      '7f80cd', 'b3e900', 'c42e60', 'a65628', 'f781bf', '8dd3c7', 'bebada',
      'fb8072', '80b1d3', 'fdb462', 'fccde5', 'bc80bd', 'ffed6f', 'c4eaff',
      'cf8c00', '1b9e77', 'd95f02', 'e7298a', 'e6ab02', 'a6761d', '0097ff',
      '00d067', '000000', '252525', '525252', '737373', '969696', 'bdbdbd',
      'f43600', '4ba93b', '5779bb', '927acc', '97ee3f', 'bf3947', '9f5b00',
      'f48758', '8caed6', 'f2b94f', 'eff26e', 'e43872', 'd9b100', '9d7a00',
      '698cff', 'd9d9d9', '00d27e', 'd06800', '009f82', 'c49200', 'cbe8ff',
      'fecddf', 'c27eb6', '8cd2ce', 'c4b8d9', 'f883b0', 'a49100', 'f48800',
      '27d0df', 'a04a9b'
    ]]);
    scheme.shrinkByTakingHead(true);
    palette.register(scheme);
  })();
  
  /* Paul Tol's schemes start here. *******************************************/
  /* See http://www.sron.nl/~pault/ */
  
  (function() {
    var rgb = palette.rgbColor;
  
    /**
     * Calculates value of a polynomial at given point.
     * For example, poly(x, 1, 2, 3) calculates value of “1 + 2*x + 3*X²”.
     * @param {number} x Value to calculate polynomial for.
     * @param {...number} varargs Coefficients of the polynomial specified in
     *     the order of rising powers of x including constant as the first
     *     variable argument.
     */
    var poly = function(x, varargs) {
      var i = arguments.length - 1, n = arguments[i];
      while (i > 1) {
        n = n * x + arguments[--i];
      }
      return n;
    };
  
    /**
     * Calculate approximate value of error function with maximum error of 0.0005.
     * See <https://en.wikipedia.org/wiki/Error_function>.
     * @param {number} x Argument of the error function.
     * @return {number} Value of error function for x.
     */
    var erf = function(x) {
      // https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions
      // This produces a maximum error of 0.0005 which is more then we need.  In
      // the worst case, that error is multiplied by four and then divided by two
      // before being multiplied by 255, so in the end, the error is multiplied by
      // 510 which produces 0.255 which is less than a single colour step.
      var y = poly(Math.abs(x), 1, 0.278393, 0.230389, 0.000972, 0.078108);
      y *= y; // y^2
      y *= y; // y^4
      y = 1 - 1 / y;
      return x < 0 ? -y : y;
    };
  
    palette.register(palette.Scheme.fromPalettes('tol', 'qualitative', [
      ['4477aa'],
      ['4477aa', 'cc6677'],
      ['4477aa', 'ddcc77', 'cc6677'],
      ['4477aa', '117733', 'ddcc77', 'cc6677'],
      ['332288', '88ccee', '117733', 'ddcc77', 'cc6677'],
      ['332288', '88ccee', '117733', 'ddcc77', 'cc6677', 'aa4499'],
      ['332288', '88ccee', '44aa99', '117733', 'ddcc77', 'cc6677', 'aa4499'],
      ['332288', '88ccee', '44aa99', '117733', '999933', 'ddcc77', 'cc6677',
       'aa4499'],
      ['332288', '88ccee', '44aa99', '117733', '999933', 'ddcc77', 'cc6677',
       '882255', 'aa4499'],
      ['332288', '88ccee', '44aa99', '117733', '999933', 'ddcc77', '661100',
       'cc6677', '882255', 'aa4499'],
      ['332288', '6699cc', '88ccee', '44aa99', '117733', '999933', 'ddcc77',
       '661100', 'cc6677', '882255', 'aa4499'],
      ['332288', '6699cc', '88ccee', '44aa99', '117733', '999933', 'ddcc77',
       '661100', 'cc6677', 'aa4466', '882255', 'aa4499']
    ], 12, 12));
  
    /**
     * Calculates a colour along Paul Tol's sequential colours axis.
     * See <http://www.sron.nl/~pault/colourschemes.pdf> figure 7 and equation 1.
     * @param {number} x Position of the colour on the axis in the [0, 1] range.
     * @return {string} An RRGGBB representation of the colour.
     */
    palette.tolSequentialColor = function(x) {
      return rgb(1 - 0.392 * (1 + erf((x - 0.869) / 0.255)),
                 1.021 - 0.456 * (1 + erf((x - 0.527) / 0.376)),
                 1 - 0.493 * (1 + erf((x - 0.272) / 0.309)));
    };
  
    palette.register(palette.Scheme.withColorFunction(
      'tol-sq', 'sequential', palette.tolSequentialColor, true));
  
    /**
     * Calculates a colour along Paul Tol's diverging colours axis.
     * See <http://www.sron.nl/~pault/colourschemes.pdf> figure 8 and equation 2.
     * @param {number} x Position of the colour on the axis in the [0, 1] range.
     * @return {string} An RRGGBB representation of the colour.
     */
    palette.tolDivergingColor = function(x) {
      var g = poly(x, 0.572, 1.524, -1.811) / poly(x, 1, -0.291, 0.1574);
      return rgb(poly(x, 0.235, -2.13, 26.92, -65.5, 63.5, -22.36),
                 g * g,
                 1 / poly(x, 1.579, -4.03, 12.92, -31.4, 48.6, -23.36));
    };
  
    palette.register(palette.Scheme.withColorFunction(
      'tol-dv', 'diverging', palette.tolDivergingColor, true));
  
    /**
     * Calculates a colour along Paul Tol's rainbow colours axis.
     * See <http://www.sron.nl/~pault/colourschemes.pdf> figure 13 and equation 3.
     * @param {number} x Position of the colour on the axis in the [0, 1] range.
     * @return {string} An RRGGBB representation of the colour.
     */
    palette.tolRainbowColor = function(x) {
      return rgb(poly(x, 0.472, -0.567, 4.05) / poly(x, 1, 8.72, -19.17, 14.1),
                 poly(x, 0.108932, -1.22635, 27.284, -98.577, 163.3, -131.395,
                      40.634),
                 1 / poly(x, 1.97, 3.54, -68.5, 243, -297, 125));
    };
  
    palette.register(palette.Scheme.withColorFunction(
      'tol-rainbow', 'qualitative', palette.tolRainbowColor, true));
  })();
  
  
  /* Solarized colour schemes start here. *************************************/
  /* See http://ethanschoonover.com/solarized */
  
  (function() {
    /*
     * Those are not really designed to be used in graphs, but we're keeping
     * them here in case someone cares.
     */
    palette.register(palette.Scheme.fromPalettes('sol-base', 'sequential', [
      ['002b36', '073642', '586e75', '657b83', '839496', '93a1a1', 'eee8d5',
       'fdf6e3']
    ], 1, 8));
    palette.register(palette.Scheme.fromPalettes('sol-accent', 'qualitative', [
      ['b58900', 'cb4b16', 'dc322f', 'd33682', '6c71c4', '268bd2', '2aa198',
       '859900']
    ]));
  })();
  
  
  /* ColorBrewer colour schemes start here. ***********************************/
  /* See http://colorbrewer2.org/ */
  
  (function() {
    var schemes = {
      YlGn: {
        type: 'sequential',
        cbf: 42,
        3: ['f7fcb9', 'addd8e', '31a354'],
        4: ['ffffcc', 'c2e699', '78c679', '238443'],
        5: ['ffffcc', 'c2e699', '78c679', '31a354', '006837'],
        6: ['ffffcc', 'd9f0a3', 'addd8e', '78c679', '31a354', '006837'],
        7: ['ffffcc', 'd9f0a3', 'addd8e', '78c679', '41ab5d', '238443',
            '005a32'],
        8: ['ffffe5', 'f7fcb9', 'd9f0a3', 'addd8e', '78c679', '41ab5d',
            '238443', '005a32'],
        9: ['ffffe5', 'f7fcb9', 'd9f0a3', 'addd8e', '78c679', '41ab5d',
            '238443', '006837', '004529']
      },
      YlGnBu: {
        type: 'sequential',
        cbf: 42,
        3: ['edf8b1', '7fcdbb', '2c7fb8'],
        4: ['ffffcc', 'a1dab4', '41b6c4', '225ea8'],
        5: ['ffffcc', 'a1dab4', '41b6c4', '2c7fb8', '253494'],
        6: ['ffffcc', 'c7e9b4', '7fcdbb', '41b6c4', '2c7fb8', '253494'],
        7: ['ffffcc', 'c7e9b4', '7fcdbb', '41b6c4', '1d91c0', '225ea8',
            '0c2c84'],
        8: ['ffffd9', 'edf8b1', 'c7e9b4', '7fcdbb', '41b6c4', '1d91c0',
            '225ea8', '0c2c84'],
        9: ['ffffd9', 'edf8b1', 'c7e9b4', '7fcdbb', '41b6c4', '1d91c0',
            '225ea8', '253494', '081d58']
      },
      GnBu: {
        type: 'sequential',
        cbf: 42,
        3: ['e0f3db', 'a8ddb5', '43a2ca'],
        4: ['f0f9e8', 'bae4bc', '7bccc4', '2b8cbe'],
        5: ['f0f9e8', 'bae4bc', '7bccc4', '43a2ca', '0868ac'],
        6: ['f0f9e8', 'ccebc5', 'a8ddb5', '7bccc4', '43a2ca', '0868ac'],
        7: ['f0f9e8', 'ccebc5', 'a8ddb5', '7bccc4', '4eb3d3', '2b8cbe',
            '08589e'],
        8: ['f7fcf0', 'e0f3db', 'ccebc5', 'a8ddb5', '7bccc4', '4eb3d3',
            '2b8cbe', '08589e'],
        9: ['f7fcf0', 'e0f3db', 'ccebc5', 'a8ddb5', '7bccc4', '4eb3d3',
            '2b8cbe', '0868ac', '084081']
      },
      BuGn: {
        type: 'sequential',
        cbf: 42,
        3: ['e5f5f9', '99d8c9', '2ca25f'],
        4: ['edf8fb', 'b2e2e2', '66c2a4', '238b45'],
        5: ['edf8fb', 'b2e2e2', '66c2a4', '2ca25f', '006d2c'],
        6: ['edf8fb', 'ccece6', '99d8c9', '66c2a4', '2ca25f', '006d2c'],
        7: ['edf8fb', 'ccece6', '99d8c9', '66c2a4', '41ae76', '238b45',
            '005824'],
        8: ['f7fcfd', 'e5f5f9', 'ccece6', '99d8c9', '66c2a4', '41ae76',
            '238b45', '005824'],
        9: ['f7fcfd', 'e5f5f9', 'ccece6', '99d8c9', '66c2a4', '41ae76',
            '238b45', '006d2c', '00441b']
      },
      PuBuGn: {
        type: 'sequential',
        cbf: 42,
        3: ['ece2f0', 'a6bddb', '1c9099'],
        4: ['f6eff7', 'bdc9e1', '67a9cf', '02818a'],
        5: ['f6eff7', 'bdc9e1', '67a9cf', '1c9099', '016c59'],
        6: ['f6eff7', 'd0d1e6', 'a6bddb', '67a9cf', '1c9099', '016c59'],
        7: ['f6eff7', 'd0d1e6', 'a6bddb', '67a9cf', '3690c0', '02818a',
            '016450'],
        8: ['fff7fb', 'ece2f0', 'd0d1e6', 'a6bddb', '67a9cf', '3690c0',
            '02818a', '016450'],
        9: ['fff7fb', 'ece2f0', 'd0d1e6', 'a6bddb', '67a9cf', '3690c0',
            '02818a', '016c59', '014636']
      },
      PuBu: {
        type: 'sequential',
        cbf: 42,
        3: ['ece7f2', 'a6bddb', '2b8cbe'],
        4: ['f1eef6', 'bdc9e1', '74a9cf', '0570b0'],
        5: ['f1eef6', 'bdc9e1', '74a9cf', '2b8cbe', '045a8d'],
        6: ['f1eef6', 'd0d1e6', 'a6bddb', '74a9cf', '2b8cbe', '045a8d'],
        7: ['f1eef6', 'd0d1e6', 'a6bddb', '74a9cf', '3690c0', '0570b0',
            '034e7b'],
        8: ['fff7fb', 'ece7f2', 'd0d1e6', 'a6bddb', '74a9cf', '3690c0',
            '0570b0', '034e7b'],
        9: ['fff7fb', 'ece7f2', 'd0d1e6', 'a6bddb', '74a9cf', '3690c0',
            '0570b0', '045a8d', '023858']
      },
      BuPu: {
        type: 'sequential',
        cbf: 42,
        3: ['e0ecf4', '9ebcda', '8856a7'],
        4: ['edf8fb', 'b3cde3', '8c96c6', '88419d'],
        5: ['edf8fb', 'b3cde3', '8c96c6', '8856a7', '810f7c'],
        6: ['edf8fb', 'bfd3e6', '9ebcda', '8c96c6', '8856a7', '810f7c'],
        7: ['edf8fb', 'bfd3e6', '9ebcda', '8c96c6', '8c6bb1', '88419d',
            '6e016b'],
        8: ['f7fcfd', 'e0ecf4', 'bfd3e6', '9ebcda', '8c96c6', '8c6bb1',
            '88419d', '6e016b'],
        9: ['f7fcfd', 'e0ecf4', 'bfd3e6', '9ebcda', '8c96c6', '8c6bb1',
            '88419d', '810f7c', '4d004b']
      },
      RdPu: {
        type: 'sequential',
        cbf: 42,
        3: ['fde0dd', 'fa9fb5', 'c51b8a'],
        4: ['feebe2', 'fbb4b9', 'f768a1', 'ae017e'],
        5: ['feebe2', 'fbb4b9', 'f768a1', 'c51b8a', '7a0177'],
        6: ['feebe2', 'fcc5c0', 'fa9fb5', 'f768a1', 'c51b8a', '7a0177'],
        7: ['feebe2', 'fcc5c0', 'fa9fb5', 'f768a1', 'dd3497', 'ae017e',
            '7a0177'],
        8: ['fff7f3', 'fde0dd', 'fcc5c0', 'fa9fb5', 'f768a1', 'dd3497',
            'ae017e', '7a0177'],
        9: ['fff7f3', 'fde0dd', 'fcc5c0', 'fa9fb5', 'f768a1', 'dd3497',
            'ae017e', '7a0177', '49006a']
      },
      PuRd: {
        type: 'sequential',
        cbf: 42,
        3: ['e7e1ef', 'c994c7', 'dd1c77'],
        4: ['f1eef6', 'd7b5d8', 'df65b0', 'ce1256'],
        5: ['f1eef6', 'd7b5d8', 'df65b0', 'dd1c77', '980043'],
        6: ['f1eef6', 'd4b9da', 'c994c7', 'df65b0', 'dd1c77', '980043'],
        7: ['f1eef6', 'd4b9da', 'c994c7', 'df65b0', 'e7298a', 'ce1256',
            '91003f'],
        8: ['f7f4f9', 'e7e1ef', 'd4b9da', 'c994c7', 'df65b0', 'e7298a',
            'ce1256', '91003f'],
        9: ['f7f4f9', 'e7e1ef', 'd4b9da', 'c994c7', 'df65b0', 'e7298a',
            'ce1256', '980043', '67001f']
      },
      OrRd: {
        type: 'sequential',
        cbf: 42,
        3: ['fee8c8', 'fdbb84', 'e34a33'],
        4: ['fef0d9', 'fdcc8a', 'fc8d59', 'd7301f'],
        5: ['fef0d9', 'fdcc8a', 'fc8d59', 'e34a33', 'b30000'],
        6: ['fef0d9', 'fdd49e', 'fdbb84', 'fc8d59', 'e34a33', 'b30000'],
        7: ['fef0d9', 'fdd49e', 'fdbb84', 'fc8d59', 'ef6548', 'd7301f',
            '990000'],
        8: ['fff7ec', 'fee8c8', 'fdd49e', 'fdbb84', 'fc8d59', 'ef6548',
            'd7301f', '990000'],
        9: ['fff7ec', 'fee8c8', 'fdd49e', 'fdbb84', 'fc8d59', 'ef6548',
            'd7301f', 'b30000', '7f0000']
      },
      YlOrRd: {
        type: 'sequential',
        cbf: 42,
        3: ['ffeda0', 'feb24c', 'f03b20'],
        4: ['ffffb2', 'fecc5c', 'fd8d3c', 'e31a1c'],
        5: ['ffffb2', 'fecc5c', 'fd8d3c', 'f03b20', 'bd0026'],
        6: ['ffffb2', 'fed976', 'feb24c', 'fd8d3c', 'f03b20', 'bd0026'],
        7: ['ffffb2', 'fed976', 'feb24c', 'fd8d3c', 'fc4e2a', 'e31a1c',
            'b10026'],
        8: ['ffffcc', 'ffeda0', 'fed976', 'feb24c', 'fd8d3c', 'fc4e2a',
            'e31a1c', 'b10026'],
        9: ['ffffcc', 'ffeda0', 'fed976', 'feb24c', 'fd8d3c', 'fc4e2a',
            'e31a1c', 'bd0026', '800026']
      },
      YlOrBr: {
        type: 'sequential',
        cbf: 42,
        3: ['fff7bc', 'fec44f', 'd95f0e'],
        4: ['ffffd4', 'fed98e', 'fe9929', 'cc4c02'],
        5: ['ffffd4', 'fed98e', 'fe9929', 'd95f0e', '993404'],
        6: ['ffffd4', 'fee391', 'fec44f', 'fe9929', 'd95f0e', '993404'],
        7: ['ffffd4', 'fee391', 'fec44f', 'fe9929', 'ec7014', 'cc4c02',
            '8c2d04'],
        8: ['ffffe5', 'fff7bc', 'fee391', 'fec44f', 'fe9929', 'ec7014',
            'cc4c02', '8c2d04'],
        9: ['ffffe5', 'fff7bc', 'fee391', 'fec44f', 'fe9929', 'ec7014',
            'cc4c02', '993404', '662506']
      },
      Purples: {
        type: 'sequential',
        cbf: 42,
        3: ['efedf5', 'bcbddc', '756bb1'],
        4: ['f2f0f7', 'cbc9e2', '9e9ac8', '6a51a3'],
        5: ['f2f0f7', 'cbc9e2', '9e9ac8', '756bb1', '54278f'],
        6: ['f2f0f7', 'dadaeb', 'bcbddc', '9e9ac8', '756bb1', '54278f'],
        7: ['f2f0f7', 'dadaeb', 'bcbddc', '9e9ac8', '807dba', '6a51a3',
            '4a1486'],
        8: ['fcfbfd', 'efedf5', 'dadaeb', 'bcbddc', '9e9ac8', '807dba',
            '6a51a3', '4a1486'],
        9: ['fcfbfd', 'efedf5', 'dadaeb', 'bcbddc', '9e9ac8', '807dba',
            '6a51a3', '54278f', '3f007d']
      },
      Blues: {
        type: 'sequential',
        cbf: 42,
        3: ['deebf7', '9ecae1', '3182bd'],
        4: ['eff3ff', 'bdd7e7', '6baed6', '2171b5'],
        5: ['eff3ff', 'bdd7e7', '6baed6', '3182bd', '08519c'],
        6: ['eff3ff', 'c6dbef', '9ecae1', '6baed6', '3182bd', '08519c'],
        7: ['eff3ff', 'c6dbef', '9ecae1', '6baed6', '4292c6', '2171b5',
            '084594'],
        8: ['f7fbff', 'deebf7', 'c6dbef', '9ecae1', '6baed6', '4292c6',
            '2171b5', '084594'],
        9: ['f7fbff', 'deebf7', 'c6dbef', '9ecae1', '6baed6', '4292c6',
            '2171b5', '08519c', '08306b']
      },
      Greens: {
        type: 'sequential',
        cbf: 42,
        3: ['e5f5e0', 'a1d99b', '31a354'],
        4: ['edf8e9', 'bae4b3', '74c476', '238b45'],
        5: ['edf8e9', 'bae4b3', '74c476', '31a354', '006d2c'],
        6: ['edf8e9', 'c7e9c0', 'a1d99b', '74c476', '31a354', '006d2c'],
        7: ['edf8e9', 'c7e9c0', 'a1d99b', '74c476', '41ab5d', '238b45',
            '005a32'],
        8: ['f7fcf5', 'e5f5e0', 'c7e9c0', 'a1d99b', '74c476', '41ab5d',
            '238b45', '005a32'],
        9: ['f7fcf5', 'e5f5e0', 'c7e9c0', 'a1d99b', '74c476', '41ab5d',
            '238b45', '006d2c', '00441b']
      },
      Oranges: {
        type: 'sequential',
        cbf: 42,
        3: ['fee6ce', 'fdae6b', 'e6550d'],
        4: ['feedde', 'fdbe85', 'fd8d3c', 'd94701'],
        5: ['feedde', 'fdbe85', 'fd8d3c', 'e6550d', 'a63603'],
        6: ['feedde', 'fdd0a2', 'fdae6b', 'fd8d3c', 'e6550d', 'a63603'],
        7: ['feedde', 'fdd0a2', 'fdae6b', 'fd8d3c', 'f16913', 'd94801',
            '8c2d04'],
        8: ['fff5eb', 'fee6ce', 'fdd0a2', 'fdae6b', 'fd8d3c', 'f16913',
            'd94801', '8c2d04'],
        9: ['fff5eb', 'fee6ce', 'fdd0a2', 'fdae6b', 'fd8d3c', 'f16913',
            'd94801', 'a63603', '7f2704']
      },
      Reds: {
        type: 'sequential',
        cbf: 42,
        3: ['fee0d2', 'fc9272', 'de2d26'],
        4: ['fee5d9', 'fcae91', 'fb6a4a', 'cb181d'],
        5: ['fee5d9', 'fcae91', 'fb6a4a', 'de2d26', 'a50f15'],
        6: ['fee5d9', 'fcbba1', 'fc9272', 'fb6a4a', 'de2d26', 'a50f15'],
        7: ['fee5d9', 'fcbba1', 'fc9272', 'fb6a4a', 'ef3b2c', 'cb181d',
            '99000d'],
        8: ['fff5f0', 'fee0d2', 'fcbba1', 'fc9272', 'fb6a4a', 'ef3b2c',
            'cb181d', '99000d'],
        9: ['fff5f0', 'fee0d2', 'fcbba1', 'fc9272', 'fb6a4a', 'ef3b2c',
            'cb181d', 'a50f15', '67000d']
      },
      Greys: {
        type: 'sequential',
        cbf: 42,
        3: ['f0f0f0', 'bdbdbd', '636363'],
        4: ['f7f7f7', 'cccccc', '969696', '525252'],
        5: ['f7f7f7', 'cccccc', '969696', '636363', '252525'],
        6: ['f7f7f7', 'd9d9d9', 'bdbdbd', '969696', '636363', '252525'],
        7: ['f7f7f7', 'd9d9d9', 'bdbdbd', '969696', '737373', '525252',
            '252525'],
        8: ['ffffff', 'f0f0f0', 'd9d9d9', 'bdbdbd', '969696', '737373',
            '525252', '252525'],
        9: ['ffffff', 'f0f0f0', 'd9d9d9', 'bdbdbd', '969696', '737373',
            '525252', '252525', '000000']
      },
      PuOr: {
        type: 'diverging',
        cbf: 42,
        3: ['f1a340', 'f7f7f7', '998ec3'],
        4: ['e66101', 'fdb863', 'b2abd2', '5e3c99'],
        5: ['e66101', 'fdb863', 'f7f7f7', 'b2abd2', '5e3c99'],
        6: ['b35806', 'f1a340', 'fee0b6', 'd8daeb', '998ec3', '542788'],
        7: ['b35806', 'f1a340', 'fee0b6', 'f7f7f7', 'd8daeb', '998ec3',
            '542788'],
        8: ['b35806', 'e08214', 'fdb863', 'fee0b6', 'd8daeb', 'b2abd2',
            '8073ac', '542788'],
        9: ['b35806', 'e08214', 'fdb863', 'fee0b6', 'f7f7f7', 'd8daeb',
            'b2abd2', '8073ac', '542788'],
        10: ['7f3b08', 'b35806', 'e08214', 'fdb863', 'fee0b6', 'd8daeb',
             'b2abd2', '8073ac', '542788', '2d004b'],
        11: ['7f3b08', 'b35806', 'e08214', 'fdb863', 'fee0b6', 'f7f7f7',
             'd8daeb', 'b2abd2', '8073ac', '542788', '2d004b']
      },
      BrBG: {
        type: 'diverging',
        cbf: 42,
        3: ['d8b365', 'f5f5f5', '5ab4ac'],
        4: ['a6611a', 'dfc27d', '80cdc1', '018571'],
        5: ['a6611a', 'dfc27d', 'f5f5f5', '80cdc1', '018571'],
        6: ['8c510a', 'd8b365', 'f6e8c3', 'c7eae5', '5ab4ac', '01665e'],
        7: ['8c510a', 'd8b365', 'f6e8c3', 'f5f5f5', 'c7eae5', '5ab4ac',
            '01665e'],
        8: ['8c510a', 'bf812d', 'dfc27d', 'f6e8c3', 'c7eae5', '80cdc1',
            '35978f', '01665e'],
        9: ['8c510a', 'bf812d', 'dfc27d', 'f6e8c3', 'f5f5f5', 'c7eae5',
            '80cdc1', '35978f', '01665e'],
        10: ['543005', '8c510a', 'bf812d', 'dfc27d', 'f6e8c3', 'c7eae5',
             '80cdc1', '35978f', '01665e', '003c30'],
        11: ['543005', '8c510a', 'bf812d', 'dfc27d', 'f6e8c3', 'f5f5f5',
             'c7eae5', '80cdc1', '35978f', '01665e', '003c30']
      },
      PRGn: {
        type: 'diverging',
        cbf: 42,
        3: ['af8dc3', 'f7f7f7', '7fbf7b'],
        4: ['7b3294', 'c2a5cf', 'a6dba0', '008837'],
        5: ['7b3294', 'c2a5cf', 'f7f7f7', 'a6dba0', '008837'],
        6: ['762a83', 'af8dc3', 'e7d4e8', 'd9f0d3', '7fbf7b', '1b7837'],
        7: ['762a83', 'af8dc3', 'e7d4e8', 'f7f7f7', 'd9f0d3', '7fbf7b',
            '1b7837'],
        8: ['762a83', '9970ab', 'c2a5cf', 'e7d4e8', 'd9f0d3', 'a6dba0',
            '5aae61', '1b7837'],
        9: ['762a83', '9970ab', 'c2a5cf', 'e7d4e8', 'f7f7f7', 'd9f0d3',
            'a6dba0', '5aae61', '1b7837'],
        10: ['40004b', '762a83', '9970ab', 'c2a5cf', 'e7d4e8', 'd9f0d3',
             'a6dba0', '5aae61', '1b7837', '00441b'],
        11: ['40004b', '762a83', '9970ab', 'c2a5cf', 'e7d4e8', 'f7f7f7',
             'd9f0d3', 'a6dba0', '5aae61', '1b7837', '00441b']
      },
      PiYG: {
        type: 'diverging',
        cbf: 42,
        3: ['e9a3c9', 'f7f7f7', 'a1d76a'],
        4: ['d01c8b', 'f1b6da', 'b8e186', '4dac26'],
        5: ['d01c8b', 'f1b6da', 'f7f7f7', 'b8e186', '4dac26'],
        6: ['c51b7d', 'e9a3c9', 'fde0ef', 'e6f5d0', 'a1d76a', '4d9221'],
        7: ['c51b7d', 'e9a3c9', 'fde0ef', 'f7f7f7', 'e6f5d0', 'a1d76a',
            '4d9221'],
        8: ['c51b7d', 'de77ae', 'f1b6da', 'fde0ef', 'e6f5d0', 'b8e186',
            '7fbc41', '4d9221'],
        9: ['c51b7d', 'de77ae', 'f1b6da', 'fde0ef', 'f7f7f7', 'e6f5d0',
            'b8e186', '7fbc41', '4d9221'],
        10: ['8e0152', 'c51b7d', 'de77ae', 'f1b6da', 'fde0ef', 'e6f5d0',
             'b8e186', '7fbc41', '4d9221', '276419'],
        11: ['8e0152', 'c51b7d', 'de77ae', 'f1b6da', 'fde0ef', 'f7f7f7',
             'e6f5d0', 'b8e186', '7fbc41', '4d9221', '276419']
      },
      RdBu: {
        type: 'diverging',
        cbf: 42,
        3: ['ef8a62', 'f7f7f7', '67a9cf'],
        4: ['ca0020', 'f4a582', '92c5de', '0571b0'],
        5: ['ca0020', 'f4a582', 'f7f7f7', '92c5de', '0571b0'],
        6: ['b2182b', 'ef8a62', 'fddbc7', 'd1e5f0', '67a9cf', '2166ac'],
        7: ['b2182b', 'ef8a62', 'fddbc7', 'f7f7f7', 'd1e5f0', '67a9cf',
            '2166ac'],
        8: ['b2182b', 'd6604d', 'f4a582', 'fddbc7', 'd1e5f0', '92c5de',
            '4393c3', '2166ac'],
        9: ['b2182b', 'd6604d', 'f4a582', 'fddbc7', 'f7f7f7', 'd1e5f0',
            '92c5de', '4393c3', '2166ac'],
        10: ['67001f', 'b2182b', 'd6604d', 'f4a582', 'fddbc7', 'd1e5f0',
             '92c5de', '4393c3', '2166ac', '053061'],
        11: ['67001f', 'b2182b', 'd6604d', 'f4a582', 'fddbc7', 'f7f7f7',
             'd1e5f0', '92c5de', '4393c3', '2166ac', '053061']
      },
      RdGy: {
        type: 'diverging',
        cbf: 42,
        3: ['ef8a62', 'ffffff', '999999'],
        4: ['ca0020', 'f4a582', 'bababa', '404040'],
        5: ['ca0020', 'f4a582', 'ffffff', 'bababa', '404040'],
        6: ['b2182b', 'ef8a62', 'fddbc7', 'e0e0e0', '999999', '4d4d4d'],
        7: ['b2182b', 'ef8a62', 'fddbc7', 'ffffff', 'e0e0e0', '999999',
            '4d4d4d'],
        8: ['b2182b', 'd6604d', 'f4a582', 'fddbc7', 'e0e0e0', 'bababa',
            '878787', '4d4d4d'],
        9: ['b2182b', 'd6604d', 'f4a582', 'fddbc7', 'ffffff', 'e0e0e0',
            'bababa', '878787', '4d4d4d'],
        10: ['67001f', 'b2182b', 'd6604d', 'f4a582', 'fddbc7', 'e0e0e0',
             'bababa', '878787', '4d4d4d', '1a1a1a'],
        11: ['67001f', 'b2182b', 'd6604d', 'f4a582', 'fddbc7', 'ffffff',
             'e0e0e0', 'bababa', '878787', '4d4d4d', '1a1a1a']
      },
      RdYlBu: {
        type: 'diverging',
        cbf: 42,
        3: ['fc8d59', 'ffffbf', '91bfdb'],
        4: ['d7191c', 'fdae61', 'abd9e9', '2c7bb6'],
        5: ['d7191c', 'fdae61', 'ffffbf', 'abd9e9', '2c7bb6'],
        6: ['d73027', 'fc8d59', 'fee090', 'e0f3f8', '91bfdb', '4575b4'],
        7: ['d73027', 'fc8d59', 'fee090', 'ffffbf', 'e0f3f8', '91bfdb',
            '4575b4'],
        8: ['d73027', 'f46d43', 'fdae61', 'fee090', 'e0f3f8', 'abd9e9',
            '74add1', '4575b4'],
        9: ['d73027', 'f46d43', 'fdae61', 'fee090', 'ffffbf', 'e0f3f8',
            'abd9e9', '74add1', '4575b4'],
        10: ['a50026', 'd73027', 'f46d43', 'fdae61', 'fee090', 'e0f3f8',
             'abd9e9', '74add1', '4575b4', '313695'],
        11: ['a50026', 'd73027', 'f46d43', 'fdae61', 'fee090', 'ffffbf',
             'e0f3f8', 'abd9e9', '74add1', '4575b4', '313695']
      },
      Spectral: {
        type: 'diverging',
        cbf: 0,
        3: ['fc8d59', 'ffffbf', '99d594'],
        4: ['d7191c', 'fdae61', 'abdda4', '2b83ba'],
        5: ['d7191c', 'fdae61', 'ffffbf', 'abdda4', '2b83ba'],
        6: ['d53e4f', 'fc8d59', 'fee08b', 'e6f598', '99d594', '3288bd'],
        7: ['d53e4f', 'fc8d59', 'fee08b', 'ffffbf', 'e6f598', '99d594',
            '3288bd'],
        8: ['d53e4f', 'f46d43', 'fdae61', 'fee08b', 'e6f598', 'abdda4',
            '66c2a5', '3288bd'],
        9: ['d53e4f', 'f46d43', 'fdae61', 'fee08b', 'ffffbf', 'e6f598',
            'abdda4', '66c2a5', '3288bd'],
        10: ['9e0142', 'd53e4f', 'f46d43', 'fdae61', 'fee08b', 'e6f598',
             'abdda4', '66c2a5', '3288bd', '5e4fa2'],
        11: ['9e0142', 'd53e4f', 'f46d43', 'fdae61', 'fee08b', 'ffffbf',
             'e6f598', 'abdda4', '66c2a5', '3288bd', '5e4fa2']
      },
      RdYlGn: {
        type: 'diverging',
        cbf: 0,
        3: ['fc8d59', 'ffffbf', '91cf60'],
        4: ['d7191c', 'fdae61', 'a6d96a', '1a9641'],
        5: ['d7191c', 'fdae61', 'ffffbf', 'a6d96a', '1a9641'],
        6: ['d73027', 'fc8d59', 'fee08b', 'd9ef8b', '91cf60', '1a9850'],
        7: ['d73027', 'fc8d59', 'fee08b', 'ffffbf', 'd9ef8b', '91cf60',
            '1a9850'],
        8: ['d73027', 'f46d43', 'fdae61', 'fee08b', 'd9ef8b', 'a6d96a',
            '66bd63', '1a9850'],
        9: ['d73027', 'f46d43', 'fdae61', 'fee08b', 'ffffbf', 'd9ef8b',
            'a6d96a', '66bd63', '1a9850'],
        10: ['a50026', 'd73027', 'f46d43', 'fdae61', 'fee08b', 'd9ef8b',
             'a6d96a', '66bd63', '1a9850', '006837'],
        11: ['a50026', 'd73027', 'f46d43', 'fdae61', 'fee08b', 'ffffbf',
             'd9ef8b', 'a6d96a', '66bd63', '1a9850', '006837']
      },
      Accent: {
        type: 'qualitative',
        cbf: 0,
        3: ['7fc97f', 'beaed4', 'fdc086'],
        4: ['7fc97f', 'beaed4', 'fdc086', 'ffff99'],
        5: ['7fc97f', 'beaed4', 'fdc086', 'ffff99', '386cb0'],
        6: ['7fc97f', 'beaed4', 'fdc086', 'ffff99', '386cb0', 'f0027f'],
        7: ['7fc97f', 'beaed4', 'fdc086', 'ffff99', '386cb0', 'f0027f',
            'bf5b17'],
        8: ['7fc97f', 'beaed4', 'fdc086', 'ffff99', '386cb0', 'f0027f',
            'bf5b17', '666666']
      },
      Dark2: {
        type: 'qualitative',
        cbf: 3,
        3: ['1b9e77', 'd95f02', '7570b3'],
        4: ['1b9e77', 'd95f02', '7570b3', 'e7298a'],
        5: ['1b9e77', 'd95f02', '7570b3', 'e7298a', '66a61e'],
        6: ['1b9e77', 'd95f02', '7570b3', 'e7298a', '66a61e', 'e6ab02'],
        7: ['1b9e77', 'd95f02', '7570b3', 'e7298a', '66a61e', 'e6ab02',
            'a6761d'],
        8: ['1b9e77', 'd95f02', '7570b3', 'e7298a', '66a61e', 'e6ab02',
            'a6761d', '666666']
      },
      Paired: {
        type: 'qualitative',
        cbf: 4,
        3: ['a6cee3', '1f78b4', 'b2df8a'],
        4: ['a6cee3', '1f78b4', 'b2df8a', '33a02c'],
        5: ['a6cee3', '1f78b4', 'b2df8a', '33a02c', 'fb9a99'],
        6: ['a6cee3', '1f78b4', 'b2df8a', '33a02c', 'fb9a99', 'e31a1c'],
        7: ['a6cee3', '1f78b4', 'b2df8a', '33a02c', 'fb9a99', 'e31a1c',
            'fdbf6f'],
        8: ['a6cee3', '1f78b4', 'b2df8a', '33a02c', 'fb9a99', 'e31a1c',
            'fdbf6f', 'ff7f00'],
        9: ['a6cee3', '1f78b4', 'b2df8a', '33a02c', 'fb9a99', 'e31a1c',
            'fdbf6f', 'ff7f00', 'cab2d6'],
        10: ['a6cee3', '1f78b4', 'b2df8a', '33a02c', 'fb9a99', 'e31a1c',
             'fdbf6f', 'ff7f00', 'cab2d6', '6a3d9a'],
        11: ['a6cee3', '1f78b4', 'b2df8a', '33a02c', 'fb9a99', 'e31a1c',
             'fdbf6f', 'ff7f00', 'cab2d6', '6a3d9a', 'ffff99'],
        12: ['a6cee3', '1f78b4', 'b2df8a', '33a02c', 'fb9a99', 'e31a1c',
             'fdbf6f', 'ff7f00', 'cab2d6', '6a3d9a', 'ffff99', 'b15928']
      },
      Pastel1: {
        type: 'qualitative',
        cbf: 0,
        3: ['fbb4ae', 'b3cde3', 'ccebc5'],
        4: ['fbb4ae', 'b3cde3', 'ccebc5', 'decbe4'],
        5: ['fbb4ae', 'b3cde3', 'ccebc5', 'decbe4', 'fed9a6'],
        6: ['fbb4ae', 'b3cde3', 'ccebc5', 'decbe4', 'fed9a6', 'ffffcc'],
        7: ['fbb4ae', 'b3cde3', 'ccebc5', 'decbe4', 'fed9a6', 'ffffcc',
            'e5d8bd'],
        8: ['fbb4ae', 'b3cde3', 'ccebc5', 'decbe4', 'fed9a6', 'ffffcc',
            'e5d8bd', 'fddaec'],
        9: ['fbb4ae', 'b3cde3', 'ccebc5', 'decbe4', 'fed9a6', 'ffffcc',
            'e5d8bd', 'fddaec', 'f2f2f2']
      },
      Pastel2: {
        type: 'qualitative',
        cbf: 0,
        3: ['b3e2cd', 'fdcdac', 'cbd5e8'],
        4: ['b3e2cd', 'fdcdac', 'cbd5e8', 'f4cae4'],
        5: ['b3e2cd', 'fdcdac', 'cbd5e8', 'f4cae4', 'e6f5c9'],
        6: ['b3e2cd', 'fdcdac', 'cbd5e8', 'f4cae4', 'e6f5c9', 'fff2ae'],
        7: ['b3e2cd', 'fdcdac', 'cbd5e8', 'f4cae4', 'e6f5c9', 'fff2ae',
            'f1e2cc'],
        8: ['b3e2cd', 'fdcdac', 'cbd5e8', 'f4cae4', 'e6f5c9', 'fff2ae',
            'f1e2cc', 'cccccc']
      },
      Set1: {
        type: 'qualitative',
        cbf: 0,
        3: ['e41a1c', '377eb8', '4daf4a'],
        4: ['e41a1c', '377eb8', '4daf4a', '984ea3'],
        5: ['e41a1c', '377eb8', '4daf4a', '984ea3', 'ff7f00'],
        6: ['e41a1c', '377eb8', '4daf4a', '984ea3', 'ff7f00', 'ffff33'],
        7: ['e41a1c', '377eb8', '4daf4a', '984ea3', 'ff7f00', 'ffff33',
            'a65628'],
        8: ['e41a1c', '377eb8', '4daf4a', '984ea3', 'ff7f00', 'ffff33',
            'a65628', 'f781bf'],
        9: ['e41a1c', '377eb8', '4daf4a', '984ea3', 'ff7f00', 'ffff33',
            'a65628', 'f781bf', '999999']
      },
      Set2: {
        type: 'qualitative',
        cbf: 3,
        3: ['66c2a5', 'fc8d62', '8da0cb'],
        4: ['66c2a5', 'fc8d62', '8da0cb', 'e78ac3'],
        5: ['66c2a5', 'fc8d62', '8da0cb', 'e78ac3', 'a6d854'],
        6: ['66c2a5', 'fc8d62', '8da0cb', 'e78ac3', 'a6d854', 'ffd92f'],
        7: ['66c2a5', 'fc8d62', '8da0cb', 'e78ac3', 'a6d854', 'ffd92f',
            'e5c494'],
        8: ['66c2a5', 'fc8d62', '8da0cb', 'e78ac3', 'a6d854', 'ffd92f',
            'e5c494', 'b3b3b3']
      },
      Set3: {
        type: 'qualitative',
        cbf: 0,
        3: ['8dd3c7', 'ffffb3', 'bebada'],
        4: ['8dd3c7', 'ffffb3', 'bebada', 'fb8072'],
        5: ['8dd3c7', 'ffffb3', 'bebada', 'fb8072', '80b1d3'],
        6: ['8dd3c7', 'ffffb3', 'bebada', 'fb8072', '80b1d3', 'fdb462'],
        7: ['8dd3c7', 'ffffb3', 'bebada', 'fb8072', '80b1d3', 'fdb462',
            'b3de69'],
        8: ['8dd3c7', 'ffffb3', 'bebada', 'fb8072', '80b1d3', 'fdb462',
            'b3de69', 'fccde5'],
        9: ['8dd3c7', 'ffffb3', 'bebada', 'fb8072', '80b1d3', 'fdb462',
            'b3de69', 'fccde5', 'd9d9d9'],
        10: ['8dd3c7', 'ffffb3', 'bebada', 'fb8072', '80b1d3', 'fdb462',
             'b3de69', 'fccde5', 'd9d9d9', 'bc80bd'],
        11: ['8dd3c7', 'ffffb3', 'bebada', 'fb8072', '80b1d3', 'fdb462',
             'b3de69', 'fccde5', 'd9d9d9', 'bc80bd', 'ccebc5'],
        12: ['8dd3c7', 'ffffb3', 'bebada', 'fb8072', '80b1d3', 'fdb462',
             'b3de69', 'fccde5', 'd9d9d9', 'bc80bd', 'ccebc5', 'ffed6f']
      }
    };
  
    for (var name in schemes) {
      var scheme = schemes[name];
      scheme = palette.Scheme.fromPalettes(
        'cb-' + name, [scheme.type, 'cb-' + scheme.type], scheme, 12, scheme.cbf);
      palette.register(scheme);
    }
  })();
  
  if(typeof module === "object" && module.exports) {
    module.exports = palette
  }
  ;
  
  
  // require tether
  
  
  
  
  
  
  
  
  
  
  // require popper-utils
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  ;